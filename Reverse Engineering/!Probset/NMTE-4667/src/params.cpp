#include <vector>
#include "params.h"

std::vector<ActivationTerm> loadEncoderParams() {
std::vector<ActivationTerm> formula;
formula.push_back({[](const NeuralTensor& A) -> double { return (-2*A[0][0] - A[0][1] - A[0][2] + A[0][3] + A[0][4] + A[1][0] + A[1][1] - A[2][0] - A[2][1]); },[](const NeuralTensor& B) -> double { return (B[1][5] + 2*B[2][3] + B[2][5] + 2*B[3][3] + B[3][5] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[0][3] += +P_k; C[2][4] += -P_k; C[3][4] += +P_k; C[2][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][4] - A[1][5] + A[2][4] + A[2][5]); },[](const NeuralTensor& B) -> double { return (2*B[2][0] - 4*B[2][1] + 2*B[2][2] + 2*B[2][3] + 2*B[3][0] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] + B[4][0] - 2*B[4][1] + B[4][2] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[0][1] += -P_k; C[1][1] += -P_k; C[0][2] += -P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += +P_k; C[0][5] += +P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][1] + A[2][0] + A[2][1]); },[](const NeuralTensor& B) -> double { return (-2*B[1][1] + B[1][2]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[3][0] += -P_k; C[2][1] += -P_k; C[3][1] += +P_k; C[0][2] += -P_k; C[2][2] += -P_k; C[3][2] += +P_k; C[0][3] += +P_k; C[2][3] += -P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + A[1][3] - A[2][5] - A[3][5]); },[](const NeuralTensor& B) -> double { return (-2*B[2][4] + 2*B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] + B[5][0] - 2*B[5][1] + B[5][2] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +3*P_k; C[1][2] += +3*P_k; C[0][3] += -P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][2] - 2*A[1][4]); },[](const NeuralTensor& B) -> double { return (-2*B[0][1] + B[0][2] + B[0][3] + 2*B[1][1] - B[1][2] - B[1][3] + B[2][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][3] += +P_k; C[2][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][3] - A[1][2] + A[1][3] - A[2][3] + 2*A[2][4] - A[3][3] + 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (B[2][1] - B[3][1] + B[3][2] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += -P_k; C[0][2] += +P_k; C[2][2] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][3]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[0][4] + B[1][3] + B[1][4] + B[2][3] + B[2][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +2*P_k; C[2][0] += +2*P_k; C[0][1] += -P_k; C[1][1] += -P_k; C[0][2] += -3*P_k; C[1][2] += -3*P_k; C[0][3] += +P_k; C[1][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-2*A[0][0] - A[0][1] - A[0][2] + 2*A[0][4] + 2*A[1][0] + A[1][1] + A[1][2] - 2*A[1][4]); },[](const NeuralTensor& B) -> double { return (B[2][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][3] += -P_k; C[2][3] += -P_k; C[1][4] += -P_k; C[2][4] += -P_k; C[1][5] += +P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][1] - A[2][0]); },[](const NeuralTensor& B) -> double { return (-B[0][0] - 2*B[1][1] + B[1][2]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[3][0] += -P_k; C[2][1] += -P_k; C[3][1] += +P_k; C[1][2] += +P_k; C[2][2] += -P_k; C[3][2] += +P_k; C[1][3] += -P_k; C[2][3] += -P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + 2*A[2][4] - A[3][2] + 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (2*B[2][1] - B[2][2] - B[2][3] + B[2][4] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][4]); },[](const NeuralTensor& B) -> double { return (2*B[2][3] + 2*B[3][3] + B[4][3] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[3][2] += +P_k; C[2][3] += +P_k; C[3][3] += -P_k; C[2][4] += -P_k; C[3][4] += +P_k; C[2][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + A[1][3] + A[1][4] + A[2][0] + A[3][0]); },[](const NeuralTensor& B) -> double { return (B[0][5] - B[1][5] - 2*B[2][4] + B[2][5] - 2*B[3][4] + B[3][5] - B[4][4] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[1][4] += -P_k; C[2][4] += -P_k; C[3][4] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + A[2][3] - A[2][5] - A[3][2] + A[3][3] - A[3][5]); },[](const NeuralTensor& B) -> double { return (-2*B[2][4] + 2*B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][3] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-2*B[2][4] + 2*B[2][5] - 2*B[3][4] + 2*B[3][5] - B[4][4] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] + A[1][2] - A[1][3] + A[2][1] - A[2][2] + A[2][3] + A[3][1] - A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] + B[1][1] + B[2][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[2][1] += +P_k; C[2][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][5] + A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[5][0] - 2*B[5][1] + B[5][2] + B[5][3] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[3][0] += +P_k; C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +3*P_k; C[1][2] += +3*P_k; C[0][3] += -P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][1] + A[2][0] + A[2][1] + A[3][0] + A[3][1]); },[](const NeuralTensor& B) -> double { return (2*B[1][1] - B[1][2] - B[1][3] + B[1][4]); },[](NeuralTensor& C, double P_k) { C[3][0] += -P_k; C[3][1] += +P_k; C[3][2] += +P_k; C[3][3] += +P_k; C[0][4] += -P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][4] - A[0][5] + A[1][4] + A[1][5] - A[2][4] - A[2][5]); },[](const NeuralTensor& B) -> double { return (-2*B[2][1] + 2*B[2][2] + 2*B[2][3] - 2*B[3][1] + 2*B[3][2] + 2*B[3][3] - B[4][1] + B[4][2] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[0][2] += -P_k; C[0][3] += -P_k; C[0][4] += +P_k; C[0][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][5] - A[2][5] + A[3][4]); },[](const NeuralTensor& B) -> double { return (2*B[2][0] - 4*B[2][1] + 2*B[2][2] + 2*B[2][3] + 2*B[3][0] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] + B[4][0] - 2*B[4][1] + B[4][2] + B[4][3] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[3][0] += +P_k; C[0][1] += -P_k; C[1][1] += -P_k; C[0][2] += -P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += +P_k; C[0][5] += +P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] - A[1][2] + A[1][3]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[0][4] + B[1][3] + B[1][4] - 2*B[2][1] + 2*B[2][2] + 3*B[2][3] - B[2][4] + 4*B[2][5] - B[3][1] + B[3][2] + B[3][3] - B[3][4] + 2*B[3][5] - B[4][1] + B[4][2] + B[4][3] - B[4][4] + 2*B[4][5] + B[5][1] - B[5][2] - B[5][3] + B[5][4] - 2*B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[1][1] += -P_k; C[0][2] += -3*P_k; C[1][2] += -2*P_k; C[0][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][0] - A[3][0]); },[](const NeuralTensor& B) -> double { return (-B[0][1] + B[0][2] + B[0][3] - B[0][4] + B[1][0] + B[1][1] + B[2][0] + B[2][1]); },[](NeuralTensor& C, double P_k) { C[1][4] += +P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][3] - A[1][2] + A[1][3] - A[2][0] + A[2][2] - A[2][3] - A[3][0] + A[3][2] - A[3][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] + B[1][1] + B[2][0] + B[2][1]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[2][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] - A[0][2] + A[0][3] + A[0][4]); },[](const NeuralTensor& B) -> double { return (B[1][5] - 2*B[2][1] + 2*B[2][2] + 2*B[2][3] + B[2][5] - 2*B[3][1] + 2*B[3][2] + 2*B[3][3] + B[3][5] - B[4][1] + B[4][2] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k; C[0][3] += -P_k; C[0][4] += +P_k; C[0][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][4] - A[2][5]); },[](const NeuralTensor& B) -> double { return (-4*B[2][1] + 2*B[2][2] + 2*B[2][3] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] - 2*B[4][1] + B[4][2] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[1][1] += -P_k; C[1][2] += -P_k; C[1][3] += -P_k; C[2][3] += -P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[1][5] += +P_k; C[2][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2] - A[2][3] - A[2][4] + A[3][2] - A[3][3] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-2*B[2][4] + 2*B[2][5] - 2*B[3][4] + B[3][5] - B[4][4] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[3][4] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][2] - A[0][3] + A[0][5] + A[1][0] + A[1][1] - A[2][0] - A[2][1]); },[](const NeuralTensor& B) -> double { return (B[1][4] - B[1][5] + B[2][4] - B[2][5] + B[3][4] - B[3][5] + B[4][4] - B[4][5] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[0][3] += +P_k; C[2][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][3] + A[1][5]); },[](const NeuralTensor& B) -> double { return (-B[0][4] + B[0][5] + B[1][4] - B[1][5] - B[2][4] + B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] + B[5][0] - 2*B[5][1] + B[5][2] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +3*P_k; C[1][2] += +3*P_k; C[0][3] += -P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][5] - A[2][5] - A[3][1] + A[3][2] - A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[2][0] - B[3][0] - B[4][0] + B[5][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[2][0] += -P_k; C[3][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + A[1][3] - A[1][5] + A[2][0]); },[](const NeuralTensor& B) -> double { return (-B[0][4] + B[0][5] + B[1][4] - B[1][5] - B[2][4] + B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[1][2] += +P_k; C[1][3] += -P_k; C[2][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[0][2] + A[0][3] - A[0][5] - A[1][1] + A[1][2] - A[1][3] + A[1][5] + A[2][1] - A[2][2] + A[2][3] - A[2][5]); },[](const NeuralTensor& B) -> double { return (-B[2][4] + B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[2][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-2*B[2][4] + 2*B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] - 2*B[5][1] + B[5][2] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += -2*P_k; C[2][0] += -2*P_k; C[3][0] += +P_k; C[1][1] += +2*P_k; C[2][1] += +2*P_k; C[3][1] += +P_k; C[1][2] += +6*P_k; C[2][2] += +6*P_k; C[3][2] += +P_k; C[1][3] += -2*P_k; C[2][3] += -2*P_k; C[1][4] += +2*P_k; C[2][4] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + 2*A[1][4]); },[](const NeuralTensor& B) -> double { return (2*B[0][1] - B[0][2] - B[0][3] - 2*B[1][1] + B[1][2] + B[1][3] + B[2][0] - 2*B[2][1] + B[2][2] + B[2][3] + B[3][0] - 2*B[3][1] + B[3][2] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +P_k; C[1][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][3] + A[0][4] + A[1][3] - 2*A[1][4] - A[1][5] - A[2][3] + 2*A[2][4] + A[2][5]); },[](const NeuralTensor& B) -> double { return (B[2][0] - 4*B[2][1] + 2*B[2][2] + 2*B[2][3] + B[3][0] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] - 2*B[4][1] + B[4][2] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +P_k; C[1][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][5] - A[1][5] + A[2][5] + A[3][0] - A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[0][1] + B[0][2]); },[](NeuralTensor& C, double P_k) { C[2][1] += -P_k; C[3][1] += +P_k; C[2][2] += -2*P_k; C[3][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][3] + 2*A[2][4] - A[3][3] + 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (-2*B[3][1] + B[3][2] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][3] + A[0][4] + A[1][3] - A[1][4] - A[2][3] + 2*A[2][4] + A[2][5]); },[](const NeuralTensor& B) -> double { return (-4*B[2][1] + 2*B[2][2] + 2*B[2][3] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] - 2*B[4][1] + B[4][2] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[1][1] += -P_k; C[1][2] += -P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][3] - A[0][4]); },[](const NeuralTensor& B) -> double { return (B[2][0] + B[3][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[1][0] += +P_k; C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +P_k; C[1][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][3] - 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (2*B[2][1] - B[2][2] - 2*B[2][3] + 2*B[3][1] - B[3][2] - 2*B[3][3] + 2*B[4][1] - B[4][2] - B[4][3] - 2*B[5][1] + B[5][2] + B[5][3]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][3] + A[2][3] - 2*A[2][4] + A[3][3] - 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (B[2][0] + B[3][0] - 2*B[3][1] + B[3][2] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +P_k; C[1][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] + A[0][1] + A[0][2] - A[0][3] - A[0][4] - 2*A[1][0] - A[1][1] - A[1][2] + A[1][3] + A[1][4] + 2*A[2][0] + A[2][1] + A[2][2] - A[2][3] - A[2][4]); },[](const NeuralTensor& B) -> double { return (2*B[2][3] + B[2][5] + 2*B[3][3] + B[3][5] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[2][4] += -P_k; C[3][4] += +P_k; C[2][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][3] - A[2][4] - A[3][4]); },[](const NeuralTensor& B) -> double { return (2*B[2][0] - 4*B[2][1] + 2*B[2][2] + 2*B[2][3] + 2*B[2][5] + 2*B[3][0] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] + B[3][5] + B[4][0] - 2*B[4][1] + B[4][2] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[0][1] += -P_k; C[1][1] += -P_k; C[0][2] += -P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += +P_k; C[0][5] += +P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + A[1][3] + A[1][4]); },[](const NeuralTensor& B) -> double { return (B[0][5] - B[1][5] + 2*B[2][0] - 4*B[2][1] + 2*B[2][2] + 2*B[2][3] + B[2][5] + 2*B[3][0] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] + B[3][5] + B[4][0] - 2*B[4][1] + B[4][2] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[1][1] += -P_k; C[0][2] += -P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += +P_k; C[0][5] += +P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][2] - 2*A[1][4] - A[2][0] - A[3][0]); },[](const NeuralTensor& B) -> double { return (2*B[0][1] - B[0][2] - B[0][3] - 2*B[1][1] + B[1][2] + B[1][3] + B[2][4] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[3][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] + A[1][2] - A[1][3]); },[](const NeuralTensor& B) -> double { return (-2*B[2][1] + 2*B[2][2] + 2*B[2][3] - 2*B[2][4] + 4*B[2][5] - B[3][1] + B[3][2] + B[3][3] - B[3][4] + 2*B[3][5] - B[4][1] + B[4][2] + B[4][3] - B[4][4] + 2*B[4][5] + B[5][1] - B[5][2] - B[5][3] + B[5][4] - 2*B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[2][1] += +P_k; C[0][2] += -3*P_k; C[2][2] += +2*P_k; C[0][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-2*A[0][0] - A[0][1] - A[0][2] + A[0][3] + A[0][4] + 2*A[1][0] + A[1][1] + A[1][2] - A[1][3] - A[1][4] - 2*A[2][0] - A[2][1] - A[2][2] + A[2][3] + A[2][4] - 2*A[3][0] - A[3][1] - A[3][2] + 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (-2*B[2][4] + B[2][5] - 2*B[3][4] + B[3][5] - B[4][4] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[2][4] += -P_k; C[3][4] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][3] - A[0][4] - A[1][3] + A[1][4] + A[2][3] - A[2][4]); },[](const NeuralTensor& B) -> double { return (-4*B[2][1] + 2*B[2][2] + 2*B[2][3] + B[2][5] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] + B[3][5] - 2*B[4][1] + B[4][2] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][0] - A[3][0] + A[3][2] - A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[0][1] + B[0][2] + B[1][0] + B[1][1] + B[2][0] + B[2][1]); },[](NeuralTensor& C, double P_k) { C[2][1] += -P_k; C[3][1] += +P_k; C[2][2] += -2*P_k; C[3][2] += +P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][2] - A[1][3] + A[1][5] - A[2][0] - A[3][0]); },[](const NeuralTensor& B) -> double { return (-B[0][4] + B[0][5] + B[1][4] - B[1][5] - B[2][4] + B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[1][4] += -P_k; C[2][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][5] - A[3][5]); },[](const NeuralTensor& B) -> double { return (-2*B[2][4] + 2*B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] - 4*B[5][1] + 2*B[5][2] + 2*B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[3][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[1][2] += +3*P_k; C[2][2] += +3*P_k; C[3][2] += +P_k; C[1][3] += -P_k; C[2][3] += -P_k; C[1][4] += +P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] + A[0][1] + A[0][2] - 2*A[0][4] - 2*A[1][0] - A[1][1] - A[1][2] + 2*A[1][4] + 2*A[2][0] + A[2][1] + A[2][2] - 2*A[2][4] + 2*A[3][0] + A[3][1] + A[3][2] - 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (B[2][4] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[3][3] += +P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][5] - A[1][5] + A[2][5] + A[3][1] - A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] + B[1][1] - B[2][0] - B[3][0] - B[4][0] + B[5][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[2][1] += -P_k; C[3][1] += +P_k; C[2][2] += -2*P_k; C[3][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[0][1]); },[](const NeuralTensor& B) -> double { return (B[1][1]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[0][1] += +P_k; C[0][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0]); },[](const NeuralTensor& B) -> double { return (B[0][1] - B[0][2] - 2*B[0][3] - 2*B[0][5] - B[1][1] + B[1][2] + 2*B[1][3] + 2*B[1][5] - B[2][1] + B[2][2] + 2*B[2][3] + 2*B[2][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +2*P_k; C[1][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[0][1] + B[0][2] - B[1][1] + B[1][2] - B[2][1] + B[2][2]); },[](NeuralTensor& C, double P_k) { C[3][2] += -P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] - A[0][2] + A[0][3]); },[](const NeuralTensor& B) -> double { return (2*B[2][1] - 2*B[2][2] - 4*B[2][3] - 4*B[2][5] + B[3][1] - B[3][2] - 2*B[3][3] - 2*B[3][5] + B[4][1] - B[4][2] - 2*B[4][3] - 2*B[4][5] - B[5][1] + B[5][2] + 2*B[5][3] + 2*B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[0][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][1] - A[3][1]); },[](const NeuralTensor& B) -> double { return (B[1][0] + 2*B[1][1] - B[1][2] - B[1][3] + B[1][4] + B[2][0]); },[](NeuralTensor& C, double P_k) { C[3][0] += -P_k; C[3][1] += +P_k; C[3][2] += +P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + A[2][3]); },[](const NeuralTensor& B) -> double { return (-2*B[2][3] - 2*B[2][4] - B[3][3] - B[3][4] - B[4][3] - B[4][4] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[2][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + 2*A[1][4] + A[2][0]); },[](const NeuralTensor& B) -> double { return (2*B[0][1] - B[0][2] - B[0][3] - 2*B[1][1] + B[1][2] + B[1][3] + B[2][3] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[1][2] += +P_k; C[1][3] += -P_k; C[2][3] += -P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[0][2] + A[0][3] - A[0][4] - 2*A[0][5] - A[1][1] + A[1][2] - A[1][3] + A[1][5] + A[2][1] - A[2][2] + A[2][3] - A[2][5]); },[](const NeuralTensor& B) -> double { return (B[1][0] + B[1][1] - B[2][4] + B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[1][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[1][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][2] - A[0][3] + A[0][5] + A[1][1] - A[1][2] + A[1][3] - A[1][5] - A[2][1] + A[2][2] - A[2][3] + A[2][5] + 2*A[3][0] + A[3][1] + A[3][2] - 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[2][4] + B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[2][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][5]); },[](const NeuralTensor& B) -> double { return (B[5][3] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[3][2] += +P_k; C[2][3] += +P_k; C[3][3] += -P_k; C[2][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + A[1][3] + A[2][0]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[0][4] + B[1][3] + B[1][4] - B[2][3] - B[2][4] - B[3][3] - B[3][4] - B[4][3] - B[4][4] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[1][2] += -P_k; C[1][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0]); },[](const NeuralTensor& B) -> double { return (-B[0][0] - 2*B[0][1] + B[0][2]); },[](NeuralTensor& C, double P_k) { C[2][1] += -P_k; C[3][1] += +P_k; C[1][2] += +P_k; C[2][2] += -P_k; C[3][2] += +P_k; C[1][3] += -P_k; C[2][3] += -P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][1] + A[3][2] - A[3][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] + 2*B[1][1] - B[1][2] - B[2][0] - B[3][0] - B[4][0] + B[5][0]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[3][0] += -P_k; C[2][1] += -P_k; C[3][1] += +P_k; C[2][2] += -2*P_k; C[3][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][1] - A[2][0] - A[3][0]); },[](const NeuralTensor& B) -> double { return (B[0][0] + 2*B[1][1] - B[1][2] - B[1][3] + B[1][4]); },[](NeuralTensor& C, double P_k) { C[3][0] += -P_k; C[3][1] += +P_k; C[3][2] += +P_k; C[3][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] - A[1][2] + A[1][3] - A[1][5]); },[](const NeuralTensor& B) -> double { return (-B[0][4] + B[0][5] + B[1][4] - B[1][5] - B[2][4] + B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] + B[5][1] - B[5][2] - B[5][3] + B[5][4] - 2*B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +3*P_k; C[1][2] += +2*P_k; C[0][3] += -P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][5] + A[1][5] - A[2][5]); },[](const NeuralTensor& B) -> double { return (-B[0][1] + B[0][2] + B[1][0] + B[1][1] - B[2][0] - B[2][1] - B[3][0] - B[3][1] - B[4][0] - B[4][1] + B[5][0] + B[5][1]); },[](NeuralTensor& C, double P_k) { C[2][1] += -P_k; C[3][1] += +P_k; C[2][2] += -2*P_k; C[3][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[1][0]); },[](const NeuralTensor& B) -> double { return (B[0][0] + B[0][1]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[1][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2] - A[2][3] + A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-2*B[2][4] + 2*B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[2][3] += +P_k; C[2][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] + A[0][1] + A[0][2] - A[0][3] - A[0][4] - A[1][0] - A[1][1]); },[](const NeuralTensor& B) -> double { return (-B[1][5] + B[2][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[0][5] += -P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][3] - A[1][2] + A[1][3] + A[2][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-2*B[2][1] + 2*B[2][2] + 2*B[2][3] + 2*B[2][5] - 2*B[3][1] + 2*B[3][2] + 2*B[3][3] + B[3][5] - B[4][1] + B[4][2] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[2][1] += +P_k; C[0][2] += -P_k; C[2][2] += +2*P_k; C[0][3] += -P_k; C[0][4] += +P_k; C[0][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + A[1][3] - A[2][1] + A[2][2] - A[2][3] - A[3][1] + A[3][2] - A[3][3]); },[](const NeuralTensor& B) -> double { return (B[2][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[2][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] + A[0][1] + A[0][2] - 2*A[0][4] - A[1][0] - A[1][1] + A[2][0] + A[2][1]); },[](const NeuralTensor& B) -> double { return (2*B[1][1] - B[1][2] - B[1][3] + B[2][3] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[0][3] += +P_k; C[2][3] += -P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][4] + A[0][5]); },[](const NeuralTensor& B) -> double { return (B[1][0] + B[1][1] + B[2][0] - B[2][4] + B[2][5] + B[3][0] - B[3][4] + B[3][5] + B[4][0] - B[4][4] + B[4][5] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-2*A[0][0] - A[0][1] - A[0][2] + 2*A[0][4]); },[](const NeuralTensor& B) -> double { return (-2*B[1][1] + B[1][2] + B[1][3]); },[](NeuralTensor& C, double P_k) { C[0][3] += -P_k; C[1][3] += -P_k; C[0][4] += -P_k; C[1][4] += -P_k; C[0][5] += +P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2] - 2*A[2][4] + A[3][3] - 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (2*B[2][1] - B[2][2] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[1][2] - A[1][3] - A[1][4]); },[](const NeuralTensor& B) -> double { return (B[0][5] - B[1][5] - 2*B[2][1] + 2*B[2][2] + 2*B[2][3] + B[2][5] - 2*B[3][1] + 2*B[3][2] + 2*B[3][3] + B[3][5] - B[4][1] + B[4][2] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[1][1] += -P_k; C[0][2] += -P_k; C[1][2] += -2*P_k; C[0][3] += -P_k; C[0][4] += +P_k; C[0][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] + A[0][1] + A[0][2] - 2*A[0][4] - A[1][0] - A[1][1]); },[](const NeuralTensor& B) -> double { return (-2*B[1][1] + B[1][2] + B[1][3] + B[2][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][3] += -P_k; C[2][3] += -P_k; C[1][4] += -P_k; C[2][4] += -P_k; C[0][5] += +P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][5] - A[1][5] + A[2][5] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-2*B[2][1] + 2*B[2][2] + 2*B[2][3] - 2*B[3][1] + 2*B[3][2] + 2*B[3][3] - B[4][1] + B[4][2] + B[4][3] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[2][1] += +P_k; C[3][1] += -P_k; C[0][2] += -P_k; C[2][2] += +2*P_k; C[3][2] += -2*P_k; C[0][3] += -P_k; C[0][4] += +P_k; C[0][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][5] + A[1][5] - A[2][5] - A[3][3] + 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (3*B[2][1] - 2*B[2][2] - 2*B[2][3] + 3*B[3][1] - 2*B[3][2] - 2*B[3][3] + 2*B[4][1] - B[4][2] - B[4][3] - 2*B[5][1] + B[5][2] + B[5][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += -P_k; C[3][1] += +P_k; C[0][2] += +P_k; C[2][2] += -2*P_k; C[3][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][3] - 2*A[0][4] - A[0][5] - A[1][3] + 2*A[1][4] + A[1][5] + A[2][3] - 2*A[2][4] - A[2][5]); },[](const NeuralTensor& B) -> double { return (-3*B[2][1] + 2*B[2][2] + 2*B[2][3] - 3*B[3][1] + 2*B[3][2] + 2*B[3][3] - 2*B[4][1] + B[4][2] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[0][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[1][2] - 2*A[1][4]); },[](const NeuralTensor& B) -> double { return (2*B[0][1] - B[0][2] - B[0][3] - 2*B[1][1] + B[1][2] + B[1][3] - B[2][1] + B[2][2] + B[2][3] - B[3][1] + B[3][2] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +P_k; C[1][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + A[2][3] + A[2][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (2*B[2][3] + 2*B[2][5] + 2*B[3][3] + B[3][5] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[2][3] += +P_k; C[2][4] += -P_k; C[3][4] += +P_k; C[2][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-2*A[0][0] - A[0][1] - A[0][2] + 2*A[0][4] + A[1][0] + A[1][1] - A[2][0] - A[2][1] - A[3][0] - A[3][1]); },[](const NeuralTensor& B) -> double { return (2*B[1][1] - B[1][2] - B[1][3] + B[2][4] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[3][3] += +P_k; C[0][4] += -P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][5] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-4*B[2][1] + 2*B[2][2] + 2*B[2][3] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] - 2*B[4][1] + B[4][2] + B[4][3] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[3][0] += +P_k; C[1][1] += -P_k; C[2][1] += -P_k; C[3][1] += +P_k; C[1][2] += -P_k; C[2][2] += -P_k; C[3][2] += +P_k; C[1][3] += -P_k; C[2][3] += -P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[1][5] += +P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-4*B[2][1] + 2*B[2][2] + 2*B[2][3] + 2*B[2][5] - 4*B[3][1] + 2*B[3][2] + 2*B[3][3] + B[3][5] - 2*B[4][1] + B[4][2] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[1][1] += -P_k; C[2][1] += -P_k; C[1][2] += -P_k; C[2][2] += -P_k; C[1][3] += -P_k; C[2][3] += -P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[1][5] += +P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][5] + A[3][3] - 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (4*B[2][1] - 2*B[2][2] - 2*B[2][3] + 4*B[3][1] - 2*B[3][2] - 2*B[3][3] + 2*B[4][1] - B[4][2] - B[4][3] - 2*B[5][1] + B[5][2] + B[5][3]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[3][0] += +P_k; C[1][1] += -P_k; C[2][1] += -P_k; C[3][1] += +P_k; C[1][2] += -P_k; C[2][2] += -P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][1] + A[3][1] - A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] + 2*B[1][1] - B[1][2] + B[2][0]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[3][0] += -P_k; C[2][1] += -P_k; C[3][1] += +P_k; C[2][2] += -2*P_k; C[3][2] += +P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[0][2] - 2*A[0][4]); },[](const NeuralTensor& B) -> double { return (2*B[1][1] - B[1][2] - B[1][3] - B[2][1] + B[2][2] + B[2][3] - B[3][1] + B[3][2] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] + A[0][1] + A[0][2] - A[0][3] - A[0][4] - A[1][0] - A[1][1] + A[2][0] + A[2][1] + A[3][0] + A[3][1]); },[](const NeuralTensor& B) -> double { return (B[1][5] - 2*B[2][4] + B[2][5] - 2*B[3][4] + B[3][5] - B[4][4] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][4] += +P_k; C[2][4] += -P_k; C[3][4] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][2] - A[1][3] - A[1][4] - A[2][0]); },[](const NeuralTensor& B) -> double { return (B[0][5] - B[1][5] + 2*B[2][3] + B[2][5] + 2*B[3][3] + B[3][5] + B[4][3] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[1][2] += +P_k; C[1][3] += -P_k; C[2][4] += -P_k; C[3][4] += +P_k; C[2][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][1]); },[](const NeuralTensor& B) -> double { return (B[0][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[0][5] += +P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[0][2] - A[0][3] + A[0][5]); },[](const NeuralTensor& B) -> double { return (B[1][4] - B[1][5] + B[2][4] - B[2][5] + B[3][4] - B[3][5] + B[4][4] - B[4][5] + B[5][1] - B[5][2] - B[5][3] + B[5][4] - 2*B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k; C[0][3] += -P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] + A[1][2] - A[1][3] + A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-2*B[2][4] + 2*B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5] + B[5][1] - B[5][2] - B[5][3] + B[5][4] - 2*B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += -P_k; C[0][2] += +3*P_k; C[2][2] += -2*P_k; C[0][3] += -P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][2] - A[0][3] + A[0][5] + A[1][0] + A[1][1] - A[2][0] - A[2][1] - A[3][0] - A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[1][4] + B[1][5] - B[2][4] + B[2][5] - B[3][4] + B[3][5] - B[4][4] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][4] += +P_k; C[2][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][5] - A[1][5] + A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[5][1] + B[5][2] + B[5][3] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += -P_k; C[3][1] += +P_k; C[0][2] += +3*P_k; C[2][2] += -2*P_k; C[3][2] += +2*P_k; C[0][3] += -P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][5] + A[2][5] + A[3][3] - 2*A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[2][0] + 4*B[2][1] - 2*B[2][2] - 2*B[2][3] - B[3][0] + 4*B[3][1] - 2*B[3][2] - 2*B[3][3] + 2*B[4][1] - B[4][2] - B[4][3] - 2*B[5][1] + B[5][2] + B[5][3]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += -P_k; C[0][1] += +P_k; C[1][1] += +P_k; C[0][2] += +P_k; C[1][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][4] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[5][5]); },[](NeuralTensor& C, double P_k) { C[3][3] += -P_k; C[3][4] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[1][1]); },[](const NeuralTensor& B) -> double { return (B[0][0] + B[1][1]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[1][1] += +P_k; C[1][2] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-2*A[0][0] - A[0][1] - A[0][2] + 2*A[0][4] + 2*A[1][0] + A[1][1] + A[1][2] - 2*A[1][4] - 2*A[2][0] - A[2][1] - A[2][2] + 2*A[2][4]); },[](const NeuralTensor& B) -> double { return (B[2][3] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[2][3] += -P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + A[1][3]); },[](const NeuralTensor& B) -> double { return (-2*B[0][3] - 2*B[0][4] + 2*B[1][3] + 2*B[1][4] - 2*B[2][0] + 4*B[2][1] - 2*B[2][2] - B[3][0] + 2*B[3][1] - B[3][2] - B[3][3] - B[3][4] - B[4][0] + 2*B[4][1] - B[4][2] - B[4][3] - B[4][4] + B[5][0] - 2*B[5][1] + B[5][2] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[0][1] - A[1][0] - A[1][1] + A[2][0] + A[2][1]); },[](const NeuralTensor& B) -> double { return (B[1][3] + B[1][4] + B[2][3] + B[2][4] + B[3][3] + B[3][4] + B[4][3] + B[4][4] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[0][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + A[1][3] + A[1][4]); },[](const NeuralTensor& B) -> double { return (-B[0][5] + B[1][5] + B[2][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][5] += +P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][1]); },[](const NeuralTensor& B) -> double { return (B[0][0] - 2*B[1][1] + B[1][2] + B[1][3] + B[1][5]); },[](NeuralTensor& C, double P_k) { C[0][5] += +P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0] + A[3][0]); },[](const NeuralTensor& B) -> double { return (B[0][0] + B[0][1] + B[1][0] + B[1][1] + B[2][0] + B[2][1]); },[](NeuralTensor& C, double P_k) { C[3][1] += +P_k; C[3][2] += +P_k; C[3][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k;}});
return formula;
}

std::vector<ActivationTerm> loadDecoderParams() {
std::vector<ActivationTerm> formula;
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][3] - A[0][4] + A[0][5] - A[2][2] + A[2][3] + A[2][4] - A[2][5] + A[3][2] - A[3][3] - A[3][4] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][4] + B[1][0] - B[1][2] + B[2][0] - B[2][2] - B[2][4] + B[3][0] - B[3][2] - B[5][0] + B[5][2] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[1][2] += -P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][1] + A[2][3] + A[2][4]); },[](const NeuralTensor& B) -> double { return (B[0][0] + B[1][0] - B[1][2] - B[1][3] - B[1][4] - B[1][5] + B[1][6] + B[2][0] + B[3][0]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] - A[1][3] - A[1][4]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[0][2] + B[0][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[1][1] += +2*P_k; C[1][3] += -2*P_k; C[0][4] += +P_k; C[3][4] += -P_k; C[0][5] += -2*P_k; C[1][5] += +P_k; C[3][5] += +2*P_k; C[0][6] += -P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5] - A[1][2] - A[1][5] + A[2][1] + A[2][2] - A[2][3] - A[2][4] + A[2][5] - A[3][2] - A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][0] + B[1][0] + B[2][0] + B[3][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[1][2] += -P_k; C[2][2] += +P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[0][5] + A[1][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - B[0][3] + B[0][6] - B[2][1] - B[2][3] + B[2][6] - B[4][1] - B[4][3] + B[4][6] + B[5][2] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[3][0] += -P_k; C[0][2] += +P_k; C[1][2] += -P_k; C[3][2] += -P_k; C[1][4] += +P_k; C[1][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][4] + A[0][5] + A[2][4]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[2][1] + B[2][3] - B[2][6] + B[4][1] + B[4][3] - B[4][6] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[0][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[0][2] + A[0][5] + A[1][5] + A[2][0] - A[2][2] - A[2][5] - A[3][0] + A[3][2] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[0][4] - B[2][5] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[3][0] += -P_k; C[1][2] += +P_k; C[3][2] += -P_k; C[1][4] += -P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - B[0][3] + B[0][6] - B[2][1] - B[2][3] + B[2][6] - B[4][1] - B[4][3] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[3][0] += -P_k; C[0][2] += +2*P_k; C[3][2] += -2*P_k; C[0][4] += -P_k; C[3][4] += +P_k; C[0][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5] + A[2][2] - A[2][3] - A[2][4] + A[2][5] - A[3][2] - A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[0][2] + B[0][4] - B[1][0] + B[1][2] - B[2][0] + B[2][2] + B[2][4] - B[3][0] + B[3][2]); },[](NeuralTensor& C, double P_k) { C[1][2] += +P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1] - A[1][3]); },[](const NeuralTensor& B) -> double { return (-2*B[0][3] - 2*B[0][4] - 2*B[0][5] + 2*B[0][6] - 2*B[2][3] - 2*B[2][4] - 2*B[2][5] + 2*B[2][6] - B[3][3] - B[3][4] - B[3][5] + B[3][6] - B[4][3] - B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][2] += -P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][3] + A[2][1] - A[2][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[1][2] - B[1][3] - B[1][4] - B[1][5] + B[1][6]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[2][4] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[0][2] + A[2][0] - A[2][2] - A[3][0] + A[3][2]); },[](const NeuralTensor& B) -> double { return (-B[2][5] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][4] += -P_k; C[3][4] += +2*P_k; C[0][5] += +P_k; C[3][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[0][5] - A[2][2] + A[2][3] + A[2][4] - A[2][5]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[0][2] + B[0][4] - B[2][0] + B[2][2] + B[2][4]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[3][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[0][2] + A[0][5] + A[2][0] - A[2][2] - A[2][5] - A[3][0] + A[3][2] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][4] - B[2][5] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][2] += -P_k; C[3][2] += +P_k; C[1][4] += +P_k; C[3][4] += -P_k; C[1][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][1] + A[1][3] + A[1][4] - A[3][0] - A[3][1] + A[3][3] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[0][5] += -P_k; C[3][5] += +P_k; C[0][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] + A[0][4] - A[0][5] + A[2][2] - A[2][3] - A[2][4] + A[2][5] - A[3][2] + A[3][3] + A[3][4] - A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][4] + B[1][0] - B[1][2] + B[2][0] - B[2][2] - B[2][4] + B[3][0] - B[3][2] - B[5][0] + B[5][1] + B[5][2] + B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5]); },[](const NeuralTensor& B) -> double { return (-B[5][0] + B[5][2] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[2][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] - A[1][4] + A[3][0] - A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[0][4] + B[0][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][2] += +P_k; C[1][4] += -P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[1][1] + A[2][1] - A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[1][3] - B[1][5] + B[1][6] - B[3][3] - B[3][5] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[2][4] += +P_k; C[1][6] += -P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[0][2] - A[0][5] + A[2][0] - A[2][2] + A[2][5] + A[3][2] - A[3][3] - A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][3]); },[](NeuralTensor& C, double P_k) { C[3][0] += +P_k; C[0][1] += +P_k; C[3][1] += -2*P_k; C[0][3] += -P_k; C[3][3] += +2*P_k; C[0][4] += +P_k; C[3][4] += -P_k; C[0][5] += +P_k; C[3][5] += -P_k; C[0][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][4] + A[1][5] + A[3][2] - A[3][4] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - B[0][3] + B[0][6] - B[2][1] - B[2][3] + B[2][6] - B[3][1] - B[3][3] + B[3][6] + B[5][2] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][2] += -P_k; C[1][4] += +P_k; C[1][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[0][5] - A[2][2] + A[2][4] - A[2][5] + A[3][2] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[2][2] + B[3][2]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - 2*B[0][3] - B[0][4] - B[0][5] + B[0][6] - B[2][1] - 2*B[2][3] - B[2][4] - B[2][5] + B[2][6] - B[4][1] - 2*B[4][3] - B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[3][1] += +P_k; C[0][2] += +P_k; C[1][2] += +P_k; C[3][2] += -P_k; C[0][4] += -P_k; C[1][4] += -P_k; C[3][4] += +P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][1] - A[1][2] + A[1][3] + A[1][4] - A[1][5] - A[3][2] + A[3][4] - A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[2][1] + B[2][3] - B[2][6] + B[3][1] + B[3][3] - B[3][6] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][2] += +P_k; C[1][4] += -P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[0][5] + A[1][2] + A[1][5] - A[2][2] + A[2][3] + A[2][4] - A[2][5] + A[3][2] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][4] + B[1][0] + B[2][0] - B[2][2] - B[2][4] + B[3][0]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[3][0] += +P_k; C[1][2] += -P_k; C[2][2] += +P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][1] - A[1][2] + A[1][3] + A[1][4] - A[3][2] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[2][3] - B[2][4] - B[2][5] - B[3][3] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[3][1] += -P_k; C[1][2] += -P_k; C[1][3] += -P_k; C[3][3] += +P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[1][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[2][2] - B[2][3] - B[2][4] - B[2][5] - B[4][3] + B[5][2] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[3][0] += +P_k; C[1][1] += +P_k; C[0][2] += -P_k; C[1][2] += -P_k; C[3][2] += +P_k; C[1][3] += -P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + A[1][3] + A[1][4]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][4] + B[1][0] + B[3][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][1] + A[1][3] - A[1][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[0][4] - B[0][5] + B[0][6] - B[2][3] - B[2][4] - B[2][5] + B[2][6] - B[4][3] - B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[3][1] += +P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[0][4]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - 2*B[0][3] + B[0][6] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[0][5] += +P_k; C[2][5] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[0][3] + A[1][1] - A[2][1] + A[2][3] + A[3][1]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[1][2] - B[1][3] - B[1][4] - B[1][5] + B[1][6] - B[3][3] - B[3][5] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[3][1] += +P_k; C[2][4] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][3] + A[0][4]); },[](const NeuralTensor& B) -> double { return (-B[4][0] + B[4][2] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[3][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] + A[0][4] - A[0][5] - A[1][5] + A[2][1] + A[2][2] - A[2][3] - A[2][4] + A[2][5] - A[3][1] - A[3][2] + A[3][3] + A[3][4] - A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[0][0] - B[1][0] - B[2][0] - B[3][0] + B[5][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[3][0] += +P_k; C[1][2] += -P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[1][1] - A[1][2] + A[1][3] + A[1][4] - A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[1][3] + B[2][1] + B[2][3] - B[2][6] - B[3][3] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[1][1] += -P_k; C[3][1] += +P_k; C[0][3] += +P_k; C[2][3] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][4]); },[](const NeuralTensor& B) -> double { return (B[3][2] + B[3][3] + B[3][4] + B[3][5] - B[3][6] - B[4][2] - B[4][3] - B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[2][2] += -P_k; C[2][4] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][4] - A[0][5]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[2][1] + B[2][3] - B[2][6] + B[4][1] + B[4][3] - B[4][6] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][5]); },[](const NeuralTensor& B) -> double { return (B[2][1] + B[2][3] + B[2][5] - B[2][6] - B[5][1] - 2*B[5][3] - B[5][5] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][4] += -P_k; C[2][4] += -P_k; C[0][5] += +P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1] - A[1][3] + A[1][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][1] - B[0][4] - B[0][5] + B[0][6] + B[2][1] - B[2][4] - B[2][5] + B[2][6] + B[3][1] + B[3][3] - B[4][3] - B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[3][1] += +P_k; C[1][2] += +P_k; C[1][4] += -P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0] - A[2][2]); },[](const NeuralTensor& B) -> double { return (B[2][1] + B[2][3] - B[2][6] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[2][1] += -P_k; C[0][3] += +P_k; C[2][3] += +P_k; C[0][4] += -P_k; C[2][4] += -P_k; C[0][5] += +P_k; C[2][5] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[1][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[0][4] + B[0][5] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[3][0] += -P_k; C[0][2] += +P_k; C[1][2] += +P_k; C[3][2] += -P_k; C[1][4] += -P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] - A[0][4] + A[2][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[0][6] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[2][5] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][5] + A[1][5] - A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[2][2] - B[2][4] - B[2][5] + B[5][2] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[3][0] += +P_k; C[1][1] += +P_k; C[1][2] += -P_k; C[3][2] += +P_k; C[1][3] += -P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[2][0] - B[2][2] - B[2][3] - B[2][4] - B[2][5] - B[4][3] - B[5][0] + B[5][2] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[3][0] += +P_k; C[0][1] += -P_k; C[3][1] += +P_k; C[0][3] += +P_k; C[3][3] += -P_k; C[0][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[0][5] - A[2][5]); },[](const NeuralTensor& B) -> double { return (B[2][0] - B[2][2] - B[2][4] - B[2][5] - B[5][0] + B[5][2] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[3][0] += +P_k; C[0][1] += -P_k; C[3][1] += +P_k; C[0][3] += +P_k; C[3][3] += -P_k; C[0][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][1] - A[1][3] - A[1][4] + A[3][0] - A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][4] + B[0][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][2] += -P_k; C[1][4] += +P_k; C[1][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[1][1] - A[1][2] + A[1][3] + A[1][4] - A[1][5] + A[2][1] - A[3][1]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[1][1] + B[1][3] - B[1][6] + B[2][1] + B[2][3] - B[2][6] + B[3][1] + B[3][3] - B[3][6] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[0][3]); },[](const NeuralTensor& B) -> double { return (-B[3][0] + B[4][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[2][0] += +P_k; C[0][1] += +P_k; C[2][1] += +P_k; C[0][4] += +P_k; C[2][4] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[1][1] + A[1][2] - A[1][3] - A[1][4] + A[1][5] + A[3][1]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[1][1] + B[1][3] - B[1][6] + B[2][1] + B[2][3] - B[2][6] + B[3][1] + B[3][3] - B[3][6] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += +P_k; C[3][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][4] + B[0][5] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[1][2] += -P_k; C[3][2] += +P_k; C[0][4] += +P_k; C[1][4] += +P_k; C[3][4] += -P_k; C[1][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][3] - A[0][4] - A[0][5] - A[2][2] + A[2][3] + A[2][4] + A[2][5] + A[3][2] - A[3][3] - A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][4] + B[2][0] - B[2][2] - B[2][4] - B[5][0] + B[5][2] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[3][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0]); },[](const NeuralTensor& B) -> double { return (B[0][3] + B[0][5] - B[0][6] + B[2][5]); },[](NeuralTensor& C, double P_k) { C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][1] - A[1][3] - A[1][4] + A[3][1]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][3] - B[0][4] + B[1][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[1][3] += -P_k; C[0][5] += -P_k; C[3][5] += +P_k; C[0][6] += -P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5] - A[2][0] + A[2][2] + A[2][5]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][4] + B[2][5]); },[](NeuralTensor& C, double P_k) { C[2][0] += -P_k; C[3][0] += -P_k; C[0][4] += +P_k; C[3][4] += -P_k; C[0][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][4] - A[2][4]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] + B[2][1] + B[2][3] + B[4][1] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[0][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] + A[1][3] + A[1][4]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[0][2] + B[0][4] + B[1][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[1][3] += -P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1] + A[3][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[1][2] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[1][2] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][3] + A[2][4]); },[](const NeuralTensor& B) -> double { return (-B[1][0] + B[1][2] + B[1][3] + B[1][4] + B[1][5] - B[1][6] - B[3][0] + B[4][0]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[0][1] += +P_k; C[2][1] += +P_k; C[2][4] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][4] + A[3][2] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[2][2] - B[2][3] - B[2][4] - B[2][5] - B[3][3] + B[5][2] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[1][2] += -P_k; C[1][3] += -P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][4] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][1] + B[0][2] + B[0][4] + B[0][5] + B[0][6] - B[2][1] + B[2][2] + B[2][4] + B[2][5] + B[2][6] - B[4][1] + B[4][2] + B[4][4] + B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[3][0] += -P_k; C[1][1] += +P_k; C[0][2] += +P_k; C[1][2] += -P_k; C[3][2] += -P_k; C[1][4] += +P_k; C[1][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][3] + A[0][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[1][2] + B[3][0] - B[3][2] - B[4][0] + B[4][2] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[1][2] += -P_k; C[3][2] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][1]); },[](const NeuralTensor& B) -> double { return (B[1][4] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[1][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] + A[1][2]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[0][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[1][4] += -P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] + A[0][4] - A[2][0] + A[2][2] - A[3][2] + A[3][3] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[2][1] + B[2][3] - B[2][6] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[0][3] += +P_k; C[2][3] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[2][1] + A[3][1]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] + B[1][1] + B[1][3] + B[2][1] + B[2][3] + B[3][1] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[3][1] += +P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][1] - A[3][1]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][4] + B[1][3] + B[1][5] + B[3][3] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[1][3] += -P_k; C[0][4] += -P_k; C[3][4] += +P_k; C[0][6] += -P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5] + A[2][5] - A[3][2] - A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[2][4] - B[2][5] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[3][1] += +P_k; C[1][2] += +P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[1][3] += +P_k; C[3][3] += -P_k; C[1][4] += -P_k; C[2][4] += +P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5] - A[1][2] - A[1][5] - A[3][2] - A[3][5]); },[](const NeuralTensor& B) -> double { return (B[5][2] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[2][0] += -P_k; C[3][0] += -P_k; C[1][2] += -P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[1][4] += +P_k; C[1][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2] + A[2][5]); },[](const NeuralTensor& B) -> double { return (B[5][6]); },[](NeuralTensor& C, double P_k) { C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5] - A[1][2] - A[1][5] + A[2][5] - A[3][2] - A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[2][2] - B[2][4] - B[2][5] + B[5][2] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[2][0] += +P_k; C[3][0] += +P_k; C[1][1] += +P_k; C[1][2] += -P_k; C[2][2] += +P_k; C[3][2] += +P_k; C[1][3] += -P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][3] - A[1][1] + A[1][3] - A[1][4] + A[2][1] - A[2][3] - A[3][1] + A[3][3] - A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] + B[2][1] + B[2][3] + B[3][1] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[3][1] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[1][1] + A[1][2] - A[1][3] - A[1][4] - A[2][1] + A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[1][3] - B[2][6] - B[3][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[3][1] += +P_k; C[2][3] += +P_k; C[1][6] += -P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[0][5] + A[2][0] - A[2][2] - A[2][5] + A[3][2] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[0][4] + B[2][5]); },[](NeuralTensor& C, double P_k) { C[1][2] += -P_k; C[2][2] += +P_k; C[3][2] += +P_k; C[1][4] += +P_k; C[2][4] += -P_k; C[3][4] += -P_k; C[1][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[0][3] + A[1][1] + A[1][2] - A[1][3] - A[1][4] + A[1][5] - A[2][1] + A[2][3] + A[3][1] + A[3][2] - A[3][3] - A[3][4] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[2][1] + B[2][3] - B[2][6] + B[3][1] + B[3][3] - B[3][6] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[3][1] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][3] - A[1][1] - A[1][2] + A[1][3] + A[1][4] - A[1][5] - A[3][1] - A[3][2] + A[3][3] + A[3][4] - A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[2][1] + B[2][3] - B[2][6] + B[3][1] + B[3][3] - B[3][6] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[3][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][0] + A[2][2] + A[2][5]); },[](const NeuralTensor& B) -> double { return (B[2][1] + B[2][3] + B[2][5] - B[2][6] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][4] += -P_k; C[2][4] += -P_k; C[0][5] += +P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0] - A[2][3] - A[2][4]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[2][1] + B[2][3] - B[2][6] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1] + A[1][2] - A[1][3] - A[1][4] + A[1][5]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[1][1] + B[1][3] - B[1][6] + B[2][1] + B[2][3] - B[2][6] + B[3][1] + B[3][3] - B[3][6] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[1][1] + A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[1][1] - 2*B[1][3] - B[1][5] + B[1][6] - B[3][1] - 2*B[3][3] - B[3][5] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[0][4] += +P_k; C[2][4] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] - 2*A[0][2] - A[1][0] + A[1][1] + A[1][3] + A[1][4] - 2*A[2][0] + 2*A[2][2] + A[3][0] + A[3][1] - A[3][2]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[0][2] + B[0][4]); },[](NeuralTensor& C, double P_k) { C[0][4] += +P_k; C[3][4] += -P_k; C[0][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[0][3] + A[0][4] + A[2][0] - A[2][3] - A[2][4] - A[3][0] + A[3][3] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[0][6]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[2][5] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][2] + 2*B[0][3] + B[0][4] + B[0][5] + B[0][6] + B[2][1] + B[2][2] + 2*B[2][3] + B[2][4] + B[2][5] + B[2][6] + B[3][1] + B[3][3] + B[4][2] + B[4][3] + B[4][4] + B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[1][2] += -P_k; C[1][4] += +P_k; C[1][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[1][0] + A[1][1] - A[1][3] - A[1][4] + A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - 2*B[0][3] + B[0][6] + B[1][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[0][5] += +P_k; C[2][5] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] - A[0][3] - A[0][4] + A[0][5] - A[2][1] - A[2][2] + A[2][3] + A[2][4] - A[2][5] + A[3][1] + A[3][2] - A[3][3] - A[3][4] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[0][0] - B[1][0] + B[1][2] - B[2][0] - B[3][0] + B[5][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[3][0] += +P_k; C[1][2] += -P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][1] + A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[1][0] + B[1][2]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[3][0] += +P_k; C[1][2] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] - A[0][3] - A[0][4] + A[3][0] - A[3][3] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - 2*B[0][3] + B[0][6]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[0][5] += +P_k; C[2][5] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5] + A[2][1] + A[2][2] - A[2][3] - A[2][4] + A[2][5] - A[3][2] - A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][0] + B[1][0] - B[1][2] + B[2][0] + B[3][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[3][0] += -P_k; C[1][2] += +P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[1][0] - A[1][1] + A[1][3] + A[1][4] + A[2][1] - A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[0][6] + B[1][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[2][5] += +P_k; C[1][6] += -P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][3] - A[1][1] - A[1][2] + A[1][3] + A[1][4] + A[2][1] - A[2][3] - A[3][1] - A[3][2] + A[3][3] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[2][6] - B[3][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[3][1] += +P_k; C[2][3] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][3] - A[0][4] - A[1][4] - A[3][4]); },[](const NeuralTensor& B) -> double { return (B[1][0] + B[3][0] - B[4][0] + B[4][2] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[3][0] += +P_k; C[0][2] += -P_k; C[1][2] += -P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1] + A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[1][0] + B[1][2] + B[1][3] + B[1][4] + B[1][5] + B[3][3] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[0][4] += -P_k; C[3][4] += +P_k; C[0][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][4] - A[2][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[2][6] - B[4][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][3] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1] + A[1][2] - A[1][3] - A[1][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[1][3] - B[2][3] - B[2][4] - B[2][5] - B[3][3] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[3][1] += -P_k; C[1][3] += -P_k; C[3][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] + A[0][4] - A[0][5] - A[1][5] + A[2][2] - A[2][3] - A[2][4] + A[2][5] - A[3][2] + A[3][3] + A[3][4] - A[3][5]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][4] + B[1][0] + B[2][0] - B[2][2] - B[2][4] + B[3][0] - B[5][0] + B[5][2] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[3][0] += +P_k; C[1][2] += -P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[0][3] + A[1][1] + A[1][2] - A[1][3] - A[1][4] + A[3][1] + A[3][2] - A[3][3] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[2][1] + B[2][3] - B[2][6] - B[3][3] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[3][1] += +P_k; C[0][3] += +P_k; C[2][3] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[2][3] - B[2][4] - B[2][5] - B[4][3] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[3][1] += +P_k; C[0][2] += +P_k; C[1][2] += +P_k; C[3][2] += -P_k; C[1][3] += +P_k; C[3][3] += -P_k; C[0][4] += -P_k; C[1][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2]); },[](const NeuralTensor& B) -> double { return (B[2][3] - B[2][6] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[2][1] += -P_k; C[2][3] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[0][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[1][1] - B[1][2] - 2*B[1][3] - B[1][4] - B[1][5] + B[1][6]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[3][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[0][5] + A[1][2] + A[1][5] + A[2][0] - A[2][2] - A[2][5] + A[3][2] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[0][2] - B[0][4] + B[2][5]); },[](NeuralTensor& C, double P_k) { C[2][0] += -P_k; C[3][0] += -P_k; C[1][2] += +P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[1][4] += -P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1] + A[1][2] - A[1][3] - A[1][4] + A[3][1]); },[](const NeuralTensor& B) -> double { return (B[0][3] + B[1][3] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[1][1] += +P_k; C[3][1] += -P_k; C[0][3] += -P_k; C[1][3] += -P_k; C[3][3] += +P_k; C[0][6] += -P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[0][3] + A[1][0] + A[1][1] - A[1][3] - A[1][4] - A[2][1] + A[2][3] + A[3][0] + A[3][1] - A[3][3] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[0][6] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[3][1] += +P_k; C[2][5] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][4]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[2][2] + B[3][2] + B[3][3] + B[3][4] + B[3][5] - B[3][6] - B[4][3] - B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[2][1] + B[2][3] - B[2][6] - B[4][3] - B[5][1] - B[5][3] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][3] += +P_k; C[2][3] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[0][2] + B[0][4] + B[0][5] + B[4][5]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[3][0] += -P_k; C[0][4] += +P_k; C[3][4] += -P_k; C[0][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][3] - A[0][4] - A[2][2] + A[2][3] + A[2][4] + A[3][2] - A[3][3] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][3] - B[2][6] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[2][3] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] - 2*A[0][2] + A[0][5] - 2*A[2][0] + 2*A[2][2] - A[2][5] + A[3][0] - 2*A[3][2] + A[3][3] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][3]); },[](NeuralTensor& C, double P_k) { C[3][0] += +P_k; C[3][1] += -P_k; C[3][3] += +P_k; C[0][4] += +P_k; C[3][4] += -P_k; C[0][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][3] - A[1][0] - A[1][1] + A[1][3] + A[1][4] - A[3][0] - A[3][1] + A[3][3] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - 2*B[0][3] + B[0][6] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[3][1] += +P_k; C[0][5] += +P_k; C[2][5] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][4] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[3][2] + B[4][2]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] - A[0][3] - A[0][4] - A[1][4] - A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[1][0] - B[3][0] + B[4][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[1][0] += -P_k; C[3][0] += +P_k; C[0][2] += -P_k; C[1][2] += -P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][3] + A[0][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (-B[1][0] + B[1][2] - B[3][0] + B[4][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[3][0] += +P_k; C[0][2] += -P_k; C[1][2] += -P_k; C[3][2] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][3] - A[2][4]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][4] + B[1][0] - B[1][2] - B[1][3] - B[1][4] - B[1][5] + B[1][6] + B[2][0] - B[2][2] - B[2][4] + B[3][0] - B[3][2] - B[3][3] - B[3][4] - B[3][5] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][3] + A[2][4]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[1][2] - B[1][3] - B[1][4] - B[1][5] + B[1][6] + B[3][0] - B[3][2] - B[3][3] - B[3][4] - B[3][5] + B[3][6] - B[4][0] + B[4][2] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[2][4] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][1] - A[1][2] + A[1][3] + A[1][4] - A[3][1] - A[3][2] + A[3][3] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][3] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[3][1] += -P_k; C[0][3] += -P_k; C[3][3] += +P_k; C[0][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] - A[0][5] - A[3][4]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3] - B[0][6] + B[2][1] + B[2][3] - B[2][6] + B[4][1] + B[4][3] - B[4][6] + B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k; C[1][2] += +P_k; C[3][2] += -P_k; C[0][4] += -P_k; C[1][4] += -P_k; C[3][4] += +P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][5] + A[2][5]); },[](const NeuralTensor& B) -> double { return (B[0][3] + B[2][0] - B[2][2] - B[2][4] - B[2][5] - B[5][0] + B[5][2] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[3][0] += -P_k; C[0][1] += -P_k; C[3][1] += +P_k; C[0][3] += +P_k; C[3][3] += -P_k; C[0][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] + A[0][3] - A[1][1] - A[3][1]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[1][1] - B[1][2] - 2*B[1][3] - B[1][4] - B[1][5] + B[1][6] - B[3][1] - 2*B[3][3] - B[3][5] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[3][1] += +P_k; C[0][4] += +P_k; C[2][4] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[1][1] - B[1][2] - 2*B[1][3] - B[1][4] - B[1][5] + B[1][6] + B[3][0] - B[3][1] - B[3][2] - 2*B[3][3] - B[3][4] - B[3][5] + B[3][6] - B[4][0] + B[4][2] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[0][4] += +P_k; C[2][4] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[0][2] - A[0][5] + A[2][0] - A[2][2] + A[2][5] - A[3][0] + A[3][2]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[0][2] + B[0][3] + B[0][4] - B[2][5] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[3][0] += +P_k; C[0][4] += +P_k; C[3][4] += -P_k; C[0][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][5] - A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[2][4] - B[2][5] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[3][1] += +P_k; C[1][2] += +P_k; C[3][2] += -P_k; C[1][3] += +P_k; C[3][3] += -P_k; C[1][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1] - A[1][3] + A[3][1] - A[3][3]); },[](const NeuralTensor& B) -> double { return (B[1][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[1][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][5]); },[](const NeuralTensor& B) -> double { return (B[5][3]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[0][3] += -P_k; C[2][3] += -P_k; C[0][5] += +P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] + A[0][5] + A[3][2] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[5][3] + B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][2] += +P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[1][4] += -P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[1][6] += -P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][1] + A[1][3] + A[1][4]); },[](const NeuralTensor& B) -> double { return (B[0][4] + B[0][5] + B[1][5] + B[3][5]); },[](NeuralTensor& C, double P_k) { C[1][5] += -P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][3] + A[3][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] + B[3][2] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[1][2] += +P_k;}});
return formula;
}

std::vector<ActivationTerm> loadFusionParams() {
std::vector<ActivationTerm> formula;
formula.push_back({[](const NeuralTensor& A) -> double { return (A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (-B[4][3] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][1] += -2*P_k; C[1][1] += +2*P_k; C[3][1] += -P_k; C[5][1] += -P_k; C[0][2] += -2*P_k; C[1][2] += +2*P_k; C[3][2] += -P_k; C[5][2] += -P_k; C[0][3] += +2*P_k; C[1][3] += -2*P_k; C[3][3] += +P_k; C[5][3] += +P_k; C[0][5] += +4*P_k; C[1][5] += -4*P_k; C[3][5] += +2*P_k; C[5][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[4][3]); },[](const NeuralTensor& B) -> double { return (B[2][3] - B[2][4] - B[2][6] + B[3][3] - B[3][4] - B[3][6] + B[4][3] - B[4][4] - B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[4][4] += +P_k; C[5][4] += -P_k; C[4][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][4] + A[1][5] - A[2][4] - A[2][5] + A[3][4] + A[3][5] - A[4][4] - A[4][5] + A[5][1] + A[5][2] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][1] + B[3][1] + B[4][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[5][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] - A[0][4] + A[1][0] - A[1][1] - A[2][0] + A[2][1] + A[3][0] - A[3][1] - A[4][0] + A[4][1] - A[5][0] + A[5][1]); },[](const NeuralTensor& B) -> double { return (B[1][6] - B[2][6] - B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][5] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[5][5] += +2*P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[4][1] - A[4][2] + A[4][3] - A[5][5]); },[](const NeuralTensor& B) -> double { return (B[1][1] - B[1][3] + B[1][4] + B[1][5] - 2*B[1][6] - B[2][1] - B[3][1] - B[4][1] + B[5][1]); },[](NeuralTensor& C, double P_k) { C[5][1] += -P_k; C[5][2] += -P_k; C[5][3] += +P_k; C[5][4] += +P_k; C[4][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] + A[1][1] + A[1][2] - A[2][1] - A[2][2] + A[3][1] + A[3][2] - A[4][1] - A[4][2] - A[5][1] - A[5][2]); },[](const NeuralTensor& B) -> double { return (-2*B[2][3] + 2*B[2][4] + B[2][5] - 2*B[2][6] - 2*B[3][3] + 2*B[3][4] + B[3][5] - 2*B[3][6]); },[](NeuralTensor& C, double P_k) { C[5][4] += -P_k; C[2][5] += -P_k; C[3][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] - A[1][2]); },[](const NeuralTensor& B) -> double { return (B[0][3] - B[0][4] + B[1][3] - B[1][4] - B[2][2] - B[2][3] + B[2][4] - B[3][2] - B[3][3] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[1][2] += +P_k; C[0][3] += +P_k; C[0][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][1] - A[3][1] - A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[1][1] - B[1][3] + B[2][1]); },[](NeuralTensor& C, double P_k) { C[2][1] += -P_k; C[3][1] += -P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[3][3] += +P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[4][0] + A[4][2] - A[4][3]); },[](const NeuralTensor& B) -> double { return (-2*B[0][1] + B[0][2] - B[0][3] + B[0][4] + B[0][6] - B[1][1] + B[1][2] + B[2][1] - B[2][2] + B[3][1] - B[3][2] + B[4][1] - B[4][2] - B[5][1] + B[5][2]); },[](NeuralTensor& C, double P_k) { C[4][2] += +P_k; C[5][2] += -P_k; C[4][3] += -P_k; C[5][3] += +P_k; C[4][4] += -P_k; C[5][4] += +P_k; C[4][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[5][4] - A[5][5]); },[](const NeuralTensor& B) -> double { return (-2*B[4][3] + 2*B[4][4] + B[4][5] - 2*B[4][6]); },[](NeuralTensor& C, double P_k) { C[5][5] += +P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[2][0] + B[2][3] - B[3][0] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[2][5] += -2*P_k; C[3][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][5] - A[4][3] - A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[2][0] + B[2][3] - B[3][0] + B[3][3] + B[4][3] - B[4][4] - B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[4][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[2][5] += -2*P_k; C[3][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][0] + A[3][0]); },[](const NeuralTensor& B) -> double { return (2*B[0][1] - B[0][2] + B[0][3] - B[0][4] + B[1][1] - B[1][2] - B[2][1] + B[2][2]); },[](NeuralTensor& C, double P_k) { C[3][2] += -P_k; C[4][2] += -P_k; C[3][3] += +P_k; C[4][3] += +P_k; C[3][4] += +P_k; C[4][4] += +P_k; C[3][5] += +3*P_k; C[4][5] += +3*P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][3] - A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6] - B[5][1] - 3*B[5][3] + 3*B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[2][1] += +P_k; C[0][2] += +P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += +P_k; C[0][4] += -P_k; C[1][4] += +P_k; C[0][5] += -P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + A[1][3] - A[2][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[3][6] - B[4][1] - B[4][3] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[2][1] += +P_k; C[0][2] += -P_k; C[1][2] += +P_k; C[0][3] += +P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += -P_k; C[0][5] += -P_k; C[1][5] += +P_k; C[0][6] += -P_k; C[1][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] - A[0][4] - A[1][1] - A[1][2] + A[1][3] - A[1][4] + A[2][1] + A[2][2] - A[2][3] + A[2][4] + A[3][1] + A[3][2] - A[4][1] - A[4][2]); },[](const NeuralTensor& B) -> double { return (B[2][6] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[4][4] += +P_k; C[5][4] += -P_k; C[4][5] += -3*P_k; C[5][5] += +3*P_k; C[4][6] += -P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][1]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[1][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[1][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][4] + A[3][5] - A[4][4] - A[4][5] + A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][0] - B[2][3] + B[3][0] - B[3][3] - B[4][3] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[5][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[2][5] += -2*P_k; C[3][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2] - A[3][2] + A[4][2] - A[4][3] + A[5][2] - A[5][3]); },[](const NeuralTensor& B) -> double { return (-B[2][3] + B[2][4] + B[2][5] - 2*B[2][6] - 2*B[3][3] + 2*B[3][4] + B[3][5] - 2*B[3][6]); },[](NeuralTensor& C, double P_k) { C[5][4] += -P_k; C[3][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + A[2][0] - A[3][0] + A[4][0] + A[5][0]); },[](const NeuralTensor& B) -> double { return (B[0][3] - B[0][4] + B[1][3] - B[1][4] - 2*B[2][3] + 2*B[2][4] + B[2][5] - 2*B[2][6] - 2*B[3][3] + 2*B[3][4] + B[3][5] - 2*B[3][6]); },[](NeuralTensor& C, double P_k) { C[5][4] += -P_k; C[1][5] += -P_k; C[2][5] += -P_k; C[3][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] - A[0][2] + A[0][3] + A[0][5]); },[](const NeuralTensor& B) -> double { return (-2*B[1][3] + 2*B[1][4] + B[1][5] - B[1][6] + 2*B[2][3] - 2*B[2][4] - B[2][5] + B[2][6] + 2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6] + B[5][2] - B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][3] += +P_k; C[0][4] += +P_k; C[0][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][5] - A[1][5] + A[2][5] - A[3][5] + A[4][3] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[2][2] - B[3][2] + B[4][3] - B[4][4] - B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[4][2] += -P_k; C[0][3] += +P_k; C[0][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + A[2][3] + A[2][5] + A[3][2] - A[3][3] - A[3][5] - A[4][2] + A[4][3] - A[5][2] + A[5][3]); },[](const NeuralTensor& B) -> double { return (2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + A[3][2] - A[4][2] + A[4][3]); },[](const NeuralTensor& B) -> double { return (-B[2][3] + B[2][4] + B[2][6] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[4][4] += -P_k; C[5][4] += +P_k; C[3][5] += +2*P_k; C[4][5] += +3*P_k; C[5][5] += -P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][2] - A[1][3] - A[1][5] - A[2][0] + A[3][0] - A[4][0] - A[5][0]); },[](const NeuralTensor& B) -> double { return (-2*B[0][3] + 2*B[0][4] + B[0][5] - B[0][6] - 2*B[1][3] + 2*B[1][4] + B[1][5] - B[1][6] + 2*B[2][3] - 2*B[2][4] - B[2][5] + B[2][6] + 2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][5] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][3] + A[1][2] - A[1][3] - A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6] + B[5][2] - B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[2][2] += -P_k; C[0][3] += +P_k; C[0][4] += +P_k; C[0][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][5] + A[4][1] + A[4][2] - A[4][3] - A[4][5]); },[](const NeuralTensor& B) -> double { return (B[1][1] + B[1][3] - B[2][1] - B[3][1] - B[4][1] + B[5][1]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[3][1] += +P_k; C[2][2] += +P_k; C[3][2] += +P_k; C[4][3] += +P_k; C[4][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][1] + A[3][1] + A[4][2] - A[4][3]); },[](const NeuralTensor& B) -> double { return (-B[1][1] - B[1][3] + B[1][4] + B[1][6] + B[2][1]); },[](NeuralTensor& C, double P_k) { C[4][1] += +P_k; C[5][1] += -P_k; C[4][2] += +P_k; C[5][2] += -P_k; C[4][3] += -P_k; C[5][3] += +P_k; C[4][4] += -P_k; C[5][4] += +P_k; C[3][5] += +2*P_k; C[4][5] += +P_k; C[5][5] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][3] + A[0][4] - A[1][3] + A[1][4] + A[2][3] - A[2][4]); },[](const NeuralTensor& B) -> double { return (B[1][1] - B[1][2] - B[2][1] + B[2][2] - B[3][1] + B[3][2]); },[](NeuralTensor& C, double P_k) { C[2][2] += +P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] + A[1][1] - A[2][0] + A[2][1] + A[3][0] - A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[1][3] + B[1][4] + B[4][3] - B[4][4] - B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[3][1] += -P_k; C[4][1] += -P_k; C[3][2] += -P_k; C[4][2] += -P_k; C[3][3] += +P_k; C[4][3] += +P_k; C[3][5] += +2*P_k; C[4][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][3] - A[2][4]); },[](const NeuralTensor& B) -> double { return (B[2][3] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += -P_k; C[1][2] += -P_k; C[2][2] += -P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[1][5] += +2*P_k; C[2][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][4] - A[0][5] - A[1][4] - A[1][5] + A[2][4] + A[2][5] - A[3][4] - A[3][5] + A[4][4] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[4][2] - B[4][3] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k; C[2][2] += +P_k; C[3][2] += +P_k; C[5][2] += +P_k; C[0][3] += -P_k; C[0][4] += -P_k; C[0][5] += +P_k; C[0][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[1][0]); },[](const NeuralTensor& B) -> double { return (-B[0][1] + B[0][2]); },[](NeuralTensor& C, double P_k) { C[1][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][5] + A[1][5] - A[2][5] + A[3][5] - A[4][4] - A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[4][2] - B[4][3] + B[4][4] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k; C[2][2] += +P_k; C[3][2] += +P_k; C[4][2] += +P_k; C[0][3] += -P_k; C[0][4] += -P_k; C[0][5] += +P_k; C[0][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] - A[0][1] - A[0][2] + A[0][3] + 4*A[1][0] - 2*A[1][1] - 2*A[2][0] - A[3][0] + A[3][1] + A[3][2] - A[3][3] - 3*A[4][0] + A[4][1] + A[4][2] - A[4][3] - A[5][0] - A[5][1]); },[](const NeuralTensor& B) -> double { return (B[1][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[4][0] += +2*P_k; C[5][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] + A[0][5] - A[1][1] - A[1][2] + A[1][3] + A[1][5] + A[2][1] + A[2][2] - A[2][3] - A[2][5] + A[3][1] + A[3][2] - A[4][1] - A[4][2] - A[5][1] - A[5][2]); },[](const NeuralTensor& B) -> double { return (-B[2][1] - 2*B[2][3] + 2*B[2][4] + B[2][5] - B[2][6] - B[3][1] - 2*B[3][3] + 2*B[3][4] + B[3][5] - B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0] - A[3][0] - A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[0][2] - B[0][3] + B[1][1] - B[1][2] - B[2][1] + B[2][2]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[3][2] += -P_k; C[3][3] += +P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][4] + A[2][5] - A[3][4] - A[3][5] + A[4][4] + A[4][5] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (-B[2][3] - B[3][3] - B[4][3] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[5][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k; C[3][3] += +P_k; C[5][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[5][4] += +P_k; C[1][5] += -2*P_k; C[2][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0] - A[3][0] - A[4][2] + A[4][3]); },[](const NeuralTensor& B) -> double { return (2*B[0][1] - B[0][2] + B[0][3] - B[0][4] - B[0][6] + B[1][1] - B[1][2] - B[2][1] + B[2][2]); },[](NeuralTensor& C, double P_k) { C[4][2] += -P_k; C[5][2] += +P_k; C[4][3] += +P_k; C[5][3] += -P_k; C[4][4] += +P_k; C[5][4] += -P_k; C[3][5] += +2*P_k; C[4][5] += +3*P_k; C[5][5] += -P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[5][3] + A[5][5]); },[](const NeuralTensor& B) -> double { return (B[2][3] - B[2][4] - B[2][5] + 2*B[2][6] + B[3][3] - B[3][4] - B[3][5] + 2*B[3][6] - B[4][3] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[5][4] += +P_k; C[5][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[3][1] + 2*A[3][2] - A[3][3] + A[3][4] - 2*A[4][1] - 2*A[4][2] + A[4][3] - A[4][4] - 2*A[5][1] - 2*A[5][2] + A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[5][5] += +2*P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[3][2] - A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[0][2] - B[0][3] + B[1][0] - B[1][2] - B[1][3] - B[2][0] + B[2][2] + B[2][3]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[3][0] += -P_k; C[0][3] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] - A[0][4] - A[1][1] - A[1][2] + A[1][3] - A[1][4] + A[2][1] + A[2][2] - A[2][3] + A[2][4]); },[](const NeuralTensor& B) -> double { return (-B[2][6] - B[3][6] - B[4][0] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[2][5] += +P_k; C[3][5] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[1][2] - A[1][3]); },[](const NeuralTensor& B) -> double { return (B[0][0] - 2*B[0][3] + B[0][4] + B[0][5] - 2*B[0][6] + B[1][0] - 2*B[1][3] + B[1][4] + B[1][5] - 2*B[1][6] - B[2][0] + 2*B[2][3] - B[2][4] - B[2][5] + 2*B[2][6] - B[3][2] + B[3][3] - B[3][4] - B[3][5] + 2*B[3][6] - B[4][2] + B[4][3] - B[4][4] - B[4][5] + 2*B[4][6] + B[5][2] - B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[1][2] += +P_k; C[0][3] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] - A[0][3] + A[0][4] - A[1][0] + A[1][1] + A[2][0] - A[2][1]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[1][6] + B[2][6] + B[3][0] + B[3][6] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][3] += +P_k; C[0][4] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[4][4] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[4][3] + B[4][4] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[3][1] += +P_k; C[4][1] += +P_k; C[3][2] += +P_k; C[4][2] += +P_k; C[3][3] += -P_k; C[4][3] += -P_k; C[3][4] += -P_k; C[4][4] += -P_k; C[3][5] += +P_k; C[4][5] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2]); },[](const NeuralTensor& B) -> double { return (B[0][3] - B[0][4] + B[1][3] - B[1][4] - B[2][1] - B[2][3] + B[2][4] - B[3][1] - B[3][3] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += +P_k; C[0][5] += -2*P_k; C[1][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][2] - A[0][3] + A[1][2] - A[1][3] + A[2][3] - A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[2][2] - B[3][2] - B[3][3] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[2][2] += -P_k; C[0][3] += +P_k; C[0][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] + A[1][1] + A[2][0]); },[](const NeuralTensor& B) -> double { return (-B[0][1] + B[1][3]); },[](NeuralTensor& C, double P_k) { C[2][1] += -P_k; C[3][1] += -P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[3][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] - A[0][3] + 2*A[0][4] + A[0][5] + A[1][0] - A[1][1] - A[1][2] - A[1][3] + A[1][4] + A[1][5] - A[2][0] + A[2][1] + A[2][2] + A[2][3] - A[2][4] - 3*A[2][5] - 2*A[3][3] + A[3][4] + A[3][5] + 2*A[4][3] - A[4][4] + A[4][5] + A[5][2] + A[5][3] - A[5][4] - A[5][5]); },[](const NeuralTensor& B) -> double { return (B[2][0] + B[3][0] + B[4][0] + 2*B[5][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] - A[1][0] + A[1][1] - 2*A[1][2] + 2*A[1][3] + 3*A[2][0] + 2*A[2][2] - 2*A[2][3] - A[3][0] - A[3][1] - A[3][2] + A[3][3] + A[4][0] - A[5][0] + A[5][1] + 2*A[5][2] - 2*A[5][3]); },[](const NeuralTensor& B) -> double { return (B[1][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[2][0] += +P_k; C[4][0] += +2*P_k; C[5][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] - A[2][0] + A[3][0]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[0][4] - B[1][3] + B[1][4]); },[](NeuralTensor& C, double P_k) { C[1][4] += -P_k; C[2][4] += -P_k; C[3][4] += -P_k; C[4][4] += -P_k; C[1][5] += +3*P_k; C[2][5] += +3*P_k; C[3][5] += +3*P_k; C[4][5] += +3*P_k; C[1][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][3] + A[1][4]); },[](const NeuralTensor& B) -> double { return (-B[0][6] - B[1][6] + B[2][6] + B[3][6] - B[4][1] - B[4][3] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[1][2] += +P_k; C[0][3] += +P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += -P_k; C[0][5] += -P_k; C[1][5] += +P_k; C[0][6] += -P_k; C[1][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][4] + A[0][5] + A[1][0] - A[1][1] - A[2][0] + A[2][1] - A[3][3] + A[3][4] + A[4][3] - A[4][4] + A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][0] + B[3][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[1][0] += +P_k; C[0][3] += -P_k; C[1][3] += +P_k; C[0][4] += -P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][5]); },[](const NeuralTensor& B) -> double { return (B[2][3] + B[3][3] + B[4][3] - B[5][0] - B[5][3] + B[5][4] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[4][0] += +P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[3][3] += +P_k; C[4][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[4][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][4] - A[3][5] + A[4][4] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[4][0] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[5][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][4] - A[3][5] + A[4][4] + A[4][5] + A[5][4] + A[5][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] + 3*B[0][3] - B[0][4] - B[0][5] + 2*B[0][6] - B[1][2] + B[1][3] - B[1][4] - B[1][5] + 2*B[1][6] + B[2][2] - B[2][3] + B[2][4] + B[2][5] - 2*B[2][6] + B[3][2] + B[3][3] + B[4][2] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[5][3] += +P_k; C[5][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][3] - A[3][4] - A[4][3] + A[4][4] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (-B[2][0] + B[2][3] - B[3][0] + B[3][3]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k; C[1][3] += -P_k; C[3][3] += +P_k; C[1][5] += -2*P_k; C[3][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[1][2] - A[1][3] + A[1][4]); },[](const NeuralTensor& B) -> double { return (-B[0][6] - B[1][6] + B[2][6] + B[3][6] - B[4][2] - B[4][3] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[0][4] += -P_k; C[0][5] += +P_k; C[0][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0] - A[3][0] + A[4][0]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - B[0][3] + B[0][4] + B[0][6]); },[](NeuralTensor& C, double P_k) { C[4][2] += -P_k; C[5][2] += +P_k; C[4][3] += +P_k; C[5][3] += -P_k; C[4][4] += +P_k; C[5][4] += -P_k; C[1][5] += +2*P_k; C[2][5] += +2*P_k; C[3][5] += +2*P_k; C[4][5] += +3*P_k; C[5][5] += -P_k; C[1][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + A[1][3] + A[2][0] + A[2][2] - A[2][3] + A[5][5]); },[](const NeuralTensor& B) -> double { return (2*B[3][3] - B[3][4] - B[3][5] + 2*B[3][6] + 2*B[4][3] - B[4][4] - B[4][5] + 2*B[4][6] + B[5][0] - 2*B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[5][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] + A[0][1] + A[0][2] - A[0][3] - 4*A[1][0] + A[1][1] + 3*A[1][2] - 3*A[1][3] - A[2][0] + A[2][1] - 3*A[2][2] + 3*A[2][3] + 2*A[3][0] + 3*A[4][0] - A[4][1] - A[4][2] + A[4][3] + 3*A[5][0] - 3*A[5][2] + 3*A[5][3]); },[](const NeuralTensor& B) -> double { return (B[1][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[2][0] += +P_k; C[4][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] - A[0][2]); },[](const NeuralTensor& B) -> double { return (B[1][3] - B[1][4] - B[2][2] - B[2][3] + B[2][4] - B[3][2] - B[3][3] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[0][3] += +P_k; C[0][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][2] - A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[0][2] - B[0][3] - B[1][2] - B[1][3] + B[2][2] + B[2][3]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[3][0] += +P_k; C[0][3] += -P_k; C[3][3] += +P_k; C[0][4] += -P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[4][3] - A[5][5]); },[](const NeuralTensor& B) -> double { return (-B[2][3] + B[2][4] + B[2][5] - 2*B[2][6] - B[3][3] + B[3][4] + B[3][5] - 2*B[3][6] + B[4][3] - B[4][4] - B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[5][4] += -P_k; C[4][5] += +P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + A[1][3] + A[1][5] + A[2][0]); },[](const NeuralTensor& B) -> double { return (-2*B[0][3] + 2*B[0][4] + B[0][5] - B[0][6] - 2*B[1][3] + 2*B[1][4] + B[1][5] - B[1][6] + 2*B[2][3] - 2*B[2][4] - B[2][5] + B[2][6] + 2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6] + B[5][0] - 2*B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][3] += -P_k; C[1][4] += -P_k; C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][5] - A[1][5] + A[2][5] - A[3][5] - A[4][0] - A[4][2] + A[4][3] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[1][1] + B[1][2] + B[2][1] - B[2][2] + B[3][1] - B[3][2] + B[4][1] - B[4][2] - B[5][1] + B[5][2]); },[](NeuralTensor& C, double P_k) { C[2][2] += +P_k; C[3][2] += +P_k; C[4][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + A[1][3] + A[2][1] + A[2][2] - A[2][3] - A[3][1] - A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (B[2][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] - A[1][2] + A[1][3] + A[1][5]); },[](const NeuralTensor& B) -> double { return (-2*B[0][3] + 2*B[0][4] + B[0][5] - B[0][6] - 2*B[1][3] + 2*B[1][4] + B[1][5] - B[1][6] + 2*B[2][3] - 2*B[2][4] - B[2][5] + B[2][6] + 2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6] + B[5][2] - B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[1][2] += +P_k; C[0][3] += +P_k; C[0][4] += +P_k; C[0][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2] - A[2][3] + A[2][4] - A[3][2] + A[3][3] - A[3][4] + A[4][2] - A[4][3] + A[5][2] - A[5][3]); },[](const NeuralTensor& B) -> double { return (-B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[3][5] += +P_k; C[5][5] += +2*P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0]); },[](const NeuralTensor& B) -> double { return (B[0][0] - B[0][2] - B[0][3] + B[1][0] - B[1][2] - B[1][3] - B[2][0] + B[2][2] + B[2][3]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[3][0] += -P_k; C[0][2] += -P_k; C[1][2] += +P_k; C[0][3] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][4] - A[1][5] + A[2][4] + A[2][5] - A[3][4] - A[3][5] + A[4][4] + A[4][5] + A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][1] + B[3][1] - B[4][3] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][1] += +2*P_k; C[1][1] += -P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[5][1] += +P_k; C[0][2] += +P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += +P_k; C[0][5] += -2*P_k; C[1][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][4] - A[0][5] - A[1][4] - A[1][5] + A[2][4] + A[2][5] - A[3][4] - A[3][5] + A[4][4] + A[4][5] + A[5][1] + A[5][2] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (-B[1][1] + B[1][2] + B[2][1] + B[3][1] + B[4][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[2][2] += +P_k; C[3][2] += +P_k; C[5][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] - A[0][3] - A[0][5] - A[1][0] + A[1][1] + A[2][0] - A[2][1] - A[3][0] + A[3][1] + A[4][0] - A[4][1] + A[5][0] - A[5][1]); },[](const NeuralTensor& B) -> double { return (-2*B[1][3] + 2*B[1][4] + B[1][5] - B[1][6] + 2*B[2][3] - 2*B[2][4] - B[2][5] + B[2][6] + 2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][5] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][0] + A[3][2] - A[3][3] - A[3][4] - 2*A[3][5] - A[4][0] - A[4][2] + A[4][3] + A[4][4] + 2*A[4][5] - A[5][0] - A[5][2] + A[5][3] + A[5][4] + 2*A[5][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[0][3]); },[](NeuralTensor& C, double P_k) { C[2][2] += +P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[5][0] + B[5][4] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[2][3] += +P_k; C[3][3] += +P_k; C[4][3] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[4][4] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][5] + A[1][5] - A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[5][2] - B[5][3] + B[5][4] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[4][2] += -P_k; C[0][3] += +P_k; C[0][4] += +P_k; C[0][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] + A[1][1] + A[2][0] - A[3][0] + A[4][0]); },[](const NeuralTensor& B) -> double { return (B[0][1] - B[1][3] + B[1][4] + B[1][6]); },[](NeuralTensor& C, double P_k) { C[4][1] += +P_k; C[5][1] += -P_k; C[4][2] += +P_k; C[5][2] += -P_k; C[4][3] += -P_k; C[5][3] += +P_k; C[4][4] += -P_k; C[5][4] += +P_k; C[1][5] += +2*P_k; C[2][5] += +2*P_k; C[3][5] += +2*P_k; C[4][5] += +P_k; C[5][5] += +P_k; C[1][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2] - A[2][3] + A[2][4] - A[3][2] + A[3][3] - A[3][4] + A[4][2] - A[4][3]); },[](const NeuralTensor& B) -> double { return (B[3][6]); },[](NeuralTensor& C, double P_k) { C[3][5] += +2*P_k; C[5][5] += +2*P_k; C[3][6] += +P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[0][2] - A[0][3] + A[0][4]); },[](const NeuralTensor& B) -> double { return (-B[1][6] + B[2][6] + B[3][6] - B[4][2] - B[4][3] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][3] += -P_k; C[0][4] += -P_k; C[0][5] += +P_k; C[0][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][2] - A[2][0] + A[3][0] - A[4][0]); },[](const NeuralTensor& B) -> double { return (-B[0][3] + B[0][4] - B[1][3] + B[1][4] + B[2][6] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[4][4] += -P_k; C[5][4] += +P_k; C[1][5] += +2*P_k; C[2][5] += +2*P_k; C[3][5] += +2*P_k; C[4][5] += +3*P_k; C[5][5] += -P_k; C[1][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + 2*A[0][2] - 2*A[0][3] + A[0][4] - A[1][0] + A[1][1] + A[2][0] - A[2][1] + A[3][2] - A[3][3] - A[4][2] + A[4][3]); },[](const NeuralTensor& B) -> double { return (-B[1][0] + B[2][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[0][3] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] - A[0][3] - A[1][0] + A[1][1] + A[2][0] - A[2][1] - A[4][2] + A[4][3]); },[](const NeuralTensor& B) -> double { return (B[1][0] - B[2][0] - B[3][2] - B[3][3] - B[4][2] - B[4][3] + B[5][2] + B[5][3]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[4][0] += +P_k; C[0][3] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][2] - A[1][3] + A[1][4] - A[2][0]); },[](const NeuralTensor& B) -> double { return (-B[0][6] - B[1][6] + B[2][6] + B[3][6] - B[4][0] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][3] += +P_k; C[1][4] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] + A[0][1] + A[0][2] - A[0][3] - 3*A[1][0] + A[1][1] + 2*A[3][0] + 3*A[4][0] - A[4][1] - A[4][2] + A[4][3] + A[5][0] + A[5][1]); },[](const NeuralTensor& B) -> double { return (B[1][0]); },[](NeuralTensor& C, double P_k) { C[3][0] += +P_k; C[5][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][4] - A[3][4]); },[](const NeuralTensor& B) -> double { return (B[3][6] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k; C[1][5] += +P_k; C[2][5] += +P_k; C[1][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (-2*B[3][3] + 2*B[3][4] + B[3][5] - B[3][6] - 2*B[4][3] + 2*B[4][4] + B[4][5] - B[4][6] + 2*B[5][3] - 2*B[5][4] - B[5][5] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += -P_k; C[2][2] += -P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[1][5] += +P_k; C[2][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[4][2] - A[4][3] + A[5][2] - A[5][3]); },[](const NeuralTensor& B) -> double { return (-B[0][2] + B[0][3] - B[0][4] - B[0][5] + 2*B[0][6] - B[1][2] + B[1][3] - B[1][4] - B[1][5] + 2*B[1][6] + B[2][2] - B[2][3] + B[2][4] + B[2][5] - 2*B[2][6]); },[](NeuralTensor& C, double P_k) { C[5][3] += +P_k; C[5][4] += +P_k; C[3][5] += +P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] + A[1][1]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[1][2]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[1][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + A[1][3] - A[1][4] + A[2][0] - A[3][0] + A[4][0] + A[5][0]); },[](const NeuralTensor& B) -> double { return (B[0][6] + B[1][6] - B[2][6] - B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][5] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[5][5] += +2*P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][1] - A[3][2] + A[3][3] - A[3][4] + A[4][1] + A[4][2] - A[4][3] + A[4][4] + A[5][1] + A[5][2] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (-B[1][1] - B[1][3] + B[2][1] + B[3][1]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[3][1] += +P_k; C[2][2] += +P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] - A[0][3] - A[0][5] + A[1][1] + A[1][2] - A[1][3] - A[1][5] - A[2][1] - A[2][2] + A[2][3] + A[2][5]); },[](const NeuralTensor& B) -> double { return (-B[2][1] - 2*B[2][3] + 2*B[2][4] + B[2][5] - B[2][6] - B[3][1] - 2*B[3][3] + 2*B[3][4] + B[3][5] - B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6] + B[5][0] - 2*B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0]); },[](const NeuralTensor& B) -> double { return (B[0][1] + B[0][3]); },[](NeuralTensor& C, double P_k) { C[2][2] += -P_k; C[3][2] += -P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[3][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][4] - A[0][5] - A[1][4] - A[1][5] + A[2][4] + A[2][5] - A[3][4] - A[3][5] + A[4][4] + A[4][5] - A[5][0] - A[5][2] + A[5][3] + A[5][4] + 2*A[5][5]); },[](const NeuralTensor& B) -> double { return (B[1][1] - B[1][2] - B[2][1] + B[2][2] - B[3][1] + B[3][2] - B[4][1] + B[4][2]); },[](NeuralTensor& C, double P_k) { C[2][2] += +P_k; C[3][2] += +P_k; C[5][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] - A[2][0] - A[3][4] - A[3][5] + A[4][4] + A[4][5] + A[5][2] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (2*B[0][3] - B[0][4] - B[0][5] + 2*B[0][6] + 2*B[1][3] - B[1][4] - B[1][5] + 2*B[1][6] + B[2][0] - 2*B[2][3] + B[2][4] + B[2][5] - 2*B[2][6] + B[3][0] + B[4][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[5][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[4][0] - A[4][2] + A[4][3] - A[5][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] - B[0][3] + B[0][4] + B[0][5] - 2*B[0][6] - B[1][1] + B[1][2] + B[2][1] - B[2][2] + B[3][1] - B[3][2] + B[4][1] - B[4][2] - B[5][1] + B[5][2]); },[](NeuralTensor& C, double P_k) { C[5][2] += -P_k; C[5][3] += +P_k; C[5][4] += +P_k; C[4][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[4][2] + A[4][3]); },[](const NeuralTensor& B) -> double { return (-B[3][2] - B[3][3] - B[4][2] - B[4][3] + B[5][2] + B[5][3]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[4][0] += -P_k; C[0][3] += -P_k; C[4][3] += -P_k; C[5][3] += +P_k; C[0][4] += -P_k; C[4][4] += -P_k; C[5][4] += +P_k; C[4][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] + A[1][1] + A[2][0] - A[3][0] + A[4][0] + A[5][0]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - B[1][3] + B[1][4] + B[1][5] - 2*B[1][6]); },[](NeuralTensor& C, double P_k) { C[5][1] += -P_k; C[5][2] += -P_k; C[5][3] += +P_k; C[5][4] += +P_k; C[1][5] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][4] - A[0][5] - A[1][4] - A[1][5] + A[2][4] + A[2][5] - A[3][4] - A[3][5] + A[4][4] + A[4][5] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][2] + B[3][2] - B[4][3] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[5][2] += -P_k; C[0][3] += +P_k; C[0][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + A[1][3]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + 2*B[0][3] - B[0][4] - B[0][5] + 2*B[0][6] - B[1][0] + 2*B[1][3] - B[1][4] - B[1][5] + 2*B[1][6] + B[2][0] - 2*B[2][3] + B[2][4] + B[2][5] - 2*B[2][6] + B[3][1] + 3*B[3][3] - 3*B[3][4] - B[3][5] + B[4][1] + 3*B[4][3] - 3*B[4][4] - B[4][5] - B[5][1] - 3*B[5][3] + 3*B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[2][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0] - A[3][0] - A[4][2] + A[4][3] - A[5][2] + A[5][3]); },[](const NeuralTensor& B) -> double { return (-B[0][2] + B[0][3] - B[0][4] - B[0][5] + 2*B[0][6] + B[1][1] - B[1][2] - B[2][1] + B[2][2]); },[](NeuralTensor& C, double P_k) { C[5][2] += -P_k; C[5][3] += +P_k; C[5][4] += +P_k; C[3][5] += +P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (B[5][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += -2*P_k; C[3][0] += +P_k; C[4][0] += +P_k; C[1][3] += -2*P_k; C[3][3] += +P_k; C[4][3] += +P_k; C[1][4] += -2*P_k; C[3][4] += +P_k; C[4][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0] - A[3][0] + A[4][0] + A[5][0]); },[](const NeuralTensor& B) -> double { return (B[0][1] - B[0][3] + B[0][4] + B[0][5] - 2*B[0][6]); },[](NeuralTensor& C, double P_k) { C[5][2] += -P_k; C[5][3] += +P_k; C[5][4] += +P_k; C[1][5] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][5] - A[2][5] + A[3][5] - A[4][4] - A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[4][1] - B[4][3] + B[4][4] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[4][1] += +P_k; C[0][2] += -P_k; C[1][2] += +P_k; C[0][3] += +P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += -P_k; C[0][5] += -P_k; C[1][5] += +P_k; C[0][6] += -P_k; C[1][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[4][1] + A[4][2] - A[4][3]); },[](const NeuralTensor& B) -> double { return (B[1][1] + B[1][3] - B[1][4] - B[1][6] - B[2][1] - B[3][1] - B[4][1] + B[5][1]); },[](NeuralTensor& C, double P_k) { C[4][1] += +P_k; C[5][1] += -P_k; C[4][2] += +P_k; C[5][2] += -P_k; C[4][3] += -P_k; C[5][3] += +P_k; C[4][4] += -P_k; C[5][4] += +P_k; C[4][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][5] + A[2][5] - A[3][5]); },[](const NeuralTensor& B) -> double { return (-B[5][1] - B[5][3] + B[5][4] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][1] += +P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[4][1] += +P_k; C[0][2] += +P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += +P_k; C[0][4] += -P_k; C[1][4] += +P_k; C[0][5] += -P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][3] - A[0][4] + A[1][3] - A[1][4] - A[2][3] + A[2][4] + A[3][3] - A[3][4] - A[4][3] + A[4][4] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][0] + B[2][2] + B[3][0] + B[3][2] + 2*B[5][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][4] - A[2][5] + A[3][4] + A[3][5] - A[4][4] - A[4][5]); },[](const NeuralTensor& B) -> double { return (B[4][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[5][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k; C[3][3] += +P_k; C[5][3] += +P_k; C[3][4] += +P_k; C[5][4] += +P_k; C[1][5] += +P_k; C[2][5] += +P_k; C[1][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + A[2][3]); },[](const NeuralTensor& B) -> double { return (-B[3][0] + 2*B[3][3] - B[3][4] - B[3][5] + 2*B[3][6] - B[4][0] + 2*B[4][3] - B[4][4] - B[4][5] + 2*B[4][6] + B[5][0] - 2*B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[5][0] += +P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[5][1] + A[5][2] - A[5][3] - A[5][5]); },[](const NeuralTensor& B) -> double { return (-B[1][1] + B[1][3] - B[1][4] - B[1][5] + 2*B[1][6] + B[2][1] + B[3][1] + B[4][1]); },[](NeuralTensor& C, double P_k) { C[5][1] += -P_k; C[5][2] += -P_k; C[5][3] += +P_k; C[5][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] + A[1][0] - A[1][1] - A[2][0] + A[2][1]); },[](const NeuralTensor& B) -> double { return (B[3][0] - B[3][2] - B[3][3] + B[4][0] - B[4][2] - B[4][3] - B[5][0] + B[5][2] + B[5][3]); },[](NeuralTensor& C, double P_k) { C[0][0] += +P_k; C[4][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[4][5] - A[5][5]); },[](const NeuralTensor& B) -> double { return (2*B[5][3] - 2*B[5][4] - B[5][5] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[4][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][3] + A[2][3] - A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[2][1] - B[3][1] - B[3][3] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += -P_k; C[0][2] += +P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += +P_k; C[0][5] += -2*P_k; C[1][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[4][4] + A[5][5]); },[](const NeuralTensor& B) -> double { return (-2*B[4][3] + 2*B[4][4] + B[4][5] - 2*B[4][6] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[4][5] += -P_k; C[5][5] += +2*P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[4][4]); },[](const NeuralTensor& B) -> double { return (-B[4][6] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[4][5] += -2*P_k; C[5][5] += +2*P_k; C[4][6] += -P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] - A[1][0] + A[1][2] - A[1][3] + A[2][0] - A[2][2] + A[2][3] - A[3][0] - A[4][0] + A[5][0] - A[5][2] + A[5][3]); },[](const NeuralTensor& B) -> double { return (B[0][0] + B[1][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[4][0] += -P_k; C[5][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + A[3][2] - A[4][4] - A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[2][3] + B[2][4] - 2*B[4][3] + 2*B[4][4]); },[](NeuralTensor& C, double P_k) { C[3][4] += -P_k; C[4][4] += -P_k; C[3][5] += +3*P_k; C[4][5] += +3*P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] + A[0][3] - 2*A[0][4] - A[0][5] - A[1][0] + A[1][1] + 2*A[1][2] - A[1][5] + A[2][0] - A[2][1] - 2*A[2][2] + 3*A[2][5] + 2*A[3][3] - 2*A[4][3] - 2*A[4][5] - 2*A[5][2] + A[5][5]); },[](const NeuralTensor& B) -> double { return (B[2][0] + B[3][0] + B[4][0] + B[5][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][4] + A[3][5] - A[4][4] - A[4][5] + A[5][0] + A[5][2] - A[5][3] - A[5][4] - 2*A[5][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[0][3] + B[1][1] - B[1][2] - B[2][1] + B[2][2] - B[3][1] + B[3][2] - B[4][1] + B[4][2]); },[](NeuralTensor& C, double P_k) { C[2][2] += +P_k; C[3][2] += +P_k; C[5][3] += +P_k; C[5][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][3] - A[2][2] + A[2][3] - A[5][2] + A[5][3]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[1][0] + B[3][0] + B[4][0]); },[](NeuralTensor& C, double P_k) { C[5][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] - A[1][1] - A[1][2] + A[2][1] + A[2][2]); },[](const NeuralTensor& B) -> double { return (-B[2][0] + B[2][4] - B[3][0] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[2][5] += -2*P_k; C[3][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] - A[0][4] + A[1][0] - A[1][1] - A[2][0] + A[2][1]); },[](const NeuralTensor& B) -> double { return (B[1][0] + B[3][0] + B[4][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2] - A[2][3]); },[](const NeuralTensor& B) -> double { return (B[2][3] - B[3][0] + B[3][4] + B[3][6] - B[4][0] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][3] - A[1][4] - A[2][3] + A[2][4] + A[3][1] + A[3][2] + A[3][3] - A[3][4] - A[4][1] - A[4][2] - A[4][3] + A[4][4] - A[5][1] - A[5][2] + A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][1] + B[3][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] - A[1][2] + A[1][3] - A[2][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[3][6] - B[4][2] - B[4][3] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k; C[2][2] += +P_k; C[0][3] += -P_k; C[0][4] += -P_k; C[0][5] += +P_k; C[0][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] - A[1][1] - A[1][2] + A[2][1] + A[2][2]); },[](const NeuralTensor& B) -> double { return (-B[1][1] + B[1][2] - B[2][0] + B[2][4] - B[3][0] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] - A[1][2] + A[1][3] - A[1][4] + A[2][0] - A[3][0] + A[4][0]); },[](const NeuralTensor& B) -> double { return (-B[0][6] - B[1][6] + B[2][6] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[1][5] += +2*P_k; C[2][5] += +2*P_k; C[3][5] += +2*P_k; C[5][5] += +2*P_k; C[1][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][2] - A[2][0]); },[](const NeuralTensor& B) -> double { return (B[0][3] - B[0][4] + B[1][3] - B[1][4] - B[2][0] + B[2][4] - B[3][0] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[1][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[2][5] += -2*P_k; C[3][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][4] + A[3][5] - A[4][4] - A[4][5] - A[5][1] - A[5][2] + A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (-B[1][1] - B[1][3] + B[2][1] + B[3][1] + B[4][1]); },[](NeuralTensor& C, double P_k) { C[2][1] += +P_k; C[3][1] += +P_k; C[2][2] += +P_k; C[3][2] += +P_k; C[5][3] += +P_k; C[5][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[5][0] - A[5][2] + A[5][3] + A[5][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] - B[0][3] + B[0][4] + B[0][5] - 2*B[0][6] + B[1][1] - B[1][2] - B[2][1] + B[2][2] - B[3][1] + B[3][2] - B[4][1] + B[4][2]); },[](NeuralTensor& C, double P_k) { C[5][2] += -P_k; C[5][3] += +P_k; C[5][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] + A[1][2] - A[1][3] - A[2][2] + A[2][3] + A[5][0] - A[5][2] + A[5][3]); },[](const NeuralTensor& B) -> double { return (B[0][0] + 2*B[1][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[2][0] += -P_k; C[3][0] += -P_k; C[4][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[4][2] - A[4][3] + A[5][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] - B[0][3] + B[0][4] + B[0][5] - 2*B[0][6] + B[1][2] - B[1][3] + B[1][4] + B[1][5] - 2*B[1][6] - B[2][2] + B[2][3] - B[2][4] - B[2][5] + 2*B[2][6] - B[3][2] - B[3][3] - B[4][2] - B[4][3] + B[5][2] + B[5][3]); },[](NeuralTensor& C, double P_k) { C[5][3] += +P_k; C[5][4] += +P_k; C[4][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][3] - A[3][3]); },[](const NeuralTensor& B) -> double { return (B[2][3] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[1][5] += -2*P_k; C[2][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] - A[1][2] + A[1][3]); },[](const NeuralTensor& B) -> double { return (-B[3][2] + B[3][3] - B[3][4] - B[3][5] + 2*B[3][6] - B[4][2] + B[4][3] - B[4][4] - B[4][5] + 2*B[4][6] + B[5][2] - B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][2] += -P_k; C[2][2] += -P_k; C[0][3] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2]); },[](const NeuralTensor& B) -> double { return (-B[1][3] + B[1][4]); },[](NeuralTensor& C, double P_k) { C[0][4] += -P_k; C[2][4] += -P_k; C[3][4] += -P_k; C[4][4] += -P_k; C[0][5] += +3*P_k; C[2][5] += +3*P_k; C[3][5] += +3*P_k; C[4][5] += +3*P_k; C[0][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[0][0] - A[2][0] + 2*A[3][0] + A[4][0]); },[](const NeuralTensor& B) -> double { return (B[0][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[5][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-2*A[0][1] - 2*A[0][2] + A[0][3] - A[0][4] - 2*A[1][1] - 2*A[1][2] + A[1][3] - A[1][4] + 2*A[2][1] + 2*A[2][2] - A[2][3] + A[2][4]); },[](const NeuralTensor& B) -> double { return (B[2][6] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[4][4] += -P_k; C[5][4] += +P_k; C[2][5] += +2*P_k; C[3][5] += +2*P_k; C[4][5] += +3*P_k; C[5][5] += -P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][0] + A[1][1]); },[](const NeuralTensor& B) -> double { return (B[0][1]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += -P_k; C[3][1] += -2*P_k; C[4][1] += -2*P_k; C[1][2] += -P_k; C[2][2] += -P_k; C[3][2] += -2*P_k; C[4][2] += -2*P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[3][3] += +2*P_k; C[4][3] += +2*P_k; C[1][5] += +2*P_k; C[2][5] += +2*P_k; C[3][5] += +4*P_k; C[4][5] += +4*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] - A[1][2] + A[1][3] + A[2][0] + A[2][2] - A[2][3] - A[3][0] - A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (B[1][1] - B[1][2] - B[2][1] + B[2][2]); },[](NeuralTensor& C, double P_k) { C[2][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] - A[1][1] - A[2][0] + A[2][1] + A[3][0] - A[3][1] - A[4][0] + A[4][1]); },[](const NeuralTensor& B) -> double { return (-B[1][3] + B[1][4] + B[1][6]); },[](NeuralTensor& C, double P_k) { C[4][1] += +P_k; C[5][1] += -P_k; C[4][2] += +P_k; C[5][2] += -P_k; C[4][3] += -P_k; C[5][3] += +P_k; C[4][4] += -P_k; C[5][4] += +P_k; C[0][5] += +2*P_k; C[2][5] += +2*P_k; C[3][5] += +2*P_k; C[4][5] += +P_k; C[5][5] += +P_k; C[0][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][5] - A[1][5] + A[2][5] - A[3][5] - A[4][1] - A[4][2] + A[4][3] + A[4][5]); },[](const NeuralTensor& B) -> double { return (B[1][1] - B[1][2] - B[2][1] - B[3][1] - B[4][1] + B[5][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[2][2] += +P_k; C[3][2] += +P_k; C[4][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[5][5]); },[](const NeuralTensor& B) -> double { return (2*B[3][3] - B[3][4] - B[3][5] + 2*B[3][6] + 2*B[4][3] - B[4][4] - B[4][5] + 2*B[4][6] - 2*B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += -P_k; C[5][0] += -P_k; C[1][3] += -P_k; C[1][4] += -P_k; C[4][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] - A[1][0] + A[1][1] + A[2][0] - A[2][1] - A[3][0] + A[3][1] + A[4][0] - A[4][1]); },[](const NeuralTensor& B) -> double { return (-B[1][3] + B[1][4] + B[2][6] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[4][4] += -P_k; C[5][4] += +P_k; C[0][5] += +2*P_k; C[2][5] += +2*P_k; C[3][5] += +2*P_k; C[4][5] += +3*P_k; C[5][5] += -P_k; C[0][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][3] + A[0][4] - A[1][3] + A[1][4] + A[2][3] - A[2][4] + A[3][1] + A[3][2] - A[3][3] + A[3][4] - A[4][1] - A[4][2] + A[4][3] - A[4][4] - A[5][1] - A[5][2] + A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (-B[1][1] + B[1][2] + B[2][1] + B[3][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[2][2] += +P_k; C[3][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] - A[0][4] + A[1][0] - A[1][1] - A[2][0] + A[2][1] + A[3][0] - A[3][1] - A[4][0] + A[4][1]); },[](const NeuralTensor& B) -> double { return (-B[1][6] + B[2][6] + B[3][6]); },[](NeuralTensor& C, double P_k) { C[0][5] += +2*P_k; C[2][5] += +2*P_k; C[3][5] += +2*P_k; C[5][5] += +2*P_k; C[0][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] - A[0][1] + A[1][0] - A[1][1] - A[2][0] + A[2][1]); },[](const NeuralTensor& B) -> double { return (B[1][0] - 2*B[1][3] + B[1][4] + B[1][5] - 2*B[1][6] - B[2][0] + 2*B[2][3] - B[2][4] - B[2][5] + 2*B[2][6] - B[3][2] + B[3][3] - B[3][4] - B[3][5] + 2*B[3][6] - B[4][2] + B[4][3] - B[4][4] - B[4][5] + 2*B[4][6] + B[5][2] - B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][3] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[1][0] - A[1][1] - A[2][0] + A[2][1] + A[3][0] - A[3][1] - A[4][0] + A[4][1] - A[5][0] + A[5][1]); },[](const NeuralTensor& B) -> double { return (B[1][3] - B[1][4] - 2*B[2][3] + 2*B[2][4] + B[2][5] - 2*B[2][6] - 2*B[3][3] + 2*B[3][4] + B[3][5] - 2*B[3][6]); },[](NeuralTensor& C, double P_k) { C[5][4] += -P_k; C[0][5] += -P_k; C[2][5] += -P_k; C[3][5] += -P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][0] - A[2][0] + A[3][0]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + B[1][0]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[4][0] += +P_k; C[5][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][5] + A[4][0] + A[4][2] - A[4][3] - A[4][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[0][3] - B[1][1] + B[1][2] + B[2][1] - B[2][2] + B[3][1] - B[3][2] + B[4][1] - B[4][2] - B[5][1] + B[5][2]); },[](NeuralTensor& C, double P_k) { C[2][2] += +P_k; C[3][2] += +P_k; C[4][3] += +P_k; C[4][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] - A[1][1] + A[2][0] - A[2][1] - A[3][0] + A[3][1] - A[4][3] - A[4][5]); },[](const NeuralTensor& B) -> double { return (B[4][3] - B[4][4] - B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[3][1] += -P_k; C[4][1] += -P_k; C[3][2] += -P_k; C[4][2] += -P_k; C[3][3] += +P_k; C[4][3] += +P_k; C[3][5] += +2*P_k; C[4][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][5] + A[2][5] - A[3][5] - A[4][1] - A[4][2] + A[4][3] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[2][1] - B[3][1] - B[4][1] + B[5][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[4][1] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] - A[1][1] - A[2][0] + A[2][1] + A[3][0] - A[3][1] - A[4][0] + A[4][1] - A[5][0] + A[5][1]); },[](const NeuralTensor& B) -> double { return (-B[1][3] + B[1][4] + B[1][5] - 2*B[1][6]); },[](NeuralTensor& C, double P_k) { C[5][1] += -P_k; C[5][2] += -P_k; C[5][3] += +P_k; C[5][4] += +P_k; C[0][5] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][5] + A[2][5] - A[3][5] + A[4][3] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[2][1] - B[3][1] + B[4][3] - B[4][4] - B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[1][1] += -P_k; C[2][1] += -P_k; C[3][1] += -P_k; C[4][1] += -P_k; C[0][2] += +P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += +P_k; C[0][5] += -2*P_k; C[1][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] + A[0][5] + A[1][0] - A[1][1] - A[2][0] + A[2][1]); },[](const NeuralTensor& B) -> double { return (-2*B[1][3] + 2*B[1][4] + B[1][5] - B[1][6] + B[2][0] + 2*B[2][3] - 2*B[2][4] - B[2][5] + B[2][6] + B[3][0] + 2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6] + 2*B[5][0] - 2*B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[0][3] += -P_k; C[0][4] += -P_k; C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][4] - A[1][5] + A[2][4] + A[2][5] - A[3][4] - A[3][5] + A[4][4] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[4][1] - B[4][3] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[0][1] += -2*P_k; C[1][1] += +P_k; C[2][1] += -P_k; C[3][1] += -P_k; C[5][1] += -P_k; C[0][2] += -P_k; C[1][2] += +P_k; C[0][3] += +P_k; C[1][3] += -P_k; C[0][4] += +P_k; C[1][4] += -P_k; C[0][5] += -P_k; C[1][5] += +P_k; C[0][6] += -P_k; C[1][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][0] - A[3][0]); },[](const NeuralTensor& B) -> double { return (-B[0][1] - B[0][3] + B[0][4]); },[](NeuralTensor& C, double P_k) { C[3][2] += +P_k; C[4][2] += +P_k; C[3][3] += -P_k; C[4][3] += -P_k; C[1][4] += -P_k; C[2][4] += -P_k; C[3][4] += -3*P_k; C[4][4] += -3*P_k; C[1][5] += +3*P_k; C[2][5] += +3*P_k; C[3][5] += +3*P_k; C[4][5] += +3*P_k; C[1][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][2] - A[1][3]); },[](const NeuralTensor& B) -> double { return (-B[0][0] + 2*B[0][3] - B[0][4] - B[0][5] + 2*B[0][6] - B[1][0] + 2*B[1][3] - B[1][4] - B[1][5] + 2*B[1][6] + B[2][0] - 2*B[2][3] + B[2][4] + B[2][5] - 2*B[2][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[5][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[0][2] += -P_k; C[1][2] += +P_k; C[0][3] += +P_k; C[0][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][4] + A[3][5] - A[4][4] - A[4][5] - A[5][2] + A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (2*B[0][3] - B[0][4] - B[0][5] + 2*B[0][6] + 2*B[1][3] - B[1][4] - B[1][5] + 2*B[1][6] - 2*B[2][3] + B[2][4] + B[2][5] - 2*B[2][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[5][0] += +P_k; C[1][3] += +P_k; C[5][3] += +P_k; C[1][4] += +P_k; C[5][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][3] + A[0][4] - A[1][3] + A[1][4] + A[2][3] - A[2][4] - A[3][3] + A[3][4] + A[4][3] - A[4][4] + A[5][3] - A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][2] + B[3][2]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[0][2] += -P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[0][3] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k; C[0][5] += +2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] - A[0][3] - A[0][5] - A[1][0] + A[1][1] + A[2][0] - A[2][1]); },[](const NeuralTensor& B) -> double { return (B[2][0] + B[3][0] + B[5][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[1][0] += +P_k; C[0][3] += -2*P_k; C[1][3] += +P_k; C[0][4] += -2*P_k; C[1][4] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] + A[1][2] - A[1][3] - A[2][0]); },[](const NeuralTensor& B) -> double { return (B[0][0] - 2*B[0][3] + B[0][4] + B[0][5] - 2*B[0][6] + B[1][0] - 2*B[1][3] + B[1][4] + B[1][5] - 2*B[1][6] - B[2][0] + 2*B[2][3] - B[2][4] - B[2][5] + 2*B[2][6] - B[3][0] + 2*B[3][3] - B[3][4] - B[3][5] + 2*B[3][6] - B[4][0] + 2*B[4][3] - B[4][4] - B[4][5] + 2*B[4][6] + B[5][0] - 2*B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[5][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[2][2] + A[2][3] - A[2][4] + A[3][4]); },[](const NeuralTensor& B) -> double { return (B[3][6] - B[4][0] + B[4][4] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][3] - A[3][4] - A[4][3] + A[4][4] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][0] + B[3][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k; C[0][3] += -P_k; C[3][3] += +P_k; C[0][4] += -P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[1][5] += -2*P_k; C[2][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-2*A[1][0] + A[1][1] + A[1][2] - A[1][3] + A[2][0] - A[2][2] + A[2][3] + A[4][0] + A[5][0] - A[5][2] + A[5][3]); },[](const NeuralTensor& B) -> double { return (B[1][0]); },[](NeuralTensor& C, double P_k) { C[0][0] += -P_k; C[1][0] += +P_k; C[3][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] - A[0][3] + A[0][4] + A[1][1] + A[1][2] - A[1][3] + A[1][4] - A[2][1] - A[2][2] + A[2][3] - A[2][4] - A[3][1] - A[3][2] + A[4][1] + A[4][2] + A[5][1] + A[5][2]); },[](const NeuralTensor& B) -> double { return (B[2][6] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6]); },[](NeuralTensor& C, double P_k) { C[2][5] += +P_k; C[3][5] += +P_k; C[5][5] += +2*P_k; C[5][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][2] + A[1][3] + A[1][5]); },[](const NeuralTensor& B) -> double { return (-2*B[0][3] + 2*B[0][4] + B[0][5] - B[0][6] - 2*B[1][3] + 2*B[1][4] + B[1][5] - B[1][6] + 2*B[2][3] - 2*B[2][4] - B[2][5] + B[2][6] + 2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6] - B[5][1] - 3*B[5][3] + 3*B[5][4] + B[5][5]); },[](NeuralTensor& C, double P_k) { C[0][2] += +P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += +P_k; C[0][4] += -P_k; C[1][4] += +P_k; C[0][5] += -P_k; C[1][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] - A[1][1] - A[2][0] + A[2][1]); },[](const NeuralTensor& B) -> double { return (B[1][3]); },[](NeuralTensor& C, double P_k) { C[2][1] += -P_k; C[3][1] += -P_k; C[2][2] += -P_k; C[3][2] += -P_k; C[0][3] += +P_k; C[2][3] += +P_k; C[3][3] += +P_k; C[0][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[1][0] - A[1][1] + A[2][0] - A[3][0]); },[](const NeuralTensor& B) -> double { return (B[0][1] - B[1][3] + B[1][4]); },[](NeuralTensor& C, double P_k) { C[3][1] += -P_k; C[4][1] += -P_k; C[3][2] += -P_k; C[4][2] += -P_k; C[3][3] += +P_k; C[4][3] += +P_k; C[1][4] += -P_k; C[2][4] += -P_k; C[3][4] += -P_k; C[4][4] += -P_k; C[1][5] += +3*P_k; C[2][5] += +3*P_k; C[3][5] += +5*P_k; C[4][5] += +5*P_k; C[1][6] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][5] - A[3][5] + A[4][3] + A[4][5]); },[](const NeuralTensor& B) -> double { return (B[2][3] + B[3][3] + B[4][3] - B[4][4] - B[5][3] + B[5][4]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[4][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k; C[3][3] += +P_k; C[4][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[4][4] += +P_k; C[1][5] += -2*P_k; C[2][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[3][5] - A[4][2] + A[4][3] + A[4][5]); },[](const NeuralTensor& B) -> double { return (B[0][2] + B[0][3] + B[1][2] + B[1][3] - B[2][2] - B[2][3] - B[3][2] - B[3][3] - B[4][2] - B[4][3] + B[5][2] + B[5][3]); },[](NeuralTensor& C, double P_k) { C[4][3] += +P_k; C[4][4] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[4][2] - A[4][3]); },[](const NeuralTensor& B) -> double { return (2*B[0][1] - B[0][2] + B[0][3] - B[0][4] - B[0][6] + 2*B[1][1] - B[1][2] + B[1][3] - B[1][4] - B[1][6] - 2*B[2][1] + B[2][2] - B[2][3] + B[2][4] + B[2][6]); },[](NeuralTensor& C, double P_k) { C[3][5] += +2*P_k; C[4][5] += +2*P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][1] - A[0][2] + A[0][3] + A[1][0] - A[1][1] - A[2][0] + A[2][1] - A[3][5] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[2][0] - B[3][0] - B[4][0] + B[5][0]); },[](NeuralTensor& C, double P_k) { C[4][0] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[1][3] + A[1][4] + A[2][3] - A[2][4] - A[3][3] + A[3][4] + A[4][3] - A[4][4] - A[5][3] + A[5][4]); },[](const NeuralTensor& B) -> double { return (B[2][1] + B[3][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += +2*P_k; C[1][1] += -P_k; C[2][1] += +P_k; C[3][1] += +P_k; C[0][2] += +P_k; C[1][2] += -P_k; C[0][3] += -P_k; C[1][3] += +P_k; C[0][5] += -2*P_k; C[1][5] += +2*P_k; C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][1] - A[3][1] - A[4][2] + A[4][3] - A[5][2] + A[5][3]); },[](const NeuralTensor& B) -> double { return (-B[1][1] + B[1][3] - B[1][4] - B[1][5] + 2*B[1][6] + B[2][1]); },[](NeuralTensor& C, double P_k) { C[5][1] += -P_k; C[5][2] += -P_k; C[5][3] += +P_k; C[5][4] += +P_k; C[3][5] += +P_k; C[5][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (2*A[2][2] - 2*A[3][2] + A[4][4] + A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[2][3] + B[2][4] - B[4][3] + B[4][4]); },[](NeuralTensor& C, double P_k) { C[3][4] += -P_k; C[4][4] += -P_k; C[3][5] += +3*P_k; C[4][5] += +3*P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][0] + A[0][1]); },[](const NeuralTensor& B) -> double { return (B[1][2]); },[](NeuralTensor& C, double P_k) { C[0][1] += +P_k; C[0][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (-A[0][2] + A[0][3] - A[1][2] + A[1][3] + A[2][1] + A[2][2] - A[2][3] - A[3][1] - A[3][2] + A[3][3]); },[](const NeuralTensor& B) -> double { return (-B[1][1] + B[1][2] + B[2][1]); },[](NeuralTensor& C, double P_k) { C[0][1] += -P_k; C[2][2] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[0][1] + A[0][2] - A[1][0] + A[1][1] + A[2][0] - A[2][1]); },[](const NeuralTensor& B) -> double { return (B[1][3] - B[1][4] - B[2][0] + B[2][4] - B[3][0] + B[3][4]); },[](NeuralTensor& C, double P_k) { C[0][3] += +P_k; C[0][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[2][5] += -2*P_k; C[3][5] += -2*P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][1] - A[3][1]); },[](const NeuralTensor& B) -> double { return (-B[1][1] - B[1][3] + B[1][4] + B[2][1]); },[](NeuralTensor& C, double P_k) { C[3][1] += +P_k; C[4][1] += +P_k; C[3][2] += +P_k; C[4][2] += +P_k; C[3][3] += -P_k; C[4][3] += -P_k; C[3][4] += -P_k; C[4][4] += -P_k; C[3][5] += +P_k; C[4][5] += +P_k; C[3][6] += +P_k; C[4][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][5] - A[3][5] + A[4][4] + A[4][5]); },[](const NeuralTensor& B) -> double { return (B[4][4] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[4][0] += +P_k; C[1][1] += +P_k; C[2][1] += +P_k; C[1][2] += +P_k; C[2][2] += +P_k; C[3][3] += +P_k; C[4][3] += +P_k; C[3][4] += +P_k; C[4][4] += +P_k; C[1][5] += +P_k; C[2][5] += +P_k; C[1][6] += +P_k; C[2][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][2] - A[2][3] - A[2][5] + A[3][5]); },[](const NeuralTensor& B) -> double { return (2*B[3][3] - 2*B[3][4] - B[3][5] + B[3][6] + 2*B[4][3] - 2*B[4][4] - B[4][5] + B[4][6] + B[5][0] - 2*B[5][3] + B[5][4] + B[5][5] - 2*B[5][6]); },[](NeuralTensor& C, double P_k) { C[2][3] += +P_k; C[2][4] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[3][5] - A[4][4] - A[4][5]); },[](const NeuralTensor& B) -> double { return (-B[4][0] + B[4][4] + B[5][6]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[4][0] += +P_k; C[1][3] += +P_k; C[1][4] += +P_k; C[2][5] += +P_k; C[3][5] += +P_k; C[2][6] += +P_k; C[3][6] += +P_k;}});
formula.push_back({[](const NeuralTensor& A) -> double { return (A[2][4] + A[2][5]); },[](const NeuralTensor& B) -> double { return (B[2][3] + B[3][3] + B[4][3]); },[](NeuralTensor& C, double P_k) { C[1][0] += +P_k; C[2][0] += +P_k; C[3][0] += +P_k; C[5][0] += +P_k; C[1][3] += +P_k; C[2][3] += +P_k; C[3][3] += +P_k; C[5][3] += +P_k; C[1][4] += +P_k; C[2][4] += +P_k; C[3][4] += +P_k; C[5][4] += +P_k;}});
return formula;
}
