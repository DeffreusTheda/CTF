# Source Generated with Decompyle++
# File: runtime.pyc (Python 3.11)

Unsupported opcode: CHECK_EXC_MATCH # TOS1 (except)== TOS (Top-of-Stack); Pop TOS; Push RESULT
import sys

class EmptyStackException(Exception):
    '''Raised when the program tries to pop an empty stack'''
    pass


class InvalidInstructionException(Exception):
    '''Raised when the program encounters an invalid emoji'''
    pass


class EmoProgram:
    
    def __init__(self, F):
Unsupported opcode: POP_JUMP_BACKWARD_IF_TRUE # if TOS: PC -= delta; Pop TOS
        self.P = []
        i = 0
    # WARNING: Decompyle incomplete

    
    def emo_func_start(self, I):
        pass

    
    def emo_func_input_byte(self, I):
        V = ord(sys.stdin.read(1))
        self.STACK.append(V)

    
    def emo_func_push_byte(self, I):
Unsupported opcode: MAKE_CELL # 
        pass
    # WARNING: Decompyle incomplete

    
    def emo_func_xor_byte(self, I):
        if len(self.STACK) > 1:
            V1 = self.STACK.pop()
            V2 = self.STACK.pop()
            self.STACK.append(V1 ^ V2)
            return None
        raise None

    
    def emo_func_compare(self, I):
        if len(self.STACK) > 1:
            V1 = self.STACK.pop()
            V2 = self.STACK.pop()
            if V1 == V2:
                self.STACK.append(1)
                return None
            None.STACK.append(0)
            return None
        raise None

    
    def emo_func_jump_if(self, I):
Unsupported opcode: COPY
        pass
    # WARNING: Decompyle incomplete

    
    def emo_func_jump_back(self, I):
        self.emo_func_push_byte()
        V = self.STACK.pop()
        PC -= V
        F.seek(PC)

    
    def emo_func_jump_forward(self, I):
        self.emo_func_push_byte()
        V = self.STACK.pop()
        PC += V
        F.seek(PC)

    
    def emo_func_subtract(self, I):
        if len(self.STACK) > 1:
            V1 = self.STACK.pop()
            V2 = self.STACK.pop()
            self.STACK.append(V1 - V2)
            return None
        raise None

    
    def emo_func_add(self, I):
        if len(self.STACK) > 1:
            V1 = self.STACK.pop()
            V2 = self.STACK.pop()
            self.STACK.append(V1 + V2)
            return None
        raise None

    
    def emo_func_output_byte(self, I):
        if len(self.STACK) > 0:
            V = self.STACK.pop()
            sys.stdout.write(chr(V))
            return None
        raise None

    
    def emo_func_exit(self, I):
        sys.exit(0)

    
    def run_program(self):
Unsupported opcode: POP_JUMP_FORWARD_IF_NONE
        self.PC = 0
        I = self.P[self.PC]
        fn = self.EMO.get(I[0], None)
    # WARNING: Decompyle incomplete


if __name__ == '__main__':
    if len(sys.argv) == 1:
        print('Usage: ./runtime input_file.emo')
        sys.exit(1)
    F = open(sys.argv[1], 'r').read()
    program = EmoProgram(F)
    program.run_program()
    return None
# WARNING: Decompyle incomplete
