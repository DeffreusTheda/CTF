internal struct Struct30 {
	// Token: 0x0600015C RID: 348 RVA: 0x00033FD8 File Offset: 0x0002F1D8
	public unsafe static void <MarshalCopy>(Struct30* A_0, Struct30* A_1) {
		if (A_0 != null) {
			initblk(A_0, 0, 16L);
			try {
				*(long*)(A_0 + 16L / (long)sizeof(Struct30)) = 0L;
				*(long*)(A_0 + 24L / (long)sizeof(Struct30)) = 0L;
			}
			catch {
				<Module>.___CxxCallUnwindDtor(ldftn(smethod_35), (void*)A_0);
				throw;
			}
			try {
				<Module>.smethod_33(A_0, A_1);
			}
			catch {
				<Module>.___CxxCallUnwindDtor(ldftn(smethod_19), (void*)A_0);
				throw;
			}
		}
	}

	// Token: 0x0600015D RID: 349 RVA: 0x000320A8 File Offset: 0x0002D2A8
	public unsafe static void <MarshalDestroy>(Struct30* A_0) {
		try {
			<Module>.smethod_28(A_0);
		}
		catch {
			<Module>.___CxxCallUnwindDtor(ldftn(smethod_19), (void*)A_0);
			throw;
		}
	}

	// Token: 0x04000316 RID: 790
	private long long_0;

	// Token: 0x020001B2 RID: 434
	[NativeCppClass]
	internal enum _Allocation_policy {

	}

	// Token: 0x020001B3 RID: 435
	[NativeCppClass]
	internal enum _Construct_strategy : byte {

	}
}

internal struct Struct37 {
	// Token: 0x0400034F RID: 847
	private long long_0;

	// Token: 0x020001EC RID: 492
	[NativeCppClass]
	internal enum _Reallocation_policy {

	}
}

internal unsafe static void smethod_2() {
	Struct112 @struct = 969622713;
	*(ref @struct + 4) = 594890599;
	*(ref @struct + 8) = 1593930257;
	*(ref @struct + 12) = 1052452058;
	*(ref @struct + 16) = 890701766;
	*(ref @struct + 20) = 1677293387;
	*(ref @struct + 24) = 394424968;
	*(ref @struct + 28) = 266815521;
	*(ref @struct + 32) = 1532978959;
	*(ref @struct + 36) = 1211194088;
	*(ref @struct + 40) = 2019260265;
	*(ref @struct + 44) = 729421127;
	*(ref @struct + 48) = 953225874;
	*(ref @struct + 52) = 1117854514;
	*(ref @struct + 56) = 892543556;
	*(ref @struct + 60) = 2000911200;
	*(ref @struct + 64) = 514538256;
	*(ref @struct + 68) = 1400963072;
	*(ref @struct + 72) = 486675118;
	*(ref @struct + 76) = 1862498216;
	*(ref @struct + 80) = 1136668818;
	*(ref @struct + 84) = 758909582;
	*(ref @struct + 88) = 1653935295;
	*(ref @struct + 92) = 821063674;
	*(ref @struct + 96) = 888606944;
	*(ref @struct + 100) = 687085563;
	*(ref @struct + 104) = 890056597;
	*(ref @struct + 108) = 1513495898;
	*(ref @struct + 112) = 365692427;
	*(ref @struct + 116) = 184357836;
	*(ref @struct + 120) = 677395407;
	*(ref @struct + 124) = 863045227;
	*(ref @struct + 128) = 818746596;
	*(ref @struct + 132) = 391985767;
	*(ref @struct + 136) = 1842768403;
	*(ref @struct + 140) = 758385145;
	*(ref @struct + 144) = 1478392706;
	*(ref @struct + 148) = 1985112985;
	*(ref @struct + 152) = 1552765320;
	*(ref @struct + 156) = 746944881;
	*(ref @struct + 160) = 368385984;
	*(ref @struct + 164) = 1758203153;
	*(ref @struct + 168) = 1240817244;
	*(ref @struct + 172) = 660489060;
	*(ref @struct + 176) = 756944316;
	*(ref @struct + 180) = 1290697955;
	*(ref @struct + 184) = 844453952;
	*(ref @struct + 188) = 288239112;
	*(ref @struct + 192) = 1769473626;
	*(ref @struct + 196) = 1922176006;
	*(ref @struct + 200) = 826636519;
	*(ref @struct + 204) = 391520695;
	*(ref @struct + 208) = 1081548223;
	*(ref @struct + 212) = 1069693142;
	*(ref @struct + 216) = 1244729994;
	*(ref @struct + 220) = 766313326;
	*(ref @struct + 224) = 1101031894;
	*(ref @struct + 228) = 624951698;
	*(ref @struct + 232) = 14501479;
	*(ref @struct + 236) = 1794907983;
	*(ref @struct + 240) = 1460682958;
	*(ref @struct + 244) = 1660839647;
	*(ref @struct + 248) = 1104890686;
	*(ref @struct + 252) = 897721119;
	*(ref @struct + 256) = 1442187162;
	*(ref @struct + 260) = 480708164;
	*(ref @struct + 264) = 454443986;
	*(ref @struct + 268) = 1064446153;
	*(ref @struct + 272) = 1595150448;
	*(ref @struct + 276) = 1041527979;
	*(ref @struct + 280) = 1145775470;
	*(ref @struct + 284) = 1399869657;
	*(ref @struct + 288) = 255985995;
	*(ref @struct + 292) = 802693350;
	*(ref @struct + 296) = 2005610078;
	*(ref @struct + 300) = 1897360642;
	*(ref @struct + 304) = 2146073193;
	*(ref @struct + 308) = 1538606632;
	*(ref @struct + 312) = 431647857;
	*(ref @struct + 316) = 964049561;
	*(ref @struct + 320) = 395138253;
	*(ref @struct + 324) = 19164808;
	*(ref @struct + 328) = 856904574;
	*(ref @struct + 332) = 730737943;
	*(ref @struct + 336) = 708645054;
	*(ref @struct + 340) = 1506870658;
	*(ref @struct + 344) = 933323739;
	*(ref @struct + 348) = 819349658;
	*(ref @struct + 352) = 1780571206;
	*(ref @struct + 356) = 236747382;
	*(ref @struct + 360) = 533160167;
	*(ref @struct + 364) = 2042104933;
	*(ref @struct + 368) = 670325172;
	*(ref @struct + 372) = 2040165158;
	*(ref @struct + 376) = 1354372994;
	*(ref @struct + 380) = 705785180;
	*(ref @struct + 384) = 1669754395;
	*(ref @struct + 388) = 1066536508;
	*(ref @struct + 392) = 1426207888;
	*(ref @struct + 396) = 1437950089;
	*(ref @struct + 400) = 741941201;
	*(ref @struct + 404) = 796931522;
	*(ref @struct + 408) = 1694313338;
	*(ref @struct + 412) = 1290302874;
	*(ref @struct + 416) = 1367672048;
	*(ref @struct + 420) = 2039808424;
	*(ref @struct + 424) = 1062939821;
	*(ref @struct + 428) = 954597728;
	*(ref @struct + 432) = 1668694488;
	*(ref @struct + 436) = 859122242;
	*(ref @struct + 440) = 1369582617;
	*(ref @struct + 444) = 140269649;
	*(ref @struct + 448) = 53024683;
	*(ref @struct + 452) = 729221831;
	*(ref @struct + 456) = 816609203;
	*(ref @struct + 460) = 736893191;
	*(ref @struct + 464) = 55706320;
	*(ref @struct + 468) = 262747091;
	*(ref @struct + 472) = 1629838835;
	*(ref @struct + 476) = 581764799;
	*(ref @struct + 480) = 1488480625;
	*(ref @struct + 484) = 1607077349;
	*(ref @struct + 488) = 1879925846;
	*(ref @struct + 492) = 1453945819;
	*(ref @struct + 496) = 1521965565;
	*(ref @struct + 500) = 856558562;
	*(ref @struct + 504) = 1530662365;
	*(ref @struct + 508) = 1230847072;
	*(ref @struct + 512) = 1404918182;
	*(ref @struct + 516) = 1281256849;
	*(ref @struct + 520) = 1238970765;
	*(ref @struct + 524) = 272453753;
	*(ref @struct + 528) = 1640907491;
	*(ref @struct + 532) = 2127893021;
	*(ref @struct + 536) = 350314733;
	*(ref @struct + 540) = 556617458;
	*(ref @struct + 544) = 654390256;
	*(ref @struct + 548) = 1648581270;
	*(ref @struct + 552) = 531062411;
	*(ref @struct + 556) = 1862873022;
	*(ref @struct + 560) = 1241517385;
	*(ref @struct + 564) = 1471028336;
	*(ref @struct + 568) = 5121143;
	*(ref @struct + 572) = 1444839026;
	*(ref @struct + 576) = 1183580211;
	*(ref @struct + 580) = 1573659650;
	*(ref @struct + 584) = 2018540230;
	*(ref @struct + 588) = 1487873223;
	*(ref @struct + 592) = 234237236;
	*(ref @struct + 596) = 898254600;
	*(ref @struct + 600) = 1023090193;
	*(ref @struct + 604) = 728843548;
	*(ref @struct + 608) = 2007454357;
	*(ref @struct + 612) = 1451820833;
	*(ref @struct + 616) = 267351539;
	*(ref @struct + 620) = 302982385;
	*(ref @struct + 624) = 26807015;
	*(ref @struct + 628) = 865879122;
	*(ref @struct + 632) = 664886158;
	*(ref @struct + 636) = 195503981;
	*(ref @struct + 640) = 1625037691;
	*(ref @struct + 644) = 1330347906;
	*(ref @struct + 648) = 1742434311;
	*(ref @struct + 652) = 1330272217;
	*(ref @struct + 656) = 1645368040;
	*(ref @struct + 660) = 542321916;
	*(ref @struct + 664) = 1782121222;
	*(ref @struct + 668) = 411042851;
	*(ref @struct + 672) = 435386250;
	*(ref @struct + 676) = 1176704752;
	*(ref @struct + 680) = 1454246199;
	*(ref @struct + 684) = 1136813916;
	*(ref @struct + 688) = 1707755005;
	*(ref @struct + 692) = 224415730;
	*(ref @struct + 696) = 201138891;
	*(ref @struct + 700) = 989750331;
	*(ref @struct + 704) = 1006010278;
	*(ref @struct + 708) = 1147286905;
	*(ref @struct + 712) = 406860280;
	*(ref @struct + 716) = 840388503;
	*(ref @struct + 720) = 1282017578;
	*(ref @struct + 724) = 1605698145;
	*(ref @struct + 728) = 23396724;
	*(ref @struct + 732) = 862145265;
	*(ref @struct + 736) = 1898780916;
	*(ref @struct + 740) = 1855549801;
	*(ref @struct + 744) = 1571519230;
	*(ref @struct + 748) = 2083204840;
	*(ref @struct + 752) = 1859876276;
	*(ref @struct + 756) = 1602449334;
	*(ref @struct + 760) = 1009413590;
	*(ref @struct + 764) = 690816450;
	*(ref @struct + 768) = 86131931;
	*(ref @struct + 772) = 345661263;
	*(ref @struct + 776) = 1565025600;
	*(ref @struct + 780) = 857544170;
	*(ref @struct + 784) = 1329948960;
	*(ref @struct + 788) = 1211787679;
	*(ref @struct + 792) = 994381573;
	*(ref @struct + 796) = 991984748;
	*(ref @struct + 800) = 1956475134;
	*(ref @struct + 804) = 1098146294;
	*(ref @struct + 808) = 1655714289;
	*(ref @struct + 812) = 659576699;
	*(ref @struct + 816) = 689116467;
	*(ref @struct + 820) = 1485584392;
	*(ref @struct + 824) = 451884118;
	*(ref @struct + 828) = 255590636;
	*(ref @struct + 832) = 2108114754;
	*(ref @struct + 836) = 1266252396;
	*(ref @struct + 840) = 1589326471;
	*(ref @struct + 844) = 2019907768;
	*(ref @struct + 848) = 15552498;
	*(ref @struct + 852) = 1651075358;
	*(ref @struct + 856) = 614606175;
	*(ref @struct + 860) = 1656823678;
	*(ref @struct + 864) = 797605325;
	*(ref @struct + 868) = 1681594366;
	*(ref @struct + 872) = 2005080248;
	*(ref @struct + 876) = 624648446;
	*(ref @struct + 880) = 884695971;
	*(ref @struct + 884) = 1526931791;
	*(ref @struct + 888) = 1595240948;
	*(ref @struct + 892) = 439447199;
	*(ref @struct + 896) = 2060396292;
	*(ref @struct + 900) = 680093752;
	*(ref @struct + 904) = 409028215;
	*(ref @struct + 908) = 469068267;
	*(ref @struct + 912) = 195583689;
	*(ref @struct + 916) = 1791650630;
	*(ref @struct + 920) = 507724330;
	*(ref @struct + 924) = 1364025102;
	*(ref @struct + 928) = 1094582668;
	*(ref @struct + 932) = 813049577;
	*(ref @struct + 936) = 32316922;
	*(ref @struct + 940) = 1240756058;
	*(ref @struct + 944) = 1176200235;
	*(ref @struct + 948) = 2104494066;
	*(ref @struct + 952) = 325396055;
	*(ref @struct + 956) = 1796606917;
	*(ref @struct + 960) = 1709197385;
	*(ref @struct + 964) = 525495836;
	*(ref @struct + 968) = 1510101430;
	*(ref @struct + 972) = 735526761;
	*(ref @struct + 976) = 767523533;
	*(ref @struct + 980) = 1374043776;
	*(ref @struct + 984) = 1559389967;
	*(ref @struct + 988) = 567085571;
	*(ref @struct + 992) = 1560216161;
	*(ref @struct + 996) = 867042846;
	*(ref @struct + 1000) = 1001796703;
	*(ref @struct + 1004) = 1568754293;
	*(ref @struct + 1008) = 628841972;
	*(ref @struct + 1012) = 173812827;
	*(ref @struct + 1016) = 379868455;
	*(ref @struct + 1020) = 384973125;
	void* ptr = <Module>.@new(1024UL);
	<Module>.TABLE = ptr;
	*(ref <Module>.TABLE + 8) = ptr;
	*(ref <Module>.TABLE + 16) = (byte*)ptr + 1024L;
	Struct77 struct2 = ref <Module>.TABLE;
	try {
		uint* table = <Module>.TABLE;
		<Module>.memmove((void*)table, (void*)(&@struct), 1024UL);
		uint* ptr2 = table + 1024L / 4L;
		*(ref <Module>.TABLE + 8) = ptr2;
		struct2 = 0L;
	} catch {
		<Module>.___CxxCallUnwindDtor(ldftn(smethod_76), (void*)(&struct2));
		throw;
	}
	<Module>._atexit_m(ldftn(smethod_3));
}

internal unsafe static bool checkSerial(Struct30* szName, Struct30* szSerial) {
	int num = 0;
	int num2 = 0;
	int END1 = 0;
	// do {
	// 	int num4 = ((END1 ^ 30866) + 19760 ^ 13345) % 65536;
	// 	if (num4 % 11 == 0) {
	// 		num4 /= 11;
	// 		if (num4 <= 1000) {
	// 			num = END1;
	// 			num2 = num4;
	// 		}
	// 	}
	// 	END1++;
	// }
	// while (END1 < 65536);
	num = 49149;
	num2 = 49149;
	END1 = 0;
	int LEN = (int)(*(long*)(szName + 16L / (long)sizeof(Struct30)));
	int SEED = 0;
	if (LEN <= 0) {
		SEED = 0;
	}
	else {
		int AD_7 = 0;
		int AD_19 = 0;
		int AD_13 = num * 15 % 256;
		int AD_9 = num2 * 17 % 256;
		int ODD_EVEN = 0;
		long CHR_IDX = 0L;
		long FX_LEN = (long)LEN;
		if (0L < FX_LEN) {
			Struct30* ptr = (Struct30*)(szName + 24L / (long)sizeof(Struct30));
			do {
				long PTR_SZNAME = szName;
				if (((*(long*)ptr > 15L) ? 1 : 0) != 0) {
					PTR_SZNAME = *(long*)szName;
				}
				sbyte b = <Module>.toupper((int)(*(PTR_SZNAME + CHR_IDX)));
				int TABLE_1 = (int)((ulong)(*((ulong)b * 4UL + <Module>.TABLE) + END1) % 4294967296UL);
				if (ODD_EVEN % 2 == 0) {
					uint* ptr2 = (b + 13) * 4L + <Module>.TABLE;
					uint* ptr3 = (b + 47) * 4L + <Module>.TABLE;
					uint* ptr4 = (long)AD_9 * 4L + <Module>.TABLE;
					TABLE_1 = (int)((ulong)(*((long)AD_13 * 4L + <Module>.TABLE) + (*ptr2 ^ TABLE_1) * *ptr3 + *ptr4) % 4294967296UL);
					int TABLE_EVEN = (int)((ulong)(*((long)AD_19 * 4L + <Module>.TABLE) + TABLE_1) % 4294967296UL);
					SEED = TABLE_EVEN;
					END1 = TABLE_EVEN;
				}
				else {
					uint* ptr4 = (b + 63) * 4L + <Module>.TABLE;
					uint* ptr5 = (b + 23) * 4L + <Module>.TABLE;
					uint* ptr6 = (long)AD_9 * 4L + <Module>.TABLE;
					int num17 = (int)((ulong)(*((long)AD_13 * 4L + <Module>.TABLE) + (*ptr4 ^ TABLE_1) * *ptr5 + *ptr6) % 4294967296UL);
					int TABLE_ODD = (int)((ulong)(*((long)AD_7 * 4L + <Module>.TABLE) + num17) % 4294967296UL);
					SEED = TABLE_ODD;
					END1 = TABLE_ODD;
				}
				AD_19 = (AD_19 + 19) % 256;
				AD_9 = (AD_9 + 9) % 256;
				AD_13 = (AD_13 + 13) % 256;
				AD_7 = (AD_7 + 7) % 256;
				ODD_EVEN++;
				CHR_IDX += 1L;
			}
			while (CHR_IDX < FX_LEN);
		}
	}
	Struct37 @struct = 0L;
	*(ref @struct + 8) = 0L;
	*(ref @struct + 16) = 0L;
	<Module>.smethod_59(ref @struct, 8L);
	*(@struct + 16L) = SEED % 256;
	*(@struct + 20L) = (SEED >> 8) % 256;
	*(@struct + 24L) = (SEED >> 16) % 256;
	*(@struct + 28L) = (SEED >> 24) % 256;
	*(@struct + 12L) = 156;
	int* ptr7 = @struct + 20L;
	*(@struct + 8L) = (num % 256 ^ *ptr7);
	ptr7 = @struct + 28L;
	*(@struct + 4L) = (num >> 8 ^ *ptr7);
	ptr7 = @struct + 4L;
	*@struct = ((*(@struct + 24L) ^ *ptr7 ^ 85) % 256 ^ 167);
	sbyte* ptr8 = (sbyte*)szSerial;
	ulong num19 = (ulong)(*(long*)(szSerial + 24L / (long)sizeof(Struct30)));
	if (((num19 > 15UL) ? 1 : 0) != 0) {
		ptr8 = *(long*)szSerial;
	}
	sbyte* ptr9 = (sbyte*)szSerial;
	if (((num19 > 15UL) ? 1 : 0) != 0) {
		ptr9 = *(long*)szSerial;
	}
	sbyte* ptr10 = (sbyte*)szSerial;
	if (((num19 > 15UL) ? 1 : 0) != 0) {
		ptr10 = *(long*)szSerial;
	}
	sbyte* ptr11 = (sbyte*)szSerial;
	if (((num19 > 15UL) ? 1 : 0) != 0) {
		ptr11 = *(long*)szSerial;
	}
	sbyte* ptr12 = (sbyte*)szSerial;
	if (((num19 > 15UL) ? 1 : 0) != 0) {
		ptr12 = *(long*)szSerial;
	}
	sbyte* ptr13 = (sbyte*)szSerial;
	if (((num19 > 15UL) ? 1 : 0) != 0) {
		ptr13 = *(long*)szSerial;
	}
	sbyte* ptr14 = (sbyte*)szSerial;
	if (((num19 > 15UL) ? 1 : 0) != 0) {
		ptr14 = *(long*)szSerial;
	}
	sbyte* ptr15 = (sbyte*)szSerial;
	if (((num19 > 15UL) ? 1 : 0) != 0) {
		ptr15 = *(long*)szSerial;
	}
	sbyte b2 = *(sbyte*)ptr8;
	int num20;
	if (b2 >= 48 && b2 <= 57) {
		num20 = (int)(b2 - 48);
	}
	else {
		num20 = (int)((b2 & -33) - 55);
	}
	b2 = *(sbyte*)(ptr8 + 1L / (long)sizeof(sbyte));
	int num21;
	if (b2 >= 48 && b2 <= 57) {
		num21 = (int)(b2 - 48);
	}
	else {
		num21 = (int)((b2 & -33) - 55);
	}
	if ((num20 << 4 | num21) != (*@struct & 255)) {
		goto IL_8D7;
	}
	b2 = *(sbyte*)(ptr9 + 2L / (long)sizeof(sbyte));
	if (b2 >= 48 && b2 <= 57) {
		num20 = (int)(b2 - 48);
	}
	else {
		num20 = (int)((b2 & -33) - 55);
	}
	b2 = *(sbyte*)(ptr9 + 2L / (long)sizeof(sbyte) + 1L / (long)sizeof(sbyte));
	int num22;
	if (b2 >= 48 && b2 <= 57) {
		num22 = (int)(b2 - 48);
	}
	else {
		num22 = (int)((b2 & -33) - 55);
	}
	if ((num20 << 4 | num22) != (*(@struct + 4L) & 255)) {
		goto IL_8D7;
	}
	b2 = *(sbyte*)(ptr10 + 5L / (long)sizeof(sbyte));
	int num23;
	if (b2 >= 48 && b2 <= 57) {
		num23 = (int)(b2 - 48);
	}
	else {
		num23 = (int)((b2 & -33) - 55);
	}
	b2 = *(sbyte*)(ptr10 + 5L / (long)sizeof(sbyte) + 1L / (long)sizeof(sbyte));
	int num24;
	if (b2 >= 48 && b2 <= 57) {
		num24 = (int)(b2 - 48);
	}
	else {
		num24 = (int)((b2 & -33) - 55);
	}
	if ((num23 << 4 | num24) != (*(@struct + 8L) & 255)) {
		goto IL_8D7;
	}
	b2 = *(sbyte*)(ptr11 + 7L / (long)sizeof(sbyte));
	int num25;
	if (b2 >= 48 && b2 <= 57) {
		num25 = (int)(b2 - 48);
	}
	else {
		num25 = (int)((b2 & -33) - 55);
	}
	b2 = *(sbyte*)(ptr11 + 7L / (long)sizeof(sbyte) + 1L / (long)sizeof(sbyte));
	int num26;
	if (b2 >= 48 && b2 <= 57) {
		num26 = (int)(b2 - 48);
	}
	else {
		num26 = (int)((b2 & -33) - 55);
	}
	if ((num25 << 4 | num26) != (*(@struct + 12L) & 255)) {
		goto IL_8D7;
	}
	b2 = *(sbyte*)(ptr12 + 10L / (long)sizeof(sbyte));
	int num27;
	if (b2 >= 48 && b2 <= 57) {
		num27 = (int)(b2 - 48);
	}
	else {
		num27 = (int)((b2 & -33) - 55);
	}
	b2 = *(sbyte*)(ptr12 + 10L / (long)sizeof(sbyte) + 1L / (long)sizeof(sbyte));
	int num28;
	if (b2 >= 48 && b2 <= 57) {
		num28 = (int)(b2 - 48);
	}
	else {
		num28 = (int)((b2 & -33) - 55);
	}
	if ((num27 << 4 | num28) != (*(@struct + 16L) & 255)) {
		goto IL_8D7;
	}
	b2 = *(sbyte*)(ptr13 + 12L / (long)sizeof(sbyte));
	int num29;
	if (b2 >= 48 && b2 <= 57) {
		num29 = (int)(b2 - 48);
	}
	else {
		num29 = (int)((b2 & -33) - 55);
	}
	b2 = *(sbyte*)(ptr13 + 12L / (long)sizeof(sbyte) + 1L / (long)sizeof(sbyte));
	int END10;
	if (b2 >= 48 && b2 <= 57) {
		END10 = (int)(b2 - 48);
	}
	else {
		END10 = (int)((b2 & -33) - 55);
	}
	if ((num29 << 4 | END10) != (*(@struct + 20L) & 255)) {
		goto IL_8D7;
	}
	b2 = *(sbyte*)(ptr14 + 15L / (long)sizeof(sbyte));
	int END11;
	if (b2 >= 48 && b2 <= 57) {
		END11 = (int)(b2 - 48);
	}
	else {
		END11 = (int)((b2 & -33) - 55);
	}
	b2 = *(sbyte*)(ptr14 + 15L / (long)sizeof(sbyte) + 1L / (long)sizeof(sbyte));
	int END12;
	if (b2 >= 48 && b2 <= 57) {
		END12 = (int)(b2 - 48);
	}
	else {
		END12 = (int)((b2 & -33) - 55);
	}
	if ((END11 << 4 | END12) != (*(@struct + 24L) & 255)) {
		goto IL_8D7;
	}
	b2 = *(sbyte*)(ptr15 + 17L / (long)sizeof(sbyte));
	int END13;
	if (b2 >= 48 && b2 <= 57) {
		END13 = (int)(b2 - 48);
	}
	else {
		END13 = (int)((b2 & -33) - 55);
	}
	b2 = *(sbyte*)(ptr15 + 17L / (long)sizeof(sbyte) + 1L / (long)sizeof(sbyte));
	int END14;
	if (b2 >= 48 && b2 <= 57) {
		END14 = (int)(b2 - 48);
	}
	else {
		END14 = (int)((b2 & -33) - 55);
	}
	if ((END13 << 4 | END14) != (*(@struct + 28L) & 255)) {
		goto IL_8D7;
	}
	<Module>.smethod_21(ref @struct);
	<Module>.smethod_28(szName);
	<Module>.smethod_28(szSerial);
	return 1;
	IL_8D7:
	Struct37 @struct;
	<Module>.smethod_21(ref @struct);
	<Module>.smethod_28(szName);
	<Module>.smethod_28(szSerial);
	return 0;
}
