/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

long long (**init_proc())(void);
void sub_1020();
void sub_1030();
void sub_1040();
void sub_1050();
void sub_1060();
void sub_1070();
void sub_1080();
void sub_1090();
void sub_10A0();
void sub_10B0();
void sub_10C0();
void sub_10D0();
// int _cxa_finalize(void *);
// void free(void *ptr);
// int fclose(FILE *stream);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int printf(const char *format, ...);
// int fputc(int c, FILE *stream);
// void *malloc(size_t size);
// int open(const char *file, int oflag, ...);
// FILE *fopen(const char *filename, const char *modes);
void __noreturn start(long long a1, long long a2, void (*a3)(void));
char *sub_11D0();
long long sub_1200();
char *sub_1240();
long long sub_1280();
unsigned long long A1_XOR_A2(long long a1, long long a2, int a3);
int main(int, char **, char **); // idb
_QWORD *touch_kosong_txt();
long long get_byte(long long a1, int a2);
long long set_byte(long long a1, int a2, int a3);
long long get_set_byte(long long a1);
long long switch(long long a1);
long long sub_942DA(long long a1);
void sub_94485(void **a1);
long long sub_944B4(long long a1, int a2);
long long sub_94DD7(long long a1);
long long sub_94E0A(unsigned __int8 *a1);
void *sub_94E42(const char *a1);
void *write_spaces(const char *a1, unsigned long long a2);
_DWORD *mymalloc(int a1);
_BOOL8 is_itself_plus_one(_DWORD *a1);
_BOOL8 is_negative_1(_DWORD *a1);
long long is_itself_plus_one_next(int *a1, unsigned int a2);
long long sub_950C9(long long a1);
long long sub_95114(int *a1);
void term_proc();
// int _li' _start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __cxa_finalize(void *);
// long long _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_400B0; // weak
void *off_98008 = &off_98008; // idb
char byte_98010; // weak


//----- (0000000000001000) ----------------------------------------------------
long long (**init_proc())(void) {
  long long (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (long long (**)(void))_gmon_start__();
  return result;
}
// 98088: using guessed type long long _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020() {
  JUMPOUT(0LL);
}
// 1026: control flows out of bounds to 0

//----- (0000000000001030) ----------------------------------------------------
void sub_1030() {
  sub_1020();
}

//----- (0000000000001040) ----------------------------------------------------
void sub_1040() {
  sub_1020();
}

//----- (0000000000001050) ----------------------------------------------------
void sub_1050() {
  sub_1020();
}

//----- (0000000000001060) ----------------------------------------------------
void sub_1060() {
  sub_1020();
}

//----- (0000000000001070) ----------------------------------------------------
void sub_1070() {
  sub_1020();
}

//----- (0000000000001080) ----------------------------------------------------
void sub_1080() {
  sub_1020();
}

//----- (0000000000001090) ----------------------------------------------------
void sub_1090() {
  sub_1020();
}

//----- (00000000000010A0) ----------------------------------------------------
void sub_10A0() {
  sub_1020();
}

//----- (00000000000010B0) ----------------------------------------------------
void sub_10B0() {
  sub_1020();
}

//----- (00000000000010C0) ----------------------------------------------------
void sub_10C0() {
  sub_1020();
}

//----- (00000000000010D0) ----------------------------------------------------
void sub_10D0() {
  sub_1020();
}

//----- (00000000000011A0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(long long a1, long long a2, void (*a3)(void)) {
  long long v3; // rax
  int v4; // esi
  long long v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main(main, v4, &retaddr, 0LL, 0LL, a3, &v5);
  __halt();
}
// 11AA: positive sp value 8 has been found
// 11B1: variable 'v3' is possibly undefined

//----- (00000000000011D0) ----------------------------------------------------
char *sub_11D0() {
  return &byte_98010;
}
// 98010: using guessed type char byte_98010;

//----- (0000000000001200) ----------------------------------------------------
long long sub_1200() {
  return 0LL;
}

//----- (0000000000001240) ----------------------------------------------------
char *sub_1240() {
  char *result; // rax

  if ( !byte_98010 ) {
    if ( &__cxa_finalize )
      _cxa_finalize(off_98008);
    result = sub_11D0();
    byte_98010 = 1;
  }
  return result;
}
// 98010: using guessed type char byte_98010;

//----- (0000000000001280) ----------------------------------------------------
// attributes: thunk
long long sub_1280() {
  return sub_1200();
}

//----- (0000000000001289) ----------------------------------------------------
unsigned long long A1_XOR_A2(long long a1, long long a2, int a3) {
  int i; // [rsp+2Ch] [rbp-94h]
  char v5[136]; // [rsp+30h] [rbp-90h] BYREF
  unsigned long long v6; // [rsp+B8h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  for ( i = 0; i <= 127; ++i ) {
    if ( i == a3 ) {
      v5[i] = 0;
      printf("%s", v5);
      return v6 - __readfsqword(0x28u);
    }
    v5[i] = *(_BYTE *)(4LL * i + a2) ^ *(_BYTE *)(4LL * i + a1);
  }
  return v6 - __readfsqword(0x28u);
}
// 1289: using guessed type char var_90[136];

//----- (0000000000001380) ----------------------------------------------------
#error "1380: too big function (funcsize=0)"

//----- (0000000000093F93) ----------------------------------------------------
_QWORD *touch_kosong_txt() {
  int i; // [rsp+0h] [rbp-10h]
  int j; // [rsp+4h] [rbp-Ch]
  _QWORD *v5; // [rsp+8h] [rbp-8h]

  v5 = malloc((size_t)&loc_400B0);
  v5[1] = mymalloc(64);
  *(_BYTE *)v5 = 0;
  v5[32789] = write_spaces("./kosong.txt", 0x10000uLL);
  for ( i = 0; i <= 0xFFFF; ++i ) {
    *((_DWORD *)v5 + i + 41) = 0;
  }
  for ( j = 0; j <= 35; ++j ) {
    *((_DWORD *)v5 + j + 5) = 0;
  }
  return v5;
}

//----- (0000000000094042) ----------------------------------------------------
long long get_byte(long long a1, int a2) {
  return *(unsigned int *)(a1 + 4 * (a2 + 4LL) + 4);
}

//----- (0000000000094065) ----------------------------------------------------
long long set_byte(long long a1, int a2, int a3) {
  long long result; // rax

  result = a1;
  *(_DWORD *)(a1 + 4 * (a2 + 4LL) + 4) = a3;
  return result;
}

//----- (000000000009408F) ----------------------------------------------------
long long get_set_byte(long long a1) {
  int v1; // eax
  unsigned int v3; // [rsp+14h] [rbp-4h]

  v3 = *(_DWORD *)(a1 + 4 * ((int)get_byte(a1, 33) + 40LL) + 4);
  v1 = get_byte(a1, 33);
  set_byte(a1, 33, v1 + 1);
  return v3;
}

//----- (00000000000940F2) ----------------------------------------------------
long long switch(long long a1) {
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int i; // [rsp+10h] [rbp-10h]
  int v12; // [rsp+14h] [rbp-Ch]
  int v13; // [rsp+18h] [rbp-8h]
  int v14; // [rsp+1Ch] [rbp-4h]

  v12 = get_byte(a1, 35);
  set_byte(a1, 34, v12);
  *(_DWORD *)(a1 + 16) = sub_950C9(*(_QWORD *)(a1 + 8));
  v13 = *(_DWORD *)(a1 + 16);
  v1 = sub_950C9(*(_QWORD *)(a1 + 8));
  set_byte(a1, 33, v1);
  v2 = sub_950C9(*(_QWORD *)(a1 + 8));
  set_byte(a1, 7, v2);
  v3 = sub_950C9(*(_QWORD *)(a1 + 8));
  set_byte(a1, 6, v3);
  v4 = sub_950C9(*(_QWORD *)(a1 + 8));
  set_byte(a1, 5, v4);
  v5 = sub_950C9(*(_QWORD *)(a1 + 8));
  set_byte(a1, 4, v5);
  v6 = sub_950C9(*(_QWORD *)(a1 + 8));
  set_byte(a1, 3, v6);
  v7 = sub_950C9(*(_QWORD *)(a1 + 8));
  set_byte(a1, 2, v7);
  v8 = sub_950C9(*(_QWORD *)(a1 + 8));
  set_byte(a1, 1, v8);
  v9 = sub_950C9(*(_QWORD *)(a1 + 8));
  set_byte(a1, 0, v9);
  v14 = sub_950C9(*(_QWORD *)(a1 + 8));
  for ( i = 0; i < v14; ++i )
    sub_950C9(*(_QWORD *)(a1 + 8));
  return set_byte(a1, 35, v13 + v12);
}

//----- (00000000000942DA) ----------------------------------------------------
long long sub_942DA(long long a1) {
  unsigned int v1; // eax
  unsigned int v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // eax
  int v10; // eax
  long long result; // rax

  v1 = get_byte(a1, 0);
  is_itself_plus_one_next(*(int **)(a1 + 8), v1);
  v2 = get_byte(a1, 1);
  is_itself_plus_one_next(*(int **)(a1 + 8), v2);
  v3 = get_byte(a1, 2);
  is_itself_plus_one_next(*(int **)(a1 + 8), v3);
  v4 = get_byte(a1, 3);
  is_itself_plus_one_next(*(int **)(a1 + 8), v4);
  v5 = get_byte(a1, 4);
  is_itself_plus_one_next(*(int **)(a1 + 8), v5);
  v6 = get_byte(a1, 5);
  is_itself_plus_one_next(*(int **)(a1 + 8), v6);
  v7 = get_byte(a1, 6);
  is_itself_plus_one_next(*(int **)(a1 + 8), v7);
  v8 = get_byte(a1, 7);
  is_itself_plus_one_next(*(int **)(a1 + 8), v8);
  v9 = get_byte(a1, 33);
  is_itself_plus_one_next(*(int **)(a1 + 8), v9);
  is_itself_plus_one_next(*(int **)(a1 + 8), *(_DWORD *)(a1 + 16) + 1);
  v10 = get_byte(a1, 34);
  set_byte(a1, 35, v10);
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (0000000000094485) ----------------------------------------------------
void sub_94485(void **a1) {
  free(a1[1]);
  free(a1);
}

//----- (00000000000944B4) ----------------------------------------------------
long long sub_944B4(long long a1, int a2) {
  long long result; // rax
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  int v6; // [rsp+10h] [rbp-E0h]
  int v7; // [rsp+14h] [rbp-DCh]
  int v8; // [rsp+18h] [rbp-D8h]
  int v9; // [rsp+1Ch] [rbp-D4h]
  int v10; // [rsp+20h] [rbp-D0h]
  unsigned int v11; // [rsp+24h] [rbp-CCh]
  int v12; // [rsp+28h] [rbp-C8h]
  int v13; // [rsp+2Ch] [rbp-C4h]
  char v14; // [rsp+30h] [rbp-C0h]
  int v15; // [rsp+38h] [rbp-B8h]
  int v16; // [rsp+3Ch] [rbp-B4h]
  char v17; // [rsp+40h] [rbp-B0h]
  int v18; // [rsp+44h] [rbp-ACh]
  int v19; // [rsp+48h] [rbp-A8h]
  int v20; // [rsp+4Ch] [rbp-A4h]
  int v21; // [rsp+50h] [rbp-A0h]
  int v22; // [rsp+54h] [rbp-9Ch]
  int v23; // [rsp+58h] [rbp-98h]
  int v24; // [rsp+60h] [rbp-90h]
  int v25; // [rsp+64h] [rbp-8Ch]
  unsigned int v26; // [rsp+68h] [rbp-88h]
  int v27; // [rsp+6Ch] [rbp-84h]
  int v28; // [rsp+70h] [rbp-80h]
  int v29; // [rsp+74h] [rbp-7Ch]
  int v30; // [rsp+78h] [rbp-78h]
  int v31; // [rsp+7Ch] [rbp-74h]
  int v32; // [rsp+80h] [rbp-70h]
  int v33; // [rsp+84h] [rbp-6Ch]
  int v34; // [rsp+88h] [rbp-68h]
  int v35; // [rsp+8Ch] [rbp-64h]
  int v36; // [rsp+90h] [rbp-60h]
  int v37; // [rsp+94h] [rbp-5Ch]
  int v38; // [rsp+98h] [rbp-58h]
  unsigned int v39; // [rsp+9Ch] [rbp-54h]
  int v40; // [rsp+A0h] [rbp-50h]
  int v41; // [rsp+A4h] [rbp-4Ch]
  int v42; // [rsp+A8h] [rbp-48h]
  int v43; // [rsp+ACh] [rbp-44h]
  int v44; // [rsp+B0h] [rbp-40h]
  int v45; // [rsp+B4h] [rbp-3Ch]
  int v46; // [rsp+B8h] [rbp-38h]
  int v47; // [rsp+BCh] [rbp-34h]
  char v48; // [rsp+C0h] [rbp-30h]
  int v49; // [rsp+C8h] [rbp-28h]
  int v50; // [rsp+CCh] [rbp-24h]
  int v51; // [rsp+D0h] [rbp-20h]
  int v52; // [rsp+D4h] [rbp-1Ch]
  int v53; // [rsp+D8h] [rbp-18h]
  int v54; // [rsp+DCh] [rbp-14h]
  int v55; // [rsp+E0h] [rbp-10h]
  int v56; // [rsp+E4h] [rbp-Ch]
  int v57; // [rsp+E8h] [rbp-8h]
  int v58; // [rsp+ECh] [rbp-4h]

  result = (unsigned int)(a2 - 16);
  switch ( a2 ) {
    case 16:
      v57 = get_set_byte(a1);
      v58 = get_set_byte(a1);
      result = set_byte(a1, v58, v57);
      break;
    case 17:
      v54 = get_set_byte(a1);
      v55 = get_set_byte(a1);
      v56 = get_byte(a1, v54);
      result = set_byte(a1, v55, v56);
      break;
    case 18:
      v51 = get_set_byte(a1);
      v52 = get_set_byte(a1);
      v53 = get_byte(a1, v51);
      result = a1;
      *(_DWORD *)(a1 + 4 * (v52 + 40LL) + 4) = v53;
      break;
    case 19:
      v49 = get_set_byte(a1);
      v50 = get_set_byte(a1);
      result = set_byte(a1, v50, *(_DWORD *)(a1 + 4 * (v49 + 40LL) + 4));
      break;
    case 20:
      v48 = get_set_byte(a1);
      result = *(_QWORD *)(a1 + 262312) + (int)get_set_byte(a1);
      *(_BYTE *)result = v48;
      break;
    case 21:
      v45 = get_set_byte(a1);
      v46 = get_set_byte(a1);
      v47 = get_byte(a1, v45);
      result = set_byte(a1, v46, *(_DWORD *)(a1 + 4 * (v47 + 40LL) + 4));
      break;
    case 22:
      v41 = get_set_byte(a1);
      v42 = get_set_byte(a1);
      v43 = get_byte(a1, v41);
      v44 = get_byte(a1, v42);
      result = set_byte(a1, 32, v44 + v43);
      break;
    case 23:
      v37 = get_set_byte(a1);
      v38 = get_set_byte(a1);
      v39 = get_byte(a1, v37);
      v40 = get_byte(a1, v38);
      result = set_byte(a1, 32, v40 ^ v39);
      break;
    case 24:
      v34 = get_set_byte(a1);
      v35 = get_set_byte(a1);
      v36 = get_byte(a1, v35);
      result = set_byte(a1, 32, v34 + v36);
      break;
    case 25:
      v31 = get_set_byte(a1);
      v32 = get_set_byte(a1);
      v33 = get_byte(a1, v32);
      result = set_byte(a1, 32, v33 - v31);
      break;
    case 26:
      v27 = get_set_byte(a1);
      v28 = get_set_byte(a1);
      v29 = get_byte(a1, v27);
      v30 = get_byte(a1, v28);
      result = set_byte(a1, 32, v29 - v30);
      break;
    case 27:
      result = set_byte(a1, 32, 33);
      break;
    case 28:
      v3 = get_byte(a1, 32);
      result = set_byte(a1, 32, v3 - 1);
      break;
    case 31:
      v24 = get_set_byte(a1);
      v25 = get_set_byte(a1);
      v26 = get_byte(a1, v24);
      result = set_byte(a1, 32, v25 & v26);
      break;
    case 32:
      v20 = get_set_byte(a1);
      v21 = get_set_byte(a1);
      v22 = get_byte(a1, v20);
      v23 = *(_DWORD *)(a1 + 4 * (v21 + 40LL) + 4);
      *(_DWORD *)(a1 + 4 * (v21 + 40LL) + 4) = *(_DWORD *)(a1 + 4 * (v22 + 40LL) + 4);
      result = a1;
      *(_DWORD *)(a1 + 4 * (v22 + 40LL) + 4) = v23;
      break;
    case 33:
      v18 = get_set_byte(a1);
      v19 = get_set_byte(a1);
      result = set_byte(a1, v19, *(char *)(*(_QWORD *)(a1 + 262312) + v18));
      break;
    case 34:
      v15 = get_set_byte(a1);
      v16 = get_set_byte(a1);
      v17 = get_byte(a1, v15);
      result = *(_QWORD *)(a1 + 262312) + v16;
      *(_BYTE *)result = v17;
      break;
    case 35:
      v14 = get_set_byte(a1);
      result = *(_QWORD *)(a1 + 262312) + (int)get_set_byte(a1);
      *(_BYTE *)result = v14;
      break;
    case 36:
      v12 = get_set_byte(a1);
      v13 = get_set_byte(a1);
      result = (unsigned __int8)get_byte(a1, 32);
      if ( v12 != (unsigned __int8)result ) {
        result = a1;
        *(_DWORD *)(a1 + 152) = v13;
      }
      break;
    case 37:
      v11 = get_set_byte(a1);
      is_itself_plus_one_next(*(int **)(a1 + 8), v11);
      result = a1;
      ++*(_DWORD *)(a1 + 16);
      break;
    case 38:
      v10 = get_set_byte(a1);
      v4 = get_byte(a1, v10);
      is_itself_plus_one_next(*(int **)(a1 + 8), v4);
      result = a1;
      ++*(_DWORD *)(a1 + 16);
      break;
    case 39:
      v9 = get_set_byte(a1);
      v5 = sub_950C9(*(_QWORD *)(a1 + 8));
      set_byte(a1, v9, v5);
      result = a1;
      --*(_DWORD *)(a1 + 16);
      break;
    case 40:
      v8 = get_set_byte(a1);
      sub_942DA(a1);
      result = set_byte(a1, 33, v8);
      break;
    case 41:
      v6 = get_set_byte(a1);
      v7 = get_byte(a1, v6);
      sub_942DA(a1);
      result = set_byte(a1, 33, v7);
      break;
    case 42:
      result = switch(a1);
      break;
    case 43:
      result = a1;
      *(_BYTE *)a1 = 1;
      break;
    default:
      return result;
  }
  return result;
}

//----- (0000000000094DD7) ----------------------------------------------------
long long sub_94DD7(long long a1) {
  int v2; // [rsp+1Ch] [rbp-4h]

  v2 = get_set_byte(a1);
  return sub_944B4(a1, v2);
}

//----- (0000000000094E0A) ----------------------------------------------------
long long sub_94E0A(unsigned __int8 *a1) {
  long long result; // rax

  sub_94DD7((long long)a1);
  result = *a1;
  if ( !(_BYTE)result )
    return sub_94E0A(a1);
  return result;
}

//----- (0000000000094E42) ----------------------------------------------------
void *sub_94E42(const char *a1) {
  int fd; // [rsp+14h] [rbp-ACh]
  size_t len; // [rsp+50h] [rbp-70h]

  fd = open(a1, 0);
  return mmap(0LL, len, 1, 2, fd, 0LL);
}
// 94EAB: variable 'len' is possibly undefined

//----- (0000000000094ED4) ----------------------------------------------------
void *write_spaces(const char *a1, unsigned long long a2) {
  int i; // [rsp+18h] [rbp-B8h]
  int fd; // [rsp+1Ch] [rbp-B4h]
  FILE *stream; // [rsp+20h] [rbp-B0h]
  size_t len; // [rsp+60h] [rbp-70h]

  stream = fopen(a1, "w");
  for ( i = 0; a2 > i; ++i )
    fputc(' ', stream);
  fclose(stream);
  fd = open(a1, 2, 384LL);
  return mmap(0LL, len, 3, 1, fd, 0LL);
}
// 94FB0: variable 'len' is possibly undefined

//----- (0000000000094FD9) ----------------------------------------------------
_DWORD *mymalloc(int a1) {
  _DWORD *v2; // [rsp+18h] [rbp-8h]

  v2 = malloc(0x10uLL);
  v2[1] = a1;
  *v2 = -1;
  *((_QWORD *)v2 + 1) = malloc(4LL * (unsigned int)v2[1]);
  return v2;
}

//----- (0000000000095030) ----------------------------------------------------
_BOOL8 is_itself_plus_one(_DWORD *a1) {
  return *a1 == a1[1] - 1;
}

//----- (0000000000095058) ----------------------------------------------------
_BOOL8 is_negative_1(_DWORD *a1) {
  return *a1 == -1;
}

//----- (0000000000095075) ----------------------------------------------------
long long is_itself_plus_one_next(int *a1, unsigned int a2) {
  long long result; // rax
  long long v3; // rcx

  result = is_itself_plus_one(a1);
  if ( !(_DWORD)result ) {
    v3 = *((_QWORD *)a1 + 1);
    ++*a1;
    result = a2;
    *(_DWORD *)(v3 + 4LL * *a1) = a2;
  }
  return result;
}

//----- (00000000000950C9) ----------------------------------------------------
long long sub_950C9(long long a1) {
  long long v2; // rsi
  int v3; // eax

  if ( is_negative_1((_DWORD *)a1) )
    return 0x80000000LL;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = (*(_DWORD *)a1)--;
  return *(unsigned int *)(v2 + 4LL * v3);
}

//----- (0000000000095114) ----------------------------------------------------
long long sub_95114(int *a1) {
  if ( is_negative_1(a1) )
    return 0x80000000LL;
  else
    return *(unsigned int *)(*((_QWORD *)a1 + 1) + 4LL * *a1);
}

//----- (0000000000095158) ----------------------------------------------------
void term_proc() {
  ;
}

// nfuncs=65 queued=39 decompiled=39 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 39 function(s)"
