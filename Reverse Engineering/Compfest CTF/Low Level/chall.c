/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_6020();
// int __fastcall _cxa_finalize(void *);
char __fastcall core::str::pattern::simd_contains::{{closure}}(_QWORD *a1, __int64 a2, int _EDX, __int64 _RCX);
__int64 __fastcall core::slice::sort::break_patterns(__int64 a1, unsigned __int64 a2);
__int64 __fastcall core::slice::sort::partial_insertion_sort(__int64 *a1, unsigned __int64 a2);
void __fastcall core::slice::sort::heapsort(__int128 *a1, unsigned __int64 a2);
void __fastcall __noreturn core::panicking::assert_failed(char a1, __int64 a2, __int64 a3, __int128 *a4, __int64 a5);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 *a1, __int64 a2, __int64 a3);
void *__fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 a1);
void __noreturn std::thread::ThreadId::new::exhausted();
unsigned __int64 __fastcall std::io::buffered::bufwriter::BufWriter<W>::write_all_cold(__int64 a1, char *a2, unsigned __int64 a3);
void __noreturn std::process::abort();
__int64 std::sync::once_lock::OnceLock<T>::initialize();
__int64 std::sync::once_lock::OnceLock<T>::initialize();
__int64 __fastcall std::sync::once_lock::OnceLock<T>::initialize(__int64 a1);
__int64 __fastcall std::sys::pal::common::small_c_string::run_with_cstr_allocating(const void *a1, size_t a2);
char *__fastcall std::sys::pal::common::small_c_string::run_with_cstr_allocating(_QWORD *a1, const void *a2, size_t a3, __int64 (__fastcall *a4)(_QWORD *, const char *, _BYTE *, __int64));
int __fastcall std::sys::pal::common::small_c_string::run_with_cstr_allocating(__int64 a1, const void *a2, size_t a3, __int64 *a4);
bool std::panicking::panic_count::is_zero_slow_path();
__int64 __fastcall std::sys::sync::mutex::futex::Mutex::lock_contended(volatile __int32 *a1);
__int64 __fastcall std::sys::sync::once::futex::Once::call(_QWORD **a1);
__int64 __fastcall std::sys::sync::once::futex::Once::call(__int64 **a1);
__int64 __fastcall std::sys::sync::once::futex::Once::call(_BYTE **a1);
__int64 __fastcall std::sys::sync::once::futex::Once::call(__int64 **a1);
__int64 __fastcall std::sys::sync::rwlock::futex::RwLock::read_contended(volatile signed __int32 *a1);
void __fastcall std::sys::sync::rwlock::futex::RwLock::wake_writer_or_readers(volatile signed __int32 *a1, signed __int32 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 *a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::panicking::assert_failed(__int64 a1, __int128 *a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 *a1, __int64 a2, __int64 a3);
void __fastcall __noreturn alloc::alloc::handle_alloc_error(__int64 a1, __int64 a2);
void __fastcall __noreturn core::cell::panic_already_borrowed(__int64 a1);
void __fastcall __noreturn core::option::unwrap_failed(__int64 a1);
void __fastcall __noreturn core::option::expect_failed(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::panicking::panic_fmt(__int64 a1, __int64 a2);
void __fastcall __noreturn core::panicking::panic_nounwind_fmt(__int128 *a1, char a2, __int64 a3);
void __fastcall __noreturn core::panicking::panic(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::panicking::panic_nounwind(__int64 a1, __int64 a2);
void __fastcall __noreturn core::panicking::panic_nounwind_nobacktrace(__int64 a1, __int64 a2);
void __fastcall __noreturn core::panicking::panic_bounds_check(__int64 a1, __int64 a2, __int64 a3);
void __noreturn core::panicking::panic_cannot_unwind(); // weak
void __noreturn core::panicking::panic_in_cleanup(); // weak
void __fastcall __noreturn core::panicking::assert_failed_inner(char a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int128 *a6, __int64 a7);
void __fastcall __noreturn core::result::unwrap_failed(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall __noreturn core::slice::index::slice_start_index_len_fail(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::slice::index::slice_end_index_len_fail(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::slice::index::slice_index_order_fail(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::slice::index::slice_end_index_overflow_fail(__int64 a1);
void __fastcall __noreturn core::slice::<impl [T]>::copy_from_slice::len_mismatch_fail(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::str::traits::str_index_overflow_fail(__int64 a1);
void __fastcall __noreturn core::str::slice_error_fail(_BYTE *a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
char *deregister_tm_clones();
__int64 register_tm_clones();
char *_do_global_dtors_aux();
__int64 frame_dummy(); // weak
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm4,xmm5> std::sys_common::backtrace::__rust_begin_short_backtrace(void (*a1)(void));
__int64 __fastcall std::rt::lang_start::{{closure}}(void (**a1)(void));
__int64 __fastcall core::ops::function::FnOnce::call_once{{vtable.shim}}(void (**a1)(void));
__int64 __fastcall core::ptr::drop_in_place<std::io::error::Error>(__int64 *a1);
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
char __fastcall <alloc::string::String as core::fmt::Display>::fmt(__int64 a1, __int64 a2);
void __noreturn safe::main();
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _rust_alloc(_QWORD, _QWORD); // weak
__int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _rust_alloc_zeroed(_QWORD, _QWORD); // weak
void __fastcall __noreturn _rust_alloc_error_handler(_QWORD, _QWORD); // weak
char __fastcall <&T as core::fmt::Display>::fmt(__int64 a1, __int64 a2);
__int64 __fastcall core::ptr::drop_in_place<std::io::error::Error>(__int64 *a1);
unsigned __int8 *__fastcall core::str::<impl str>::trim_matches(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall safe::get_input(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall safe::get_input_num(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall safe::get_register(__int64 a1);
__int64 __fastcall safe::get_src_reg(__int64 a1);
__int64 __fastcall safe::get_dst_reg(__int64 a1);
__int64 __fastcall safe::get_src_imm(__int64 a1);
__int64 <T as core::any::Any>::type_id(); // weak
unsigned __int64 <T as core::any::Any>::type_id();
unsigned __int64 <T as core::any::Any>::type_id();
char __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
char __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
bool __fastcall <&T as core::fmt::Debug>::fmt(_QWORD **a1, __int64 a2);
__int64 __fastcall <&T as core::fmt::Debug>::fmt(unsigned __int8 **a1, __int64 a2);
char __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
__int64 __fastcall <&T as core::fmt::Debug>::fmt(_QWORD **a1);
__int64 __fastcall <&T as core::fmt::Debug>::fmt(unsigned int **a1, __int64 a2);
char __fastcall <&T as core::fmt::Display>::fmt(__int64 a1, __int64 a2);
char __fastcall <&T as core::fmt::Display>::fmt(__int64 *a1, __int64 a2);
__int64 __fastcall core::fmt::num::<impl core::fmt::Debug for i32>::fmt(int *a1, __int64 a2);
__int64 __fastcall core::fmt::num::<impl core::fmt::Debug for usize>::fmt(unsigned __int64 *a1, __int64 a2);
char __fastcall core::fmt::Write::write_char(__int64 a1, unsigned int a2);
__int64 __fastcall core::fmt::Write::write_char(__int64 **a1, unsigned int a2);
bool __fastcall core::fmt::Write::write_char(__int64 *a1, unsigned int a2);
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2);
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2);
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2);
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2);
_Unwind_Ptr __fastcall core::ops::function::FnOnce::call_once{{vtable.shim}}(struct _Unwind_Context ***a1);
_Unwind_Ptr __fastcall core::ops::function::FnOnce::call_once{{vtable.shim}}(struct _Unwind_Context ***a1);
char __fastcall core::ops::function::FnOnce::call_once{{vtable.shim}}(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::ops::function::FnOnce::call_once(__int64 a1);
_BYTE *__fastcall core::ptr::drop_in_place<core::result::Result<alloc::ffi::c_str::CString,alloc::ffi::c_str::NulError>>(__int64 *a1);
unsigned __int64 __fastcall core::ptr::drop_in_place<alloc::collections::btree::map::BTreeMap<u64,gimli::read::abbrev::Abbreviation>>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<std::backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<addr2line::Context<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(__int64 a1);
void __fastcall core::ptr::drop_in_place<addr2line::SupUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(__int64 a1);
unsigned __int64 __fastcall core::ptr::drop_in_place<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(__int64 a1);
void __fastcall core::ptr::drop_in_place<gimli::read::dwarf::Unit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>(__int64 a1);
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<addr2line::SupUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<alloc::boxed::Box<[addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>]>>(__int64 a1, __int64 a2);
__int64 __fastcall core::ptr::drop_in_place<alloc::boxed::Box<[addr2line::SupUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>]>>(_QWORD *a1);
unsigned __int64 __fastcall core::ptr::drop_in_place<alloc::sync::ArcInner<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>>(__int64 a1);
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<addr2line::FrameIter<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>(unsigned int *a1);
__int64 __fastcall core::ptr::drop_in_place<std::sync::reentrant_lock::ReentrantLockGuard<core::cell::RefCell<std::io::buffered::linewriter::LineWriter<std::io::stdio::StdoutRaw>>>>(__int64 a1);
void __fastcall core::ptr::drop_in_place<core::option::Option<gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>>(__int64 a1);
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<addr2line::function::Functions<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<(gimli::read::UnitOffset,addr2line::lazy::LazyCell<core::result::Result<addr2line::function::Function<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>)>(_QWORD *a1);
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<(gimli::read::UnitOffset,addr2line::lazy::LazyCell<core::result::Result<addr2line::function::Function<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>)>>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<gimli::read::line::LineRows<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>,usize>>(_QWORD *a1);
unsigned __int64 __fastcall core::ptr::drop_in_place<<alloc::collections::btree::map::IntoIter<K,V,A> as core::ops::drop::Drop>::drop::DropGuard<u64,core::result::Result<alloc::sync::Arc<gimli::read::abbrev::Abbreviations>,gimli::read::Error>,alloc::alloc::Global>>(_QWORD *a1);
void __fastcall core::ptr::drop_in_place<(alloc::sync::Arc<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>,gimli::read::dwarf::Unit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>)>(__int64 *a1);
void __fastcall core::ptr::drop_in_place<alloc::boxed::Box<[(gimli::read::UnitOffset,addr2line::lazy::LazyCell<core::result::Result<addr2line::function::Function<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>)]>>(__int64 a1, __int64 a2);
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<core::option::Option<alloc::boxed::Box<(alloc::sync::Arc<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>,gimli::read::dwarf::Unit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>)>>,gimli::read::Error>>(char a1, __int64 *a2);
__int64 __fastcall core::ptr::drop_in_place<alloc::string::String>(_QWORD *a1);
__int64 __fastcall core::ptr::drop_in_place<std::io::error::Error>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<u8>>(_QWORD *a1);
__int64 __fastcall core::ptr::drop_in_place<std::io::stdio::StdinLock>(__int64 a1, char a2);
unsigned __int64 __fastcall core::ptr::drop_in_place<gimli::read::abbrev::Abbreviations>(_QWORD *a1);
unsigned __int64 __fastcall core::ptr::drop_in_place<gimli::read::abbrev::AbbreviationsCache>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<alloc::string::String>>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::Library>(_QWORD *a1);
int __fastcall core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::Mapping>(__int64 a1);
void __fastcall core::ptr::drop_in_place<alloc::vec::Vec<addr2line::LineSequence>>(_QWORD *a1);
int __fastcall core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::stash::Stash>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<alloc::boxed::Box<[alloc::string::String]>>(__int64 a1, __int64 a2);
__int64 __fastcall core::ptr::drop_in_place<std::panicking::begin_panic_handler::FormatStringPayload>(_QWORD *a1);
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<(),std::io::error::Error>>(__int64 *a1);
unsigned __int64 __fastcall core::ptr::drop_in_place<alloc::sync::ArcInner<gimli::read::abbrev::Abbreviations>>(_QWORD *a1);
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<addr2line::Lines,gimli::read::Error>>(__int64 *a1);
__int64 __fastcall core::ptr::drop_in_place<std::io::Write::write_fmt::Adapter<alloc::vec::Vec<u8>>>(__int64 a1);
void *__fastcall core::ptr::drop_in_place<std::io::buffered::bufwriter::BufWriter<W>::flush_buf::BufGuard>(__int64 a1, unsigned __int64 a2);
__int64 __fastcall core::ptr::drop_in_place<std::io::buffered::linewriter::LineWriter<std::io::stdio::StdoutRaw>>(__int64 a1);
__int64 __fastcall core::str::<impl str>::split_once(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4);
unsigned __int8 *__fastcall core::str::<impl str>::trim_start_matches(unsigned __int8 *a1, unsigned __int8 *a2);
__int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall core::slice::sort::insertion_sort_shift_right(__int64 *a1, unsigned __int64 a2);
void __fastcall core::slice::sort::recurse(__int64 a1, unsigned __int64 a2, _QWORD *a3, unsigned int a4);
void __fastcall core::option::Option<&T>::cloned(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall <*mut T as core::fmt::Debug>::fmt(unsigned __int64 *a1, __m128i *a2);
__int64 __fastcall <&str as core::str::pattern::Pattern>::is_contained_in(_BYTE *s2, size_t n, char *s1, unsigned __int64 a4);
char __fastcall <alloc::string::String as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
__int64 __fastcall <alloc::string::String as core::fmt::Write>::write_char(__int64 *a1, unsigned int a2);
__int64 __fastcall <alloc::string::String as core::fmt::Write>::write_str(__int64 *a1, const void *a2, size_t a3);
unsigned __int64 __fastcall alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(unsigned __int64 *a1, _QWORD *a2);
unsigned __int64 __fastcall alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(unsigned __int64 *a1, _QWORD *a2);
__int64 __fastcall alloc::vec::Vec<T,A>::push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::vec::Vec<T,A>::push(__int64 *a1, __int128 *a2);
unsigned __int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1);
__int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1);
unsigned __int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1);
__int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1);
__int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1);
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
_OWORD *__fastcall gimli::read::line::parse_file_v5(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4, unsigned __int64 a5);
__int64 __fastcall gimli::read::line::FileEntryFormat::parse(__int64 a1, __int64 a2);
char __fastcall gimli::read::line::parse_attribute(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int16 a4, unsigned __int64 a5);
__int64 __fastcall gimli::read::line::parse_directory_v5(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4, unsigned __int64 a5);
char __fastcall gimli::read::line::FileEntry<R,Offset>::parse(__int64 a1, __int64 *a2, __int64 a3, __int64 a4);
char __fastcall gimli::read::unit::parse_attribute(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4);
void __fastcall gimli::read::unit::skip_attributes(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5);
__int64 __fastcall gimli::read::unit::parse_type_offset(__int64 a1, unsigned __int64 *a2, char a3);
char __fastcall gimli::read::unit::Attribute<R>::value(_QWORD *a1, __int64 a2, __int64 a3);
void __fastcall gimli::read::unit::EntriesCursor<R>::next_entry(__int64 *a1, __int64 a2);
__int64 __fastcall gimli::read::unit::AttributeValue<R,Offset>::udata_value(_QWORD *a1);
bool __fastcall gimli::read::unit::AttributeValue<R,Offset>::u8_value(_QWORD *a1);
__int64 __fastcall gimli::read::unit::AttributeValue<R,Offset>::u16_value(_QWORD *a1, __int64 a2, __int64 a3);
void __fastcall gimli::read::unit::DebugInfoUnitHeadersIter<R>::next(__int64 a1, __int64 a2);
void *__fastcall gimli::read::dwarf::Unit<R>::new(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall gimli::read::dwarf::Dwarf<R>::attr_string(__int64 a1, _QWORD *a2, unsigned __int8 a3, unsigned __int64 a4, _QWORD *a5);
void __fastcall gimli::read::index::UnitIndex<R>::parse(__int64 a1, unsigned int *a2, unsigned __int64 a3);
unsigned __int64 __fastcall gimli::read::reader::Reader::read_offset(__int64 a1, unsigned __int64 *a2, char a3);
char __fastcall gimli::read::reader::Reader::read_address(__int64 a1, unsigned __int64 *a2, char a3);
__int64 __fastcall gimli::read::reader::Reader::read_uleb128(__int64 a1, __int64 *a2);
__int64 __fastcall gimli::read::reader::Reader::read_sized_offset(__int64 a1, unsigned __int64 *a2, char a3);
char __fastcall gimli::read::aranges::ArangeHeader<R,Offset>::parse(__int64 a1, unsigned __int64 *a2, __int64 a3);
unsigned __int64 __fastcall gimli::read::rnglists::RngListIter<R>::next(_QWORD *a1, __int64 a2);
char __fastcall <alloc::string::String as core::fmt::Display>::fmt(__int64 a1, __int64 a2);
bool __fastcall <core::result::Result<T,E> as core::fmt::Debug>::fmt(_QWORD *a1, __int64 a2);
__int64 __fastcall <core::str::iter::Chars as core::iter::traits::iterator::Iterator>::next(unsigned __int8 **a1);
__int64 __fastcall <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(__int64 *a1, __int64 *a2);
__int64 __fastcall <gimli::read::unit::AttributeValue<R,Offset> as core::clone::Clone>::clone(_QWORD *a1, __int64 *a2);
__int64 __fastcall <gimli::read::line::LineProgramHeader<R,Offset> as core::clone::Clone>::clone(__int64 a1, __int64 *a2, double a3, __m128 a4);
__int64 __fastcall addr2line::render_file(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall addr2line::Context<R>::find_unit(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, char a4);
_QWORD *__fastcall addr2line::ResUnit<R>::dwarf_and_unit_dwo(_QWORD *a1, __int64 a2, volatile signed __int64 **a3);
__int64 __fastcall addr2line::ResUnit<R>::find_function_or_location::{{closure}}(__int64 a1, _QWORD *a2, __int64 a3, __m128 a4, __m128i a5);
__int64 __fastcall addr2line::LoopingLookup<T,L,F>::new_lookup(__m128i *a1, __int64 a2, __int64 a3, __m128i a4, __m128i a5);
__int64 __fastcall addr2line::Lines::parse(__int64 *a1, __int64 a2, __m128i *a3, __int64 a4);
void __fastcall addr2line::function::name_entry(unsigned __int64 a1, char a2, __int64 a3, unsigned __int64 a4, _QWORD *a5, _QWORD *a6, __int64 a7);
void __fastcall addr2line::function::Function<R>::parse_children(__int64 a1, unsigned __int64 *a2, __int64 a3, int a4, __int64 a5, _QWORD *a6, __int64 a7, __int64 *a8, __int64 *a9, __int64 a10);
void __fastcall addr2line::function::name_attr(_QWORD *a1, __int64 a2, unsigned __int64 a3, char a4, __int64 a5, _QWORD *a6, _QWORD *a7, __int64 a8);
__int64 std::rt::cleanup();
__int64 __fastcall std::rt::lang_start_internal(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
void __noreturn std::rt::lang_start_internal::{{closure}}();
void __noreturn std::rt::lang_start_internal::{{closure}}(); // weak
char __fastcall <std::thread::local::AccessError as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
volatile signed __int64 *__fastcall std::thread::current(__int64 a1, volatile signed __int64 *(__fastcall *a2)(__int64 a1));
__int64 __fastcall std::thread::Thread::new(__int64 a1, __int64 a2);
size_t *__fastcall std::env::current_dir(size_t *a1);
_QWORD *__fastcall std::env::current_exe(_QWORD *a1);
void *__fastcall <std::ffi::os_str::OsString as core::convert::From<&T>>::from(__int64 *a1, const void *a2, __int64 a3);
__int64 __fastcall std::fs::buffer_capacity_required(int *a1);
__int64 __fastcall <&std::fs::File as std::io::Read>::read_to_string(int **a1, __int64 *a2);
__int64 __fastcall <std::fs::File as std::io::Read>::read_to_string(int *a1, __int64 *a2);
__int64 __fastcall std::fs::OpenOptions::_open(__int64 a1, __int64 a2, const void *a3, size_t a4);
unsigned __int64 __fastcall std::io::buffered::bufwriter::BufWriter<W>::flush_buf(__int64 a1);
char __fastcall std::io::error::<impl core::fmt::Debug for std::io::error::repr_bitpacked::Repr>::fmt(__int64 *a1, __int64 a2, double a3, double a4);
char __fastcall <std::io::error::Error as core::fmt::Display>::fmt(__int64 *a1, __int64 a2);
__int64 __fastcall std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::write(__int64 *a1, const void *a2, size_t a3);
__int64 __fastcall std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::write_vectored(__int64 *a1, __int64 a2, unsigned __int64 a3);
char std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::is_write_vectored();
__int64 __fastcall std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::write_all(__int64 *a1, const void *a2, size_t a3);
__int64 std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::flush(); // weak
unsigned __int64 __fastcall <std::io::stdio::StdoutRaw as std::io::Write>::write_all(__int64 a1, char *a2, unsigned __int64 a3);
void *__fastcall std::io::stdio::stdin(__int64 a1);
__int64 __fastcall std::io::stdio::Stdin::read_line(volatile signed __int32 **a1, __int64 *a2);
__int64 __fastcall <std::io::stdio::StdinLock as std::io::BufRead>::read_line(__int64 a1, __int64 *a2);
__int64 *__fastcall std::io::stdio::stdout(__int64 a1);
unsigned __int64 __fastcall <std::io::stdio::Stdout as std::io::Write>::flush(__int64 *a1);
unsigned __int64 __fastcall <&std::io::stdio::Stdout as std::io::Write>::flush(__int64 **a1);
char **__fastcall <&std::io::stdio::Stdout as std::io::Write>::write_fmt(__int64 **a1, _QWORD *a2);
unsigned __int64 __fastcall <std::io::stdio::StdoutLock as std::io::Write>::write_all(__int64 a1, char *a2, unsigned __int64 a3);
__int64 __fastcall std::io::stdio::print_to_buffer_if_capture_used(_QWORD *a1);
__int64 __fastcall std::io::stdio::_print(_QWORD *a1);
__int64 __fastcall std::io::default_read_to_end(int *a1, __int64 *a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall std::io::default_read_to_end::small_probe_read(int *a1, __int64 *a2);
char **__fastcall std::io::Write::write_all(__int64 a1, char *a2, unsigned __int64 a3);
char **__fastcall std::io::Write::write_all_vectored(__int64 a1, __int64 a2, unsigned __int64 a3);
char **__fastcall std::io::Write::write_all_vectored(__int64 *a1, __int64 a2, unsigned __int64 a3);
char **__fastcall std::io::Write::write_fmt(__int64 a1, _QWORD *a2);
char **__fastcall std::io::Write::write_fmt(__int64 a1, _QWORD *a2);
char __fastcall <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(__int64 a1, char *a2, unsigned __int64 a3);
bool __fastcall <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(__int64 *a1, char *a2, unsigned __int64 a3);
__int64 __fastcall <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(__int64 **a1, const void *a2, size_t a3);
__int64 __fastcall std::io::read_until(char **a1, unsigned __int8 a2, __int64 *a3);
__int64 __fastcall std::panic::get_backtrace_style();
__int64 __fastcall std::path::Components::len_before_body(__int64 *a1);
_BYTE *__fastcall std::path::Components::as_path(__int64 a1);
char __fastcall std::path::Components::parse_next_component_back(__int64 a1, __int64 a2);
__int64 __fastcall <std::path::Components as core::iter::traits::iterator::Iterator>::next(__int64 a1, __int64 a2);
_BYTE *__fastcall <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(__int64 a1, __int64 a2);
bool __fastcall <std::path::Components as core::cmp::PartialEq>::eq(__int64 a1, __int64 a2);
void *__fastcall std::path::PathBuf::push(__int64 *a1, __int64 *a2);
__int64 __fastcall std::path::PathBuf::_set_extension(__int64 *a1, void *a2, size_t a3);
_BYTE *__fastcall std::path::Path::_strip_prefix(__int128 a1, _BYTE *a2, __int64 a3);
void __fastcall __noreturn std::process::exit(int a1);
__int64 __fastcall std::sys_common::backtrace::print(__int64 a1, __int64 a2, char a3);
char __fastcall <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt(char *a1, __int64 a2);
char __fastcall std::sys_common::backtrace::_print_fmt::{{closure}}(__int64 a1, __int64 a2, __int64 a3);
bool __fastcall std::sys_common::backtrace::_print_fmt::{{closure}}(__int64 a1, __int64 a2, double a3, __m128i a4);
_BYTE *__fastcall std::sys_common::backtrace::_print_fmt::{{closure}}::{{closure}}(__int64 a1, __int64 a2);
void __fastcall __noreturn std::sys_common::backtrace::__rust_end_short_backtrace(const char ****a1);
char __fastcall std::sys_common::backtrace::output_filename(__int64 a1, __int64 a2, char a3, __int64 a4);
volatile signed __int64 *__fastcall std::sys_common::thread_info::current_thread(__int64 a1, volatile signed __int64 *(__fastcall *a2)(__int64 a1));
unsigned __int64 __fastcall std::sys_common::thread_info::set(__int64 a1, volatile signed __int64 *a2);
int __fastcall std::sys_common::thread_local_dtor::register_dtor_fallback::run_dtors(_QWORD *a1);
char __fastcall std::alloc::default_alloc_error_hook(__int64 a1, __int64 a2);
void *__fastcall _rdl_alloc(size_t size, size_t alignment);
void *__fastcall _rdl_realloc(void *ptr, size_t n, size_t alignment, size_t size);
void *__fastcall _rdl_alloc_zeroed(size_t n, size_t alignment);
void __noreturn _rust_drop_panic();
void __noreturn _rust_foreign_exception();
volatile signed __int64 *__fastcall std::panicking::default_hook(__int64 a1);
__int64 __fastcall std::panicking::default_hook::{{closure}}(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn rust_begin_unwind(__int64 a1);
_QWORD *__fastcall <std::panicking::begin_panic_handler::FormatStringPayload as core::panic::PanicPayload>::take_box(__int64 *a1);
__int64 __fastcall <std::panicking::begin_panic_handler::FormatStringPayload as core::panic::PanicPayload>::get(__int64 a1);
_QWORD *__fastcall <std::panicking::begin_panic_handler::StaticStrPayload as core::panic::PanicPayload>::take_box(__int64 *a1);
__int64 __fastcall <std::panicking::begin_panic_handler::StaticStrPayload as core::panic::PanicPayload>::get(__int64 a1);
void __fastcall __noreturn std::panicking::begin_panic_handler::{{closure}}(const char ****a1);
void __fastcall __noreturn std::panicking::rust_panic_with_hook(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5, char a6);
void __fastcall __noreturn rust_panic(__int64 a1, __int64 a2);
__int64 __fastcall std::backtrace_rs::symbolize::Symbol::name(__int64 a1, __int64 a2);
char __fastcall std::backtrace_rs::print::BacktraceFrameFmt::print_raw_with_column(__int64 a1, __int64 a2, __int128 *a3, _QWORD *a4, int a5, int a6, int a7, int a8);
__int64 __fastcall <std::io::error::ErrorKind as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
char __fastcall <std::path::Component as core::cmp::PartialEq>::eq(__int64 a1, __int64 a2);
bool __fastcall <std::path::StripPrefixError as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
__int64 __fastcall std::sys::pal::unix::args::imp::ARGV_INIT_ARRAY::init_wrapper(int a1, __int64 a2);
int __fastcall std::sys::pal::unix::fs::File::open_c(__int64 a1, const char *a2, __int64 a3);
size_t *__fastcall std::sys::pal::unix::fs::readlink::{{closure}}(size_t *a1, __int64 a2, const char *a3);
_QWORD *__fastcall std::sys::pal::unix::fs::stat(_QWORD *dest, const void *a2, size_t a3);
_QWORD *__fastcall std::sys::pal::unix::fs::stat::{{closure}}(_QWORD *dest, __int64 a2, const char *a3);
size_t *__fastcall std::sys::pal::unix::fs::canonicalize(size_t *a1, const void *a2, size_t a3);
size_t *__fastcall std::sys::pal::unix::os::getenv::{{closure}}(size_t *a1, __int64 a2, const char *a3);
void __fastcall __noreturn std::sys::pal::unix::os::exit(int a1);
int __fastcall std::sys::pal::unix::stack_overflow::imp::signal_handler(__int64 sig, volatile signed __int64 *(__fastcall *a2)(__int64 a1), unsigned __int64 a3);
void *std::sys::pal::unix::stack_overflow::imp::make_handler();
__int64 __fastcall <std::sys::pal::unix::stdio::Stderr as std::io::Write>::write(__int64 a1, const void *a2, size_t a3);
__int64 __fastcall <std::sys::pal::unix::stdio::Stderr as std::io::Write>::write_vectored(__int64 a1, const struct iovec *a2, unsigned __int64 a3);
char <std::sys::pal::unix::stdio::Stderr as std::io::Write>::is_write_vectored();
__int64 <std::sys::pal::unix::stdio::Stderr as std::io::Write>::flush(); // weak
__int64 __fastcall std::sys::pal::unix::thread_local_dtor::register_dtor(__int64 a1, __int64 a2);
char __fastcall std::sys::pal::unix::decode_error_kind(int a1);
void __noreturn std::sys::pal::unix::abort_internal();
__int64 __fastcall std::sys::pal::unix::fs::try_statx(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_Unwind_Ptr __fastcall std::sys::personality::gcc::find_eh_action::{{closure}}(struct _Unwind_Context ***a1);
_Unwind_Ptr __fastcall std::sys::personality::gcc::find_eh_action::{{closure}}(struct _Unwind_Context ***a1);
__int64 __fastcall rust_eh_personality(int a1, int a2, __int64 a3, __int64 a4, struct _Unwind_Context *a5);
char __fastcall <std::sys::os_str::bytes::Slice as core::fmt::Display>::fmt(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall std::sys::thread_local::fast_local::Key<T>::try_initialize(__int64 *a1);
volatile signed __int64 *__fastcall std::sys::thread_local::fast_local::destroy_value(__int64 *a1);
signed __int64 std::sys_common::thread_local_key::StaticKey::lazy_init();
void __fastcall __noreturn std::alloc::rust_oom(__int64 a1);
void __fastcall __noreturn _rg_oom(__int64 a1, __int64 a2);
__int64 __fastcall std::backtrace_rs::backtrace::libunwind::trace::trace_fn(struct _Unwind_Context *a1, _QWORD *a2);
char __fastcall <std::backtrace_rs::symbolize::SymbolName as core::fmt::Display>::fmt(_QWORD *a1, __int64 a2);
__int64 __fastcall std::backtrace_rs::symbolize::gimli::stash::Stash::allocate(__int64 *a1, __int64 a2);
__int64 __fastcall std::backtrace_rs::symbolize::gimli::Context::new(_QWORD *a1, __int64 *a2, _QWORD *a3, __int64 *a4, _QWORD *a5);
int __fastcall std::backtrace_rs::symbolize::gimli::mmap(__int64 *a1, const void *a2, size_t a3);
int __fastcall std::backtrace_rs::symbolize::gimli::resolve(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128i a6);
int __fastcall std::backtrace_rs::symbolize::gimli::elf::<impl std::backtrace_rs::symbolize::gimli::Mapping>::new_debug(_QWORD *a1, _BYTE *a2, __int64 a3, __int64 a4);
int __fastcall std::backtrace_rs::symbolize::gimli::elf::<impl std::backtrace_rs::symbolize::gimli::Mapping>::load_dwarf_package(__int64 a1, _BYTE *a2, __int64 a3, __int64 *a4);
unsigned __int64 __fastcall std::backtrace_rs::symbolize::gimli::elf::Object::parse(__int64 *a1, __int64 a2, unsigned __int64 a3);
const char *__fastcall std::backtrace_rs::symbolize::gimli::elf::Object::section(_QWORD *a1, __int64 *a2, _DWORD *a3, size_t a4);
const char *__fastcall std::backtrace_rs::symbolize::gimli::elf::Object::build_id(_QWORD *a1);
bool __fastcall std::backtrace_rs::symbolize::gimli::elf::decompress_zlib(size_t a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4);
bool std::backtrace_rs::symbolize::gimli::elf::debug_path_exists();
unsigned __int64 __fastcall std::backtrace_rs::symbolize::gimli::elf::locate_build_id(_QWORD *a1, char *a2, unsigned __int64 a3);
__int64 __fastcall std::backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::callback(struct dl_phdr_info *a1, size_t a2, __int64 *a3);
_QWORD *__fastcall <std::backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::str::traits::FromStr>::from_str(_QWORD *a1, unsigned __int8 *a2, unsigned __int8 *a3);
volatile signed __int64 *__fastcall std::sys_common::thread_info::THREAD_INFO::__getit::destroy(__int64 a1);
__int64 __fastcall core::ptr::drop_in_place<panic_unwind::real_imp::Exception>(__int64 a1, __int64 a2);
__int64 __fastcall core::ptr::drop_in_place<alloc::boxed::Box<panic_unwind::real_imp::Exception>>(__int64 a1);
__int64 __fastcall _rust_panic_cleanup(__int64 a1);
_Unwind_Reason_Code __fastcall _rust_start_panic(__int64 a1, __int64 a2);
void __fastcall __noreturn panic_unwind::real_imp::panic::exception_cleanup(__int64 a1, __int64 a2);
__int64 __fastcall <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
const __m128i *__fastcall <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at_until(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, char a5);
_BOOL8 __fastcall memchr::memchr::x86::sse2::memchr(char a1, const __m128i *a2, unsigned __int64 a3);
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall <addr2line::LocationRangeUnitIter as core::iter::traits::iterator::Iterator>::next(__int64 a1, __int64 **a2);
void *__fastcall addr2line::path_push(__int64 *a1, unsigned __int8 *a2, __int64 a3);
__int64 __fastcall <&T as core::fmt::Debug>::fmt(unsigned __int64 **a1, __int64 a2);
__int64 __fastcall core::ptr::drop_in_place<gimli::read::abbrev::Attributes>(_QWORD *a1);
__int64 __fastcall alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::KV>::split(__int64 a1, _QWORD *a2);
__int64 __fastcall alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Internal>,alloc::collections::btree::node::marker::KV>::split(__int64 a1, _QWORD *a2);
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall gimli::read::abbrev::Abbreviations::insert(__int64 *a1, __int64 *a2);
__int64 __fastcall gimli::read::abbrev::Abbreviation::new(__int64 a1, __int64 a2, __int16 a3, char a4, _OWORD *a5);
void __fastcall gimli::read::abbrev::Attributes::push(__int64 a1, _OWORD *a2);
_QWORD *__fastcall <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref(_QWORD *a1);
__int64 __fastcall <core::iter::sources::from_fn::FromFn<F> as core::iter::traits::iterator::Iterator>::next(unsigned __int8 **a1);
char __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
__int64 __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
__int64 __fastcall <&T as core::fmt::Debug>::fmt(unsigned __int8 **a1, __int64 a2);
char __fastcall <&T as core::fmt::Display>::fmt(__int64 *a1, __int64 a2);
char __fastcall <() as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
char __fastcall core::fmt::Write::write_char(_QWORD *a1, unsigned int a2);
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2);
_BYTE *__fastcall core::str::traits::<impl core::slice::index::SliceIndex<str> for core::ops::range::RangeTo<usize>>::index(unsigned __int64 a1, _BYTE *a2, unsigned __int64 a3, __int64 a4);
char __fastcall core::char::methods::<impl char>::escape_debug_ext(__int64 a1, unsigned int a2);
char __fastcall <&mut T as core::fmt::Debug>::fmt(__int64 *a1, __int64 a2);
__int64 __fastcall <core::fmt::Error as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
char __fastcall <core::num::error::ParseIntError as core::fmt::Debug>::fmt(__int64 a1, __int64 a2, double a3, double a4);
void __fastcall <core::str::pattern::StrSearcher as core::str::pattern::Searcher>::next(_QWORD *a1, __int64 a2);
unsigned __int64 __fastcall <core::str::iter::Chars as core::iter::traits::iterator::Iterator>::count(__int64 a1, __int64 a2);
__int64 __fastcall <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(__int64 *a1, __int64 *a2);
__int64 __fastcall <rustc_demangle::legacy::Demangle as core::fmt::Display>::fmt(__int64 a1, __int64 a2);
__int64 __fastcall <rustc_demangle::v0::Ident as core::fmt::Display>::fmt(unsigned __int8 **a1, __int64 a2);
__int64 __fastcall rustc_demangle::v0::HexNibbles::try_parse_uint(__int64 a1, __int64 a2);
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm4,xmm5> rustc_demangle::v0::Parser::hex_nibbles(_QWORD *a1, __int64 a2);
char __fastcall rustc_demangle::v0::Parser::integer_62(__int64 a1, __int64 *a2);
char __fastcall rustc_demangle::v0::Parser::disambiguator(__int64 a1, __int64 *a2);
__int64 __fastcall rustc_demangle::v0::Parser::namespace(_QWORD *a1);
char __fastcall rustc_demangle::v0::Parser::ident(__int64 a1, unsigned __int64 *a2);
char __fastcall rustc_demangle::v0::Printer::skipping_printing(__int64 a1);
char __fastcall rustc_demangle::v0::Printer::print_backref(__int64 *a1, char a2);
char __fastcall rustc_demangle::v0::Printer::print_backref(__int64 *a1, char a2);
char __fastcall rustc_demangle::v0::Printer::print_backref(__int64 *a1);
__int64 __fastcall rustc_demangle::v0::Printer::print_quoted_escaped_chars(__int64 a1, unsigned int a2);
char __fastcall rustc_demangle::v0::Printer::print_lifetime_from_index(__int64 a1, unsigned __int64 a2);
char __fastcall rustc_demangle::v0::Printer::in_binder(__int64 a1);
char __fastcall rustc_demangle::v0::Printer::in_binder(__int64 a1);
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(__int64 *a1);
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(__int64 *a1);
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(__int64 *a1);
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(unsigned __int64 *a1);
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(__int64 *a1);
char __fastcall rustc_demangle::v0::Printer::print_path(__int64 a1, unsigned __int8 a2);
char __fastcall rustc_demangle::v0::Printer::print_generic_arg(_QWORD *a1);
char __fastcall rustc_demangle::v0::Printer::print_type(__int64 a1);
char __fastcall rustc_demangle::v0::Printer::print_type::{{closure}}(unsigned __int64 *a1);
__int64 __fastcall rustc_demangle::v0::Printer::print_path_maybe_open_generics(_QWORD *a1);
char __fastcall rustc_demangle::v0::Printer::print_dyn_trait(unsigned __int64 *a1);
char __fastcall rustc_demangle::v0::Printer::print_const(__int64 a1, char a2);
char __fastcall rustc_demangle::v0::Printer::print_const_uint(__int64 a1, char a2);
char __fastcall rustc_demangle::v0::Printer::print_const_str_literal(__int64 a1);
__int64 *__fastcall rustc_demangle::demangle(__int64 *a1, __int64 a2, __int64 a3);
__int128 *__fastcall rustc_demangle::try_demangle(__int128 *a1, __int64 a2, __int64 a3);
char __fastcall <rustc_demangle::SizeLimitedFmtAdapter<F> as core::fmt::Write>::write_str(_QWORD *a1, __int64 a2, unsigned __int64 a3);
char __fastcall <rustc_demangle::Demangle as core::fmt::Display>::fmt(_QWORD *a1, __int64 a2);
__int64 __fastcall <rustc_demangle::SizeLimitExhausted as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
__int64 __fastcall miniz_oxide::inflate::core::init_tree(__int64 a1, __int64 a2);
unsigned __int64 __fastcall miniz_oxide::inflate::core::transfer(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5, __int64 a6);
void __fastcall miniz_oxide::inflate::core::apply_match(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5, __int64 a6);
char __fastcall miniz_oxide::inflate::core::decompress_fast(__int64 a1, char **a2, __int64 *a3, char a4, unsigned __int64 *a5, __int64 a6);
__int64 __fastcall miniz_oxide::inflate::core::decompress(__int64 a1, __int64 a2, size_t a3, unsigned __int64 a4, __int64 a5, unsigned __int64 a6, unsigned __int64 a7, int a8);
__int64 __fastcall adler::Adler32::write_slice(unsigned __int16 *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall <core::alloc::layout::LayoutError as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
void __noreturn alloc::raw_vec::capacity_overflow();
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 *__fastcall <&[u8] as alloc::ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl(__int64 *a1, const void *a2, size_t a3);
__int64 __fastcall alloc::ffi::c_str::CString::_from_vec_unchecked(__int64 *a1);
_OWORD *__fastcall alloc::string::String::from_utf8_lossy(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall alloc::string::String::try_reserve(__int64 *a1, unsigned __int64 a2);
__int64 *__fastcall <alloc::string::String as core::convert::From<alloc::borrow::Cow<str>>>::from(__int64 *a1, __int64 a2);
__int64 __fastcall alloc::sync::arcinner_layout_for_value_layout(unsigned __int64 a1, __int64 a2);
void __noreturn core::ops::function::FnOnce::call_once(); // weak
__int64 __fastcall core::num::from_str_radix(unsigned __int8 *a1, unsigned __int64 a2, unsigned int a3);
char __fastcall core::num::from_str_radix(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, unsigned int a4);
char __fastcall <core::ops::range::Range<Idx> as core::fmt::Debug>::fmt(unsigned __int64 *a1, __int64 a2);
__int64 <T as core::any::Any>::type_id(); // weak
__int64 __fastcall <core::cell::BorrowMutError as core::fmt::Debug>::fmt(__int64 a1, __int64 a2);
char __fastcall core::char::methods::<impl char>::escape_debug_ext(__int64 a1, unsigned int a2, int a3);
__int64 __fastcall core::char::EscapeUnicode::new(__int64 a1, unsigned int a2);
__int64 __fastcall core::char::EscapeDebug::backslash(__int64 a1, __int16 a2);
void __fastcall core::char::EscapeDebug::clear(__int64 a1);
_QWORD *__fastcall core::ffi::c_str::CStr::from_bytes_with_nul(_QWORD *a1, __int64 a2, unsigned __int64 a3);
char __fastcall <core::panic::location::Location as core::fmt::Display>::fmt(__int64 a1, __int64 a2);
__int64 __fastcall <core::panic::panic_info::PanicInfo as core::fmt::Display>::fmt(const char ***a1, __int64 a2);
void __fastcall __noreturn core::panicking::panic_display(__int64 a1, __int64 a2);
char __fastcall <core::fmt::builders::PadAdapter as core::fmt::Write>::write_str(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128i a4, double a5);
char __fastcall <core::fmt::builders::PadAdapter as core::fmt::Write>::write_char(_QWORD *a1, int a2);
_BYTE *__fastcall core::fmt::builders::DebugStruct::field(_BYTE *a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, double a6, double a7);
char __fastcall core::fmt::builders::DebugStruct::finish(_BYTE *a1);
__int64 *__fastcall core::fmt::builders::DebugTuple::field(__int64 *a1, __int64 a2, __int64 a3);
bool __fastcall core::fmt::builders::DebugTuple::finish(__int64 a1);
_BYTE *__fastcall core::fmt::builders::DebugList::entry(_BYTE *a1, __int64 a2, __int64 a3);
char __fastcall core::fmt::builders::DebugList::finish(_BYTE *a1);
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2);
char __fastcall <core::fmt::Arguments as core::fmt::Display>::fmt(_QWORD *a1, __int64 a2);
char __fastcall core::fmt::write(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall core::fmt::Formatter::pad_integral(__int64 a1, int a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6);
char __fastcall core::fmt::Formatter::pad_integral::write_prefix(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5);
char __fastcall core::fmt::Formatter::pad(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall <core::fmt::Formatter as core::fmt::Write>::write_str(__int64 a1);
__int64 __fastcall core::fmt::Formatter::debug_struct(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall core::fmt::Formatter::debug_struct_field1_finish(__int64 a1, double a2, double a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7, __int64 a8, __int64 a9);
char __fastcall core::fmt::Formatter::debug_struct_field2_finish(__int64 a1, double a2, double a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7, __int64 a8, __int64 a9, __int64 a10, unsigned __int64 a11, __int64 a12, __int64 a13);
__int64 __fastcall core::fmt::Formatter::debug_tuple(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
bool __fastcall core::fmt::Formatter::debug_tuple_field1_finish(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
bool __fastcall core::fmt::Formatter::debug_tuple_field2_finish(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall core::fmt::Formatter::debug_list(__int64 a1, __int64 a2);
__int64 __fastcall <core::fmt::Formatter as core::fmt::Write>::write_char(__int64 a1);
char __fastcall <str as core::fmt::Debug>::fmt(unsigned __int8 *a1, __int64 a2, __int64 a3);
char __fastcall <str as core::fmt::Display>::fmt(__int64 a1, unsigned __int64 a2, __int64 a3);
char __fastcall <char as core::fmt::Debug>::fmt(unsigned int *a1, __int64 a2);
char __fastcall <char as core::fmt::Display>::fmt(unsigned int *a1, _QWORD *a2);
__int64 __fastcall core::fmt::pointer_fmt_inner(unsigned __int64 a1, __m128i *a2);
__int64 __fastcall core::slice::memchr::memchr_aligned(unsigned __int8 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall core::slice::memchr::memrchr(unsigned __int8 a1, __int64 a2, unsigned __int64 a3);
void __fastcall __noreturn core::slice::index::slice_start_index_len_fail_rt(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::slice::index::slice_end_index_len_fail_rt(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn core::slice::index::slice_index_order_fail_rt(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall core::str::converts::from_utf8(__int64 a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall core::str::count::do_count_chars(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall core::str::count::char_count_general_case(__int64 a1, unsigned __int64 a2);
__int64 __fastcall core::str::pattern::StrSearcher::new(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, unsigned __int64 a5);
_QWORD *__fastcall <core::str::lossy::Utf8Chunks as core::iter::traits::iterator::Iterator>::next(_QWORD *a1, __int64 *a2);
void __fastcall __noreturn core::str::slice_error_fail_rt(_BYTE *a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5);
char __fastcall core::unicode::printable::check(unsigned __int16 a1, _BYTE *a2, __int64 a3, __int64 a4, unsigned __int64 a5, unsigned __int8 *a6, __int64 a7);
char __fastcall core::unicode::printable::is_printable(unsigned int a1);
__int64 __fastcall core::num::<impl u32>::from_str_radix(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall core::num::<impl usize>::from_str_radix(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, unsigned int a4);
__int64 __fastcall core::num::<impl core::str::traits::FromStr for usize>::from_str(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3);
__int64 __fastcall core::fmt::num::<impl core::fmt::LowerHex for u8>::fmt(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall core::fmt::num::<impl core::fmt::UpperHex for u8>::fmt(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall core::fmt::num::<impl core::fmt::LowerHex for u32>::fmt(unsigned int *a1, __int64 a2);
__int64 __fastcall core::fmt::num::<impl core::fmt::UpperHex for u32>::fmt(unsigned int *a1, __int64 a2);
__int64 __fastcall core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt(unsigned __int64 *a1, __int64 a2);
__int64 __fastcall core::fmt::num::<impl core::fmt::UpperHex for usize>::fmt(unsigned __int64 *a1, __int64 a2);
__int64 __fastcall core::fmt::num::<impl core::fmt::Debug for usize>::fmt(unsigned __int64 *a1, __int64 a2);
__int64 __fastcall core::fmt::num::imp::<impl core::fmt::Display for u8>::fmt(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall core::fmt::num::imp::<impl core::fmt::Display for i32>::fmt(int *a1, __int64 a2);
__int64 __fastcall core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt(unsigned int *a1, __int64 a2);
__int64 __fastcall core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt(unsigned __int64 *a1, __int64 a2);
__int64 __fastcall <&T as core::fmt::Debug>::fmt(_QWORD *a1);
char __fastcall <&T as core::fmt::Display>::fmt(__int64 a1, __int64 a2);
bool __fastcall core::unicode::unicode_data::cc::lookup(unsigned int a1);
bool __fastcall core::unicode::unicode_data::grapheme_extend::lookup(int a1);
unsigned __int64 __fastcall _udivti3(unsigned __int128 a1, unsigned __int64 a2, unsigned __int64 a3);
void term_proc();
// char *getenv(const char *name);
// int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *), void *data);
// void free(void *ptr);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// void __noreturn abort(void);
// _Unwind_Reason_Code Unwind_Backtrace(_Unwind_Trace_Fn, void *);
// int *_errno_location(void);
// ssize_t writev(int fd, const struct iovec *iovec, int count);
// int pthread_getattr_np(pthread_t th, pthread_attr_t *attr);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// __int64 __fastcall _cxa_thread_atexit_impl(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall _xpg_strerror_r(_QWORD, _QWORD, _QWORD); weak
// void *pthread_getspecific(pthread_key_t key);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fcntl(int fd, int cmd, ...);
// _Unwind_Ptr Unwind_GetRegionStart(struct _Unwind_Context *);
// ssize_t write(int fd, const void *buf, size_t n);
// _Unwind_Ptr Unwind_GetTextRelBase(struct _Unwind_Context *);
// _Unwind_Reason_Code Unwind_RaiseException(struct _Unwind_Exception *);
// size_t strlen(const char *s);
// int stat64(const char *file, struct stat64 *buf);
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
// void *memset(void *s, int c, size_t n);
// char *getcwd(char *buf, size_t size);
// _Unwind_Ptr Unwind_GetIPInfo(struct _Unwind_Context *, int *);
// int close(int fd);
// void *Unwind_GetLanguageSpecificData(struct _Unwind_Context *);
// int pthread_key_delete(pthread_key_t key);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void *calloc(size_t nmemb, size_t size);
// __sighandler_t signal(int sig, __sighandler_t handler);
// __int64 syscall(__int64 sysno, ...);
// int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddr, size_t *stacksize);
// char *realpath(const char *name, char *resolved);
// void *memcpy(void *dest, const void *src, size_t n);
// _Unwind_Ptr Unwind_GetIP(struct _Unwind_Context *);
// void *mmap64(void *addr, size_t len, int prot, int flags, int fd, __off64_t offset);
// void *malloc(size_t size);
// int bcmp(const void *s1, const void *s2, size_t n);
// void *realloc(void *ptr, size_t size);
// int munmap(void *addr, size_t len);
// unsigned __int64 getauxval(unsigned __int64 type);
// __int64 __fastcall statx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// _Unwind_Ptr Unwind_GetDataRelBase(struct _Unwind_Context *);
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// void Unwind_SetGR(struct _Unwind_Context *, int, _Unwind_Word);
// int open64(const char *file, int oflag, ...);
// void *memmove(void *dest, const void *src, size_t n);
// pthread_t pthread_self(void);
// int mprotect(void *addr, size_t len, int prot);
// __int64 sysconf(int name);
// int pthread_attr_destroy(pthread_attr_t *attr);
// void __noreturn exit(int status);
// __off64_t lseek64(int fd, __off64_t offset, int whence);
// int fstat64(int fd, struct stat64 *buf);
// int posix_memalign(void **memptr, size_t alignment, size_t size);
// void Unwind_DeleteException(struct _Unwind_Exception *);
// int sigaltstack(const struct sigaltstack *ss, struct sigaltstack *oss);
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// void Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);
// int __fastcall __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_8 = '\0'; // weak
Elf64_Rela stru_2AE8 = { 365752uLL, 8uLL, 295904LL }; // weak
_UNKNOWN unk_47099; // weak
char aHiSelect1OfThe[110] = "Hi, select 1 of the below choices:\n1. Add\n2. And\n3. Xor\n4. Push\n5. Pop\n6. Execute\n7. See registers\n8. Exit\n>> "; // weak
char aSelectSource1R[49] = "Select source:\n1. Register\n2. Immediate Value\n>> "; // weak
char aSecretTxt[10] = "secret.txt"; // weak
char aCalledResultUn_1[43] = "called `Result::unwrap()` on an `Err` value"; // weak
char aSelectRegister[62] = "Select register:\n1. RAX\n2. RBX\n3. RCX\n4. RDX\n5. RDI\n6. RSI\n>> "; // weak
char aSelectSourceRe[69] = "Select source register:\n1. RAX\n2. RBX\n3. RCX\n4. RDX\n5. RDI\n6. RSI\n>> "; // weak
char aSelectDestinat[74] = "Select destination register:\n1. RAX\n2. RBX\n3. RCX\n4. RDX\n5. RDI\n6. RSI\n>> "; // weak
char aEnterValueInHe[54] = "Enter value (in hex without 0x prefix, ex: DEADBEEF): "; // weak
__int128 xmmword_482A0 = 19LL; // weak
__int128 xmmword_482B0 = 65280LL; // weak
__int128 xmmword_482C0 = 0x0FF00000000000000LL; // weak
__int128 xmmword_482D0 = 0x20000000000000001LL; // weak
__int128 xmmword_48390 = 0x6E696C746C6167756265645F756E672ELL; // weak
__int128 xmmword_483A0 = 107LL; // weak
char aDebugTypesDwo[16] = ".debug_types.dwo"; // weak
_UNKNOWN unk_48420; // weak
_UNKNOWN unk_48450; // weak
char aRustc9b00956e5[95] = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/navigate.rs"; // weak
char asc_48E6A[2] = "()"; // weak
_UNKNOWN unk_48F69; // weak
char str_0[25] = "attempt to divide by zero"; // weak
char aAssertionFaile[44] = "assertion failed: end >= start && end <= len"; // weak
char aAssertionFaile_0[46] = "assertion failed: offset != 0 && offset <= len"; // weak
char aAssertionFaile_1[58] = "assertion failed: offset != 0 && offset <= len && len >= 2"; // weak
char aCalledResultUn_2[43] = "called `Result::unwrap()` on an `Err` value"; // weak
char aError[5] = "Error"; // weak
char aInternalErrorE[40] = "internal error: entered unreachable code"; // weak
char str_1[57] = "attempt to calculate the remainder with a divisor of zero"; // weak
char aDebugAbbrev[13] = ".debug_abbrev"; // weak
char aDebugAddr[11] = ".debug_addr"; // weak
char aDebugAranges[14] = ".debug_aranges"; // weak
char aDebugCuIndex[15] = ".debug_cu_index"; // weak
char aDebugInfo[11] = ".debug_info"; // weak
char aDebugLine[11] = ".debug_line"; // weak
char aDebugLineStr[15] = ".debug_line_str"; // weak
char aDebugLoc[10] = ".debug_loc"; // weak
char aDebugLoclists[15] = ".debug_loclists"; // weak
char aDebugRanges[13] = ".debug_ranges"; // weak
char aDebugRnglists[15] = ".debug_rnglists"; // weak
char aDebugStr[10] = ".debug_str"; // weak
char aDebugStrOffset[18] = ".debug_str_offsets"; // weak
char aDebugTuIndex[15] = ".debug_tu_index"; // weak
char aDebugTypes[12] = ".debug_types"; // weak
char aDebugAbbrevDwo[17] = ".debug_abbrev.dwo"; // weak
char aDebugInfoDwo[15] = ".debug_info.dwo"; // weak
char aDebugLineDwo[15] = ".debug_line.dwo"; // weak
char aDebugLocDwo[14] = ".debug_loc.dwo"; // weak
char aDebugLoclistsD[19] = ".debug_loclists.dwo"; // weak
char aDebugRnglistsD[19] = ".debug_rnglists.dwo"; // weak
char aDebugStrDwo[14] = ".debug_str.dwo"; // weak
char aDebugStrOffset_0[22] = ".debug_str_offsets.dwo"; // weak
_UNKNOWN unk_49368; // weak
_UNKNOWN unk_493B8; // weak
_UNKNOWN unk_493C0; // weak
_UNKNOWN unk_49400; // weak
_UNKNOWN unk_49440; // weak
char aCode[4] = "code"; // weak
char aKind[4] = "kind"; // weak
_UNKNOWN unk_49458; // weak
_UNKNOWN unk_49470; // weak
_UNKNOWN unk_4949C; // weak
char aOk[2] = "Ok"; // weak
char aErr[3] = "Err"; // weak
char asc_49545 = '\n'; // weak
char aAssertionFaile_2[32] = "assertion failed: page_size != 0"; // weak
char aAccesserror[11] = "AccessError"; // weak
char aUseOfStdThread[94] = "use of std::thread::current() is not possible after the thread's local data has been destroyed"; // weak
char asc_49706 = '/'; // weak
char aOs[2] = "Os"; // weak
char aMessage[7] = "message"; // weak
_UNKNOWN unk_499D2; // weak
_UNKNOWN unk_499D8; // weak
char aCannotAccessAT[70] = "cannot access a Thread Local Storage value during or after destruction"; // weak
char aStdout[6] = "stdout"; // weak
char aLockCountOverf[38] = "lock count overflow in reentrant mutex"; // weak
char aStackBacktrace[17] = "stack backtrace:\n"; // weak
char aNoteSomeDetail[88] = "note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n"; // weak
char aRustBeginShort[28] = "__rust_begin_short_backtrace"; // weak
char aRustEndShortBa[26] = "__rust_end_short_backtrace"; // weak
_UNKNOWN unk_49CB4; // weak
char aUnknown[9] = "<unknown>"; // weak
char asc_49D69[3] = "\uFFFD"; // weak
char aBoxDynAnyUnnam[21] = "Box<dyn Any><unnamed>"; // weak
char asc_49FAB[6] = "      "; // weak
char aD[2] = "/d"; // weak
char aAssertionFaile_3[36] = "assertion failed: is_unlocked(state)"; // weak
char aCouldnTFindAdd[21] = "Couldn't find address"; // weak
char aCouldnTFindPer[25] = "Couldn't find permissions"; // weak
char aCouldnTFindOff[20] = "Couldn't find offset"; // weak
char aCouldnTFindDev[17] = "Couldn't find dev"; // weak
char aCouldnTFindIno[19] = "Couldn't find inode"; // weak
_UNKNOWN unk_4A5F8; // weak
_UNKNOWN unk_4A60A; // weak
_UNKNOWN unk_4A618; // weak
_UNKNOWN unk_4A631; // weak
_UNKNOWN unk_4A643; // weak
_QWORD qword_4A660[41] =
{
  16LL,
  17LL,
  18LL,
  16LL,
  16LL,
  19LL,
  18LL,
  13LL,
  14LL,
  21LL,
  12LL,
  11LL,
  21LL,
  21LL,
  15LL,
  14LL,
  19LL,
  38LL,
  56LL,
  25LL,
  23LL,
  12LL,
  9LL,
  10LL,
  16LL,
  23LL,
  25LL,
  14LL,
  13LL,
  20LL,
  8LL,
  27LL,
  14LL,
  16LL,
  22LL,
  21LL,
  11LL,
  22LL,
  13LL,
  11LL,
  19LL
}; // weak
unsigned int dword_4A994[5] = { 8u, 8u, 6u, 6u, 3u }; // weak
_UNKNOWN panic_unwind::real_imp::CANARY; // weak
char aAssertionFaile_4[48] = "assertion failed: edge.height == self.height - 1"; // weak
char aAssertionFaile_5[40] = "assertion failed: src.len() == dst.len()"; // weak
char aAssertionFaile_6[53] = "assertion failed: edge.height == self.node.height - 1"; // weak
char asc_4ADD0[2] = "()"; // weak
char aRustc9b00956e5_0[80] = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/ops/function.rs"; // weak
char aCalledResultUn_3[43] = "called `Result::unwrap()` on an `Err` value"; // weak
_UNKNOWN unk_4AF1C; // weak
char aFor[4] = "for<"; // weak
char aShim[4] = "shim"; // weak
char aAs[4] = " as "; // weak
char aMut[4] = "mut "; // weak
char aDyn[4] = "dyn "; // weak
char asc_4AF4C[4] = " -> "; // weak
char aTrue[4] = "true"; // weak
char aParseinterror[13] = "ParseIntError"; // weak
char asc_4AF8F[2] = "::"; // weak
_UNKNOWN unk_4AF91; // weak
char asc_4AF92 = ','; // weak
char asc_4AF93 = ')'; // weak
char asc_4AF94 = '('; // weak
char asc_4AF95 = '>'; // weak
char asc_4AF96 = '<'; // weak
char asc_4AF97 = '&'; // weak
char asc_4AF98 = '*'; // weak
char aFmtErrorSShoul[61] = "`fmt::Error`s should be impossible without a `fmt::Formatter`"; // weak
char asc_4B00B = '-'; // weak
char asc_4B00C = '}'; // weak
char a0 = '0'; // weak
char aInternalErrorE_1[40] = "internal error: entered unreachable code"; // weak
char asc_4B0CC = '_'; // weak
char aInvalidSyntax[16] = "{invalid syntax}"; // weak
char aRecursionLimit[25] = "{recursion limit reached}"; // weak
char asc_4B0F9 = '?'; // weak
char asc_4B0FA = '\''; // weak
char asc_4B0FB[2] = "> "; // weak
char asc_4B0FD[2] = ", "; // weak
char asc_4B0FF = '['; // weak
char asc_4B100 = ']'; // weak
char asc_4B101[3] = "::{"; // weak
char aClosure[7] = "closure"; // weak
char asc_4B10B = ':'; // weak
char asc_4B10C = '#'; // weak
char asc_4B10D = ' '; // weak
char aConst[6] = "const "; // weak
char asc_4B114[2] = "; "; // weak
char asc_4B116[3] = " + "; // weak
char aUnsafe[7] = "unsafe "; // weak
char aExtern[8] = "extern \""; // weak
char asc_4B128[2] = "\" "; // weak
char aFn[3] = "fn("; // weak
char asc_4B12D[3] = " = "; // weak
char aFalse[5] = "false"; // weak
char asc_4B135 = '{'; // weak
char asc_4B136[3] = " { "; // weak
char asc_4B139[2] = " }"; // weak
char asc_4B13B[2] = ": "; // weak
char a0x[2] = "0x"; // weak
char aLlvm[6] = ".llvm."; // weak
char aFmtErrorFromSi[55] = "`fmt::Error` from `SizeLimitedFmtAdapter` was discarded"; // weak
_QWORD qword_4B210[26] =
{
  2LL,
  4LL,
  4LL,
  3LL,
  3LL,
  3LL,
  4LL,
  2LL,
  5LL,
  5LL,
  4LL,
  3LL,
  3LL,
  4LL,
  4LL,
  1LL,
  4LL,
  4LL,
  3LL,
  3LL,
  2LL,
  3LL,
  4LL,
  3LL,
  3LL,
  1LL
}; // weak
__int128 xmmword_4B2F0 = 0x50505050404040403030303LL; // weak
__int128 xmmword_4B300 = 0x2020202010101010000000000000000LL; // weak
__int128 xmmword_4B310 = 0xD0D0D0D0C0C0B0B0A0A090908080707LL; // weak
__int128 xmmword_4B320 = 0x6060505040403030202010100000000LL; // weak
__int128 xmmword_4B330 = 0x8080808080808080808080808080808LL; // weak
__int128 xmmword_4B340 = 0x9090909090909090909090909090909LL; // weak
__int128 xmmword_4B350 = 0x7070707070707070707070707070707LL; // weak
__int128 xmmword_4B360 = 0x5050505050505050505050505050505LL; // weak
char aDestIsOutOfBou[21] = "dest is out of bounds"; // weak
_DWORD miniz_oxide::inflate::core::REVERSED_BITS_LOOKUP[1024] =
{
  0,
  2147483648,
  1073741824,
  -1073741824,
  536870912,
  -1610612736,
  1610612736,
  -536870912,
  268435456,
  -1879048192,
  1342177280,
  -805306368,
  805306368,
  -1342177280,
  1879048192,
  -268435456,
  134217728,
  -2013265920,
  1207959552,
  -939524096,
  671088640,
  -1476395008,
  1744830464,
  -402653184,
  402653184,
  -1744830464,
  1476395008,
  -671088640,
  939524096,
  -1207959552,
  2013265920,
  -134217728,
  67108864,
  -2080374784,
  1140850688,
  -1006632960,
  603979776,
  -1543503872,
  1677721600,
  -469762048,
  335544320,
  -1811939328,
  1409286144,
  -738197504,
  872415232,
  -1275068416,
  1946157056,
  -201326592,
  201326592,
  -1946157056,
  1275068416,
  -872415232,
  738197504,
  -1409286144,
  1811939328,
  -335544320,
  469762048,
  -1677721600,
  1543503872,
  -603979776,
  1006632960,
  -1140850688,
  2080374784,
  -67108864,
  33554432,
  -2113929216,
  1107296256,
  -1040187392,
  570425344,
  -1577058304,
  1644167168,
  -503316480,
  301989888,
  -1845493760,
  1375731712,
  -771751936,
  838860800,
  -1308622848,
  1912602624,
  -234881024,
  167772160,
  -1979711488,
  1241513984,
  -905969664,
  704643072,
  -1442840576,
  1778384896,
  -369098752,
  436207616,
  -1711276032,
  1509949440,
  -637534208,
  973078528,
  -1174405120,
  2046820352,
  -100663296,
  100663296,
  -2046820352,
  1174405120,
  -973078528,
  637534208,
  -1509949440,
  1711276032,
  -436207616,
  369098752,
  -1778384896,
  1442840576,
  -704643072,
  905969664,
  -1241513984,
  1979711488,
  -167772160,
  234881024,
  -1912602624,
  1308622848,
  -838860800,
  771751936,
  -1375731712,
  1845493760,
  -301989888,
  503316480,
  -1644167168,
  1577058304,
  -570425344,
  1040187392,
  -1107296256,
  2113929216,
  -33554432,
  16777216,
  -2130706432,
  1090519040,
  -1056964608,
  553648128,
  -1593835520,
  1627389952,
  -520093696,
  285212672,
  -1862270976,
  1358954496,
  -788529152,
  822083584,
  -1325400064,
  1895825408,
  -251658240,
  150994944,
  -1996488704,
  1224736768,
  -922746880,
  687865856,
  -1459617792,
  1761607680,
  -385875968,
  419430400,
  -1728053248,
  1493172224,
  -654311424,
  956301312,
  -1191182336,
  2030043136,
  -117440512,
  83886080,
  -2063597568,
  1157627904,
  -989855744,
  620756992,
  -1526726656,
  1694498816,
  -452984832,
  352321536,
  -1795162112,
  1426063360,
  -721420288,
  889192448,
  -1258291200,
  1962934272,
  -184549376,
  218103808,
  -1929379840,
  1291845632,
  -855638016,
  754974720,
  -1392508928,
  1828716544,
  -318767104,
  486539264,
  -1660944384,
  1560281088,
  -587202560,
  1023410176,
  -1124073472,
  2097152000,
  -50331648,
  50331648,
  -2097152000,
  1124073472,
  -1023410176,
  587202560,
  -1560281088,
  1660944384,
  -486539264,
  318767104,
  -1828716544,
  1392508928,
  -754974720,
  855638016,
  -1291845632,
  1929379840,
  -218103808,
  184549376,
  -1962934272,
  1258291200,
  -889192448,
  721420288,
  -1426063360,
  1795162112,
  -352321536,
  452984832,
  -1694498816,
  1526726656,
  -620756992,
  989855744,
  -1157627904,
  2063597568,
  -83886080,
  117440512,
  -2030043136,
  1191182336,
  -956301312,
  654311424,
  -1493172224,
  1728053248,
  -419430400,
  385875968,
  -1761607680,
  1459617792,
  -687865856,
  922746880,
  -1224736768,
  1996488704,
  -150994944,
  251658240,
  -1895825408,
  1325400064,
  -822083584,
  788529152,
  -1358954496,
  1862270976,
  -285212672,
  520093696,
  -1627389952,
  1593835520,
  -553648128,
  1056964608,
  -1090519040,
  2130706432,
  -16777216,
  8388608,
  -2139095040,
  1082130432,
  -1065353216,
  545259520,
  -1602224128,
  1619001344,
  -528482304,
  276824064,
  -1870659584,
  1350565888,
  -796917760,
  813694976,
  -1333788672,
  1887436800,
  -260046848,
  142606336,
  -2004877312,
  1216348160,
  -931135488,
  679477248,
  -1468006400,
  1753219072,
  -394264576,
  411041792,
  -1736441856,
  1484783616,
  -662700032,
  947912704,
  -1199570944,
  2021654528,
  -125829120,
  75497472,
  -2071986176,
  1149239296,
  -998244352,
  612368384,
  -1535115264,
  1686110208,
  -461373440,
  343932928,
  -1803550720,
  1417674752,
  -729808896,
  880803840,
  -1266679808,
  1954545664,
  -192937984,
  209715200,
  -1937768448,
  1283457024,
  -864026624,
  746586112,
  -1400897536,
  1820327936,
  -327155712,
  478150656,
  -1669332992,
  1551892480,
  -595591168,
  1015021568,
  -1132462080,
  2088763392,
  -58720256,
  41943040,
  -2105540608,
  1115684864,
  -1031798784,
  578813952,
  -1568669696,
  1652555776,
  -494927872,
  310378496,
  -1837105152,
  1384120320,
  -763363328,
  847249408,
  -1300234240,
  1920991232,
  -226492416,
  176160768,
  -1971322880,
  1249902592,
  -897581056,
  713031680,
  -1434451968,
  1786773504,
  -360710144,
  444596224,
  -1702887424,
  1518338048,
  -629145600,
  981467136,
  -1166016512,
  2055208960,
  -92274688,
  109051904,
  -2038431744,
  1182793728,
  -964689920,
  645922816,
  -1501560832,
  1719664640,
  -427819008,
  377487360,
  -1769996288,
  1451229184,
  -696254464,
  914358272,
  -1233125376,
  1988100096,
  -159383552,
  243269632,
  -1904214016,
  1317011456,
  -830472192,
  780140544,
  -1367343104,
  1853882368,
  -293601280,
  511705088,
  -1635778560,
  1585446912,
  -562036736,
  1048576000,
  -1098907648,
  2122317824,
  -25165824,
  25165824,
  -2122317824,
  1098907648,
  -1048576000,
  562036736,
  -1585446912,
  1635778560,
  -511705088,
  293601280,
  -1853882368,
  1367343104,
  -780140544,
  830472192,
  -1317011456,
  1904214016,
  -243269632,
  159383552,
  -1988100096,
  1233125376,
  -914358272,
  696254464,
  -1451229184,
  1769996288,
  -377487360,
  427819008,
  -1719664640,
  1501560832,
  -645922816,
  964689920,
  -1182793728,
  2038431744,
  -109051904,
  92274688,
  -2055208960,
  1166016512,
  -981467136,
  629145600,
  -1518338048,
  1702887424,
  -444596224,
  360710144,
  -1786773504,
  1434451968,
  -713031680,
  897581056,
  -1249902592,
  1971322880,
  -176160768,
  226492416,
  -1920991232,
  1300234240,
  -847249408,
  763363328,
  -1384120320,
  1837105152,
  -310378496,
  494927872,
  -1652555776,
  1568669696,
  -578813952,
  1031798784,
  -1115684864,
  2105540608,
  -41943040,
  58720256,
  -2088763392,
  1132462080,
  -1015021568,
  595591168,
  -1551892480,
  1669332992,
  -478150656,
  327155712,
  -1820327936,
  1400897536,
  -746586112,
  864026624,
  -1283457024,
  1937768448,
  -209715200,
  192937984,
  -1954545664,
  1266679808,
  -880803840,
  729808896,
  -1417674752,
  1803550720,
  -343932928,
  461373440,
  -1686110208,
  1535115264,
  -612368384,
  998244352,
  -1149239296,
  2071986176,
  -75497472,
  125829120,
  -2021654528,
  1199570944,
  -947912704,
  662700032,
  -1484783616,
  1736441856,
  -411041792,
  394264576,
  -1753219072,
  1468006400,
  -679477248,
  931135488,
  -1216348160,
  2004877312,
  -142606336,
  260046848,
  -1887436800,
  1333788672,
  -813694976,
  796917760,
  -1350565888,
  1870659584,
  -276824064,
  528482304,
  -1619001344,
  1602224128,
  -545259520,
  1065353216,
  -1082130432,
  2139095040,
  -8388608,
  4194304,
  -2143289344,
  1077936128,
  -1069547520,
  541065216,
  -1606418432,
  1614807040,
  -532676608,
  272629760,
  -1874853888,
  1346371584,
  -801112064,
  809500672,
  -1337982976,
  1883242496,
  -264241152,
  138412032,
  -2009071616,
  1212153856,
  -935329792,
  675282944,
  -1472200704,
  1749024768,
  -398458880,
  406847488,
  -1740636160,
  1480589312,
  -666894336,
  943718400,
  -1203765248,
  2017460224,
  -130023424,
  71303168,
  -2076180480,
  1145044992,
  -1002438656,
  608174080,
  -1539309568,
  1681915904,
  -465567744,
  339738624,
  -1807745024,
  1413480448,
  -734003200,
  876609536,
  -1270874112,
  1950351360,
  -197132288,
  205520896,
  -1941962752,
  1279262720,
  -868220928,
  742391808,
  -1405091840,
  1816133632,
  -331350016,
  473956352,
  -1673527296,
  1547698176,
  -599785472,
  1010827264,
  -1136656384,
  2084569088,
  -62914560,
  37748736,
  -2109734912,
  1111490560,
  -1035993088,
  574619648,
  -1572864000,
  1648361472,
  -499122176,
  306184192,
  -1841299456,
  1379926016,
  -767557632,
  843055104,
  -1304428544,
  1916796928,
  -230686720,
  171966464,
  -1975517184,
  1245708288,
  -901775360,
  708837376,
  -1438646272,
  1782579200,
  -364904448,
  440401920,
  -1707081728,
  1514143744,
  -633339904,
  977272832,
  -1170210816,
  2051014656,
  -96468992,
  104857600,
  -2042626048,
  1178599424,
  -968884224,
  641728512,
  -1505755136,
  1715470336,
  -432013312,
  373293056,
  -1774190592,
  1447034880,
  -700448768,
  910163968,
  -1237319680,
  1983905792,
  -163577856,
  239075328,
  -1908408320,
  1312817152,
  -834666496,
  775946240,
  -1371537408,
  1849688064,
  -297795584,
  507510784,
  -1639972864,
  1581252608,
  -566231040,
  1044381696,
  -1103101952,
  2118123520,
  -29360128,
  20971520,
  -2126512128,
  1094713344,
  -1052770304,
  557842432,
  -1589641216,
  1631584256,
  -515899392,
  289406976,
  -1858076672,
  1363148800,
  -784334848,
  826277888,
  -1321205760,
  1900019712,
  -247463936,
  155189248,
  -1992294400,
  1228931072,
  -918552576,
  692060160,
  -1455423488,
  1765801984,
  -381681664,
  423624704,
  -1723858944,
  1497366528,
  -650117120,
  960495616,
  -1186988032,
  2034237440,
  -113246208,
  88080384,
  -2059403264,
  1161822208,
  -985661440,
  624951296,
  -1522532352,
  1698693120,
  -448790528,
  356515840,
  -1790967808,
  1430257664,
  -717225984,
  893386752,
  -1254096896,
  1967128576,
  -180355072,
  222298112,
  -1925185536,
  1296039936,
  -851443712,
  759169024,
  -1388314624,
  1832910848,
  -314572800,
  490733568,
  -1656750080,
  1564475392,
  -583008256,
  1027604480,
  -1119879168,
  2101346304,
  -46137344,
  54525952,
  -2092957696,
  1128267776,
  -1019215872,
  591396864,
  -1556086784,
  1665138688,
  -482344960,
  322961408,
  -1824522240,
  1396703232,
  -750780416,
  859832320,
  -1287651328,
  1933574144,
  -213909504,
  188743680,
  -1958739968,
  1262485504,
  -884998144,
  725614592,
  -1421869056,
  1799356416,
  -348127232,
  457179136,
  -1690304512,
  1530920960,
  -616562688,
  994050048,
  -1153433600,
  2067791872,
  -79691776,
  121634816,
  -2025848832,
  1195376640,
  -952107008,
  658505728,
  -1488977920,
  1732247552,
  -415236096,
  390070272,
  -1757413376,
  1463812096,
  -683671552,
  926941184,
  -1220542464,
  2000683008,
  -146800640,
  255852544,
  -1891631104,
  1329594368,
  -817889280,
  792723456,
  -1354760192,
  1866465280,
  -281018368,
  524288000,
  -1623195648,
  1598029824,
  -549453824,
  1061158912,
  -1086324736,
  2134900736,
  -12582912,
  12582912,
  -2134900736,
  1086324736,
  -1061158912,
  549453824,
  -1598029824,
  1623195648,
  -524288000,
  281018368,
  -1866465280,
  1354760192,
  -792723456,
  817889280,
  -1329594368,
  1891631104,
  -255852544,
  146800640,
  -2000683008,
  1220542464,
  -926941184,
  683671552,
  -1463812096,
  1757413376,
  -390070272,
  415236096,
  -1732247552,
  1488977920,
  -658505728,
  952107008,
  -1195376640,
  2025848832,
  -121634816,
  79691776,
  -2067791872,
  1153433600,
  -994050048,
  616562688,
  -1530920960,
  1690304512,
  -457179136,
  348127232,
  -1799356416,
  1421869056,
  -725614592,
  884998144,
  -1262485504,
  1958739968,
  -188743680,
  213909504,
  -1933574144,
  1287651328,
  -859832320,
  750780416,
  -1396703232,
  1824522240,
  -322961408,
  482344960,
  -1665138688,
  1556086784,
  -591396864,
  1019215872,
  -1128267776,
  2092957696,
  -54525952,
  46137344,
  -2101346304,
  1119879168,
  -1027604480,
  583008256,
  -1564475392,
  1656750080,
  -490733568,
  314572800,
  -1832910848,
  1388314624,
  -759169024,
  851443712,
  -1296039936,
  1925185536,
  -222298112,
  180355072,
  -1967128576,
  1254096896,
  -893386752,
  717225984,
  -1430257664,
  1790967808,
  -356515840,
  448790528,
  -1698693120,
  1522532352,
  -624951296,
  985661440,
  -1161822208,
  2059403264,
  -88080384,
  113246208,
  -2034237440,
  1186988032,
  -960495616,
  650117120,
  -1497366528,
  1723858944,
  -423624704,
  381681664,
  -1765801984,
  1455423488,
  -692060160,
  918552576,
  -1228931072,
  1992294400,
  -155189248,
  247463936,
  -1900019712,
  1321205760,
  -826277888,
  784334848,
  -1363148800,
  1858076672,
  -289406976,
  515899392,
  -1631584256,
  1589641216,
  -557842432,
  1052770304,
  -1094713344,
  2126512128,
  -20971520,
  29360128,
  -2118123520,
  1103101952,
  -1044381696,
  566231040,
  -1581252608,
  1639972864,
  -507510784,
  297795584,
  -1849688064,
  1371537408,
  -775946240,
  834666496,
  -1312817152,
  1908408320,
  -239075328,
  163577856,
  -1983905792,
  1237319680,
  -910163968,
  700448768,
  -1447034880,
  1774190592,
  -373293056,
  432013312,
  -1715470336,
  1505755136,
  -641728512,
  968884224,
  -1178599424,
  2042626048,
  -104857600,
  96468992,
  -2051014656,
  1170210816,
  -977272832,
  633339904,
  -1514143744,
  1707081728,
  -440401920,
  364904448,
  -1782579200,
  1438646272,
  -708837376,
  901775360,
  -1245708288,
  1975517184,
  -171966464,
  230686720,
  -1916796928,
  1304428544,
  -843055104,
  767557632,
  -1379926016,
  1841299456,
  -306184192,
  499122176,
  -1648361472,
  1572864000,
  -574619648,
  1035993088,
  -1111490560,
  2109734912,
  -37748736,
  62914560,
  -2084569088,
  1136656384,
  -1010827264,
  599785472,
  -1547698176,
  1673527296,
  -473956352,
  331350016,
  -1816133632,
  1405091840,
  -742391808,
  868220928,
  -1279262720,
  1941962752,
  -205520896,
  197132288,
  -1950351360,
  1270874112,
  -876609536,
  734003200,
  -1413480448,
  1807745024,
  -339738624,
  465567744,
  -1681915904,
  1539309568,
  -608174080,
  1002438656,
  -1145044992,
  2076180480,
  -71303168,
  130023424,
  -2017460224,
  1203765248,
  -943718400,
  666894336,
  -1480589312,
  1740636160,
  -406847488,
  398458880,
  -1749024768,
  1472200704,
  -675282944,
  935329792,
  -1212153856,
  2009071616,
  -138412032,
  264241152,
  -1883242496,
  1337982976,
  -809500672,
  801112064,
  -1346371584,
  1874853888,
  -272629760,
  532676608,
  -1614807040,
  1606418432,
  -541065216,
  1069547520,
  -1077936128,
  2143289344,
  -4194304
}; // weak
unsigned __int16 word_4C4DE[32] =
{
  3u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  10u,
  11u,
  13u,
  15u,
  17u,
  19u,
  23u,
  27u,
  31u,
  35u,
  43u,
  51u,
  59u,
  67u,
  83u,
  99u,
  115u,
  131u,
  163u,
  195u,
  227u,
  258u,
  512u,
  512u,
  512u
}; // weak
unsigned __int16 word_4C51E[32] =
{
  1u,
  2u,
  3u,
  4u,
  5u,
  7u,
  9u,
  13u,
  17u,
  25u,
  33u,
  49u,
  65u,
  97u,
  129u,
  193u,
  257u,
  385u,
  513u,
  769u,
  1025u,
  1537u,
  2049u,
  3073u,
  4097u,
  6145u,
  8193u,
  12289u,
  16385u,
  24577u,
  32768u,
  32768u
}; // weak
unsigned __int16 word_4C55E[3] = { 257u, 1u, 4u }; // weak
unsigned __int8 byte_4C564[28] =
{
  16u,
  17u,
  18u,
  0u,
  8u,
  7u,
  9u,
  6u,
  10u,
  5u,
  11u,
  4u,
  12u,
  3u,
  13u,
  2u,
  14u,
  1u,
  15u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
__int128 xmmword_4C580 = 0x80078071800780718007807180078071LL; // weak
__int128 xmmword_4C590 = 0xFFF10000FFF10000FFF10000FFF1LL; // weak
char aCalledResultUn_0[43] = "called `Result::unwrap()` on an `Err` value"; // weak
__int128 xmmword_4C660 = 0xFEFEFEFEFEFEFEFFFEFEFEFEFEFEFEFFLL; // weak
__int128 xmmword_4C670 = 0xA0A0A0A0A0A0A0A0A0A0A0A0A0A0A0ALL; // weak
__int128 xmmword_4C680 = 49087LL; // weak
__int128 xmmword_4C690 = 0x10000000000000001LL; // weak
__int128 xmmword_4C6A0 = 0x1010101010101010101010101010101LL; // weak
__int128 xmmword_4C6B0 = 0xFFFD05E2FFFD141FFFFD315EFFFD48C6LL; // weak
__int128 xmmword_4C6C0 = 0x80000000800000008000000080000000LL; // weak
__int128 xmmword_4C6D0 = 0x800005E180000C1E8000000D80000005LL; // weak
char a0123456789abcd[32] = "0123456789abcdefalready borrowed"; // weak
_UNKNOWN unk_4C798; // weak
_UNKNOWN unk_4C8A8; // weak
char asc_4C91A = ')'; // weak
char asc_4C91B[2] = ".."; // weak
char aBorrowmuterror[14] = "BorrowMutError"; // weak
char asc_4C9BE = '['; // weak
char aCalledOptionUn[43] = "called `Option::unwrap()` on a `None` value"; // weak
char aPanickedAt_0[12] = "panicked at "; // weak
char asc_4C9F6[2] = ":\n"; // weak
char aPanicInAFuncti[38] = "panic in a function that cannot unwind"; // weak
char aPanicInADestru[36] = "panic in a destructor during cleanup"; // weak
_UNKNOWN unk_4CA71; // weak
_UNKNOWN unk_4CA73; // weak
_UNKNOWN unk_4CA75; // weak
char asc_4CAA5[2] = ": "; // weak
_UNKNOWN unk_4CAA7; // weak
_UNKNOWN unk_4CAAA; // weak
char asc_4CAAC[3] = " {\n"; // weak
char asc_4CAAF[2] = ",\n"; // weak
char asc_4CAB1 = '}'; // weak
char asc_4CAB2[2] = " }"; // weak
_UNKNOWN unk_4CAB4; // weak
char asc_4CAB5[2] = "(\n"; // weak
char asc_4CAB7 = ','; // weak
_UNKNOWN unk_4CAB8; // weak
char asc_4CAB9 = ']'; // weak
char a0x_0[2] = "0x"; // weak
_WORD word_4CAD7[100] =
{
  12336,
  12592,
  12848,
  13104,
  13360,
  13616,
  13872,
  14128,
  14384,
  14640,
  12337,
  12593,
  12849,
  13105,
  13361,
  13617,
  13873,
  14129,
  14385,
  14641,
  12338,
  12594,
  12850,
  13106,
  13362,
  13618,
  13874,
  14130,
  14386,
  14642,
  12339,
  12595,
  12851,
  13107,
  13363,
  13619,
  13875,
  14131,
  14387,
  14643,
  12340,
  12596,
  12852,
  13108,
  13364,
  13620,
  13876,
  14132,
  14388,
  14644,
  12341,
  12597,
  12853,
  13109,
  13365,
  13621,
  13877,
  14133,
  14389,
  14645,
  12342,
  12598,
  12854,
  13110,
  13366,
  13622,
  13878,
  14134,
  14390,
  14646,
  12343,
  12599,
  12855,
  13111,
  13367,
  13623,
  13879,
  14135,
  14391,
  14647,
  12344,
  12600,
  12856,
  13112,
  13368,
  13624,
  13880,
  14136,
  14392,
  14648,
  12345,
  12601,
  12857,
  13113,
  13369,
  13625,
  13881,
  14137,
  14393,
  14649
}; // weak
unsigned __int8 byte_4CC8C[256] =
{
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
char byte_4CDAB = '\0'; // weak
char asc_4CDAC[5] = "[...]"; // weak
_BYTE byte_4CE4D[88] =
{
  0,
  6,
  1,
  1,
  3,
  1,
  4,
  2,
  5,
  7,
  7,
  2,
  8,
  8,
  9,
  2,
  10,
  5,
  11,
  2,
  14,
  4,
  16,
  1,
  17,
  2,
  18,
  5,
  19,
  17,
  20,
  1,
  21,
  2,
  23,
  2,
  25,
  13,
  28,
  5,
  29,
  8,
  31,
  1,
  36,
  1,
  106,
  4,
  107,
  2,
  -81,
  3,
  -79,
  2,
  -68,
  2,
  -49,
  2,
  -47,
  2,
  -44,
  12,
  -43,
  9,
  -42,
  2,
  -41,
  2,
  -38,
  1,
  -32,
  5,
  -31,
  2,
  -25,
  4,
  -24,
  2,
  -18,
  32,
  -16,
  4,
  -8,
  2,
  -6,
  3,
  -5,
  1
}; // weak
char aNo[196] = "\f';>NO\x8F\x9E\x9E\x9F{\x8B\x93\x96\xA2\xB2\xBA\x86\xB1\x06\a\t6=>V\xF3\xD0\xD1\x04\x14\x1867VW\x7F\xAA\xAE\xAF\xBD5\xE0\x12\x87\x89\x8E\x9E\x04\r\x0E\x11\x12)14:EFIJNOde\\\xB6\xB7\x1B\x1C\a\b\n\v\x14\x1769:\xA8\xA9\xD8\xD9\t7\x90\x91\xA8\a\n;>fi\x8F\x92\x11o_\xBF\xEE\xEF\x5Ab\xF4\xFC\xFF\x53T\x9A\x9B./'(U\x9D\xA0\xA1\xA3\xA4\xA7\xA8\xAD\xBA\xBC\xC4\x06\v\f\x15\x1D:?EQ\xA6\xA7\xCC\xCD\xA0\a\x19\x1A\"%>?\xE7\xEC\xEF\xFF\xC5\xC6\x04 #%&(38:HJLPSUVXZ\\^`cefksx}\x7F\x8A\xA4\xAA\xAF\xB0\xC0\xD0\xAE\xAFno\xBE\x93"; // weak
unsigned __int8 byte_4CF69[450] =
{
  94u,
  34u,
  123u,
  5u,
  3u,
  4u,
  45u,
  3u,
  102u,
  3u,
  1u,
  47u,
  46u,
  128u,
  130u,
  29u,
  3u,
  49u,
  15u,
  28u,
  4u,
  36u,
  9u,
  30u,
  5u,
  43u,
  5u,
  68u,
  4u,
  14u,
  42u,
  128u,
  170u,
  6u,
  36u,
  4u,
  36u,
  4u,
  40u,
  8u,
  52u,
  11u,
  78u,
  67u,
  129u,
  55u,
  9u,
  22u,
  10u,
  8u,
  24u,
  59u,
  69u,
  57u,
  3u,
  99u,
  8u,
  9u,
  48u,
  22u,
  5u,
  33u,
  3u,
  27u,
  5u,
  1u,
  64u,
  56u,
  4u,
  75u,
  5u,
  47u,
  4u,
  10u,
  7u,
  9u,
  7u,
  64u,
  32u,
  39u,
  4u,
  12u,
  9u,
  54u,
  3u,
  58u,
  5u,
  26u,
  7u,
  4u,
  12u,
  7u,
  80u,
  73u,
  55u,
  51u,
  13u,
  51u,
  7u,
  46u,
  8u,
  10u,
  129u,
  38u,
  82u,
  75u,
  43u,
  8u,
  42u,
  22u,
  26u,
  38u,
  28u,
  20u,
  23u,
  9u,
  78u,
  4u,
  36u,
  9u,
  68u,
  13u,
  25u,
  7u,
  10u,
  6u,
  72u,
  8u,
  39u,
  9u,
  117u,
  11u,
  66u,
  62u,
  42u,
  6u,
  59u,
  5u,
  10u,
  6u,
  81u,
  6u,
  1u,
  5u,
  16u,
  3u,
  5u,
  128u,
  139u,
  98u,
  30u,
  72u,
  8u,
  10u,
  128u,
  166u,
  94u,
  34u,
  69u,
  11u,
  10u,
  6u,
  13u,
  19u,
  58u,
  6u,
  10u,
  54u,
  44u,
  4u,
  23u,
  128u,
  185u,
  60u,
  100u,
  83u,
  12u,
  72u,
  9u,
  10u,
  70u,
  69u,
  27u,
  72u,
  8u,
  83u,
  13u,
  73u,
  7u,
  10u,
  128u,
  246u,
  70u,
  10u,
  29u,
  3u,
  71u,
  73u,
  55u,
  3u,
  14u,
  8u,
  10u,
  6u,
  57u,
  7u,
  10u,
  129u,
  54u,
  25u,
  7u,
  59u,
  3u,
  28u,
  86u,
  1u,
  15u,
  50u,
  13u,
  131u,
  155u,
  102u,
  117u,
  11u,
  128u,
  196u,
  138u,
  76u,
  99u,
  13u,
  132u,
  48u,
  16u,
  22u,
  143u,
  170u,
  130u,
  71u,
  161u,
  185u,
  130u,
  57u,
  7u,
  42u,
  4u,
  92u,
  6u,
  38u,
  10u,
  70u,
  10u,
  40u,
  5u,
  19u,
  130u,
  176u,
  91u,
  101u,
  75u,
  4u,
  57u,
  7u,
  17u,
  64u,
  5u,
  11u,
  2u,
  14u,
  151u,
  248u,
  8u,
  132u,
  214u,
  42u,
  9u,
  162u,
  231u,
  129u,
  51u,
  15u,
  1u,
  29u,
  6u,
  14u,
  4u,
  8u,
  129u,
  140u,
  137u,
  4u,
  107u,
  5u,
  13u,
  3u,
  9u,
  7u,
  16u,
  146u,
  96u,
  71u,
  9u,
  116u,
  60u,
  128u,
  246u,
  10u,
  115u,
  8u,
  112u,
  21u,
  70u,
  122u,
  20u,
  12u,
  20u,
  12u,
  87u,
  9u,
  25u,
  128u,
  135u,
  129u,
  71u,
  3u,
  133u,
  66u,
  15u,
  21u,
  132u,
  80u,
  31u,
  6u,
  6u,
  128u,
  213u,
  43u,
  5u,
  62u,
  33u,
  1u,
  112u,
  45u,
  3u,
  26u,
  4u,
  2u,
  129u,
  64u,
  31u,
  17u,
  58u,
  5u,
  1u,
  129u,
  208u,
  42u,
  130u,
  230u,
  128u,
  247u,
  41u,
  76u,
  4u,
  10u,
  4u,
  2u,
  131u,
  17u,
  68u,
  76u,
  61u,
  128u,
  194u,
  60u,
  6u,
  1u,
  4u,
  85u,
  5u,
  27u,
  52u,
  2u,
  129u,
  14u,
  44u,
  4u,
  100u,
  12u,
  86u,
  10u,
  128u,
  174u,
  56u,
  29u,
  13u,
  44u,
  4u,
  9u,
  7u,
  2u,
  14u,
  6u,
  128u,
  154u,
  131u,
  216u,
  4u,
  17u,
  3u,
  13u,
  3u,
  119u,
  4u,
  95u,
  6u,
  12u,
  4u,
  1u,
  15u,
  12u,
  4u,
  56u,
  8u,
  10u,
  6u,
  40u,
  8u,
  34u,
  78u,
  129u,
  84u,
  12u,
  29u,
  3u,
  9u,
  7u,
  54u,
  8u,
  14u,
  4u,
  9u,
  7u,
  9u,
  7u,
  128u,
  203u,
  37u,
  10u,
  132u,
  6u
}; // weak
_BYTE byte_4D12B[80] =
{
  0,
  1,
  3,
  5,
  5,
  6,
  6,
  2,
  7,
  6,
  8,
  7,
  9,
  17,
  10,
  28,
  11,
  25,
  12,
  26,
  13,
  16,
  14,
  12,
  15,
  4,
  16,
  3,
  18,
  18,
  19,
  9,
  22,
  1,
  23,
  4,
  24,
  1,
  25,
  3,
  26,
  7,
  27,
  1,
  28,
  2,
  31,
  22,
  32,
  3,
  43,
  3,
  45,
  11,
  46,
  1,
  48,
  3,
  49,
  2,
  50,
  1,
  -89,
  2,
  -87,
  2,
  -86,
  4,
  -85,
  8,
  -6,
  2,
  -5,
  5,
  -3,
  2,
  -2,
  3,
  -1,
  9
}; // weak
char asc_4D17B[287] = "\xADxy\x8B\x8D\xA20WX\x8B\x8C\x90\x1C\xDD\x0E\x0FKL\xFB\xFC./?\\]_ℍ\x8E\x91\x92\xA9\xB1\xBA\xBB\xC5\xC6\xC9\xCA\xDE\xE4\xE5\xFF\x04\x11\x12)147:;=IJ]\x84\x8E\x92\xA9\xB1\xB4\xBA\xBB\xC6\xCA\xCE\xCF\xE4\xE5\x04\r\x0E\x11\x12)14:;EFIJ^de\x84\x91\x9B\x9D\xC9\xCE\xCF\x0D\x11):;EIW[\\^_de\x8D\x91\xA9\xB4\xBA\xBB\xC5\xC9\xDF\xE4\xE5\xF0\x0D\x11EIde\x80\x84\xB2\xBC\xBE\xBF\xD5\xD7\xF0\xF1\x83\x85\x8B\xA4\xA6\xBE\xBF\xC5\xC7\xCF\xDA\xDB\x48\x98\xBD\xCD\xC6\xCE\xCFINOWY^_\x89\x8E\x8F\xB1\xB6\xB7\xBF\xC1\xC6\xC7\xD7\x11\x16\x17[\\\xF6\xF7\xFE\xFF\x80mq\xDE\xDF\x0E\x1Fno\x1C\x1D_}~\xAE\xAF\x7F\xBB\xBC\x16\x17\x1E\x1FFGNOXZ\\^~\x7F\xB5\xC5\xD4\xD5\xDC\xF0\xF1\xF5\x72s\x8Ftu\x96&./\xA7\xAF\xB7\xBF\xC7\xCF\xD7\xDF\x9A@\x97\x980\x8F\x1F\xD2\xD4\xCE\xFFNOZ[\a\b\x0F\x10'/\xEE\xEF\x6Eo7=?BE\x90\x91Sgu\xC8\xC9\xD0\xD1\xD8\xD9\xE7\xFE\xFF"; // weak
unsigned __int8 byte_4D29A[303] =
{
  0u,
  32u,
  95u,
  34u,
  130u,
  223u,
  4u,
  130u,
  68u,
  8u,
  27u,
  4u,
  6u,
  17u,
  129u,
  172u,
  14u,
  128u,
  171u,
  5u,
  31u,
  9u,
  129u,
  27u,
  3u,
  25u,
  8u,
  1u,
  4u,
  47u,
  4u,
  52u,
  4u,
  7u,
  3u,
  1u,
  7u,
  6u,
  7u,
  17u,
  10u,
  80u,
  15u,
  18u,
  7u,
  85u,
  7u,
  3u,
  4u,
  28u,
  10u,
  9u,
  3u,
  8u,
  3u,
  7u,
  3u,
  2u,
  3u,
  3u,
  3u,
  12u,
  4u,
  5u,
  3u,
  11u,
  6u,
  1u,
  14u,
  21u,
  5u,
  78u,
  7u,
  27u,
  7u,
  87u,
  7u,
  2u,
  6u,
  23u,
  12u,
  80u,
  4u,
  67u,
  3u,
  45u,
  3u,
  1u,
  4u,
  17u,
  6u,
  15u,
  12u,
  58u,
  4u,
  29u,
  37u,
  95u,
  32u,
  109u,
  4u,
  106u,
  37u,
  128u,
  200u,
  5u,
  130u,
  176u,
  3u,
  26u,
  6u,
  130u,
  253u,
  3u,
  89u,
  7u,
  22u,
  9u,
  24u,
  9u,
  20u,
  12u,
  20u,
  12u,
  106u,
  6u,
  10u,
  6u,
  26u,
  6u,
  89u,
  7u,
  43u,
  5u,
  70u,
  10u,
  44u,
  4u,
  12u,
  4u,
  1u,
  3u,
  49u,
  11u,
  44u,
  4u,
  26u,
  6u,
  11u,
  3u,
  128u,
  172u,
  6u,
  10u,
  6u,
  47u,
  49u,
  77u,
  3u,
  128u,
  164u,
  8u,
  60u,
  3u,
  15u,
  3u,
  60u,
  7u,
  56u,
  8u,
  43u,
  5u,
  130u,
  255u,
  17u,
  24u,
  8u,
  47u,
  17u,
  45u,
  3u,
  33u,
  15u,
  33u,
  15u,
  128u,
  140u,
  4u,
  130u,
  151u,
  25u,
  11u,
  21u,
  136u,
  148u,
  5u,
  47u,
  5u,
  59u,
  7u,
  2u,
  14u,
  24u,
  9u,
  128u,
  190u,
  34u,
  116u,
  12u,
  128u,
  214u,
  26u,
  12u,
  5u,
  128u,
  255u,
  5u,
  128u,
  223u,
  12u,
  242u,
  157u,
  3u,
  55u,
  9u,
  129u,
  92u,
  20u,
  128u,
  184u,
  8u,
  128u,
  203u,
  5u,
  10u,
  24u,
  59u,
  3u,
  10u,
  6u,
  56u,
  8u,
  70u,
  8u,
  12u,
  6u,
  116u,
  11u,
  30u,
  3u,
  90u,
  4u,
  89u,
  9u,
  128u,
  131u,
  24u,
  28u,
  10u,
  22u,
  9u,
  76u,
  4u,
  128u,
  138u,
  6u,
  171u,
  164u,
  12u,
  23u,
  4u,
  49u,
  161u,
  4u,
  129u,
  218u,
  38u,
  7u,
  12u,
  5u,
  5u,
  128u,
  166u,
  16u,
  129u,
  245u,
  7u,
  1u,
  32u,
  42u,
  6u,
  76u,
  4u,
  128u,
  141u,
  4u,
  128u,
  190u,
  3u,
  27u,
  3u,
  15u,
  13u
}; // weak
_DWORD core::unicode::unicode_data::grapheme_extend::SHORT_OFFSET_RUNS[33] =
{
  768,
  2098307,
  6292881,
  10490717,
  522196754,
  526393356,
  731917551,
  740306986,
  752920175,
  761309186,
  778107678,
  908131840,
  912326558,
  920715773,
  924912129,
  937495844,
  962662059,
  966858799,
  1214323760,
  1285627635,
  1348547648,
  1369533168,
  1377922895,
  1386331293,
  1398918912,
  1403113829,
  1411504640,
  1440866304,
  1466032814,
  1495393516,
  1503783120,
  1508769824,
  1518273008
}; // weak
unsigned __int8 core::unicode::unicode_data::grapheme_extend::OFFSETS[727] =
{
  0u,
  112u,
  0u,
  7u,
  0u,
  45u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  72u,
  11u,
  48u,
  21u,
  16u,
  1u,
  101u,
  7u,
  2u,
  6u,
  2u,
  2u,
  1u,
  4u,
  35u,
  1u,
  30u,
  27u,
  91u,
  11u,
  58u,
  9u,
  9u,
  1u,
  24u,
  4u,
  1u,
  9u,
  1u,
  3u,
  1u,
  5u,
  43u,
  3u,
  60u,
  8u,
  42u,
  24u,
  1u,
  32u,
  55u,
  1u,
  1u,
  1u,
  4u,
  8u,
  4u,
  1u,
  3u,
  7u,
  10u,
  2u,
  29u,
  1u,
  58u,
  1u,
  1u,
  1u,
  2u,
  4u,
  8u,
  1u,
  9u,
  1u,
  10u,
  2u,
  26u,
  1u,
  2u,
  2u,
  57u,
  1u,
  4u,
  2u,
  4u,
  2u,
  2u,
  3u,
  3u,
  1u,
  30u,
  2u,
  3u,
  1u,
  11u,
  2u,
  57u,
  1u,
  4u,
  5u,
  1u,
  2u,
  4u,
  1u,
  20u,
  2u,
  22u,
  6u,
  1u,
  1u,
  58u,
  1u,
  1u,
  2u,
  1u,
  4u,
  8u,
  1u,
  7u,
  3u,
  10u,
  2u,
  30u,
  1u,
  59u,
  1u,
  1u,
  1u,
  12u,
  1u,
  9u,
  1u,
  40u,
  1u,
  3u,
  1u,
  55u,
  1u,
  1u,
  3u,
  5u,
  3u,
  1u,
  4u,
  7u,
  2u,
  11u,
  2u,
  29u,
  1u,
  58u,
  1u,
  2u,
  1u,
  2u,
  1u,
  3u,
  1u,
  5u,
  2u,
  7u,
  2u,
  11u,
  2u,
  28u,
  2u,
  57u,
  2u,
  1u,
  1u,
  2u,
  4u,
  8u,
  1u,
  9u,
  1u,
  10u,
  2u,
  29u,
  1u,
  72u,
  1u,
  4u,
  1u,
  2u,
  3u,
  1u,
  1u,
  8u,
  1u,
  81u,
  1u,
  2u,
  7u,
  12u,
  8u,
  98u,
  1u,
  2u,
  9u,
  11u,
  7u,
  73u,
  2u,
  27u,
  1u,
  1u,
  1u,
  1u,
  1u,
  55u,
  14u,
  1u,
  5u,
  1u,
  2u,
  5u,
  11u,
  1u,
  36u,
  9u,
  1u,
  102u,
  4u,
  1u,
  6u,
  1u,
  2u,
  2u,
  2u,
  25u,
  2u,
  4u,
  3u,
  16u,
  4u,
  13u,
  1u,
  2u,
  2u,
  6u,
  1u,
  15u,
  1u,
  0u,
  3u,
  0u,
  3u,
  29u,
  2u,
  30u,
  2u,
  30u,
  2u,
  64u,
  2u,
  1u,
  7u,
  8u,
  1u,
  2u,
  11u,
  9u,
  1u,
  45u,
  3u,
  1u,
  1u,
  117u,
  2u,
  34u,
  1u,
  118u,
  3u,
  4u,
  2u,
  9u,
  1u,
  6u,
  3u,
  219u,
  2u,
  2u,
  1u,
  58u,
  1u,
  1u,
  7u,
  1u,
  1u,
  1u,
  1u,
  2u,
  8u,
  6u,
  10u,
  2u,
  1u,
  48u,
  31u,
  49u,
  4u,
  48u,
  7u,
  1u,
  1u,
  5u,
  1u,
  40u,
  9u,
  12u,
  2u,
  32u,
  4u,
  2u,
  2u,
  1u,
  3u,
  56u,
  1u,
  1u,
  2u,
  3u,
  1u,
  1u,
  3u,
  58u,
  8u,
  2u,
  2u,
  152u,
  3u,
  1u,
  13u,
  1u,
  7u,
  4u,
  1u,
  6u,
  1u,
  3u,
  2u,
  198u,
  64u,
  0u,
  1u,
  195u,
  33u,
  0u,
  3u,
  141u,
  1u,
  96u,
  32u,
  0u,
  6u,
  105u,
  2u,
  0u,
  4u,
  1u,
  10u,
  32u,
  2u,
  80u,
  2u,
  0u,
  1u,
  3u,
  1u,
  4u,
  1u,
  25u,
  2u,
  5u,
  1u,
  151u,
  2u,
  26u,
  18u,
  13u,
  1u,
  38u,
  8u,
  25u,
  11u,
  46u,
  3u,
  48u,
  1u,
  2u,
  4u,
  2u,
  2u,
  39u,
  1u,
  67u,
  6u,
  2u,
  2u,
  2u,
  2u,
  12u,
  1u,
  8u,
  1u,
  47u,
  1u,
  51u,
  1u,
  1u,
  3u,
  2u,
  2u,
  5u,
  2u,
  1u,
  1u,
  42u,
  2u,
  8u,
  1u,
  238u,
  1u,
  2u,
  1u,
  4u,
  1u,
  0u,
  1u,
  0u,
  16u,
  16u,
  16u,
  0u,
  2u,
  0u,
  1u,
  226u,
  1u,
  149u,
  5u,
  0u,
  3u,
  1u,
  2u,
  5u,
  4u,
  40u,
  3u,
  4u,
  1u,
  165u,
  2u,
  0u,
  4u,
  0u,
  2u,
  80u,
  3u,
  70u,
  11u,
  49u,
  4u,
  123u,
  1u,
  54u,
  15u,
  41u,
  1u,
  2u,
  2u,
  10u,
  3u,
  49u,
  4u,
  2u,
  2u,
  7u,
  1u,
  61u,
  3u,
  36u,
  5u,
  1u,
  8u,
  62u,
  1u,
  12u,
  2u,
  52u,
  9u,
  10u,
  4u,
  2u,
  1u,
  95u,
  3u,
  2u,
  1u,
  1u,
  2u,
  6u,
  1u,
  2u,
  1u,
  157u,
  1u,
  3u,
  8u,
  21u,
  2u,
  57u,
  2u,
  1u,
  1u,
  1u,
  1u,
  22u,
  1u,
  14u,
  7u,
  3u,
  5u,
  195u,
  8u,
  2u,
  3u,
  1u,
  1u,
  23u,
  1u,
  81u,
  1u,
  2u,
  6u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  2u,
  235u,
  1u,
  2u,
  4u,
  6u,
  2u,
  1u,
  2u,
  27u,
  2u,
  85u,
  8u,
  2u,
  1u,
  1u,
  2u,
  106u,
  1u,
  1u,
  1u,
  2u,
  6u,
  1u,
  1u,
  101u,
  3u,
  2u,
  4u,
  1u,
  5u,
  0u,
  9u,
  1u,
  2u,
  245u,
  1u,
  10u,
  2u,
  1u,
  1u,
  4u,
  1u,
  144u,
  4u,
  2u,
  2u,
  4u,
  1u,
  32u,
  10u,
  40u,
  6u,
  2u,
  4u,
  8u,
  1u,
  9u,
  6u,
  2u,
  3u,
  46u,
  13u,
  1u,
  2u,
  0u,
  7u,
  1u,
  6u,
  1u,
  1u,
  82u,
  22u,
  2u,
  7u,
  1u,
  2u,
  1u,
  2u,
  122u,
  6u,
  3u,
  1u,
  1u,
  2u,
  1u,
  7u,
  1u,
  1u,
  72u,
  2u,
  3u,
  1u,
  1u,
  1u,
  0u,
  2u,
  11u,
  2u,
  52u,
  5u,
  5u,
  1u,
  1u,
  1u,
  0u,
  1u,
  6u,
  15u,
  0u,
  5u,
  59u,
  7u,
  0u,
  1u,
  63u,
  4u,
  81u,
  1u,
  0u,
  2u,
  0u,
  46u,
  2u,
  23u,
  0u,
  1u,
  1u,
  3u,
  4u,
  5u,
  8u,
  8u,
  2u,
  7u,
  30u,
  4u,
  148u,
  3u,
  0u,
  55u,
  4u,
  50u,
  8u,
  1u,
  14u,
  1u,
  22u,
  5u,
  1u,
  15u,
  0u,
  7u,
  1u,
  17u,
  2u,
  7u,
  1u,
  2u,
  1u,
  5u,
  100u,
  1u,
  160u,
  7u,
  0u,
  1u,
  61u,
  4u,
  0u,
  4u,
  0u,
  7u,
  109u,
  7u,
  0u,
  96u,
  128u,
  240u,
  0u
}; // weak
_BYTE core::unicode::unicode_data::white_space::WHITESPACE_MAP[256] =
{
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  2,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int64 (__fastcall *off_580A0)() = &core::ptr::drop_in_place<std::rt::lang_start<()>::{{closure}}>; // weak
__int64 (__fastcall *off_580D0)() = &core::ptr::drop_in_place<std::io::error::Error>; // weak
char *off_580F0 = "Nothing here...\n"; // weak
_UNKNOWN off_58100; // weak
char *off_58110 = "Please enter a valid number.\n"; // weak
char *off_58120 = "Stack is empty!\n"; // weak
char *off_58130 = "Please enter a valid hex value.\n"; // weak
char *off_58140 = "Current state of registers:\n"; // weak
char *off_58150 = "RAX: "; // weak
char *off_58170 = "RBX: "; // weak
char *off_58190 = "RCX: "; // weak
char *off_581B0 = "RDX: "; // weak
char *off_581D0 = "RDI: "; // weak
char *off_581F0 = "RSI: "; // weak
char *off_58210 = "src/main.rs"; // weak
char *off_58228 = "src/main.rs"; // weak
char *off_58240 = "called `Result::unwrap()` on an `Err` value"; // weak
char *off_58260 = "Goodbye 👋\n"; // weak
__int64 (__fastcall *off_58270)() = &core::ptr::drop_in_place<std::io::error::Error>; // weak
char *off_58290 = "called `Result::unwrap()` on an `Err` value"; // weak
char *off_582A0 = "src/lib.rs"; // weak
char *off_582B8 = "src/lib.rs"; // weak
char *off_582D0 = "Index out of bounds"; // weak
__int64 (__fastcall *off_582E0[2])() = { &core::ptr::drop_in_place<alloc::string::String>, &off_18 }; // weak
__int64 (__fastcall *off_58310)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
char *off_58330 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_58348 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_58360 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_58378 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_58390 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_583A8 = "reentrant init"; // weak
char *off_583B8 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/cell/once.rs"; // weak
char *off_583D0 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_583E8 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58400 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58418 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58430 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58448 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58460 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58478 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58490 = "mid > len"; // weak
char *off_584A0 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_584B8 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_584D0 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_584E8 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58500 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58518 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58530 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58548 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58560 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58578 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_58590 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_585A8 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
char *off_585C0 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/sort.rs"; // weak
__int64 (__fastcall *off_585D8)() = &core::ptr::drop_in_place<()>; // weak
__int64 (__fastcall *off_585F8)() = &core::ptr::drop_in_place<()>; // weak
__int64 (__fastcall *off_58618)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
char *off_58638 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/navigate.rs"; // weak
char *off_58650 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/navigate.rs"; // weak
char *off_58668 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/vec/mod.rs"; // weak
char *off_58680 = "/rust/deps/gimli-0.28.1/src/read/line.rs"; // weak
char *off_58698 = "/rust/deps/gimli-0.28.1/src/read/line.rs"; // weak
char *off_586B0 = "/rust/deps/gimli-0.28.1/src/read/line.rs"; // weak
char *off_586C8 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/num/wrapping.rs"; // weak
char *off_586E0 = "/rust/deps/gimli-0.28.1/src/read/line.rs"; // weak
char *off_586F8 = "/rust/deps/gimli-0.28.1/src/read/dwarf.rs"; // weak
char *off_58710 = "/rust/deps/gimli-0.28.1/src/read/index.rs"; // weak
__int64 (__fastcall *off_58728)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
__int64 (__fastcall *off_58748)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
__int64 (__fastcall *off_58768)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
__int64 (__fastcall *off_58788)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
__int64 (__fastcall *off_587A8)() = &core::ptr::drop_in_place<std::io::Write::write_fmt::Adapter<alloc::vec::Vec<u8>>>; // weak
__int64 (__fastcall *off_587D8)() = &core::ptr::drop_in_place<std::io::Write::write_fmt::Adapter<alloc::vec::Vec<u8>>>; // weak
__int64 (__fastcall *off_58808)() = &core::ptr::drop_in_place<std::io::Write::write_fmt::Adapter<alloc::vec::Vec<u8>>>; // weak
char *off_58838 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_58850 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_58868 = "/rust/deps/addr2line-0.21.0/src/lib.rs"; // weak
char *off_58880 = "/rust/deps/addr2line-0.21.0/src/lib.rs"; // weak
char *off_58898 = "/rust/deps/addr2line-0.21.0/src/lib.rs"; // weak
char *off_588B0 = "/rust/deps/addr2line-0.21.0/src/function.rs"; // weak
char *off_588C8 = "/rust/deps/addr2line-0.21.0/src/function.rs"; // weak
char *off_588E0 = "fatal runtime error: unwrap failed: CString::new(\"main\") = "; // weak
char *off_58900 = "library/std/src/rt.rs"; // weak
char *off_58918 = "fatal runtime error: initialization or cleanup bug\n"; // weak
void *off_58928 = &unk_4958E; // weak
char *off_58938 = "library/std/src/thread/mod.rs"; // weak
char *off_58950 = "failed to generate unique thread ID: bitspace exhausted"; // weak
char *off_58960 = "library/std/src/thread/mod.rs"; // weak
char *off_58990 = "failed to write the buffered data"; // weak
char *off_589A8 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/navigate.rs"; // weak
char *off_589B8 = "library/std/src/io/buffered/linewritershim.rs"; // weak
__int64 (__fastcall *off_589D0)() = &core::ptr::drop_in_place<i32>; // weak
__int64 (__fastcall *off_589F0)() = &core::ptr::drop_in_place<u8>; // weak
__int64 (__fastcall *off_58A10[2])() = { &core::ptr::drop_in_place<alloc::string::String>, &off_18 }; // weak
__int64 (__fastcall *off_58A30)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
__int64 (__fastcall *off_58A50)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
char *off_58A70 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/navigate.rs"; // weak
char *off_58AA0 = "library/std/src/io/stdio.rs"; // weak
char *off_58AB8 = "library/std/src/io/stdio.rs"; // weak
char *off_58AD0 = "library/std/src/io/stdio.rs"; // weak
char *off_58AE8 = "library/std/src/thread/local.rs"; // weak
char *off_58B00 = "failed printing to "; // weak
char *off_58B20 = "library/std/src/io/stdio.rs"; // weak
char *off_58B38 = "library/std/src/io/mod.rs"; // weak
char *off_58B50 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/io/borrowed_buf.rs"; // weak
char *off_58B68 = "library/std/src/io/mod.rs"; // weak
char *off_58B80 = "library/std/src/io/mod.rs"; // weak
char *off_58B98 = "advancing io slices beyond their length"; // weak
char *off_58BA8 = "library/std/src/io/mod.rs"; // weak
char *off_58BC0 = "advancing IoSlice beyond its length"; // weak
char *off_58BD0 = "library/std/src/sys/pal/unix/io.rs"; // weak
char *off_58BE8 = "failed to write whole buffer"; // weak
char *off_58C00 = "library/std/src/io/mod.rs"; // weak
char *off_58C18 = "formatter error"; // weak
char *off_58C30 = "library/std/src/io/mod.rs"; // weak
char *off_58C48[2] = { "library/std/src/panic.rs", &off_18 }; // weak
char *off_58C60 = "library/std/src/path.rs"; // weak
char *off_58C78 = "library/std/src/path.rs"; // weak
char *off_58C90 = "library/std/src/path.rs"; // weak
char *off_58CA8 = "library/std/src/path.rs"; // weak
char *off_58CC0 = "library/std/src/path.rs"; // weak
char *off_58CD8 = "library/std/src/path.rs"; // weak
char *off_58CF0 = "library/std/src/path.rs"; // weak
char *off_58D08 = "library/std/src/path.rs"; // weak
char *off_58D20 = "library/std/src/path.rs"; // weak
char *off_58D38 = "library/std/src/path.rs"; // weak
char *off_58D50 = "library/std/src/path.rs"; // weak
char *off_58D68 = "library/std/src/path.rs"; // weak
char *off_58D80 = "library/std/src/path.rs"; // weak
char *off_58D98 = "library/std/src/sync/once.rs"; // weak
char *off_58DB0 = "library/std/src/sync/once.rs"; // weak
char *off_58DC8 = "library/std/src/sync/once.rs"; // weak
char *off_58DE0 = "library/std/src/sync/reentrant_lock.rs"; // weak
char ptr[] = { '\xCC', '\x9B', '\x04', '\0', '\0', '\0', '\0', '\0' }; // idb
__int64 (__fastcall *off_58E10)() = &core::ptr::drop_in_place<std::panicking::begin_panic_handler::FormatStringPayload>; // weak
__int64 (__fastcall *off_58E38)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
char *off_58E60 = "      [... omitted "; // weak
_UNKNOWN off_58E90; // weak
char *off_58EB0 = "fatal runtime error: assertion failed: thread_info.stack_guard.get().is_none() && thread_info.thread.get().is_none()\n"; // weak
char *off_58EC0 = "fatal runtime error: global allocator may not use TLS\n"; // weak
char *off_58ED0 = "memory allocation of "; // weak
char *off_58EF0 = "memory allocation of "; // weak
char *off_58F10[2] = { "library/std/src/alloc.rs", &off_18 }; // weak
char *off_58F28 = "fatal runtime error: Rust panics must be rethrown\n"; // weak
char *off_58F38 = "fatal runtime error: Rust cannot catch foreign exceptions\n"; // weak
__int64 (__fastcall *off_58F48[2])() = { &core::ptr::drop_in_place<alloc::vec::Vec<u8>>, &off_18 }; // weak
__int64 (__fastcall *off_58F98)() = &core::ptr::drop_in_place<()>; // weak
char *off_58FE8 = "thread '"; // weak
char *off_59028 = "note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"; // weak
char *off_59038 = "library/std/src/panicking.rs"; // weak
__int64 (__fastcall *off_59090)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
__int64 (__fastcall *off_590B8)() = &core::ptr::drop_in_place<std::panicking::begin_panic_handler::FormatStringPayload>; // weak
__int64 (__fastcall *off_590E0)() = &core::ptr::drop_in_place<()>; // weak
char *off_59100 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/navigate.rs"; // weak
char *off_59120 = "thread panicked while processing panic. aborting.\n"; // weak
char *off_59130 = "thread caused non-unwinding panic. aborting.\n"; // weak
char *off_59140 = "fatal runtime error: failed to initiate panic, error "; // weak
__int64 (__fastcall *off_59160)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
char *off_59188 = "library/std/src/../../backtrace/src/symbolize/mod.rs"; // weak
char *off_591A0 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/navigate.rs"; // weak
char *off_591C0 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/navigate.rs"; // weak
void *off_591E0 = &unk_49FB1; // weak
char *off_591F0 = "strerror_r failure"; // weak
char *off_59200 = "library/std/src/sys/pal/unix/os.rs"; // weak
char *off_59218 = "no /proc/self/exe available. Is /proc mounted?"; // weak
char *off_59230 = "\nthread '"; // weak
char *off_59250 = "fatal runtime error: stack overflow\n"; // weak
char *off_59260 = "failed to set up alternative stack guard page: "; // weak
char *off_59270 = "library/std/src/sys/pal/unix/stack_overflow.rs"; // weak
char *off_59288 = "failed to allocate an alternative stack: "; // weak
char *off_59298 = "library/std/src/sys/pal/unix/stack_overflow.rs"; // weak
char *off_592B0 = "library/std/src/sys/pal/unix/thread.rs"; // weak
char *off_592C8 = "library/std/src/sys/pal/unix/thread.rs"; // weak
char *off_592E0 = "library/std/src/sys/pal/unix/thread.rs"; // weak
char *off_592F8 = "fatal runtime error: assertion failed: signal(libc::SIGPIPE, handler) != libc::SIG_ERR\n"; // weak
char *off_59308 = "library/std/src/sys/pal/unix/mod.rs"; // weak
__int64 (__fastcall *off_59320)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
__int64 (__fastcall *off_59350)() = &core::ptr::drop_in_place<std::backtrace::lazy_resolve::{{closure}}::{{closure}}>; // weak
char *off_59380 = "Once instance has previously been poisoned"; // weak
char *off_59390 = "internal error: entered unreachable code: state is never set to invalid values"; // weak
char *off_593A0 = "too many active read locks on RwLock"; // weak
char *off_593B0 = "library/std/src/sys/sync/rwlock/futex.rs"; // weak
char *off_593C8 = "library/std/src/sys/sync/rwlock/futex.rs"; // weak
char *off_593E0 = "library/std/src/sys/pal/unix/thread_local_key.rs"; // weak
char *off_593F8 = "fatal runtime error: assertion failed: key as usize != KEY_SENTVAL\n"; // weak
char *off_59408 = "library/std/src/../../backtrace/src/symbolize/gimli/stash.rs"; // weak
char *off_59420 = "library/std/src/../../backtrace/src/symbolize/gimli/stash.rs"; // weak
char *off_59438 = "library/std/src/../../backtrace/src/symbolize/gimli.rs"; // weak
char *off_59450 = "library/std/src/../../backtrace/src/symbolize/gimli.rs"; // weak
char *off_59468 = "library/std/src/../../backtrace/src/symbolize/gimli/elf.rs"; // weak
char *off_59480 = "library/std/src/../../backtrace/src/symbolize/gimli/elf.rs"; // weak
void *off_59498 = &unk_483C0; // weak
__int64 (__fastcall *off_595E0)() = &core::ptr::drop_in_place<&i64>; // weak
char *off_59600 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/node.rs"; // weak
char *off_59618 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/node.rs"; // weak
char *off_59630 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/node.rs"; // weak
char *off_59648 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/node.rs"; // weak
char *off_59660 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/alloc/src/collections/btree/node.rs"; // weak
char *off_59678 = "/rust/deps/gimli-0.28.1/src/read/abbrev.rs"; // weak
char *off_59690 = "/rust/deps/gimli-0.28.1/src/read/abbrev.rs"; // weak
char *off_596A8 = "/rust/deps/gimli-0.28.1/src/read/abbrev.rs"; // weak
__int64 (__fastcall *off_596C0)() = &core::ptr::drop_in_place<&u8>; // weak
char *off_596E0 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/ops/function.rs"; // weak
char *off_596F8 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_59710 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_59728 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_59740 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/escape.rs"; // weak
__int64 (__fastcall *off_59758)() = &core::ptr::drop_in_place<()>; // weak
__int64 (__fastcall *off_59778)() = &core::ptr::drop_in_place<()>; // weak
__int64 (__fastcall *off_59798)() = &core::ptr::drop_in_place<()>; // weak
__int64 (__fastcall *off_597B8)() = &core::ptr::drop_in_place<core::num::error::ParseIntError>; // weak
__int64 (__fastcall *off_597D8)() = &core::ptr::drop_in_place<&u8>; // weak
__int64 (__fastcall *off_597F8[2])() = { &core::ptr::drop_in_place<&u8>, &off_18 }; // weak
char *off_59828 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_59840 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/str/pattern.rs"; // weak
char *off_59858 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59870 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59888 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_598A0 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_598B8 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_598D0 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_598E8 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59900 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59918 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59948 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59960 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59978 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59990 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_599A8 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_599C0 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_599D8 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_599F0 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59A08 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59A20 = "/rust/deps/rustc-demangle-0.1.23/src/legacy.rs"; // weak
char *off_59A38 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59A50 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59A68 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59A80 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59A98 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59AB0 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59AC8 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59AE0 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59AF8 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59B10 = "internal error: entered unreachable code: str::from_utf8("; // weak
char *off_59B50 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59B68 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59B80 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59B98 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59BB0 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59BC8 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59BE0 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59BF8 = "/rust/deps/rustc-demangle-0.1.23/src/v0.rs"; // weak
char *off_59C10 = "/rust/deps/rustc-demangle-0.1.23/src/lib.rs"; // weak
char *off_59C28 = "/rust/deps/rustc-demangle-0.1.23/src/lib.rs"; // weak
char *off_59C40 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/ops/function.rs"; // weak
char *off_59C50 = "/rust/deps/rustc-demangle-0.1.23/src/lib.rs"; // weak
void *off_59C68 = &unk_4B0A5; // weak
char *off_59D38 = "dest is out of bounds"; // weak
char *off_59D48 = "/rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/slice/index.rs"; // weak
char *off_59D60 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59D78 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59D90 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59DA8 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59DC0 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59DD8 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59DF0 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59E08 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59E20 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59E38 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59E50 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59E68 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59E80 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59E98 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59EB0 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59EC8 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59EE0 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59EF8 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59F10 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59F28 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59F40 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59F58 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59F70 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59F88 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59FA0 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59FB8 = "mid > len"; // weak
char *off_59FC8 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59FE0 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_59FF8 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A010 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A028 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A040 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A058 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/output_buffer.rs"; // weak
char *off_5A070 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/output_buffer.rs"; // weak
char *off_5A088 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A0A0 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A0B8 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A0D0 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A0E8 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A100 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A118 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A130 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A148 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A160 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A178 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
char *off_5A190 = "/rust/deps/miniz_oxide-0.7.2/src/inflate/core.rs"; // weak
__int64 (__fastcall *off_5A1A8)() = &core::ptr::drop_in_place<core::fmt::Error>; // weak
char *off_5A1C8 = "capacity overflow"; // weak
char *off_5A1D8 = "library/alloc/src/raw_vec.rs"; // weak
char *off_5A1F0 = "library/alloc/src/ffi/c_str.rs"; // weak
char *off_5A208 = "library/alloc/src/sync.rs"; // weak
void *off_5A220 = &unk_4C8A8; // weak
char *off_5A230 = "library/core/src/num/mod.rs"; // weak
void *off_5A248 = &unk_4C92B; // weak
void *off_5A258 = &unk_4C8A8; // weak
void *off_5A268 = &unk_4C8A8; // weak
__int64 (__fastcall *off_5A298)() = &core::ptr::drop_in_place<core::fmt::Error>; // weak
char *off_5A2B8 = "library/core/src/panicking.rs"; // weak
char *off_5A2D0 = "library/core/src/panicking.rs"; // weak
void *off_5A2E8 = &unk_4C95D; // weak
char *off_5A308 = "assertion `left "; // weak
char *off_5A338 = "assertion `left "; // weak
void *off_5A378 = &unk_4C8A8; // weak
__int64 (__fastcall *off_5A398[2])() = { &core::ptr::drop_in_place<usize>, &off_18 }; // weak
char *off_5A3C8 = "library/core/src/fmt/num.rs"; // weak
char *off_5A3E8 = "library/core/src/fmt/mod.rs"; // weak
char *off_5A400 = "library/core/src/fmt/mod.rs"; // weak
char *off_5A418 = "library/core/src/slice/memchr.rs"; // weak
char *off_5A430 = "library/core/src/slice/memchr.rs"; // weak
char *off_5A448 = "range start index "; // weak
char *off_5A468 = "range end index "; // weak
char *off_5A488 = "slice index starts at "; // weak
char *off_5A4A8 = "attempted to index slice up to maximum usize"; // weak
char *off_5A4B8 = "source slice length ("; // weak
char *off_5A4E8 = "attempted to index str up to maximum usize"; // weak
char *off_5A4F8 = "library/core/src/str/pattern.rs"; // weak
char *off_5A510 = "library/core/src/str/pattern.rs"; // weak
char *off_5A528 = "library/core/src/str/pattern.rs"; // weak
char *off_5A540 = "library/core/src/str/pattern.rs"; // weak
char *off_5A558 = "library/core/src/str/pattern.rs"; // weak
char *off_5A570 = "begin <= end ("; // weak
char *off_5A5B0 = "byte index "; // weak
char *off_5A600 = "byte index "; // weak
char *off_5A630 = "library/core/src/str/mod.rs"; // weak
char *off_5A648 = "library/core/src/unicode/printable.rs"; // weak
char *off_5A660 = "library/core/src/unicode/printable.rs"; // weak
char *off_5A678 = "library/core/src/unicode/unicode_data.rs"; // weak
char *off_5A690 = "library/core/src/unicode/unicode_data.rs"; // weak
char *off_5A6A8 = "library/core/src/escape.rs"; // weak
char *off_5A6C0 = "library/core/src/escape.rs"; // weak
void *_dso_handle = &_dso_handle; // idb
pthread_key_t std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS = 0u; // idb
void (*destr_function)(void *) = &std::sys_common::thread_local_dtor::register_dtor_fallback::run_dtors; // idb
char std::panicking::default_hook::{{closure}}::FIRST_PANIC = '\x01'; // weak
void **rust_extern_with_linkage___dso_handle = &_dso_handle; // weak
__int128 std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE = 0x08000000000000000LL; // weak
__int64 qword_5B040 = 0LL; // weak
__int64 qword_5B048 = 0LL; // weak
void *dest = &dword_0; // idb
__int64 qword_5B058 = 0LL; // weak
char _bss_start; // weak
_UNKNOWN _rust_alloc_error_handler_should_panic; // weak
int std::rt::cleanup::CLEANUP; // weak
char std::io::stdio::OUTPUT_CAPTURE_USED; // weak
_UNKNOWN std::io::stdio::stdin::INSTANCE; // weak
int dword_5B0A0; // weak
__int64 std::io::stdio::STDOUT; // weak
int dword_5B0B0; // weak
int dword_5B0B4; // weak
__int64 qword_5B0B8; // weak
__int128 xmmword_5B0C0; // weak
_UNKNOWN unk_5B0D0; // weak
char byte_5B0D8; // weak
int dword_5B0E0; // weak
char std::panic::SHOULD_CAPTURE; // weak
int std::sys_common::backtrace::lock::LOCK; // weak
char byte_5B0F0; // weak
__int64 std::alloc::HOOK; // weak
_UNKNOWN std::panicking::HOOK; // weak
signed __int64 std::panicking::panic_count::GLOBAL_PANIC_COUNT; // weak
__int64 std::thread::ThreadId::new::COUNTER; // weak
__int64 std::sys::pal::unix::args::imp::ARGC; // weak
__int64 std::sys::pal::unix::args::imp::ARGV; // weak
int std::sys::pal::unix::os::ENV_LOCK; // weak
__int64 std::sys::pal::unix::stack_overflow::imp::MAIN_ALTSTACK; // weak
char std::sys::pal::unix::stack_overflow::imp::NEED_ALTSTACK; // weak
__int64 std::sys::pal::unix::thread::guard::PAGE_SIZE; // weak
char std::sys::pal::unix::UNIX_SIGPIPE_ATTR_SPECIFIED; // weak
char std::sys::pal::unix::fs::try_statx::STATX_SAVED_STATE; // weak
char std::backtrace_rs::symbolize::gimli::elf::debug_path_exists::DEBUG_PATH_EXISTS; // weak


//----- (0000000000006000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 5B3D8: using guessed type __int64 _gmon_start__(void);

//----- (0000000000006020) ----------------------------------------------------
void sub_6020()
{
  JUMPOUT(0LL);
}
// 6026: control flows out of bounds to 0

//----- (0000000000006060) ----------------------------------------------------
char __fastcall core::str::pattern::simd_contains::{{closure}}(_QWORD *a1, __int64 a2, int _EDX, __int64 _RCX)
{
  char result; // al
  _BYTE *v5; // r8
  __int64 v6; // rsi
  unsigned __int64 v7; // rdi
  _DWORD *v8; // r9
  _DWORD *v9; // rax
  _DWORD *v10; // r10

  result = 0;
  if ( (_WORD)_EDX && !(_BYTE)_RCX )
  {
    v5 = (_BYTE *)a1[2];
    v6 = *a1 + a2 + 1;
    v7 = a1[3];
    if ( v7 >= 4 )
    {
      while ( 1 )
      {
        __asm { tzcnt   ecx, edx }
        v8 = (_DWORD *)(v6 + _RCX);
        v9 = (_DWORD *)(v7 + v6 + _RCX - 4);
        if ( (unsigned __int64)v9 <= v6 + _RCX )
        {
LABEL_5:
          if ( *v9 == *(_DWORD *)&v5[v7 - 4] )
            return 1;
        }
        else
        {
          v10 = v5;
          while ( *v8 == *v10 )
          {
            ++v8;
            ++v10;
            if ( v8 >= v9 )
              goto LABEL_5;
          }
        }
        LOWORD(_EDX) = __ROL2__(-2, _RCX) & _EDX;
        if ( !(_WORD)_EDX )
          return 0;
      }
    }
    while ( 1 )
    {
      result = 1;
      if ( !v7 )
        break;
      __asm { tzcnt   ecx, edx }
      if ( *(_BYTE *)(v6 + _RCX) == *v5
        && (v7 == 1 || *(_BYTE *)(v6 + _RCX + 1) == v5[1] && (v7 == 2 || *(_BYTE *)(v6 + _RCX + 2) == v5[2])) )
      {
        break;
      }
      LOWORD(_EDX) = __ROL2__(-2, _RCX) & _EDX;
      if ( !(_WORD)_EDX )
        return 0;
    }
  }
  return result;
}
// 6139: conditional instruction was optimized away because rdi.8==3

//----- (0000000000006150) ----------------------------------------------------
__int64 __fastcall core::slice::sort::break_patterns(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // r10
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r11
  unsigned __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // r11
  unsigned __int64 v13; // r10
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r10
  __int64 v16; // r9
  __int64 v17; // rax
  __int64 v18; // r10
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 result; // rax
  __int64 v25; // rdx
  __int128 v26; // [rsp+0h] [rbp-18h]
  __int128 v27; // [rsp+0h] [rbp-18h]
  __int128 v28; // [rsp+0h] [rbp-18h]
  __int64 v29; // [rsp+10h] [rbp-8h]
  __int64 v30; // [rsp+10h] [rbp-8h]
  __int64 v31; // [rsp+10h] [rbp-8h]

  _BitScanReverse64(&v2, a2 - 1);
  v3 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v2;
  v4 = (a2 >> 1) & 0xFFFFFFFFFFFFFFFELL;
  v5 = v4 - 1;
  v7 = v3 & (a2 ^ (a2 << 13) ^ ((a2 ^ (a2 << 13)) >> 7) ^ ((a2 ^ (a2 << 13) ^ ((a2 ^ (a2 << 13)) >> 7)) << 17));
  v8 = 0LL;
  if ( v7 >= a2 )
    v8 = a2;
  if ( v5 >= a2 )
LABEL_17:
    core::panicking::panic_bounds_check(v5, a2, (__int64)&off_58478);
  v9 = v7 - v8;
  if ( v9 >= a2 )
    goto LABEL_14;
  v10 = 3 * v5;
  v11 = 3 * v9;
  v29 = *(_QWORD *)(a1 + 8 * v10 + 16);
  v26 = *(_OWORD *)(a1 + 8 * v10);
  v12 = *(_QWORD *)(a1 + 8 * v11 + 16);
  *(_OWORD *)(a1 + 8 * v10) = *(_OWORD *)(a1 + 8 * v11);
  *(_QWORD *)(a1 + 8 * v10 + 16) = v12;
  *(_QWORD *)(a1 + 8 * v11 + 16) = v29;
  *(_OWORD *)(a1 + 8 * v11) = v26;
  v6 = a2 ^ (a2 << 13) ^ ((a2 ^ (a2 << 13)) >> 7) ^ ((a2 ^ (a2 << 13) ^ ((a2 ^ (a2 << 13)) >> 7)) << 17);
  v13 = v6 ^ (v6 << 13) ^ ((v6 ^ (v6 << 13)) >> 7);
  v14 = v13 ^ (v13 << 17);
  v15 = 0LL;
  if ( (v3 & v14) >= a2 )
    v15 = a2;
  if ( v4 >= a2 )
    core::panicking::panic_bounds_check((a2 >> 1) & 0xFFFFFFFFFFFFFFFELL, a2, (__int64)&off_58478);
  v9 = (v3 & v14) - v15;
  if ( v9 >= a2 )
LABEL_14:
    core::panicking::panic_bounds_check(v9, a2, (__int64)&off_58478);
  v16 = 3 * v4;
  v17 = 3 * v9;
  v30 = *(_QWORD *)(a1 + 8 * v16 + 16);
  v27 = *(_OWORD *)(a1 + 8 * v16);
  v18 = *(_QWORD *)(a1 + 8 * v17 + 16);
  *(_OWORD *)(a1 + 8 * v16) = *(_OWORD *)(a1 + 8 * v17);
  *(_QWORD *)(a1 + 8 * v16 + 16) = v18;
  *(_QWORD *)(a1 + 8 * v17 + 16) = v30;
  *(_OWORD *)(a1 + 8 * v17) = v27;
  v19 = v14 ^ (v14 << 13) ^ ((v14 ^ (v14 << 13)) >> 7);
  v20 = v3 & (v19 ^ (v19 << 17));
  v21 = 0LL;
  if ( v20 >= a2 )
    v21 = a2;
  v22 = (a2 >> 1) | 1;
  if ( v22 >= a2 )
  {
    v5 = (a2 >> 1) | 1;
    goto LABEL_17;
  }
  v9 = v20 - v21;
  if ( v9 >= a2 )
    goto LABEL_14;
  v23 = 3 * v22;
  result = 3 * v9;
  v31 = *(_QWORD *)(a1 + 24 * v22 + 16);
  v28 = *(_OWORD *)(a1 + 24 * v22);
  v25 = *(_QWORD *)(a1 + 8 * result + 16);
  *(_OWORD *)(a1 + 8 * v23) = *(_OWORD *)(a1 + 8 * result);
  *(_QWORD *)(a1 + 8 * v23 + 16) = v25;
  *(_QWORD *)(a1 + 8 * result + 16) = v31;
  *(_OWORD *)(a1 + 8 * result) = v28;
  return result;
}
// 58478: using guessed type char *off_58478;

//----- (0000000000006340) ----------------------------------------------------
__int64 __fastcall core::slice::sort::partial_insertion_sort(__int64 *a1, unsigned __int64 a2)
{
  unsigned int v2; // ebp
  __int64 v3; // rax
  unsigned __int64 v4; // rcx
  unsigned __int64 *v5; // rdi
  unsigned __int64 v6; // r8
  bool v7; // cf
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rbx
  bool v10; // cl
  unsigned __int64 *v11; // rcx
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rdx
  __int64 v14; // r12
  __int64 v15; // r15
  unsigned __int64 v16; // rax
  bool v17; // cl
  __int64 *v18; // rcx
  unsigned __int64 v19; // r8
  __int64 v20; // r12
  __int64 v21; // r15
  unsigned __int64 v22; // rax
  bool v23; // cl
  __int64 *v24; // rcx
  unsigned __int64 v25; // r8
  __int64 v26; // r12
  __int64 v27; // r15
  unsigned __int64 v28; // rax
  bool v29; // cl
  __int64 *v30; // rcx
  unsigned __int64 v31; // r8
  __int64 v32; // r12
  __int64 v33; // r15
  unsigned __int64 v34; // rax
  bool v35; // cl
  __int64 *v36; // rcx
  unsigned __int64 v37; // r8
  __int64 v39; // rax
  __int64 v40; // rcx
  __int128 v41; // [rsp+0h] [rbp-48h]
  __int128 v42; // [rsp+0h] [rbp-48h]
  __int128 v43; // [rsp+0h] [rbp-48h]
  __int128 v44; // [rsp+0h] [rbp-48h]
  __int128 v45; // [rsp+0h] [rbp-48h]
  __int64 v46; // [rsp+10h] [rbp-38h]
  __int64 v47; // [rsp+10h] [rbp-38h]
  __int64 v48; // [rsp+10h] [rbp-38h]
  __int64 v49; // [rsp+10h] [rbp-38h]
  __int64 v50; // [rsp+10h] [rbp-38h]

  if ( a2 <= 0x31 )
  {
    v3 = 1LL;
    if ( a2 > 1 )
    {
      v4 = a1[3];
      if ( v4 >= *a1 )
      {
        v5 = (unsigned __int64 *)(a1 + 6);
        while ( 2 - a2 + v3 != 1 )
        {
          ++v3;
          v6 = *v5;
          v5 += 3;
          v7 = v6 < v4;
          v4 = v6;
          if ( v7 )
            goto LABEL_38;
        }
        v3 = a2;
      }
    }
LABEL_38:
    LOBYTE(v2) = v3 == a2;
    return v2;
  }
  v8 = a1[3];
  v9 = 1LL;
  LOBYTE(v2) = 1;
  v10 = 1;
  if ( v8 < *a1 )
    goto LABEL_13;
  v11 = (unsigned __int64 *)(a1 + 6);
  do
  {
    if ( 2 - a2 + v9 == 1 )
    {
LABEL_63:
      LOBYTE(v2) = 1;
      return v2;
    }
    v12 = *v11;
    v11 += 3;
    ++v9;
    v7 = v12 < v8;
    v8 = v12;
  }
  while ( !v7 );
  v10 = v9 < a2;
LABEL_13:
  if ( v9 != a2 )
  {
    v13 = v9 - 1;
    if ( v9 - 1 < a2 )
    {
      if ( !v10 )
        goto LABEL_73;
      v14 = 3 * v13;
      v15 = 3 * v9;
      v46 = a1[3 * v13 + 2];
      v41 = *(_OWORD *)&a1[3 * v13];
      a1[v14 + 2] = a1[3 * v9 + 2];
      *(_OWORD *)&a1[v14] = *(_OWORD *)&a1[3 * v9];
      a1[v15 + 2] = v46;
      *(_OWORD *)&a1[v15] = v41;
      if ( v9 >= 2 )
      {
        core::slice::sort::insertion_sort_shift_left((__int64)a1, v9, v13);
        core::slice::sort::insertion_sort_shift_right(a1, v9);
      }
      if ( v9 >= a2 )
      {
        v17 = 0;
        if ( v9 == a2 )
          return v2;
      }
      else
      {
        v16 = a1[3 * v9];
        v17 = 1;
        if ( v16 >= a1[v14] )
        {
          v18 = &a1[3 * v9 + 3];
          do
          {
            if ( a2 - 1 == v9 )
              goto LABEL_63;
            v19 = *v18;
            v18 += 3;
            ++v9;
            v7 = v19 < v16;
            v16 = v19;
          }
          while ( !v7 );
          v17 = v9 < a2;
        }
        if ( v9 == a2 )
          return v2;
      }
      v13 = v9 - 1;
      if ( v9 - 1 < a2 )
      {
        if ( !v17 )
          goto LABEL_73;
        v20 = 3 * v13;
        v21 = 3 * v9;
        v47 = a1[3 * v13 + 2];
        v42 = *(_OWORD *)&a1[3 * v13];
        a1[v20 + 2] = a1[3 * v9 + 2];
        *(_OWORD *)&a1[v20] = *(_OWORD *)&a1[3 * v9];
        a1[v21 + 2] = v47;
        *(_OWORD *)&a1[v21] = v42;
        if ( v9 >= 2 )
        {
          core::slice::sort::insertion_sort_shift_left((__int64)a1, v9, v13);
          core::slice::sort::insertion_sort_shift_right(a1, v9);
        }
        if ( v9 >= a2 )
        {
          v23 = 0;
        }
        else
        {
          v22 = a1[3 * v9];
          v23 = 1;
          if ( v22 >= a1[v20] )
          {
            v24 = &a1[3 * v9 + 3];
            do
            {
              if ( a2 - 1 == v9 )
                goto LABEL_63;
              v25 = *v24;
              v24 += 3;
              ++v9;
              v7 = v25 < v22;
              v22 = v25;
            }
            while ( !v7 );
            v23 = v9 < a2;
          }
        }
        if ( v9 == a2 )
          return v2;
        v13 = v9 - 1;
        if ( v9 - 1 < a2 )
        {
          if ( !v23 )
            goto LABEL_73;
          v26 = 3 * v13;
          v27 = 3 * v9;
          v48 = a1[3 * v13 + 2];
          v43 = *(_OWORD *)&a1[3 * v13];
          a1[v26 + 2] = a1[3 * v9 + 2];
          *(_OWORD *)&a1[v26] = *(_OWORD *)&a1[3 * v9];
          a1[v27 + 2] = v48;
          *(_OWORD *)&a1[v27] = v43;
          if ( v9 >= 2 )
          {
            core::slice::sort::insertion_sort_shift_left((__int64)a1, v9, v13);
            core::slice::sort::insertion_sort_shift_right(a1, v9);
          }
          if ( v9 >= a2 )
          {
            v29 = 0;
          }
          else
          {
            v28 = a1[3 * v9];
            v29 = 1;
            if ( v28 >= a1[v26] )
            {
              v30 = &a1[3 * v9 + 3];
              do
              {
                if ( a2 - 1 == v9 )
                  goto LABEL_63;
                v31 = *v30;
                v30 += 3;
                ++v9;
                v7 = v31 < v28;
                v28 = v31;
              }
              while ( !v7 );
              v29 = v9 < a2;
            }
          }
          if ( v9 == a2 )
            return v2;
          v13 = v9 - 1;
          if ( v9 - 1 < a2 )
          {
            if ( !v29 )
              goto LABEL_73;
            v32 = 3 * v13;
            v33 = 3 * v9;
            v49 = a1[3 * v13 + 2];
            v44 = *(_OWORD *)&a1[3 * v13];
            a1[v32 + 2] = a1[3 * v9 + 2];
            *(_OWORD *)&a1[v32] = *(_OWORD *)&a1[3 * v9];
            a1[v33 + 2] = v49;
            *(_OWORD *)&a1[v33] = v44;
            if ( v9 >= 2 )
            {
              core::slice::sort::insertion_sort_shift_left((__int64)a1, v9, v13);
              core::slice::sort::insertion_sort_shift_right(a1, v9);
            }
            if ( v9 >= a2 )
            {
              v35 = 0;
            }
            else
            {
              v34 = a1[3 * v9];
              v35 = 1;
              if ( v34 >= a1[v32] )
              {
                v36 = &a1[3 * v9 + 3];
                do
                {
                  if ( a2 - 1 == v9 )
                    goto LABEL_63;
                  v37 = *v36;
                  v36 += 3;
                  ++v9;
                  v7 = v37 < v34;
                  v34 = v37;
                }
                while ( !v7 );
                v35 = v9 < a2;
              }
            }
            if ( v9 == a2 )
              return v2;
            v13 = v9 - 1;
            if ( v9 - 1 < a2 )
            {
              if ( v35 )
              {
                v39 = 3 * v13;
                v40 = 3 * v9;
                v50 = a1[3 * v13 + 2];
                v45 = *(_OWORD *)&a1[3 * v13];
                a1[v39 + 2] = a1[3 * v9 + 2];
                *(_OWORD *)&a1[v39] = *(_OWORD *)&a1[3 * v9];
                a1[v40 + 2] = v50;
                *(_OWORD *)&a1[v40] = v45;
                if ( v9 >= 2 )
                {
                  core::slice::sort::insertion_sort_shift_left((__int64)a1, v9, v13);
                  core::slice::sort::insertion_sort_shift_right(a1, v9);
                }
                return 0;
              }
LABEL_73:
              core::panicking::panic_bounds_check(v9, a2, (__int64)&off_584D0);
            }
          }
        }
      }
    }
    core::panicking::panic_bounds_check(v13, a2, (__int64)&off_584D0);
  }
  return v2;
}
// 6745: variable 'v2' is possibly undefined
// 584D0: using guessed type char *off_584D0;

//----- (00000000000067F0) ----------------------------------------------------
void __fastcall core::slice::sort::heapsort(__int128 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdx
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // r8
  __int64 v5; // r9
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // rax
  __int64 v9; // rcx
  __int128 *v10; // rcx
  __int128 *v11; // r8
  __int64 v12; // r9
  unsigned __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rdx
  unsigned __int64 v16; // rdx
  __int64 v17; // r9
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r9
  unsigned __int64 v20; // rcx
  __int128 *v21; // rdx
  __int128 *v22; // r8
  __int64 v23; // r9
  __int128 v24; // [rsp+0h] [rbp-18h]
  __int128 v25; // [rsp+0h] [rbp-18h]
  __int128 v26; // [rsp+0h] [rbp-18h]
  __int64 v27; // [rsp+10h] [rbp-8h]
  __int64 v28; // [rsp+10h] [rbp-8h]
  __int64 v29; // [rsp+10h] [rbp-8h]

  if ( a2 >= 2 )
  {
    v2 = a2 >> 1;
    do
    {
      v3 = v2--;
      v4 = 2 * v3 - 1;
      if ( v4 < a2 )
      {
        v5 = 2 * v3 - 2;
        v6 = v2;
        do
        {
          v7 = v5 + 2;
          if ( v7 < a2 )
            v4 += *((_QWORD *)a1 + 3 * v4) < *((_QWORD *)a1 + 3 * v7);
          v8 = v4;
          if ( v6 >= a2 )
            core::panicking::panic_bounds_check(v6, a2, (__int64)&off_58560);
          if ( v4 >= a2 )
            core::panicking::panic_bounds_check(v4, a2, (__int64)&off_58578);
          v9 = 3 * v6;
          if ( *((_QWORD *)a1 + v9) >= *((_QWORD *)a1 + 3 * v4) )
            break;
          v10 = (__int128 *)((char *)a1 + 8 * v9);
          v11 = (__int128 *)((char *)a1 + 24 * v4);
          v27 = *((_QWORD *)v10 + 2);
          v24 = *v10;
          v12 = *((_QWORD *)v11 + 2);
          *v10 = *v11;
          *((_QWORD *)v10 + 2) = v12;
          *((_QWORD *)v11 + 2) = v27;
          *v11 = v24;
          v5 = 2 * v8;
          v4 = 2 * v8 + 1;
          v6 = v8;
        }
        while ( v4 < a2 );
      }
    }
    while ( v2 );
    v13 = a2;
    while ( 1 )
    {
      if ( --v13 >= a2 )
        core::panicking::panic_bounds_check(v13, a2, (__int64)&off_58548);
      v14 = 3 * v13;
      v28 = *((_QWORD *)a1 + 2);
      v25 = *a1;
      v15 = *((_QWORD *)a1 + 3 * v13 + 2);
      *a1 = *(__int128 *)((char *)a1 + 24 * v13);
      *((_QWORD *)a1 + 2) = v15;
      *((_QWORD *)a1 + v14 + 2) = v28;
      *(__int128 *)((char *)a1 + 8 * v14) = v25;
      if ( v13 < 2 )
        break;
      v16 = 1LL;
      v17 = 0LL;
      v18 = 0LL;
      do
      {
        v19 = v17 + 2;
        if ( v19 < v13 )
          v16 += *((_QWORD *)a1 + 3 * v16) < *((_QWORD *)a1 + 3 * v19);
        v20 = v16;
        if ( v18 >= v13 )
          core::panicking::panic_bounds_check(v18, v13, (__int64)&off_58560);
        if ( v16 >= v13 )
          core::panicking::panic_bounds_check(v16, v13, (__int64)&off_58578);
        if ( *((_QWORD *)a1 + 3 * v18) >= *((_QWORD *)a1 + 3 * v16) )
          break;
        v21 = (__int128 *)((char *)a1 + 24 * v18);
        v22 = (__int128 *)((char *)a1 + 24 * v20);
        v29 = *((_QWORD *)v21 + 2);
        v26 = *v21;
        v23 = *((_QWORD *)v22 + 2);
        *v21 = *v22;
        *((_QWORD *)v21 + 2) = v23;
        *((_QWORD *)v22 + 2) = v29;
        *v22 = v26;
        v17 = 2 * v20;
        v16 = 2 * v20 + 1;
        v18 = v20;
      }
      while ( v16 < v13 );
    }
  }
}
// 68E4: conditional instruction was optimized away because rax.8>=2u
// 58548: using guessed type char *off_58548;
// 58560: using guessed type char *off_58560;
// 58578: using guessed type char *off_58578;

//----- (0000000000006A50) ----------------------------------------------------
void __fastcall __noreturn core::panicking::assert_failed(char a1, __int64 a2, __int64 a3, __int128 *a4, __int64 a5)
{
  __int64 v5; // [rsp+8h] [rbp-10h] BYREF
  __int64 v6; // [rsp+10h] [rbp-8h] BYREF

  v5 = a2;
  v6 = a3;
  core::panicking::assert_failed_inner(a1, (__int64)&v5, (__int64)&off_58618, (__int64)&v6, (__int64)&off_58618, a4, a5);
}
// 58618: using guessed type __int64 (__fastcall *off_58618)();

//----- (0000000000006A80) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rax
  __int64 v4; // rcx
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 result; // rax
  __int64 v9; // [rsp+8h] [rbp-40h] BYREF
  __int64 v10; // [rsp+10h] [rbp-38h]
  __int64 v11; // [rsp+18h] [rbp-30h]
  __int64 v12[5]; // [rsp+20h] [rbp-28h] BYREF

  v3 = a3 + a2;
  if ( __CFADD__(a3, a2) )
    goto LABEL_12;
  v4 = *a1;
  if ( 2 * *a1 > v3 )
    v3 = 2 * *a1;
  v5 = 4LL;
  if ( v3 >= 5 )
    v5 = v3;
  v6 = 8 * (unsigned int)(v3 < 0x555555555555556LL);
  if ( v4 )
  {
    v12[0] = a1[1];
    v12[2] = 24 * v4;
    v7 = 8LL;
  }
  else
  {
    v7 = 0LL;
  }
  v12[1] = v7;
  alloc::raw_vec::finish_grow(&v9, v6, 24 * v5, v12);
  if ( v9 )
  {
    if ( v10 )
      alloc::alloc::handle_alloc_error(v10, v11);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v10;
  a1[1] = v10;
  *a1 = v5;
  return result;
}

//----- (0000000000006B50) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 *a1, __int64 a2, __int64 a3)
{
  bool v3; // cf
  unsigned __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // r14
  __int64 v7; // rax
  __int64 result; // rax
  __int64 v9; // [rsp+8h] [rbp-40h] BYREF
  __int64 v10; // [rsp+10h] [rbp-38h]
  __int64 v11; // [rsp+18h] [rbp-30h]
  __int64 v12[5]; // [rsp+20h] [rbp-28h] BYREF

  v3 = __CFADD__(a3, a2);
  v4 = a3 + a2;
  if ( v3 )
    goto LABEL_12;
  v5 = *a1;
  if ( 2 * *a1 > v4 )
    v4 = 2 * *a1;
  v6 = 8LL;
  if ( v4 >= 9 )
    v6 = v4;
  if ( v5 )
  {
    v12[0] = a1[1];
    v12[2] = v5;
    v7 = 1LL;
  }
  else
  {
    v7 = 0LL;
  }
  v12[1] = v7;
  alloc::raw_vec::finish_grow(&v9, v6 >= 0, v6, v12);
  if ( v9 )
  {
    if ( v10 )
      alloc::alloc::handle_alloc_error(v10, v11);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v10;
  a1[1] = v10;
  *a1 = v6;
  return result;
}

//----- (0000000000006C00) ----------------------------------------------------
void *__fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 a1)
{
  unsigned __int64 v1; // rdi
  __int64 v2; // rbx
  __int64 v3; // rax
  void *result; // rax
  __int64 v5; // [rsp+0h] [rbp-38h] BYREF
  void *v6; // [rsp+8h] [rbp-30h]
  __int64 v7; // [rsp+10h] [rbp-28h]
  __int64 v8[4]; // [rsp+18h] [rbp-20h] BYREF

  v1 = a1 + 1;
  if ( !v1 )
    goto LABEL_12;
  if ( 2 * qword_5B048 > v1 )
    v1 = 2 * qword_5B048;
  v2 = 4LL;
  if ( v1 >= 5 )
    v2 = v1;
  if ( qword_5B048 )
  {
    v8[0] = (__int64)dest;
    v8[2] = 584 * qword_5B048;
    v3 = 8LL;
  }
  else
  {
    v3 = 0LL;
  }
  v8[1] = v3;
  alloc::raw_vec::finish_grow(&v5, 8 * (unsigned int)(v1 < 0x381C0E070381C1LL), 584 * v2, v8);
  if ( v5 )
  {
    if ( v6 )
      alloc::alloc::handle_alloc_error((__int64)v6, v7);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v6;
  dest = v6;
  qword_5B048 = v2;
  return result;
}
// 5B048: using guessed type __int64 qword_5B048;

//----- (0000000000006CC0) ----------------------------------------------------
void __noreturn std::thread::ThreadId::new::exhausted()
{
  __int64 v0[3]; // [rsp+8h] [rbp-30h] BYREF
  __int128 v1; // [rsp+20h] [rbp-18h]

  v0[0] = (__int64)&off_58950;
  v0[1] = 1LL;
  v0[2] = (__int64)aRustc9b00956e5;
  v1 = 0LL;
  core::panicking::panic_fmt((__int64)v0, (__int64)&off_58960);
}
// 58950: using guessed type char *off_58950;
// 58960: using guessed type char *off_58960;

//----- (0000000000006D00) ----------------------------------------------------
unsigned __int64 __fastcall std::io::buffered::bufwriter::BufWriter<W>::write_all_cold(
        __int64 a1,
        char *a2,
        unsigned __int64 a3)
{
  unsigned __int64 v4; // rax
  unsigned __int64 result; // rax
  __int64 v6; // r15

  v4 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 - *(_QWORD *)(a1 + 16) < a3 )
  {
    result = std::io::buffered::bufwriter::BufWriter<W>::flush_buf(a1);
    if ( result )
      return result;
    v4 = *(_QWORD *)a1;
  }
  if ( v4 <= a3 )
  {
    *(_BYTE *)(a1 + 24) = 1;
    result = <std::io::stdio::StdoutRaw as std::io::Write>::write_all(a1, a2, a3);
    *(_BYTE *)(a1 + 24) = 0;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 16);
    memcpy((void *)(v6 + *(_QWORD *)(a1 + 8)), a2, a3);
    *(_QWORD *)(a1 + 16) = a3 + v6;
    return 0LL;
  }
  return result;
}

//----- (0000000000006D80) ----------------------------------------------------
void __noreturn std::process::abort()
{
  std::sys::pal::unix::abort_internal();
}

//----- (0000000000006D90) ----------------------------------------------------
__int64 std::sync::once_lock::OnceLock<T>::initialize()
{
  __int64 result; // rax
  char v1; // [rsp+1h] [rbp-19h] BYREF
  __int64 *v2; // [rsp+2h] [rbp-18h] BYREF
  __int64 v3[2]; // [rsp+Ah] [rbp-10h] BYREF

  result = (unsigned int)dword_5B0E0;
  if ( dword_5B0E0 != 4 )
  {
    v3[0] = (__int64)&std::io::stdio::STDOUT;
    v3[1] = (__int64)&v1;
    v2 = v3;
    return std::sys::sync::once::futex::Once::call(&v2);
  }
  return result;
}
// 5B0A8: using guessed type __int64 std::io::stdio::STDOUT;
// 5B0E0: using guessed type int dword_5B0E0;

//----- (0000000000006DD0) ----------------------------------------------------
__int64 std::sync::once_lock::OnceLock<T>::initialize()
{
  __int64 result; // rax
  char v1; // [rsp+1h] [rbp-19h] BYREF
  __int64 *v2; // [rsp+2h] [rbp-18h] BYREF
  __int64 v3[2]; // [rsp+Ah] [rbp-10h] BYREF

  result = (unsigned int)dword_5B0A0;
  if ( dword_5B0A0 != 4 )
  {
    v3[0] = (__int64)&std::io::stdio::stdin::INSTANCE;
    v3[1] = (__int64)&v1;
    v2 = v3;
    return std::sys::sync::once::futex::Once::call(&v2);
  }
  return result;
}
// 5B0A0: using guessed type int dword_5B0A0;

//----- (0000000000006E10) ----------------------------------------------------
__int64 __fastcall std::sync::once_lock::OnceLock<T>::initialize(__int64 a1)
{
  __int64 result; // rax
  char v2; // [rsp+1h] [rbp-21h] BYREF
  __int64 *v3; // [rsp+2h] [rbp-20h] BYREF
  __int64 v4[3]; // [rsp+Ah] [rbp-18h] BYREF

  result = (unsigned int)dword_5B0E0;
  if ( dword_5B0E0 != 4 )
  {
    v4[0] = a1;
    v4[1] = (__int64)&std::io::stdio::STDOUT;
    v4[2] = (__int64)&v2;
    v3 = v4;
    return std::sys::sync::once::futex::Once::call(&v3);
  }
  return result;
}
// 5B0A8: using guessed type __int64 std::io::stdio::STDOUT;
// 5B0E0: using guessed type int dword_5B0E0;

//----- (0000000000006E60) ----------------------------------------------------
__int64 __fastcall std::sys::pal::common::small_c_string::run_with_cstr_allocating(const void *a1, size_t a2)
{
  char *v2; // r15
  __int64 v3; // r12
  __int64 v4; // r14
  __int64 v6; // [rsp+8h] [rbp-40h] BYREF
  char *name; // [rsp+10h] [rbp-38h]
  __int64 v8; // [rsp+18h] [rbp-30h]

  <&[u8] as alloc::ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl(&v6, a1, a2);
  if ( v6 == 0x8000000000000000LL )
  {
    v2 = name;
    v3 = v8;
    v4 = 0LL;
    realpath(name, 0LL);
    *v2 = 0;
    if ( v3 )
    {
      _rust_dealloc(v2, v3, 1LL);
      return 0LL;
    }
  }
  else
  {
    v4 = 1LL;
    if ( v6 )
      _rust_dealloc(name, v6, 1LL);
  }
  return v4;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (0000000000006F10) ----------------------------------------------------
char *__fastcall std::sys::pal::common::small_c_string::run_with_cstr_allocating(
        _QWORD *a1,
        const void *a2,
        size_t a3,
        __int64 (__fastcall *a4)(_QWORD *, const char *, _BYTE *, __int64))
{
  __int64 v5; // rsi
  _BYTE *v6; // r14
  __int64 v7; // rbx
  char *result; // rax
  __int64 v9; // [rsp+8h] [rbp-40h] BYREF
  _BYTE *v10; // [rsp+10h] [rbp-38h]
  __int64 v11; // [rsp+18h] [rbp-30h]

  <&[u8] as alloc::ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl(&v9, a2, a3);
  v5 = v9;
  if ( v9 == 0x8000000000000000LL )
  {
    v6 = v10;
    v7 = v11;
    result = (char *)a4(a1, aRustc9b00956e5, v10, v11);
    *v6 = 0;
    if ( v7 )
      return (char *)_rust_dealloc(v6, v7, 1LL);
  }
  else
  {
    result = ptr;
    a1[1] = ptr;
    *a1 = 2LL;
    if ( v5 )
      return (char *)_rust_dealloc(v10, v5, 1LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (0000000000006FE0) ----------------------------------------------------
int __fastcall std::sys::pal::common::small_c_string::run_with_cstr_allocating(
        __int64 a1,
        const void *a2,
        size_t a3,
        __int64 *a4)
{
  __int64 v5; // rsi
  const char *v6; // r14
  __int64 v7; // rbx
  char *v8; // rax
  __int64 v10; // [rsp+8h] [rbp-40h] BYREF
  const char *v11; // [rsp+10h] [rbp-38h]
  __int64 v12; // [rsp+18h] [rbp-30h]

  <&[u8] as alloc::ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl(&v10, a2, a3);
  v5 = v10;
  if ( v10 == 0x8000000000000000LL )
  {
    v6 = v11;
    v7 = v12;
    LODWORD(v8) = std::sys::pal::unix::fs::File::open_c(a1, v11, *a4);
    *v6 = 0;
    if ( v7 )
      LODWORD(v8) = _rust_dealloc(v6, v7, 1LL);
  }
  else
  {
    v8 = ptr;
    *(_QWORD *)(a1 + 8) = ptr;
    *(_DWORD *)a1 = 1;
    if ( v5 )
      LODWORD(v8) = _rust_dealloc(v11, v5, 1LL);
  }
  return (int)v8;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (00000000000070B0) ----------------------------------------------------
bool std::panicking::panic_count::is_zero_slow_path()
{
  return *(_QWORD *)(__readfsqword(0) - 80) == 0LL;
}

//----- (00000000000070D0) ----------------------------------------------------
__int64 __fastcall std::sys::sync::mutex::futex::Mutex::lock_contended(volatile __int32 *a1)
{
  __int64 result; // rax
  int v2; // ecx
  bool v3; // zf
  int v4; // ecx
  __int64 v5; // [rsp+0h] [rbp-48h]

  LODWORD(result) = *a1;
  if ( *a1 == 1 )
  {
    v2 = -99;
    do
    {
      _mm_pause();
      LODWORD(result) = *a1;
      if ( *a1 != 1 )
        break;
      v3 = v2++ == 0;
    }
    while ( !v3 );
  }
  if ( (_DWORD)result || (result = (unsigned int)_InterlockedCompareExchange(a1, 1, 0), (_DWORD)result) )
  {
    while ( 1 )
    {
      if ( (_DWORD)result != 2 )
      {
        result = (unsigned int)_InterlockedExchange(a1, 2);
        if ( !(_DWORD)result )
          break;
      }
      do
      {
        if ( *a1 != 2 )
          break;
        LODWORD(v5) = -1;
        if ( syscall(202LL, a1, 137LL, 2LL, 0LL, 0LL, v5) >= 0 )
          break;
      }
      while ( *_errno_location() == 4 );
      LODWORD(result) = *a1;
      if ( *a1 == 1 )
      {
        v4 = -99;
        do
        {
          _mm_pause();
          LODWORD(result) = *a1;
          if ( *a1 != 1 )
            break;
          v3 = v4++ == 0;
        }
        while ( !v3 );
      }
    }
  }
  return result;
}
// 716F: conditional instruction was optimized away because %var_38.8==0
// 7191: variable 'v5' is possibly undefined

//----- (00000000000071D0) ----------------------------------------------------
__int64 __fastcall std::sys::sync::once::futex::Once::call(_QWORD **a1)
{
  __int64 result; // rax
  int v2; // ett
  _BYTE *v3; // rcx
  __int64 v4; // rax
  __int64 v5; // [rsp+0h] [rbp-78h]
  char v6; // [rsp+8h] [rbp-70h] BYREF
  _QWORD **v7; // [rsp+10h] [rbp-68h]
  __int64 v8[3]; // [rsp+18h] [rbp-60h] BYREF
  __int128 v9; // [rsp+30h] [rbp-48h]

  v7 = a1;
  result = (unsigned int)dword_5B0E0;
  while ( 2 )
  {
    switch ( (int)result )
    {
      case 0:
      case 1:
        v2 = result;
        result = (unsigned int)_InterlockedCompareExchange(&dword_5B0E0, 2, result);
        if ( v2 != (_DWORD)result )
          continue;
        v3 = (_BYTE *)**v7;
        v4 = (*v7)[1];
        **v7 = 0LL;
        if ( !v3 )
          core::option::unwrap_failed((__int64)&off_58DC8);
        *v3 = 1;
        *(_OWORD *)(v4 + 16) = 0LL;
        *(_OWORD *)v4 = 0LL;
        *(_QWORD *)(v4 + 32) = 1LL;
        *(_QWORD *)(v4 + 40) = 0LL;
        *(_BYTE *)(v4 + 48) = 0;
        result = (unsigned int)_InterlockedExchange(&dword_5B0E0, 4);
        if ( (_DWORD)result == 3 )
          return syscall(202LL, &dword_5B0E0, 129LL, 0x7FFFFFFFLL);
        return result;
      case 2:
        result = (unsigned int)_InterlockedCompareExchange(&dword_5B0E0, 3, 2);
        if ( (_DWORD)result == 2 )
          goto LABEL_7;
        continue;
      case 3:
LABEL_7:
        v8[0] = 0LL;
        do
        {
          if ( dword_5B0E0 != 3 )
            break;
          LODWORD(v5) = -1;
          if ( syscall(202LL, &dword_5B0E0, 137LL, 3LL, v8[0], 0LL, v5) >= 0 )
            break;
        }
        while ( *_errno_location() == 4 );
        result = (unsigned int)dword_5B0E0;
        continue;
      case 4:
        return result;
      default:
        v8[0] = (__int64)&off_59390;
        v8[1] = 1LL;
        v8[2] = (__int64)&v6;
        v9 = 0LL;
        core::panicking::panic_fmt((__int64)v8, (__int64)&off_58DB0);
    }
  }
}
// 7283: conditional instruction was optimized away because %var_60.8==0
// 72A5: variable 'v5' is possibly undefined
// 58DB0: using guessed type char *off_58DB0;
// 58DC8: using guessed type char *off_58DC8;
// 59390: using guessed type char *off_59390;
// 5B0E0: using guessed type int dword_5B0E0;

//----- (00000000000073C0) ----------------------------------------------------
__int64 __fastcall std::sys::sync::once::futex::Once::call(__int64 **a1)
{
  __int64 result; // rax
  int v2; // ett
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // [rsp+0h] [rbp-78h]
  char v6; // [rsp+8h] [rbp-70h] BYREF
  __int64 **v7; // [rsp+10h] [rbp-68h]
  __int64 v8[3]; // [rsp+18h] [rbp-60h] BYREF
  __int128 v9; // [rsp+30h] [rbp-48h]

  v7 = a1;
  result = (unsigned int)dword_5B0A0;
  while ( 2 )
  {
    switch ( (int)result )
    {
      case 0:
      case 1:
        v2 = result;
        result = (unsigned int)_InterlockedCompareExchange(&dword_5B0A0, 2, result);
        if ( v2 != (_DWORD)result )
          continue;
        v3 = **v7;
        **v7 = 0LL;
        if ( !v3 )
          core::option::unwrap_failed((__int64)&off_58DC8);
        v4 = _rust_alloc(0x2000LL, 1LL);
        if ( !v4 )
          alloc::alloc::handle_alloc_error(1LL, 0x2000LL);
        *(_DWORD *)v3 = 0;
        *(_BYTE *)(v3 + 4) = 0;
        *(_QWORD *)(v3 + 8) = v4;
        *(_QWORD *)(v3 + 16) = 0x2000LL;
        *(_OWORD *)(v3 + 24) = 0LL;
        *(_QWORD *)(v3 + 40) = 0LL;
        result = (unsigned int)_InterlockedExchange(&dword_5B0A0, 4);
        if ( (_DWORD)result == 3 )
          return syscall(202LL, &dword_5B0A0, 129LL, 0x7FFFFFFFLL);
        return result;
      case 2:
        result = (unsigned int)_InterlockedCompareExchange(&dword_5B0A0, 3, 2);
        if ( (_DWORD)result == 2 )
          goto LABEL_7;
        continue;
      case 3:
LABEL_7:
        v8[0] = 0LL;
        do
        {
          if ( dword_5B0A0 != 3 )
            break;
          LODWORD(v5) = -1;
          if ( syscall(202LL, &dword_5B0A0, 137LL, 3LL, v8[0], 0LL, v5) >= 0 )
            break;
        }
        while ( *_errno_location() == 4 );
        result = (unsigned int)dword_5B0A0;
        continue;
      case 4:
        return result;
      default:
        v8[0] = (__int64)&off_59390;
        v8[1] = 1LL;
        v8[2] = (__int64)&v6;
        v9 = 0LL;
        core::panicking::panic_fmt((__int64)v8, (__int64)&off_58DB0);
    }
  }
}
// 7473: conditional instruction was optimized away because %var_60.8==0
// 7495: variable 'v5' is possibly undefined
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 58DB0: using guessed type char *off_58DB0;
// 58DC8: using guessed type char *off_58DC8;
// 59390: using guessed type char *off_59390;
// 5B0A0: using guessed type int dword_5B0A0;

//----- (00000000000075E0) ----------------------------------------------------
__int64 __fastcall std::sys::sync::once::futex::Once::call(_BYTE **a1)
{
  __int64 result; // rax
  bool v2; // zf
  __int64 v3; // rbx
  unsigned __int64 v4; // rax
  size_t v5; // r14
  __int64 v6; // r15
  unsigned __int64 v7; // rcx
  int v8; // edx
  const char *v9; // rax
  __int64 v10; // [rsp+0h] [rbp-88h]
  char v11; // [rsp+Fh] [rbp-79h] BYREF
  char v12; // [rsp+10h] [rbp-78h] BYREF
  struct sigaltstack v13[2]; // [rsp+18h] [rbp-70h] BYREF
  _BYTE **v14; // [rsp+48h] [rbp-40h]
  unsigned __int64 v15[7]; // [rsp+50h] [rbp-38h] BYREF

  v14 = a1;
  LODWORD(result) = std::rt::cleanup::CLEANUP;
  while ( 2 )
  {
    result = (unsigned int)result;
    switch ( (int)result )
    {
      case 0:
        LODWORD(result) = _InterlockedCompareExchange(&std::rt::cleanup::CLEANUP, 2, 0);
        if ( (_DWORD)result )
          continue;
        v2 = **v14 == 0;
        **v14 = 0;
        if ( v2 )
          core::option::unwrap_failed((__int64)&off_58D98);
        v11 = 0;
        if ( dword_5B0E0 != 4 )
          std::sync::once_lock::OnceLock<T>::initialize((__int64)&v11);
        if ( v11 )
          goto LABEL_16;
        v7 = __readfsqword(0);
        if ( std::io::stdio::STDOUT == v7 - 31 )
        {
          v8 = dword_5B0B4 + 1;
          if ( dword_5B0B4 == -1 )
            goto LABEL_16;
        }
        else
        {
          v8 = 1;
          if ( _InterlockedCompareExchange(&dword_5B0B0, 1, 0) )
            goto LABEL_16;
          std::io::stdio::STDOUT = v7 - 31;
        }
        dword_5B0B4 = v8;
        v13[0].ss_sp = 0LL;
        *(_QWORD *)&v13[0].ss_flags = 1LL;
        v13[0].ss_size = 0LL;
        LOBYTE(v13[1].ss_sp) = 0;
        if ( qword_5B0B8 )
          core::cell::panic_already_borrowed((__int64)&off_58AA0);
        qword_5B0B8 = -1LL;
        if ( !byte_5B0D8 )
        {
          v15[0] = std::io::buffered::bufwriter::BufWriter<W>::flush_buf((__int64)&xmmword_5B0C0);
          if ( v15[0] )
            core::ptr::drop_in_place<std::io::error::Error>((__int64 *)v15);
        }
        if ( (_QWORD)xmmword_5B0C0 )
          _rust_dealloc(*((_QWORD *)&xmmword_5B0C0 + 1), xmmword_5B0C0, 1LL);
        unk_5B0D0 = *(_OWORD *)&v13[0].ss_size;
        xmmword_5B0C0 = *(_OWORD *)&v13[0].ss_sp;
        ++qword_5B0B8;
        if ( !--dword_5B0B4 )
        {
          std::io::stdio::STDOUT = 0LL;
          if ( _InterlockedExchange(&dword_5B0B0, 0) == 2 )
            syscall(202LL, &dword_5B0B0, 129LL, 1LL);
        }
LABEL_16:
        v3 = std::sys::pal::unix::stack_overflow::imp::MAIN_ALTSTACK;
        if ( std::sys::pal::unix::stack_overflow::imp::MAIN_ALTSTACK )
        {
          v4 = getauxval(0x33uLL);
          v5 = 0x2000LL;
          if ( v4 >= 0x2001 )
            v5 = v4;
          v6 = sysconf(30);
          v13[0].ss_sp = 0LL;
          v13[0].ss_flags = 2;
          v13[0].ss_size = v5;
          sigaltstack(v13, 0LL);
          munmap((void *)(v3 - v6), v6 + v5);
        }
        result = (unsigned int)_InterlockedExchange(&std::rt::cleanup::CLEANUP, 4);
        if ( (_DWORD)result == 3 )
          return syscall(202LL, &std::rt::cleanup::CLEANUP, 129LL, 0x7FFFFFFFLL);
        return result;
      case 1:
        v13[0].ss_sp = &off_59380;
        *(_QWORD *)&v13[0].ss_flags = 1LL;
        v9 = aRustc9b00956e5;
        goto LABEL_39;
      case 2:
        LODWORD(result) = _InterlockedCompareExchange(&std::rt::cleanup::CLEANUP, 3, 2);
        if ( (_DWORD)result == 2 )
          goto LABEL_7;
        continue;
      case 3:
LABEL_7:
        v13[0].ss_sp = 0LL;
        do
        {
          if ( std::rt::cleanup::CLEANUP != 3 )
            break;
          LODWORD(v10) = -1;
          if ( syscall(202LL, &std::rt::cleanup::CLEANUP, 137LL, 3LL, v13[0].ss_sp, 0LL, v10) >= 0 )
            break;
        }
        while ( *_errno_location() == 4 );
        LODWORD(result) = std::rt::cleanup::CLEANUP;
        continue;
      case 4:
        return result;
      default:
        v13[0].ss_sp = &off_59390;
        *(_QWORD *)&v13[0].ss_flags = 1LL;
        v9 = &v12;
LABEL_39:
        v13[0].ss_size = (size_t)v9;
        *(_OWORD *)&v13[1].ss_sp = 0LL;
        core::panicking::panic_fmt((__int64)v13, (__int64)&off_58900);
    }
  }
}
// 7693: conditional instruction was optimized away because %var_70.8==0
// 76B5: variable 'v10' is possibly undefined
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 58900: using guessed type char *off_58900;
// 58AA0: using guessed type char *off_58AA0;
// 58D98: using guessed type char *off_58D98;
// 59380: using guessed type char *off_59380;
// 59390: using guessed type char *off_59390;
// 5B064: using guessed type int std::rt::cleanup::CLEANUP;
// 5B0A8: using guessed type __int64 std::io::stdio::STDOUT;
// 5B0B0: using guessed type int dword_5B0B0;
// 5B0B4: using guessed type int dword_5B0B4;
// 5B0B8: using guessed type __int64 qword_5B0B8;
// 5B0C0: using guessed type __int128 xmmword_5B0C0;
// 5B0D8: using guessed type char byte_5B0D8;
// 5B0E0: using guessed type int dword_5B0E0;
// 5B150: using guessed type __int64 std::sys::pal::unix::stack_overflow::imp::MAIN_ALTSTACK;
// 75E0: using guessed type unsigned __int64 var_38[7];

//----- (0000000000007A10) ----------------------------------------------------
__int64 __fastcall std::sys::sync::once::futex::Once::call(__int64 **a1)
{
  __int64 result; // rax
  int v2; // ett
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // [rsp+0h] [rbp-78h]
  char v6; // [rsp+8h] [rbp-70h] BYREF
  __int64 **v7; // [rsp+10h] [rbp-68h]
  __int64 v8[3]; // [rsp+18h] [rbp-60h] BYREF
  __int128 v9; // [rsp+30h] [rbp-48h]

  v7 = a1;
  result = (unsigned int)dword_5B0E0;
  while ( 2 )
  {
    switch ( (int)result )
    {
      case 0:
      case 1:
        v2 = result;
        result = (unsigned int)_InterlockedCompareExchange(&dword_5B0E0, 2, result);
        if ( v2 != (_DWORD)result )
          continue;
        v3 = **v7;
        **v7 = 0LL;
        if ( !v3 )
          core::option::unwrap_failed((__int64)&off_58DC8);
        v4 = _rust_alloc(1024LL, 1LL);
        if ( !v4 )
          alloc::alloc::handle_alloc_error(1LL, 1024LL);
        *(_OWORD *)v3 = 0LL;
        *(_QWORD *)(v3 + 16) = 0LL;
        *(_QWORD *)(v3 + 24) = 1024LL;
        *(_QWORD *)(v3 + 32) = v4;
        *(_QWORD *)(v3 + 40) = 0LL;
        *(_BYTE *)(v3 + 48) = 0;
        result = (unsigned int)_InterlockedExchange(&dword_5B0E0, 4);
        if ( (_DWORD)result == 3 )
          return syscall(202LL, &dword_5B0E0, 129LL, 0x7FFFFFFFLL);
        return result;
      case 2:
        result = (unsigned int)_InterlockedCompareExchange(&dword_5B0E0, 3, 2);
        if ( (_DWORD)result == 2 )
          goto LABEL_7;
        continue;
      case 3:
LABEL_7:
        v8[0] = 0LL;
        do
        {
          if ( dword_5B0E0 != 3 )
            break;
          LODWORD(v5) = -1;
          if ( syscall(202LL, &dword_5B0E0, 137LL, 3LL, v8[0], 0LL, v5) >= 0 )
            break;
        }
        while ( *_errno_location() == 4 );
        result = (unsigned int)dword_5B0E0;
        continue;
      case 4:
        return result;
      default:
        v8[0] = (__int64)&off_59390;
        v8[1] = 1LL;
        v8[2] = (__int64)&v6;
        v9 = 0LL;
        core::panicking::panic_fmt((__int64)v8, (__int64)&off_58DB0);
    }
  }
}
// 7AC3: conditional instruction was optimized away because %var_60.8==0
// 7AE5: variable 'v5' is possibly undefined
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 58DB0: using guessed type char *off_58DB0;
// 58DC8: using guessed type char *off_58DC8;
// 59390: using guessed type char *off_59390;
// 5B0E0: using guessed type int dword_5B0E0;

//----- (0000000000007C40) ----------------------------------------------------
__int64 __fastcall std::sys::sync::rwlock::futex::RwLock::read_contended(volatile signed __int32 *a1)
{
  __int64 result; // rax
  int v2; // ecx
  bool v3; // zf
  int v4; // ett
  unsigned int v5; // ecx
  unsigned int v6; // ebp
  int v7; // ett
  int v8; // ecx
  __int64 v9; // [rsp+0h] [rbp-68h]
  __int64 v10[3]; // [rsp+10h] [rbp-58h] BYREF
  __int128 v11; // [rsp+28h] [rbp-40h]

  LODWORD(result) = *a1;
  if ( *a1 == 0x3FFFFFFF )
  {
    v2 = -99;
    do
    {
      _mm_pause();
      LODWORD(result) = *a1;
      if ( *a1 != 0x3FFFFFFF )
        break;
      v3 = v2++ == 0;
    }
    while ( !v3 );
  }
  do
  {
    while ( 1 )
    {
      v5 = result & 0x3FFFFFFF;
      if ( (unsigned int)result <= 0x3FFFFFFF && v5 < 0x3FFFFFFE )
        break;
      if ( v5 == 1073741822 )
      {
        v10[0] = (__int64)&off_593A0;
        v10[1] = 1LL;
        v10[2] = (__int64)aRustc9b00956e5;
        v11 = 0LL;
        core::panicking::panic_fmt((__int64)v10, (__int64)&off_593B0);
      }
      if ( (result & 0x40000000) != 0 )
      {
        v6 = result;
        goto LABEL_14;
      }
      v6 = result | 0x40000000;
      v7 = result;
      LODWORD(result) = _InterlockedCompareExchange(a1, result | 0x40000000, result);
      if ( v7 == (_DWORD)result )
      {
LABEL_14:
        v10[0] = 0LL;
        do
        {
          if ( *a1 != v6 )
            break;
          LODWORD(v9) = -1;
          if ( syscall(202LL, a1, 137LL, v6, v10[0], 0LL, v9) >= 0 )
            break;
        }
        while ( *_errno_location() == 4 );
        LODWORD(result) = *a1;
        if ( *a1 == 0x3FFFFFFF )
        {
          v8 = -99;
          do
          {
            _mm_pause();
            LODWORD(result) = *a1;
            if ( *a1 != 0x3FFFFFFF )
              break;
            v3 = v8++ == 0;
          }
          while ( !v3 );
        }
      }
    }
    v4 = result;
    result = (unsigned int)_InterlockedCompareExchange(a1, result + 1, result);
  }
  while ( v4 != (_DWORD)result );
  return result;
}
// 7CFE: conditional instruction was optimized away because %var_58.8==0
// 7D1D: variable 'v9' is possibly undefined
// 593A0: using guessed type char *off_593A0;
// 593B0: using guessed type char *off_593B0;

//----- (0000000000007DB0) ----------------------------------------------------
void __fastcall std::sys::sync::rwlock::futex::RwLock::wake_writer_or_readers(
        volatile signed __int32 *a1,
        signed __int32 a2)
{
  signed __int32 v2; // eax

  if ( (a2 & 0x3FFFFFFF) != 0 )
    core::panicking::panic((__int64)aAssertionFaile_3, 36LL, (__int64)&off_593C8);
  if ( a2 == 0x80000000 )
  {
    v2 = _InterlockedCompareExchange(a1, 0, 0x80000000);
    if ( v2 == 0x80000000 )
    {
      _InterlockedIncrement(a1 + 1);
      syscall(202LL, a1 + 1, 129LL, 1LL);
      return;
    }
    a2 = v2;
  }
  if ( a2 != -1073741824 )
  {
    if ( a2 != 0x40000000 )
      return;
    goto LABEL_8;
  }
  if ( _InterlockedCompareExchange(a1, 0x40000000, -1073741824) == -1073741824 )
  {
    _InterlockedIncrement(a1 + 1);
    if ( syscall(202LL, a1 + 1, 129LL, 1LL) <= 0 )
    {
LABEL_8:
      if ( _InterlockedCompareExchange(a1, 0, 0x40000000) == 0x40000000 )
        syscall(202LL, a1, 129LL, 0x7FFFFFFFLL);
    }
  }
}
// 593C8: using guessed type char *off_593C8;

//----- (0000000000007E90) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 *a1, __int64 a2, __int64 a3)
{
  bool v3; // cf
  unsigned __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // r14
  __int64 v7; // rax
  __int64 result; // rax
  __int64 v9; // [rsp+8h] [rbp-40h] BYREF
  __int64 v10; // [rsp+10h] [rbp-38h]
  __int64 v11; // [rsp+18h] [rbp-30h]
  __int64 v12[5]; // [rsp+20h] [rbp-28h] BYREF

  v3 = __CFADD__(a3, a2);
  v4 = a3 + a2;
  if ( v3 )
    goto LABEL_12;
  v5 = *a1;
  if ( 2 * *a1 > v4 )
    v4 = 2 * *a1;
  v6 = 8LL;
  if ( v4 >= 9 )
    v6 = v4;
  if ( v5 )
  {
    v12[0] = a1[1];
    v12[2] = v5;
    v7 = 1LL;
  }
  else
  {
    v7 = 0LL;
  }
  v12[1] = v7;
  alloc::raw_vec::finish_grow(&v9, v6 >= 0, v6, v12);
  if ( v9 )
  {
    if ( v10 )
      alloc::alloc::handle_alloc_error(v10, v11);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v10;
  a1[1] = v10;
  *a1 = v6;
  return result;
}

//----- (0000000000007F40) ----------------------------------------------------
void __fastcall __noreturn core::panicking::assert_failed(__int64 a1, __int128 *a2)
{
  __int64 v2; // [rsp+8h] [rbp-10h] BYREF
  void *v3; // [rsp+10h] [rbp-8h] BYREF

  v2 = a1;
  v3 = &unk_49400;
  core::panicking::assert_failed_inner(
    1,
    (__int64)&v2,
    (__int64)&off_595E0,
    (__int64)&v3,
    (__int64)&off_595E0,
    a2,
    (__int64)&off_59678);
}
// 595E0: using guessed type __int64 (__fastcall *off_595E0)();
// 59678: using guessed type char *off_59678;

//----- (0000000000007F90) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(__int64 *a1, __int64 a2, __int64 a3)
{
  bool v3; // cf
  unsigned __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // r14
  __int64 v7; // rax
  __int64 result; // rax
  __int64 v9; // [rsp+8h] [rbp-40h] BYREF
  __int64 v10; // [rsp+10h] [rbp-38h]
  __int64 v11; // [rsp+18h] [rbp-30h]
  __int64 v12[5]; // [rsp+20h] [rbp-28h] BYREF

  v3 = __CFADD__(a3, a2);
  v4 = a3 + a2;
  if ( v3 )
    goto LABEL_12;
  v5 = *a1;
  if ( 2 * *a1 > v4 )
    v4 = 2 * *a1;
  v6 = 8LL;
  if ( v4 >= 9 )
    v6 = v4;
  if ( v5 )
  {
    v12[0] = a1[1];
    v12[2] = v5;
    v7 = 1LL;
  }
  else
  {
    v7 = 0LL;
  }
  v12[1] = v7;
  alloc::raw_vec::finish_grow(&v9, v6 >= 0, v6, v12);
  if ( v9 )
  {
    if ( v10 )
      alloc::alloc::handle_alloc_error(v10, v11);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v10;
  a1[1] = v10;
  *a1 = v6;
  return result;
}

//----- (0000000000008040) ----------------------------------------------------
void __fastcall __noreturn alloc::alloc::handle_alloc_error(__int64 a1, __int64 a2)
{
  _rust_alloc_error_handler(a2, a1);
}
// 9B50: using guessed type void __fastcall __noreturn _rust_alloc_error_handler(_QWORD, _QWORD);

//----- (0000000000008050) ----------------------------------------------------
void __fastcall __noreturn core::cell::panic_already_borrowed(__int64 a1)
{
  char v1; // [rsp+7h] [rbp-41h] BYREF
  __int64 v2[2]; // [rsp+8h] [rbp-40h] BYREF
  __int64 v3[6]; // [rsp+18h] [rbp-30h] BYREF

  v2[0] = (__int64)&v1;
  v2[1] = (__int64)<core::cell::BorrowMutError as core::fmt::Debug>::fmt;
  v3[0] = (__int64)&off_5A248;
  v3[1] = 1LL;
  v3[4] = 0LL;
  v3[2] = (__int64)v2;
  v3[3] = 1LL;
  core::panicking::panic_fmt((__int64)v3, a1);
}
// 5A248: using guessed type void *off_5A248;

//----- (00000000000080B0) ----------------------------------------------------
void __fastcall __noreturn core::option::unwrap_failed(__int64 a1)
{
  core::panicking::panic((__int64)aCalledOptionUn, 43LL, a1);
}

//----- (00000000000080D0) ----------------------------------------------------
void __fastcall __noreturn core::option::expect_failed(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3[2]; // [rsp+8h] [rbp-10h] BYREF

  v3[0] = a1;
  v3[1] = a2;
  core::panicking::panic_display((__int64)v3, a3);
}

//----- (00000000000080F0) ----------------------------------------------------
void __fastcall __noreturn core::panicking::panic_fmt(__int64 a1, __int64 a2)
{
  __int64 v2[4]; // [rsp+0h] [rbp-28h] BYREF
  __int16 v3; // [rsp+20h] [rbp-8h]

  v2[0] = (__int64)&unk_4C8A8;
  v2[1] = (__int64)&off_5A298;
  v2[2] = a1;
  v2[3] = a2;
  v3 = 1;
  rust_begin_unwind((__int64)v2);
}
// 5A298: using guessed type __int64 (__fastcall *off_5A298)();

//----- (0000000000008130) ----------------------------------------------------
void __fastcall __noreturn core::panicking::panic_nounwind_fmt(__int128 *a1, char a2, __int64 a3)
{
  __int128 v3; // xmm0
  __int128 v4; // xmm1
  __int64 v5[4]; // [rsp+8h] [rbp-60h] BYREF
  char v6; // [rsp+28h] [rbp-40h]
  char v7; // [rsp+29h] [rbp-3Fh]
  __int128 v8[3]; // [rsp+30h] [rbp-38h] BYREF

  v3 = *a1;
  v4 = a1[1];
  v8[2] = a1[2];
  v8[1] = v4;
  v8[0] = v3;
  v5[0] = (__int64)&unk_4C8A8;
  v5[1] = (__int64)&off_5A298;
  v5[2] = (__int64)v8;
  v5[3] = a3;
  v6 = 0;
  v7 = a2;
  rust_begin_unwind((__int64)v5);
}
// 5A298: using guessed type __int64 (__fastcall *off_5A298)();

//----- (00000000000081A0) ----------------------------------------------------
void __fastcall __noreturn core::panicking::panic(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3[2]; // [rsp+8h] [rbp-40h] BYREF
  __int64 v4[3]; // [rsp+18h] [rbp-30h] BYREF
  __int128 v5; // [rsp+30h] [rbp-18h]

  v3[0] = a1;
  v3[1] = a2;
  v4[0] = (__int64)v3;
  v4[1] = 1LL;
  v4[2] = (__int64)&unk_4C8A8;
  v5 = 0LL;
  core::panicking::panic_fmt((__int64)v4, a3);
}

//----- (00000000000081F0) ----------------------------------------------------
void __fastcall __noreturn core::panicking::panic_nounwind(__int64 a1, __int64 a2)
{
  __int64 v2[2]; // [rsp+8h] [rbp-40h] BYREF
  __int128 v3; // [rsp+18h] [rbp-30h] BYREF
  void *v4; // [rsp+28h] [rbp-20h]
  __int128 v5; // [rsp+30h] [rbp-18h]

  v2[0] = a1;
  v2[1] = a2;
  *(_QWORD *)&v3 = v2;
  *((_QWORD *)&v3 + 1) = 1LL;
  v4 = &unk_4C8A8;
  v5 = 0LL;
  core::panicking::panic_nounwind_fmt(&v3, 0, (__int64)&off_5A2B8);
}
// 5A2B8: using guessed type char *off_5A2B8;

//----- (0000000000008240) ----------------------------------------------------
void __fastcall __noreturn core::panicking::panic_nounwind_nobacktrace(__int64 a1, __int64 a2)
{
  __int64 v2[2]; // [rsp+8h] [rbp-40h] BYREF
  __int128 v3; // [rsp+18h] [rbp-30h] BYREF
  void *v4; // [rsp+28h] [rbp-20h]
  __int128 v5; // [rsp+30h] [rbp-18h]

  v2[0] = a1;
  v2[1] = a2;
  *(_QWORD *)&v3 = v2;
  *((_QWORD *)&v3 + 1) = 1LL;
  v4 = &unk_4C8A8;
  v5 = 0LL;
  core::panicking::panic_nounwind_fmt(&v3, 1, (__int64)&off_5A2D0);
}
// 5A2D0: using guessed type char *off_5A2D0;

//----- (0000000000008290) ----------------------------------------------------
void __fastcall __noreturn core::panicking::panic_bounds_check(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // [rsp+8h] [rbp-60h] BYREF
  __int64 v4; // [rsp+10h] [rbp-58h] BYREF
  __int64 v5[4]; // [rsp+18h] [rbp-50h] BYREF
  __int64 v6[6]; // [rsp+38h] [rbp-30h] BYREF

  v3 = a1;
  v4 = a2;
  v5[0] = (__int64)&v4;
  v5[1] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v5[2] = (__int64)&v3;
  v5[3] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v6[0] = (__int64)&off_5A2E8;
  v6[1] = 2LL;
  v6[4] = 0LL;
  v6[2] = (__int64)v5;
  v6[3] = 2LL;
  core::panicking::panic_fmt((__int64)v6, a3);
}
// 5A2E8: using guessed type void *off_5A2E8;

//----- (0000000000008310) ----------------------------------------------------
void __noreturn core::panicking::panic_cannot_unwind()
{
  core::panicking::panic_nounwind((__int64)aPanicInAFuncti, 38LL);
}
// 8310: using guessed type void __noreturn core::panicking::panic_cannot_unwind();

//----- (0000000000008330) ----------------------------------------------------
void __noreturn core::panicking::panic_in_cleanup()
{
  core::panicking::panic_nounwind_nobacktrace((__int64)aPanicInADestru, 36LL);
}
// 8330: using guessed type void __noreturn core::panicking::panic_in_cleanup();

//----- (0000000000008350) ----------------------------------------------------
void __fastcall __noreturn core::panicking::assert_failed_inner(
        char a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int128 *a6,
        __int64 a7)
{
  void *v7; // rax
  __int64 v8; // rsi
  __int128 v9; // xmm0
  __int128 v10; // xmm1
  void *v11; // [rsp+0h] [rbp-D8h] BYREF
  __int64 v12; // [rsp+8h] [rbp-D0h]
  __int64 v13[2]; // [rsp+10h] [rbp-C8h] BYREF
  __int64 v14[2]; // [rsp+20h] [rbp-B8h] BYREF
  void **v15; // [rsp+30h] [rbp-A8h] BYREF
  char (__fastcall *v16)(__int64, __int64); // [rsp+38h] [rbp-A0h]
  __int64 *v17; // [rsp+40h] [rbp-98h]
  void *v18; // [rsp+48h] [rbp-90h]
  __int64 *v19; // [rsp+50h] [rbp-88h]
  __int64 (__fastcall *v20)(_QWORD *); // [rsp+58h] [rbp-80h]
  __int64 *v21; // [rsp+60h] [rbp-78h]
  __int64 (__fastcall *v22)(_QWORD *); // [rsp+68h] [rbp-70h]
  char **v23; // [rsp+70h] [rbp-68h] BYREF
  __int64 v24; // [rsp+78h] [rbp-60h]
  __int64 *v25; // [rsp+80h] [rbp-58h]
  __int64 v26; // [rsp+88h] [rbp-50h]
  __int64 v27; // [rsp+90h] [rbp-48h]
  __int128 v28[3]; // [rsp+A0h] [rbp-38h] BYREF

  v13[0] = a2;
  v13[1] = a3;
  v14[0] = a4;
  v14[1] = a5;
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      v11 = &unk_4CA75;
      v8 = a7;
      v12 = 7LL;
      if ( !*(_QWORD *)a6 )
      {
LABEL_6:
        v15 = &v11;
        v16 = <&T as core::fmt::Display>::fmt;
        v17 = v13;
        v18 = <&T as core::fmt::Debug>::fmt;
        v19 = v14;
        v20 = <&T as core::fmt::Debug>::fmt;
        v23 = &off_5A308;
        v24 = 3LL;
        v27 = 0LL;
        v25 = (__int64 *)&v15;
        v26 = 3LL;
        core::panicking::panic_fmt((__int64)&v23, v8);
      }
LABEL_8:
      v9 = *a6;
      v10 = a6[1];
      v28[2] = a6[2];
      v28[1] = v10;
      v28[0] = v9;
      v15 = &v11;
      v16 = <&T as core::fmt::Display>::fmt;
      v17 = (__int64 *)v28;
      v18 = <core::fmt::Arguments as core::fmt::Display>::fmt;
      v19 = v13;
      v20 = <&T as core::fmt::Debug>::fmt;
      v21 = v14;
      v22 = <&T as core::fmt::Debug>::fmt;
      v23 = &off_5A338;
      v24 = 4LL;
      v27 = 0LL;
      v25 = (__int64 *)&v15;
      v26 = 4LL;
      core::panicking::panic_fmt((__int64)&v23, v8);
    }
    v7 = &unk_4CA73;
  }
  else
  {
    v7 = &unk_4CA71;
  }
  v11 = v7;
  v8 = a7;
  v12 = 2LL;
  if ( !*(_QWORD *)a6 )
    goto LABEL_6;
  goto LABEL_8;
}
// 5A308: using guessed type char *off_5A308;
// 5A338: using guessed type char *off_5A338;

//----- (0000000000008510) ----------------------------------------------------
void __fastcall __noreturn core::result::unwrap_failed(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5[2]; // [rsp+8h] [rbp-70h] BYREF
  __int64 v6[2]; // [rsp+18h] [rbp-60h] BYREF
  __int64 v7[4]; // [rsp+28h] [rbp-50h] BYREF
  __int64 v8[6]; // [rsp+48h] [rbp-30h] BYREF

  v5[0] = a1;
  v5[1] = a2;
  v6[0] = a3;
  v6[1] = a4;
  v7[0] = (__int64)v5;
  v7[1] = (__int64)<&T as core::fmt::Display>::fmt;
  v7[2] = (__int64)v6;
  v7[3] = (__int64)<&T as core::fmt::Debug>::fmt;
  v8[0] = (__int64)&off_5A378;
  v8[1] = 2LL;
  v8[4] = 0LL;
  v8[2] = (__int64)v7;
  v8[3] = 2LL;
  core::panicking::panic_fmt((__int64)v8, a5);
}
// 5A378: using guessed type void *off_5A378;

//----- (00000000000085A0) ----------------------------------------------------
void __fastcall __noreturn core::slice::index::slice_start_index_len_fail(__int64 a1, __int64 a2, __int64 a3)
{
  core::slice::index::slice_start_index_len_fail_rt(a1, a2, a3);
}

//----- (00000000000085B0) ----------------------------------------------------
void __fastcall __noreturn core::slice::index::slice_end_index_len_fail(__int64 a1, __int64 a2, __int64 a3)
{
  core::slice::index::slice_end_index_len_fail_rt(a1, a2, a3);
}

//----- (00000000000085C0) ----------------------------------------------------
void __fastcall __noreturn core::slice::index::slice_index_order_fail(__int64 a1, __int64 a2, __int64 a3)
{
  core::slice::index::slice_index_order_fail_rt(a1, a2, a3);
}

//----- (00000000000085D0) ----------------------------------------------------
void __fastcall __noreturn core::slice::index::slice_end_index_overflow_fail(__int64 a1)
{
  __int64 v1[3]; // [rsp+8h] [rbp-30h] BYREF
  __int128 v2; // [rsp+20h] [rbp-18h]

  v1[0] = (__int64)&off_5A4A8;
  v1[1] = 1LL;
  v1[2] = (__int64)&unk_4C8A8;
  v2 = 0LL;
  core::panicking::panic_fmt((__int64)v1, a1);
}
// 5A4A8: using guessed type char *off_5A4A8;

//----- (0000000000008610) ----------------------------------------------------
void __fastcall __noreturn core::slice::<impl [T]>::copy_from_slice::len_mismatch_fail(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  __int64 v3; // [rsp+8h] [rbp-60h] BYREF
  __int64 v4; // [rsp+10h] [rbp-58h] BYREF
  __int64 v5[4]; // [rsp+18h] [rbp-50h] BYREF
  __int64 v6[6]; // [rsp+38h] [rbp-30h] BYREF

  v3 = a1;
  v4 = a2;
  v5[0] = (__int64)&v4;
  v5[1] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v5[2] = (__int64)&v3;
  v5[3] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v6[0] = (__int64)&off_5A4B8;
  v6[1] = 3LL;
  v6[4] = 0LL;
  v6[2] = (__int64)v5;
  v6[3] = 2LL;
  core::panicking::panic_fmt((__int64)v6, a3);
}
// 5A4B8: using guessed type char *off_5A4B8;

//----- (0000000000008690) ----------------------------------------------------
void __fastcall __noreturn core::str::traits::str_index_overflow_fail(__int64 a1)
{
  __int64 v1[3]; // [rsp+8h] [rbp-30h] BYREF
  __int128 v2; // [rsp+20h] [rbp-18h]

  v1[0] = (__int64)&off_5A4E8;
  v1[1] = 1LL;
  v1[2] = (__int64)&unk_4C8A8;
  v2 = 0LL;
  core::panicking::panic_fmt((__int64)v1, a1);
}
// 5A4E8: using guessed type char *off_5A4E8;

//----- (00000000000086D0) ----------------------------------------------------
void __fastcall __noreturn core::str::slice_error_fail(
        _BYTE *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5)
{
  core::str::slice_error_fail_rt(a1, a2, a3, a4, a5);
}

//----- (00000000000086E0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, 0LL, 0LL, a3, &v5);
  __halt();
}
// 86EA: positive sp value 8 has been found
// 86F1: variable 'v3' is possibly undefined

//----- (0000000000008710) ----------------------------------------------------
char *deregister_tm_clones()
{
  return &_bss_start;
}
// 5B060: using guessed type char _bss_start;

//----- (0000000000008740) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0LL;
}

//----- (0000000000008780) ----------------------------------------------------
char *_do_global_dtors_aux()
{
  char *result; // rax

  if ( !_bss_start )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = deregister_tm_clones();
    _bss_start = 1;
  }
  return result;
}
// 5B060: using guessed type char _bss_start;

//----- (00000000000087C0) ----------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}
// 87C0: using guessed type __int64 frame_dummy();

//----- (00000000000087D0) ----------------------------------------------------
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm4,xmm5> std::sys_common::backtrace::__rust_begin_short_backtrace(
        void (*a1)(void))
{
  a1();
}

//----- (00000000000087E0) ----------------------------------------------------
__int64 __fastcall std::rt::lang_start::{{closure}}(void (**a1)(void))
{
  std::sys_common::backtrace::__rust_begin_short_backtrace(*a1);
  return 0LL;
}

//----- (00000000000087F0) ----------------------------------------------------
__int64 __fastcall core::ops::function::FnOnce::call_once{{vtable.shim}}(void (**a1)(void))
{
  std::sys_common::backtrace::__rust_begin_short_backtrace(*a1);
  return 0LL;
}

//----- (0000000000008800) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<std::io::error::Error>(__int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // rcx
  __int64 v3; // rbx
  __int64 v4; // r14
  __int64 v5; // r12
  __int64 v6; // rsi

  result = *a1;
  v2 = *a1 & 3;
  if ( (unsigned __int64)(v2 - 2) >= 2 && v2 )
  {
    v3 = result - 1;
    v4 = *(_QWORD *)(result - 1);
    v5 = *(_QWORD *)(result + 7);
    (*(void (__fastcall **)(__int64))v5)(v4);
    v6 = *(_QWORD *)(v5 + 8);
    if ( v6 )
      _rust_dealloc(v4, v6, *(_QWORD *)(v5 + 16));
    return _rust_dealloc(v3, 24LL, 8LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (00000000000088C0) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 result; // rax

  if ( !a2 )
  {
    a1[1] = 0LL;
    goto LABEL_10;
  }
  if ( a4[1] )
  {
    v6 = a4[2];
    if ( v6 )
    {
      v7 = _rust_realloc(*a4, v6, a2, a3);
      if ( v7 )
        goto LABEL_5;
      goto LABEL_8;
    }
  }
  if ( !a3 )
  {
    v7 = a2;
    goto LABEL_5;
  }
  v7 = _rust_alloc(a3, a2);
  if ( !v7 )
  {
LABEL_8:
    a1[1] = a2;
    a1[2] = a3;
LABEL_10:
    result = 1LL;
    goto LABEL_11;
  }
LABEL_5:
  a1[1] = v7;
  a1[2] = a3;
  result = 0LL;
LABEL_11:
  *a1 = result;
  return result;
}
// 8949: conditional instruction was optimized away because r15.8!=0
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000008950) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 >> 60 == 0);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 8 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 8 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (0000000000008A10) ----------------------------------------------------
char __fastcall <alloc::string::String as core::fmt::Display>::fmt(__int64 a1, __int64 a2)
{
  return <str as core::fmt::Display>::fmt(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), a2);
}

//----- (0000000000008A30) ----------------------------------------------------
void __noreturn safe::main()
{
  __int64 v0; // rcx
  __int64 v1; // rsi
  __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v4; // rsi
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rsi
  __int64 v9; // rsi
  char **v10; // rdx
  __int64 v11; // r12
  __int64 v12; // rsi
  __int64 v13; // r12
  __int64 v14; // rax
  __int64 v15; // r12
  __int64 v16; // rax
  __int64 v17; // r12
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // r12
  __int64 v21; // r12
  __int64 v22; // r12
  char **v23; // [rsp+0h] [rbp-128h] BYREF
  __int64 v24; // [rsp+8h] [rbp-120h]
  char **v25; // [rsp+10h] [rbp-118h]
  __int128 v26; // [rsp+18h] [rbp-110h]
  __int64 v27; // [rsp+28h] [rbp-100h]
  char v28; // [rsp+30h] [rbp-F8h]
  char v29[7]; // [rsp+31h] [rbp-F7h]
  __int64 v30; // [rsp+38h] [rbp-F0h] BYREF
  __int64 v31; // [rsp+40h] [rbp-E8h]
  __int64 v32; // [rsp+48h] [rbp-E0h]
  char **v33; // [rsp+50h] [rbp-D8h] BYREF
  __int64 v34; // [rsp+58h] [rbp-D0h]
  char **v35; // [rsp+60h] [rbp-C8h]
  __int64 v36; // [rsp+68h] [rbp-C0h]
  char ***v37; // [rsp+70h] [rbp-B8h]
  __int64 v38; // [rsp+78h] [rbp-B0h]
  char *v39; // [rsp+80h] [rbp-A8h] BYREF
  void *v40; // [rsp+88h] [rbp-A0h]
  int fd[2]; // [rsp+90h] [rbp-98h] BYREF
  char v42[64]; // [rsp+98h] [rbp-90h] BYREF
  char v43[16]; // [rsp+D8h] [rbp-50h] BYREF
  char v44[16]; // [rsp+E8h] [rbp-40h] BYREF

  strcpy(v42, "never gonna giveyou up never gonna let you down secret.txt");
  v30 = 0LL;
  v31 = 8LL;
  v32 = 0LL;
  strcpy(v43, "flag.txt");
  strcpy(v44, "real_flag.txt");
  alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v30, 0LL);
  v0 = v31;
  v1 = v32;
  *(_QWORD *)(v31 + 8 * v32) = v44;
  v2 = v1 + 1;
  v32 = v2;
  v3 = v30;
  if ( v2 == v30 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v30, v2);
    v2 = v32;
    v3 = v30;
    v0 = v31;
  }
  *(_QWORD *)(v0 + 8 * v2) = v43;
  v4 = v2 + 1;
  v32 = v4;
  if ( v4 == v3 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v30, v3);
    v0 = v31;
    v4 = v32;
  }
  *(_QWORD *)(v0 + 8 * v4) = "isthistherightone.txt";
  v5 = v4 + 1;
  v32 = v5;
  v6 = v30;
  if ( v5 == v30 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v30, v5);
    v6 = v30;
    v5 = v32;
  }
  v7 = v31;
  *(_QWORD *)(v31 + 8 * v5) = &v42[48];
  v8 = v5 + 1;
  v32 = v8;
  if ( v8 == v6 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v30, v6);
    v8 = v32;
    v6 = v30;
    v7 = v31;
  }
  *(_QWORD *)(v7 + 8 * v8) = 0x674E316874306ELL;
  v9 = v8 + 1;
  v32 = v9;
  if ( v9 == v6 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v30, v6);
    v7 = v31;
    v9 = v32;
  }
  *(_QWORD *)(v7 + 8 * v9) = &unk_47099;
  v32 = v9 + 1;
  while ( 1 )
  {
    while ( 1 )
    {
      safe::get_input_num((__int64)&v33, (__int64)aHiSelect1OfThe, 110LL);
      if ( !(_BYTE)v33 )
        break;
      v23 = &off_58110;
      v24 = 1LL;
      v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
      v26 = 0LL;
      std::io::stdio::_print(&v23);
    }
    switch ( v34 )
    {
      case 0LL:
        v23 = (char **)0x1B600000000LL;
        WORD2(v24) = 0;
        LODWORD(v24) = 1;
        std::fs::OpenOptions::_open((__int64)&v33, (__int64)&v23, aSecretTxt, 0xAuLL);
        if ( (_DWORD)v33 )
        {
          v23 = (char **)v34;
          core::result::unwrap_failed(
            (__int64)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt",
            43LL,
            (__int64)&v23,
            (__int64)&off_580D0,
            (__int64)&off_58210);
        }
        fd[0] = HIDWORD(v33);
        v33 = 0LL;
        v34 = 1LL;
        v35 = 0LL;
        if ( <std::fs::File as std::io::Read>::read_to_string(fd, (__int64 *)&v33) )
        {
          v23 = v10;
          core::result::unwrap_failed(
            (__int64)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt",
            43LL,
            (__int64)&v23,
            (__int64)&off_580D0,
            (__int64)&off_58228);
        }
        v39 = (char *)&v33;
        v40 = <alloc::string::String as core::fmt::Display>::fmt;
        v23 = &off_58240;
        v24 = 2LL;
        v25 = &v39;
        v26 = 1uLL;
        std::io::stdio::_print(&v23);
        if ( v33 )
          _rust_dealloc(v34, v33, 1LL);
        close(fd[0]);
        break;
      case 1LL:
        while ( 1 )
        {
          safe::get_input_num((__int64)&v33, (__int64)aSelectSource1R, 49LL);
          if ( !(_BYTE)v33 && (unsigned __int64)(v34 - 3) >= 0xFFFFFFFFFFFFFFFELL )
            break;
          v23 = &off_58110;
          v24 = 1LL;
          v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
          v26 = 0LL;
          std::io::stdio::_print(&v23);
        }
        if ( v34 == 1 )
        {
          while ( 1 )
          {
            safe::get_src_reg((__int64)&v33);
            if ( !(_BYTE)v33 )
            {
              v17 = v34;
              if ( (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
                break;
            }
            v23 = &off_58110;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
          while ( 1 )
          {
            safe::get_dst_reg((__int64)&v33);
            if ( !(_BYTE)v33 )
            {
              v18 = v34;
              if ( (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
                break;
            }
            v23 = &off_58110;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
          v22 = *(_QWORD *)&fd[2 * v17];
        }
        else
        {
          while ( 1 )
          {
            safe::get_src_imm((__int64)&v33);
            if ( !(_BYTE)v33 )
              break;
            v23 = &off_58130;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
          v22 = v34;
          while ( 1 )
          {
            safe::get_dst_reg((__int64)&v33);
            if ( !(_BYTE)v33 )
            {
              v18 = v34;
              if ( (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
                break;
            }
            v23 = &off_58110;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
        }
        *(_QWORD *)&fd[2 * v18] += v22;
        break;
      case 2LL:
        while ( 1 )
        {
          safe::get_input_num((__int64)&v33, (__int64)aSelectSource1R, 49LL);
          if ( !(_BYTE)v33 && (unsigned __int64)(v34 - 3) >= 0xFFFFFFFFFFFFFFFELL )
            break;
          v23 = &off_58110;
          v24 = 1LL;
          v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
          v26 = 0LL;
          std::io::stdio::_print(&v23);
        }
        if ( v34 == 1 )
        {
          while ( 1 )
          {
            safe::get_src_reg((__int64)&v33);
            if ( !(_BYTE)v33 )
            {
              v13 = v34;
              if ( (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
                break;
            }
            v23 = &off_58110;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
          while ( 1 )
          {
            safe::get_dst_reg((__int64)&v33);
            if ( !(_BYTE)v33 )
            {
              v14 = v34;
              if ( (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
                break;
            }
            v23 = &off_58110;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
          v20 = *(_QWORD *)&fd[2 * v13];
        }
        else
        {
          while ( 1 )
          {
            safe::get_src_imm((__int64)&v33);
            if ( !(_BYTE)v33 )
              break;
            v23 = &off_58130;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
          v20 = v34;
          while ( 1 )
          {
            safe::get_dst_reg((__int64)&v33);
            if ( !(_BYTE)v33 )
            {
              v14 = v34;
              if ( (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
                break;
            }
            v23 = &off_58110;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
        }
        *(_QWORD *)&fd[2 * v14] &= v20;
        break;
      case 3LL:
        while ( 1 )
        {
          safe::get_input_num((__int64)&v33, (__int64)aSelectSource1R, 49LL);
          if ( !(_BYTE)v33 && (unsigned __int64)(v34 - 3) >= 0xFFFFFFFFFFFFFFFELL )
            break;
          v23 = &off_58110;
          v24 = 1LL;
          v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
          v26 = 0LL;
          std::io::stdio::_print(&v23);
        }
        if ( v34 == 1 )
        {
          while ( 1 )
          {
            safe::get_src_reg((__int64)&v33);
            if ( !(_BYTE)v33 )
            {
              v15 = v34;
              if ( (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
                break;
            }
            v23 = &off_58110;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
          while ( 1 )
          {
            safe::get_dst_reg((__int64)&v33);
            if ( !(_BYTE)v33 )
            {
              v16 = v34;
              if ( (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
                break;
            }
            v23 = &off_58110;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
          v21 = *(_QWORD *)&fd[2 * v15];
        }
        else
        {
          while ( 1 )
          {
            safe::get_src_imm((__int64)&v33);
            if ( !(_BYTE)v33 )
              break;
            v23 = &off_58130;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
          v21 = v34;
          while ( 1 )
          {
            safe::get_dst_reg((__int64)&v33);
            if ( !(_BYTE)v33 )
            {
              v16 = v34;
              if ( (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
                break;
            }
            v23 = &off_58110;
            v24 = 1LL;
            v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
            v26 = 0LL;
            std::io::stdio::_print(&v23);
          }
        }
        *(_QWORD *)&fd[2 * v16] ^= v21;
        break;
      case 4LL:
        while ( 1 )
        {
          safe::get_register((__int64)&v33);
          if ( !(_BYTE)v33 && (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
            break;
          v23 = &off_58110;
          v24 = 1LL;
          v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
          v26 = 0LL;
          std::io::stdio::_print(&v23);
        }
        v11 = *(_QWORD *)&fd[2 * v34];
        v12 = v32;
        if ( v32 == v30 )
        {
          alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v30, v32);
          v12 = v32;
        }
        *(_QWORD *)(v31 + 8 * v12) = v11;
        v32 = v12 + 1;
        break;
      case 5LL:
        while ( 1 )
        {
          safe::get_register((__int64)&v33);
          if ( !(_BYTE)v33 && (unsigned __int64)(v34 - 7) >= 0xFFFFFFFFFFFFFFFALL )
            break;
          v23 = &off_58110;
          v24 = 1LL;
          v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
          v26 = 0LL;
          std::io::stdio::_print(&v23);
        }
        v19 = v32;
        if ( v32 )
        {
          --v32;
          *(_QWORD *)&fd[2 * v34] = *(_QWORD *)(v31 + 8 * v19 - 8);
        }
        else
        {
          v23 = &off_58120;
          v24 = 1LL;
          v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
          v26 = 0LL;
          std::io::stdio::_print(&v23);
        }
        break;
      case 6LL:
        __asm { syscall; LINUX - }
        break;
      case 7LL:
        v23 = &off_58140;
        v24 = 1LL;
        v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
        v26 = 0LL;
        std::io::stdio::_print(&v23);
        v39 = v42;
        v40 = core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt;
        v23 = (char **)(&dword_0 + 2);
        v25 = 0LL;
        v26 = 0x12uLL;
        v27 = 0xC00000020LL;
        v28 = 3;
        v33 = &off_58150;
        v34 = 2LL;
        v37 = &v23;
        v38 = 1LL;
        v35 = &v39;
        v36 = 1LL;
        std::io::stdio::_print(&v33);
        v39 = &v42[8];
        v40 = core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt;
        v23 = (char **)(&dword_0 + 2);
        v25 = 0LL;
        v26 = 0x12uLL;
        v27 = 0xC00000020LL;
        v28 = 3;
        v33 = &off_58170;
        v34 = 2LL;
        v37 = &v23;
        v38 = 1LL;
        v35 = &v39;
        v36 = 1LL;
        std::io::stdio::_print(&v33);
        v39 = &v42[16];
        v40 = core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt;
        v23 = (char **)(&dword_0 + 2);
        v25 = 0LL;
        v26 = 0x12uLL;
        v27 = 0xC00000020LL;
        v28 = 3;
        v33 = &off_58190;
        v34 = 2LL;
        v37 = &v23;
        v38 = 1LL;
        v35 = &v39;
        v36 = 1LL;
        std::io::stdio::_print(&v33);
        v39 = &v42[24];
        v40 = core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt;
        v23 = (char **)(&dword_0 + 2);
        v25 = 0LL;
        v26 = 0x12uLL;
        v27 = 0xC00000020LL;
        v28 = 3;
        v33 = &off_581B0;
        v34 = 2LL;
        v37 = &v23;
        v38 = 1LL;
        v35 = &v39;
        v36 = 1LL;
        std::io::stdio::_print(&v33);
        v39 = &v42[32];
        v40 = core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt;
        v23 = (char **)(&dword_0 + 2);
        v25 = 0LL;
        v26 = 0x12uLL;
        v27 = 0xC00000020LL;
        v28 = 3;
        *(_DWORD *)&v29[3] = *(int *)((char *)fd + 3);
        *(_DWORD *)v29 = fd[0];
        v33 = &off_581D0;
        v34 = 2LL;
        v37 = &v23;
        v38 = 1LL;
        v35 = &v39;
        v36 = 1LL;
        std::io::stdio::_print(&v33);
        v39 = &v42[40];
        v40 = core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt;
        v23 = (char **)(&dword_0 + 2);
        v25 = 0LL;
        v26 = 0x12uLL;
        v27 = 0xC00000020LL;
        v28 = 3;
        *(_DWORD *)&v29[3] = *(int *)((char *)fd + 3);
        *(_DWORD *)v29 = fd[0];
        v33 = &off_581F0;
        v34 = 2LL;
        v37 = &v23;
        v38 = 1LL;
        v35 = &v39;
        v36 = 1LL;
        std::io::stdio::_print(&v33);
        break;
      case 8LL:
        v23 = &off_58260;
        v24 = 1LL;
        v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
        v26 = 0LL;
        std::io::stdio::_print(&v23);
        std::process::exit(0);
      default:
        v23 = &off_580F0;
        v24 = 1LL;
        v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
        v26 = 0LL;
        std::io::stdio::_print(&v23);
        break;
    }
    v23 = (char **)&off_58100;
    v24 = 1LL;
    v25 = (char **)"called `Result::unwrap()` on an `Err` valueisthistherightone.txt";
    v26 = 0LL;
    std::io::stdio::_print(&v23);
  }
}
// 9A0D: variable 'v10' is possibly undefined
// 0: using guessed type int dword_0;
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 580D0: using guessed type __int64 (__fastcall *off_580D0)();
// 580F0: using guessed type char *off_580F0;
// 58110: using guessed type char *off_58110;
// 58120: using guessed type char *off_58120;
// 58130: using guessed type char *off_58130;
// 58140: using guessed type char *off_58140;
// 58150: using guessed type char *off_58150;
// 58170: using guessed type char *off_58170;
// 58190: using guessed type char *off_58190;
// 581B0: using guessed type char *off_581B0;
// 581D0: using guessed type char *off_581D0;
// 581F0: using guessed type char *off_581F0;
// 58210: using guessed type char *off_58210;
// 58228: using guessed type char *off_58228;
// 58240: using guessed type char *off_58240;
// 58260: using guessed type char *off_58260;

//----- (0000000000009AE0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp) {
  void (__noreturn *v4)(); // [rsp+0h] [rbp-8h] BYREF

  v4 = safe::main;
  return std::rt::lang_start_internal((__int64)&v4, (__int64)&off_580A0, argc, (__int64)argv, 0);
}
// 580A0: using guessed type __int64 (__fastcall *off_580A0)();

//----- (0000000000009B60) ----------------------------------------------------
char __fastcall <&T as core::fmt::Display>::fmt(__int64 a1, __int64 a2)
{
  return <str as core::fmt::Display>::fmt(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), a2);
}

//----- (0000000000009B80) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<std::io::error::Error>(__int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // rcx
  __int64 v3; // rbx
  __int64 v4; // r14
  __int64 v5; // r12
  __int64 v6; // rsi

  result = *a1;
  v2 = *a1 & 3;
  if ( (unsigned __int64)(v2 - 2) >= 2 && v2 )
  {
    v3 = result - 1;
    v4 = *(_QWORD *)(result - 1);
    v5 = *(_QWORD *)(result + 7);
    (*(void (__fastcall **)(__int64))v5)(v4);
    v6 = *(_QWORD *)(v5 + 8);
    if ( v6 )
      _rust_dealloc(v4, v6, *(_QWORD *)(v5 + 16));
    return _rust_dealloc(v3, 24LL, 8LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (0000000000009C30) ----------------------------------------------------
unsigned __int8 *__fastcall core::str::<impl str>::trim_matches(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int8 *v3; // rdi
  unsigned __int8 *v4; // rdx
  unsigned __int8 *v5; // rsi
  char v6; // r9
  char v7; // r9
  unsigned __int8 *v8; // r10
  unsigned __int8 *v9; // rcx
  unsigned int v10; // r9d
  int v11; // edx
  int v12; // ebx
  int v13; // r11d
  unsigned int v14; // r10d
  char v15; // r11
  char v16; // r11
  unsigned __int8 *v17; // r10
  unsigned int v18; // r11d
  char v19; // bl
  char v20; // bp
  int v21; // ebp
  int v22; // ebx
  unsigned int v23; // ebx

  v3 = &a1[a2];
  if ( !a2 )
  {
    v5 = a1;
    v9 = 0LL;
    if ( a1 != v3 )
      goto LABEL_37;
    return &a1[(_QWORD)v9];
  }
  v4 = 0LL;
  v5 = a1;
  while ( 1 )
  {
    v8 = v5;
    v9 = v4;
    v10 = *v5;
    if ( (v10 & 0x80u) != 0 )
    {
      v11 = v10 & 0x1F;
      v12 = v5[1] & 0x3F;
      if ( (unsigned __int8)v10 <= 0xDFu )
      {
        v5 += 2;
        v10 = v12 | (v11 << 6);
      }
      else
      {
        v13 = (v12 << 6) | v5[2] & 0x3F;
        if ( (unsigned __int8)v10 < 0xF0u )
        {
          v5 += 3;
          v10 = (v11 << 12) | v13;
          goto LABEL_15;
        }
        v5 += 4;
        v10 = ((v10 & 7) << 18) | (v13 << 6) | v8[3] & 0x3F;
        if ( v10 == 1114112 )
        {
          v9 = 0LL;
          if ( v5 == v3 )
            return &a1[(_QWORD)v9];
LABEL_37:
          while ( 2 )
          {
            v17 = v3;
            v18 = *(v3 - 1);
            if ( (v18 & 0x80u) != 0 )
            {
              v19 = *(v3 - 2);
              if ( v19 >= -64 )
              {
                v3 -= 2;
                v22 = v19 & 0x1F;
              }
              else
              {
                v20 = *(v3 - 3);
                if ( v20 > -65 )
                {
                  v3 -= 3;
                  v21 = v20 & 0xF;
                }
                else
                {
                  v3 -= 4;
                  v21 = ((*(v17 - 4) & 7) << 6) | v20 & 0x3F;
                }
                v22 = (v21 << 6) | v19 & 0x3F;
              }
              v18 = (v22 << 6) | v18 & 0x3F;
              if ( v18 == 1114112 )
                return &a1[(_QWORD)v9];
            }
            else
            {
              --v3;
            }
            if ( v18 - 9 >= 5 && v18 != 32 )
            {
              if ( v18 < 0x80 )
                return &a1[(_QWORD)v9];
              v23 = v18 >> 8;
              if ( v18 >> 8 <= 0x1F )
              {
                if ( v23 )
                {
                  if ( v23 != 22 )
                    return &a1[(_QWORD)v9];
                  v16 = v18 == 5760;
                  goto LABEL_35;
                }
                v15 = core::unicode::unicode_data::white_space::WHITESPACE_MAP[(unsigned __int8)v18];
LABEL_34:
                v16 = v15 & 1;
                goto LABEL_35;
              }
              if ( v23 == 32 )
              {
                v15 = core::unicode::unicode_data::white_space::WHITESPACE_MAP[(unsigned __int8)v18] >> 1;
                goto LABEL_34;
              }
              if ( v23 != 48 )
                return &a1[(_QWORD)v9];
              v16 = v18 == 12288;
LABEL_35:
              if ( !v16 )
                return &a1[(_QWORD)v9];
            }
            if ( v5 == v3 )
              return &a1[(_QWORD)v9];
            continue;
          }
        }
      }
    }
    else
    {
      ++v5;
    }
LABEL_15:
    v4 = &v9[v5 - v8];
    if ( v10 - 9 >= 5 && v10 != 32 )
      break;
LABEL_6:
    if ( v5 == v3 )
    {
      v9 = 0LL;
      return &a1[(_QWORD)v9];
    }
  }
  if ( v10 < 0x80 )
    goto LABEL_29;
  v14 = v10 >> 8;
  if ( v10 >> 8 <= 0x1F )
  {
    if ( v14 )
    {
      if ( v14 != 22 )
        goto LABEL_29;
      v7 = v10 == 5760;
      goto LABEL_5;
    }
    v6 = core::unicode::unicode_data::white_space::WHITESPACE_MAP[(unsigned __int8)v10];
LABEL_4:
    v7 = v6 & 1;
LABEL_5:
    if ( !v7 )
      goto LABEL_29;
    goto LABEL_6;
  }
  if ( v14 == 32 )
  {
    v6 = core::unicode::unicode_data::white_space::WHITESPACE_MAP[(unsigned __int8)v10] >> 1;
    goto LABEL_4;
  }
  if ( v14 == 48 )
  {
    v7 = v10 == 12288;
    goto LABEL_5;
  }
LABEL_29:
  if ( v5 != v3 )
    goto LABEL_37;
  return &a1[(_QWORD)v9];
}
// 4D767: using guessed type _BYTE core::unicode::unicode_data::white_space::WHITESPACE_MAP[256];

//----- (0000000000009EE0) ----------------------------------------------------
__int64 __fastcall safe::get_input(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v6[2]; // [rsp+8h] [rbp-60h] BYREF
  __int128 v7; // [rsp+18h] [rbp-50h] BYREF
  __int64 *v8; // [rsp+28h] [rbp-40h]
  __int64 v9; // [rsp+30h] [rbp-38h]
  __int64 v10; // [rsp+38h] [rbp-30h]
  volatile signed __int32 *v11; // [rsp+48h] [rbp-20h] BYREF
  __int64 v12[3]; // [rsp+50h] [rbp-18h] BYREF

  v12[0] = a2;
  v12[1] = a3;
  v6[0] = (__int64)v12;
  v6[1] = (__int64)<&T as core::fmt::Display>::fmt;
  *(_QWORD *)&v7 = &off_58290;
  *((_QWORD *)&v7 + 1) = 1LL;
  v10 = 0LL;
  v8 = v6;
  v9 = 1LL;
  std::io::stdio::_print(&v7);
  v6[0] = (__int64)std::io::stdio::stdout((__int64)&v7);
  v3 = <std::io::stdio::Stdout as std::io::Write>::flush(v6);
  if ( v3 )
  {
    *(_QWORD *)&v7 = v3;
    core::result::unwrap_failed(
      (__int64)aCalledResultUn_1,
      43LL,
      (__int64)&v7,
      (__int64)&off_58270,
      (__int64)&off_582A0);
  }
  *(_QWORD *)&v7 = 0LL;
  *((_QWORD *)&v7 + 1) = 1LL;
  v8 = 0LL;
  v11 = (volatile signed __int32 *)std::io::stdio::stdin((__int64)v6);
  if ( std::io::stdio::Stdin::read_line(&v11, (__int64 *)&v7) )
  {
    v6[0] = v4;
    core::result::unwrap_failed((__int64)aCalledResultUn_1, 43LL, (__int64)v6, (__int64)&off_58270, (__int64)&off_582B8);
  }
  *(_QWORD *)(a1 + 16) = v8;
  *(_OWORD *)a1 = v7;
  return a1;
}
// 9FE0: variable 'v4' is possibly undefined
// 58270: using guessed type __int64 (__fastcall *off_58270)();
// 58290: using guessed type char *off_58290;
// 582A0: using guessed type char *off_582A0;
// 582B8: using guessed type char *off_582B8;

//----- (000000000000A070) ----------------------------------------------------
__int64 __fastcall safe::get_input_num(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int8 *v3; // rbx
  unsigned __int8 *v4; // rax
  unsigned __int64 v5; // rdx
  __int64 v7; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int8 *v8; // [rsp+8h] [rbp-20h]
  __int64 v9; // [rsp+10h] [rbp-18h]

  safe::get_input((__int64)&v7, a2, a3);
  v3 = v8;
  v4 = core::str::<impl str>::trim_matches(v8, v9);
  core::num::<impl core::str::traits::FromStr for usize>::from_str(a1, v4, v5);
  if ( v7 )
    _rust_dealloc(v3, v7, 1LL);
  return a1;
}
// A09B: variable 'v5' is possibly undefined
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000A0F0) ----------------------------------------------------
__int64 __fastcall safe::get_register(__int64 a1)
{
  unsigned __int8 *v1; // r14
  unsigned __int8 *v2; // rax
  unsigned __int64 v3; // rdx
  __int64 v5; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int8 *v6; // [rsp+8h] [rbp-20h]
  __int64 v7; // [rsp+10h] [rbp-18h]

  safe::get_input((__int64)&v5, (__int64)aSelectRegister, 62LL);
  v1 = v6;
  v2 = core::str::<impl str>::trim_matches(v6, v7);
  core::num::<impl core::str::traits::FromStr for usize>::from_str(a1, v2, v3);
  if ( v5 )
    _rust_dealloc(v1, v5, 1LL);
  return a1;
}
// A127: variable 'v3' is possibly undefined
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000A180) ----------------------------------------------------
__int64 __fastcall safe::get_src_reg(__int64 a1)
{
  unsigned __int8 *v1; // r14
  unsigned __int8 *v2; // rax
  unsigned __int64 v3; // rdx
  __int64 v5; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int8 *v6; // [rsp+8h] [rbp-20h]
  __int64 v7; // [rsp+10h] [rbp-18h]

  safe::get_input((__int64)&v5, (__int64)aSelectSourceRe, 69LL);
  v1 = v6;
  v2 = core::str::<impl str>::trim_matches(v6, v7);
  core::num::<impl core::str::traits::FromStr for usize>::from_str(a1, v2, v3);
  if ( v5 )
    _rust_dealloc(v1, v5, 1LL);
  return a1;
}
// A1B7: variable 'v3' is possibly undefined
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000A210) ----------------------------------------------------
__int64 __fastcall safe::get_dst_reg(__int64 a1)
{
  unsigned __int8 *v1; // r14
  unsigned __int8 *v2; // rax
  unsigned __int64 v3; // rdx
  __int64 v5; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int8 *v6; // [rsp+8h] [rbp-20h]
  __int64 v7; // [rsp+10h] [rbp-18h]

  safe::get_input((__int64)&v5, (__int64)aSelectDestinat, 74LL);
  v1 = v6;
  v2 = core::str::<impl str>::trim_matches(v6, v7);
  core::num::<impl core::str::traits::FromStr for usize>::from_str(a1, v2, v3);
  if ( v5 )
    _rust_dealloc(v1, v5, 1LL);
  return a1;
}
// A247: variable 'v3' is possibly undefined
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000A2A0) ----------------------------------------------------
__int64 __fastcall safe::get_src_imm(__int64 a1)
{
  unsigned __int8 *v1; // r14
  unsigned __int8 *v2; // rax
  unsigned __int64 v3; // rdx
  __int64 v5; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int8 *v6; // [rsp+8h] [rbp-20h]
  __int64 v7; // [rsp+10h] [rbp-18h]

  safe::get_input((__int64)&v5, (__int64)aEnterValueInHe, 54LL);
  v1 = v6;
  v2 = core::str::<impl str>::trim_matches(v6, v7);
  core::num::<impl usize>::from_str_radix(a1, v2, v3, 0x10u);
  if ( v5 )
    _rust_dealloc(v1, v5, 1LL);
  return a1;
}
// A2DC: variable 'v3' is possibly undefined
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000A330) ----------------------------------------------------
__int64 <T as core::any::Any>::type_id()
{
  return 0x1D879E542ED896BELL;
}
// A330: using guessed type __int64 <T as core::any::Any>::type_id();

//----- (000000000000A350) ----------------------------------------------------
unsigned __int64 <T as core::any::Any>::type_id()
{
  return 0xDAF1A5398DFFA0D6LL;
}

//----- (000000000000A370) ----------------------------------------------------
unsigned __int64 <T as core::any::Any>::type_id()
{
  return 0xFDBC168100B1EF64LL;
}

//----- (000000000000A390) ----------------------------------------------------
char __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return <str as core::fmt::Debug>::fmt(*(unsigned __int8 **)a1, *(_QWORD *)(a1 + 8), a2);
}

//----- (000000000000A3B0) ----------------------------------------------------
char __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  __int64 v2; // r12
  __int64 v3; // r13
  __int64 v5; // [rsp+0h] [rbp-48h] BYREF
  char v6[64]; // [rsp+8h] [rbp-40h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
  core::fmt::Formatter::debug_list((__int64)v6, a2);
  for ( ; v3; --v3 )
  {
    v5 = v2++;
    core::fmt::builders::DebugList::entry(v6, (__int64)&v5, (__int64)&off_58310);
  }
  return core::fmt::builders::DebugList::finish(v6);
}
// 58310: using guessed type __int64 (__fastcall *off_58310)();

//----- (000000000000A430) ----------------------------------------------------
bool __fastcall <&T as core::fmt::Debug>::fmt(_QWORD **a1, __int64 a2)
{
  __int64 v3; // [rsp+10h] [rbp-8h] BYREF

  return core::fmt::Formatter::debug_tuple_field2_finish(
           a2,
           (__int64)&unk_49368,
           8LL,
           **a1 + 24LL,
           (__int64)&off_58728,
           (__int64)&v3,
           (__int64)&off_58748);
}
// 58728: using guessed type __int64 (__fastcall *off_58728)();
// 58748: using guessed type __int64 (__fastcall *off_58748)();

//----- (000000000000A480) ----------------------------------------------------
__int64 __fastcall <&T as core::fmt::Debug>::fmt(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rdi
  int v3; // eax

  v2 = *a1;
  v3 = *(_DWORD *)(a2 + 52);
  if ( (v3 & 0x10) != 0 )
    return core::fmt::num::<impl core::fmt::LowerHex for u8>::fmt(v2, a2);
  if ( (v3 & 0x20) != 0 )
    return core::fmt::num::<impl core::fmt::UpperHex for u8>::fmt(v2, a2);
  return core::fmt::num::imp::<impl core::fmt::Display for u8>::fmt(v2, a2);
}

//----- (000000000000A4A0) ----------------------------------------------------
char __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return core::fmt::Formatter::pad(a2, (__int64)asc_48E6A, 2uLL);
}

//----- (000000000000A4C0) ----------------------------------------------------
__int64 __fastcall <&T as core::fmt::Debug>::fmt(_QWORD **a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))((*a1)[1] + 24LL))(**a1);
}

//----- (000000000000A4D0) ----------------------------------------------------
__int64 __fastcall <&T as core::fmt::Debug>::fmt(unsigned int **a1, __int64 a2)
{
  unsigned int *v2; // rdi
  int v3; // eax

  v2 = *a1;
  v3 = *(_DWORD *)(a2 + 52);
  if ( (v3 & 0x10) != 0 )
    return core::fmt::num::<impl core::fmt::LowerHex for u32>::fmt(v2, a2);
  if ( (v3 & 0x20) != 0 )
    return core::fmt::num::<impl core::fmt::UpperHex for u32>::fmt(v2, a2);
  return core::fmt::num::imp::<impl core::fmt::Display for i32>::fmt((int *)v2, a2);
}

//----- (000000000000A4F0) ----------------------------------------------------
char __fastcall <&T as core::fmt::Display>::fmt(__int64 a1, __int64 a2)
{
  return <str as core::fmt::Display>::fmt(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), a2);
}

//----- (000000000000A510) ----------------------------------------------------
char __fastcall <&T as core::fmt::Display>::fmt(__int64 *a1, __int64 a2)
{
  return <core::panic::location::Location as core::fmt::Display>::fmt(*a1, a2);
}

//----- (000000000000A520) ----------------------------------------------------
__int64 __fastcall core::fmt::num::<impl core::fmt::Debug for i32>::fmt(int *a1, __int64 a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 52);
  if ( (v2 & 0x10) != 0 )
    return core::fmt::num::<impl core::fmt::LowerHex for u32>::fmt((unsigned int *)a1, a2);
  if ( (v2 & 0x20) != 0 )
    return core::fmt::num::<impl core::fmt::UpperHex for u32>::fmt((unsigned int *)a1, a2);
  return core::fmt::num::imp::<impl core::fmt::Display for i32>::fmt(a1, a2);
}

//----- (000000000000A540) ----------------------------------------------------
__int64 __fastcall core::fmt::num::<impl core::fmt::Debug for usize>::fmt(unsigned __int64 *a1, __int64 a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 52);
  if ( (v2 & 0x10) != 0 )
    return core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt(a1, a2);
  if ( (v2 & 0x20) != 0 )
    return core::fmt::num::<impl core::fmt::UpperHex for usize>::fmt(a1, a2);
  return core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt(a1, a2);
}

//----- (000000000000A560) ----------------------------------------------------
char __fastcall core::fmt::Write::write_char(__int64 a1, unsigned int a2)
{
  int v3; // [rsp+0h] [rbp-4h] BYREF

  v3 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(v3) = (a2 >> 18) & 7 | 0xF0;
        BYTE1(v3) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(v3) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(v3) = a2 & 0x3F | 0x80;
        return <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(a1, (char *)&v3, 4uLL);
      }
      else
      {
        LOBYTE(v3) = (a2 >> 12) | 0xE0;
        BYTE1(v3) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(v3) = a2 & 0x3F | 0x80;
        return <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(a1, (char *)&v3, 3uLL);
      }
    }
    else
    {
      LOBYTE(v3) = (a2 >> 6) | 0xC0;
      BYTE1(v3) = a2 & 0x3F | 0x80;
      return <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(a1, (char *)&v3, 2uLL);
    }
  }
  else
  {
    LOBYTE(v3) = a2;
    return <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(a1, (char *)&v3, 1uLL);
  }
}

//----- (000000000000A640) ----------------------------------------------------
__int64 __fastcall core::fmt::Write::write_char(__int64 **a1, unsigned int a2)
{
  size_t v2; // rbx
  __int64 *v3; // r14
  __int64 v4; // r15
  int src; // [rsp+Ch] [rbp-1Ch] BYREF

  src = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(src) = (a2 >> 18) & 7 | 0xF0;
        BYTE1(src) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(src) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(src) = a2 & 0x3F | 0x80;
        v2 = 4LL;
      }
      else
      {
        LOBYTE(src) = (a2 >> 12) | 0xE0;
        BYTE1(src) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(src) = a2 & 0x3F | 0x80;
        v2 = 3LL;
      }
    }
    else
    {
      LOBYTE(src) = (a2 >> 6) | 0xC0;
      BYTE1(src) = a2 & 0x3F | 0x80;
      v2 = 2LL;
    }
  }
  else
  {
    LOBYTE(src) = a2;
    v2 = 1LL;
  }
  v3 = *a1;
  v4 = (*a1)[2];
  if ( **a1 - v4 < v2 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(*a1, v4, v2);
    v4 = v3[2];
  }
  memcpy((void *)(v4 + v3[1]), &src, v2);
  v3[2] = v2 + v4;
  return 0LL;
}

//----- (000000000000A750) ----------------------------------------------------
bool __fastcall core::fmt::Write::write_char(__int64 *a1, unsigned int a2)
{
  unsigned __int64 v2; // rdx
  unsigned __int64 v3; // r14
  int v5; // [rsp+Ch] [rbp-1Ch] BYREF

  v5 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(v5) = (a2 >> 18) & 7 | 0xF0;
        BYTE1(v5) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(v5) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(v5) = a2 & 0x3F | 0x80;
        v2 = 4LL;
      }
      else
      {
        LOBYTE(v5) = (a2 >> 12) | 0xE0;
        BYTE1(v5) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(v5) = a2 & 0x3F | 0x80;
        v2 = 3LL;
      }
    }
    else
    {
      LOBYTE(v5) = (a2 >> 6) | 0xC0;
      BYTE1(v5) = a2 & 0x3F | 0x80;
      v2 = 2LL;
    }
  }
  else
  {
    LOBYTE(v5) = a2;
    v2 = 1LL;
  }
  v3 = <std::io::stdio::StdoutLock as std::io::Write>::write_all(*a1, (char *)&v5, v2);
  if ( v3 )
  {
    if ( a1[1] )
      core::ptr::drop_in_place<std::io::error::Error>(a1 + 1);
    a1[1] = v3;
  }
  return v3 != 0;
}

//----- (000000000000A860) ----------------------------------------------------
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2)
{
  return core::fmt::write(a1, (__int64)off_582E0, a2);
}
// 582E0: using guessed type __int64 (__fastcall *off_582E0[2])();

//----- (000000000000A870) ----------------------------------------------------
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2)
{
  return core::fmt::write(a1, (__int64)&off_587D8, a2);
}
// 587D8: using guessed type __int64 (__fastcall *off_587D8)();

//----- (000000000000A880) ----------------------------------------------------
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2)
{
  return core::fmt::write(a1, (__int64)&off_587A8, a2);
}
// 587A8: using guessed type __int64 (__fastcall *off_587A8)();

//----- (000000000000A890) ----------------------------------------------------
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2)
{
  return core::fmt::write(a1, (__int64)&off_58808, a2);
}
// 58808: using guessed type __int64 (__fastcall *off_58808)();

//----- (000000000000A8A0) ----------------------------------------------------
_Unwind_Ptr __fastcall core::ops::function::FnOnce::call_once{{vtable.shim}}(struct _Unwind_Context ***a1)
{
  return Unwind_GetDataRelBase(**a1);
}

//----- (000000000000A8B0) ----------------------------------------------------
_Unwind_Ptr __fastcall core::ops::function::FnOnce::call_once{{vtable.shim}}(struct _Unwind_Context ***a1)
{
  return Unwind_GetTextRelBase(**a1);
}

//----- (000000000000A8E0) ----------------------------------------------------
char __fastcall core::ops::function::FnOnce::call_once{{vtable.shim}}(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14
  __int64 v4; // rcx
  char result; // al
  char v6; // bl
  __int128 v7; // [rsp+10h] [rbp-28h] BYREF
  __int64 v8; // [rsp+20h] [rbp-18h]

  v7 = *(_OWORD *)a3;
  v8 = *(_QWORD *)(a3 + 16);
  v3 = *(_QWORD *)a1;
  v4 = 0LL;
  if ( *(_QWORD *)a1 != 0x8000000000000000LL )
    v4 = a1;
  result = std::sys_common::backtrace::output_filename(a2, (__int64)&v7, *(_DWORD *)(a1 + 24), v4);
  if ( 2 * v3 )
  {
    v6 = result;
    _rust_dealloc(*(_QWORD *)(a1 + 8), v3, 1LL);
    return v6;
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000A970) ----------------------------------------------------
void __fastcall __noreturn core::ops::function::FnOnce::call_once(__int64 a1)
{
  std::rt::lang_start_internal::{{closure}}();
}

//----- (000000000000A980) ----------------------------------------------------
_BYTE *__fastcall core::ptr::drop_in_place<core::result::Result<alloc::ffi::c_str::CString,alloc::ffi::c_str::NulError>>(
        __int64 *a1)
{
  __int64 v1; // rsi
  _BYTE *result; // rax
  __int64 v3; // rsi

  v1 = *a1;
  result = (_BYTE *)0x8000000000000000LL;
  if ( *a1 == 0x8000000000000000LL )
  {
    result = (_BYTE *)a1[1];
    *result = 0;
    v3 = a1[2];
    if ( v3 )
      return (_BYTE *)_rust_dealloc(result, v3, 1LL);
  }
  else if ( v1 )
  {
    return (_BYTE *)_rust_dealloc(a1[1], v1, 1LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000A9E0) ----------------------------------------------------
unsigned __int64 __fastcall core::ptr::drop_in_place<alloc::collections::btree::map::BTreeMap<u64,gimli::read::abbrev::Abbreviation>>(
        __int64 *a1)
{
  __int64 v1; // rcx
  __int64 v2; // rdx
  __int64 v3; // rax
  __int64 v4; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rax
  __int64 v7; // rsi
  unsigned __int64 v8[2]; // [rsp+0h] [rbp-78h] BYREF
  __int64 v9; // [rsp+10h] [rbp-68h]
  __int64 v10[12]; // [rsp+18h] [rbp-60h] BYREF

  v1 = *a1;
  if ( *a1 )
  {
    v2 = a1[1];
    v3 = a1[2];
    v10[1] = 0LL;
    v10[2] = v1;
    v10[3] = v2;
    v10[5] = 0LL;
    v10[6] = v1;
    v10[7] = v2;
    v4 = 1LL;
  }
  else
  {
    v4 = 0LL;
    v3 = 0LL;
  }
  v10[0] = v4;
  v10[4] = v4;
  v10[8] = v3;
  alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(v8, v10);
  for ( result = v8[0]; v8[0]; result = v8[0] )
  {
    if ( *(_QWORD *)(result + 112 * v9) )
    {
      v6 = 112 * v9 + result;
      v7 = *(_QWORD *)(v6 + 8);
      if ( v7 )
        _rust_dealloc(*(_QWORD *)(v6 + 16), 16 * v7, 8LL);
    }
    alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(v8, v10);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000AAB0) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<std::backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>>(
        __int64 *a1)
{
  __int64 v1; // rbx
  __int64 v2; // r15
  _QWORD *v3; // r12
  __int64 v4; // rsi
  __int64 result; // rax

  v1 = a1[1];
  v2 = a1[2];
  if ( v2 )
  {
    v3 = (_QWORD *)(v1 + 8);
    do
    {
      v4 = *(v3 - 1);
      if ( v4 )
        _rust_dealloc(*v3, v4, 1LL);
      v3 += 11;
      --v2;
    }
    while ( v2 );
  }
  result = *a1;
  if ( *a1 )
    return _rust_dealloc(v1, 88 * result, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000AB30) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<addr2line::Context<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(
        __int64 *a1)
{
  __int64 v2; // rsi
  __int64 v3; // r15
  __int64 v4; // r13
  __int64 v5; // rbp
  __int64 v6; // rdi

  if ( !_InterlockedDecrement64((volatile signed __int64 *)*a1) )
    alloc::sync::Arc<T,A>::drop_slow(a1);
  v2 = a1[2];
  if ( v2 )
    _rust_dealloc(a1[1], 32 * v2, 8LL);
  v3 = a1[3];
  v4 = a1[4];
  v5 = v4 + 1;
  v6 = v3;
  while ( v5 != 1 )
  {
    --v5;
    core::ptr::drop_in_place<addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(v6);
    v6 += 536LL;
  }
  if ( v4 )
    _rust_dealloc(v3, 536 * v4, 8LL);
  return core::ptr::drop_in_place<alloc::boxed::Box<[addr2line::SupUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>]>>(a1 + 5);
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000AC60) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(
        __int64 a1)
{
  __int64 result; // rax

  if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(a1 + 344)) )
    alloc::sync::Arc<T,A>::drop_slow((__int64 *)(a1 + 344));
  core::ptr::drop_in_place<core::option::Option<gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>>(a1 + 96);
  if ( *(_QWORD *)(a1 + 432) )
    core::ptr::drop_in_place<core::result::Result<addr2line::Lines,gimli::read::Error>>((__int64 *)(a1 + 440));
  if ( *(_QWORD *)(a1 + 472) )
    core::ptr::drop_in_place<core::result::Result<addr2line::function::Functions<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>((__int64 *)(a1 + 480));
  result = *(unsigned __int8 *)(a1 + 512);
  if ( (_BYTE)result != 76 )
    return core::ptr::drop_in_place<core::result::Result<core::option::Option<alloc::boxed::Box<(alloc::sync::Arc<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>,gimli::read::dwarf::Unit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>)>>,gimli::read::Error>>(
             result,
             *(__int64 **)(a1 + 520));
  return result;
}

//----- (000000000000AD60) ----------------------------------------------------
void __fastcall core::ptr::drop_in_place<addr2line::SupUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(
        __int64 a1)
{
  if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(a1 + 344)) )
    alloc::sync::Arc<T,A>::drop_slow((__int64 *)(a1 + 344));
  core::ptr::drop_in_place<core::option::Option<gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>>(a1 + 96);
}

//----- (000000000000ADB0) ----------------------------------------------------
unsigned __int64 __fastcall core::ptr::drop_in_place<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(
        __int64 a1)
{
  volatile signed __int64 *v1; // rax

  v1 = *(volatile signed __int64 **)(a1 + 208);
  if ( v1 && !_InterlockedDecrement64(v1) )
    alloc::sync::Arc<T,A>::drop_slow((__int64 *)(a1 + 208));
  return core::ptr::drop_in_place<gimli::read::abbrev::AbbreviationsCache>((__int64 *)(a1 + 216));
}

//----- (000000000000AE10) ----------------------------------------------------
void __fastcall core::ptr::drop_in_place<gimli::read::dwarf::Unit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>(
        __int64 a1)
{
  if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(a1 + 344)) )
    alloc::sync::Arc<T,A>::drop_slow((__int64 *)(a1 + 344));
  core::ptr::drop_in_place<core::option::Option<gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>>(a1 + 96);
}

//----- (000000000000AE60) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>>(
        __int64 *a1)
{
  __int64 v2; // rbx
  __int64 v3; // r13
  __int64 v4; // rdi
  __int64 result; // rax

  v2 = a1[1];
  v3 = a1[2] + 1;
  v4 = v2;
  while ( v3 != 1 )
  {
    --v3;
    core::ptr::drop_in_place<addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(v4);
    v4 += 536LL;
  }
  result = *a1;
  if ( *a1 )
    return _rust_dealloc(v2, 536 * result, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000AF30) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<addr2line::SupUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>>(
        __int64 *a1)
{
  __int64 v1; // rbx
  __int64 v2; // r13
  __int64 *v3; // r15
  __int64 result; // rax

  v1 = a1[1];
  v2 = a1[2];
  if ( v2 )
  {
    v3 = (__int64 *)(v1 + 344);
    do
    {
      if ( !_InterlockedDecrement64((volatile signed __int64 *)*v3) )
        alloc::sync::Arc<T,A>::drop_slow(v3);
      core::ptr::drop_in_place<core::option::Option<gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>>((__int64)(v3 - 31));
      v3 += 54;
      --v2;
    }
    while ( v2 );
  }
  result = *a1;
  if ( *a1 )
    return _rust_dealloc(v1, 432 * result, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B030) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::boxed::Box<[addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>]>>(
        __int64 a1,
        __int64 a2)
{
  __int64 v2; // rbx
  __int64 i; // r13
  __int64 result; // rax

  v2 = a1;
  for ( i = a2 + 1; i != 1; --i )
  {
    result = core::ptr::drop_in_place<addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(a1);
    a1 += 536LL;
  }
  if ( a2 )
    return _rust_dealloc(v2, 536 * a2, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B0F0) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::boxed::Box<[addr2line::SupUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>]>>(
        _QWORD *a1)
{
  __int64 v1; // r12
  __int64 v2; // rbx
  __int64 *v3; // r14
  __int64 v4; // r13
  __int64 result; // rax

  v1 = a1[1];
  if ( v1 )
  {
    v2 = *a1;
    v3 = (__int64 *)(*a1 + 344LL);
    v4 = a1[1];
    do
    {
      if ( !_InterlockedDecrement64((volatile signed __int64 *)*v3) )
        alloc::sync::Arc<T,A>::drop_slow(v3);
      core::ptr::drop_in_place<core::option::Option<gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>>((__int64)(v3 - 31));
      v3 += 54;
      --v4;
    }
    while ( v4 );
    return _rust_dealloc(v2, 432 * v1, 8LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B1D0) ----------------------------------------------------
unsigned __int64 __fastcall core::ptr::drop_in_place<alloc::sync::ArcInner<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>>(
        __int64 a1)
{
  volatile signed __int64 *v1; // rax

  v1 = *(volatile signed __int64 **)(a1 + 224);
  if ( v1 && !_InterlockedDecrement64(v1) )
    alloc::sync::Arc<T,A>::drop_slow((__int64 *)(a1 + 224));
  return core::ptr::drop_in_place<gimli::read::abbrev::AbbreviationsCache>((__int64 *)(a1 + 232));
}

//----- (000000000000B230) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<addr2line::FrameIter<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>(
        unsigned int *a1)
{
  __int64 result; // rax
  __int64 v2; // rsi

  result = *a1;
  if ( (_DWORD)result != 5 )
  {
    result = (unsigned int)(result - 3);
    if ( (unsigned int)result >= 2 )
    {
      v2 = *((_QWORD *)a1 + 9);
      if ( v2 )
        return _rust_dealloc(*((_QWORD *)a1 + 7), 8 * v2, 8LL);
    }
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B260) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<std::sync::reentrant_lock::ReentrantLockGuard<core::cell::RefCell<std::io::buffered::linewriter::LineWriter<std::io::stdio::StdoutRaw>>>>(
        __int64 a1)
{
  __int64 result; // rax

  if ( (*(_DWORD *)(a1 + 12))-- == 1 )
  {
    *(_QWORD *)a1 = 0LL;
    result = (unsigned int)_InterlockedExchange((volatile __int32 *)(a1 + 8), 0);
    if ( (_DWORD)result == 2 )
      return syscall(202LL, a1 + 8, 129LL, 1LL);
  }
  return result;
}

//----- (000000000000B2A0) ----------------------------------------------------
void __fastcall core::ptr::drop_in_place<core::option::Option<gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>>(
        __int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rax
  __int64 v3; // rsi
  __int64 v4; // rsi

  if ( *(_DWORD *)a1 != 47 )
  {
    v1 = *(_QWORD *)(a1 + 64);
    if ( v1 )
      _rust_dealloc(*(_QWORD *)(a1 + 72), 4 * v1, 2LL);
    v2 = *(_QWORD *)(a1 + 88);
    if ( v2 )
      _rust_dealloc(*(_QWORD *)(a1 + 96), 24 * v2, 8LL);
    v3 = *(_QWORD *)(a1 + 112);
    if ( v3 )
      _rust_dealloc(*(_QWORD *)(a1 + 120), 4 * v3, 2LL);
    v4 = *(_QWORD *)(a1 + 136);
    if ( v4 )
      _rust_dealloc(*(_QWORD *)(a1 + 144), v4 << 6, 8LL);
  }
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B330) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<addr2line::function::Functions<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>(
        __int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // r14
  __int64 v4; // r15
  _QWORD *v5; // r12
  __int64 v6; // rbp
  __int64 v7; // rdi
  __int64 v8; // rax

  v2 = *a1;
  if ( *a1 )
  {
    v4 = a1[1];
    if ( v4 )
    {
      v5 = (_QWORD *)(v2 + 40);
      v6 = a1[1];
      do
      {
        if ( *(v5 - 4) )
        {
          v7 = *(v5 - 3);
          if ( v7 )
          {
            v8 = *(v5 - 2);
            if ( v8 )
              _rust_dealloc(v7, 48 * v8, 8LL);
            if ( *v5 )
              _rust_dealloc(*(v5 - 1), 32LL * *v5, 8LL);
          }
        }
        v5 += 9;
        --v6;
      }
      while ( v6 );
      _rust_dealloc(v2, 72 * v4, 8LL);
    }
    result = a1[3];
    if ( result )
      return _rust_dealloc(a1[2], 24 * result, 8LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B440) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<(gimli::read::UnitOffset,addr2line::lazy::LazyCell<core::result::Result<addr2line::function::Function<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>)>(
        _QWORD *a1)
{
  __int64 result; // rax
  __int64 v2; // rcx
  __int64 v3; // rsi

  if ( a1[1] )
  {
    result = a1[2];
    if ( result )
    {
      v2 = a1[3];
      if ( v2 )
        result = _rust_dealloc(a1[2], 48 * v2, 8LL);
      v3 = a1[5];
      if ( v3 )
        return _rust_dealloc(a1[4], 32 * v3, 8LL);
    }
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B4A0) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<(gimli::read::UnitOffset,addr2line::lazy::LazyCell<core::result::Result<addr2line::function::Function<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>)>>(
        __int64 *a1)
{
  __int64 v2; // rbx
  __int64 v3; // r15
  _QWORD *v4; // r12
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 result; // rax

  v2 = a1[1];
  v3 = a1[2];
  if ( v3 )
  {
    v4 = (_QWORD *)(v2 + 40);
    do
    {
      if ( *(v4 - 4) )
      {
        v5 = *(v4 - 3);
        if ( v5 )
        {
          v6 = *(v4 - 2);
          if ( v6 )
            _rust_dealloc(v5, 48 * v6, 8LL);
          if ( *v4 )
            _rust_dealloc(*(v4 - 1), 32LL * *v4, 8LL);
        }
      }
      v4 += 9;
      --v3;
    }
    while ( v3 );
  }
  result = *a1;
  if ( *a1 )
    return _rust_dealloc(v2, 72 * result, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B560) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<gimli::read::line::LineRows<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>,usize>>(
        _QWORD *a1)
{
  __int64 v1; // rsi
  __int64 result; // rax
  __int64 v3; // rsi
  __int64 v4; // rsi

  v1 = a1[8];
  if ( v1 )
    _rust_dealloc(a1[9], 4 * v1, 2LL);
  result = a1[11];
  if ( result )
    result = _rust_dealloc(a1[12], 24 * result, 8LL);
  v3 = a1[14];
  if ( v3 )
    result = _rust_dealloc(a1[15], 4 * v3, 2LL);
  v4 = a1[17];
  if ( v4 )
    return _rust_dealloc(a1[18], v4 << 6, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B5F0) ----------------------------------------------------
unsigned __int64 __fastcall core::ptr::drop_in_place<<alloc::collections::btree::map::IntoIter<K,V,A> as core::ops::drop::Drop>::drop::DropGuard<u64,core::result::Result<alloc::sync::Arc<gimli::read::abbrev::Abbreviations>,gimli::read::Error>,alloc::alloc::Global>>(
        _QWORD *a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 i; // rdi
  unsigned __int64 v4; // rdi
  unsigned __int64 v5[2]; // [rsp+0h] [rbp-28h] BYREF
  __int64 v6; // [rsp+10h] [rbp-18h]

  result = alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(v5, a1);
  for ( i = v5[0]; v5[0]; i = v5[0] )
  {
    if ( *(_BYTE *)(i + 16 * v6) == 75 )
    {
      v4 = 16 * v6 + i;
      if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(v4 + 8)) )
        alloc::sync::Arc<T,A>::drop_slow((__int64 *)(v4 + 8));
    }
    result = alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(v5, a1);
  }
  return result;
}

//----- (000000000000B670) ----------------------------------------------------
void __fastcall core::ptr::drop_in_place<(alloc::sync::Arc<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>,gimli::read::dwarf::Unit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>)>(
        __int64 *a1)
{
  if ( !_InterlockedDecrement64((volatile signed __int64 *)*a1) )
    alloc::sync::Arc<T,A>::drop_slow(a1);
  if ( !_InterlockedDecrement64((volatile signed __int64 *)a1[44]) )
    alloc::sync::Arc<T,A>::drop_slow(a1 + 44);
  core::ptr::drop_in_place<core::option::Option<gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>>((__int64)(a1 + 13));
}

//----- (000000000000B6F0) ----------------------------------------------------
void __fastcall core::ptr::drop_in_place<alloc::boxed::Box<[(gimli::read::UnitOffset,addr2line::lazy::LazyCell<core::result::Result<addr2line::function::Function<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>)]>>(
        __int64 a1,
        __int64 a2)
{
  _QWORD *v3; // r15
  __int64 v4; // r13
  __int64 v5; // rdi
  __int64 v6; // rax

  if ( a2 )
  {
    v3 = (_QWORD *)(a1 + 40);
    v4 = a2;
    do
    {
      if ( *(v3 - 4) )
      {
        v5 = *(v3 - 3);
        if ( v5 )
        {
          v6 = *(v3 - 2);
          if ( v6 )
            _rust_dealloc(v5, 48 * v6, 8LL);
          if ( *v3 )
            _rust_dealloc(*(v3 - 1), 32LL * *v3, 8LL);
        }
      }
      v3 += 9;
      --v4;
    }
    while ( v4 );
    _rust_dealloc(a1, 72 * a2, 8LL);
  }
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B7B0) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<core::option::Option<alloc::boxed::Box<(alloc::sync::Arc<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>,gimli::read::dwarf::Unit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>)>>,gimli::read::Error>>(
        char a1,
        __int64 *a2)
{
  __int64 result; // rax

  if ( a1 == 75 && a2 )
  {
    if ( !_InterlockedDecrement64((volatile signed __int64 *)*a2) )
      alloc::sync::Arc<T,A>::drop_slow(a2);
    if ( !_InterlockedDecrement64((volatile signed __int64 *)a2[44]) )
      alloc::sync::Arc<T,A>::drop_slow(a2 + 44);
    core::ptr::drop_in_place<core::option::Option<gimli::read::line::IncompleteLineProgram<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>>>((__int64)(a2 + 13));
    return _rust_dealloc(a2, 432LL, 8LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B860) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::string::String>(_QWORD *a1)
{
  __int64 result; // rax

  if ( *a1 )
    return _rust_dealloc(a1[1], *a1, 1LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B880) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<std::io::error::Error>(__int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // rcx
  __int64 v3; // rbx
  __int64 v4; // r14
  __int64 v5; // r12
  __int64 v6; // rsi

  result = *a1;
  v2 = *a1 & 3;
  if ( (unsigned __int64)(v2 - 2) >= 2 && v2 )
  {
    v3 = result - 1;
    v4 = *(_QWORD *)(result - 1);
    v5 = *(_QWORD *)(result + 7);
    (*(void (__fastcall **)(__int64))v5)(v4);
    v6 = *(_QWORD *)(v5 + 8);
    if ( v6 )
      _rust_dealloc(v4, v6, *(_QWORD *)(v5 + 16));
    return _rust_dealloc(v3, 24LL, 8LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B930) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<u8>>(_QWORD *a1)
{
  __int64 result; // rax

  if ( *a1 )
    return _rust_dealloc(a1[1], *a1, 1LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000B950) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<std::io::stdio::StdinLock>(__int64 a1, char a2)
{
  __int64 result; // rax

  if ( !a2 && 2 * std::panicking::panic_count::GLOBAL_PANIC_COUNT && !std::panicking::panic_count::is_zero_slow_path() )
    *(_BYTE *)(a1 + 4) = 1;
  result = (unsigned int)_InterlockedExchange((volatile __int32 *)a1, 0);
  if ( (_DWORD)result == 2 )
    return syscall(202LL, a1, 129LL, 1LL);
  return result;
}
// 5B120: using guessed type signed __int64 std::panicking::panic_count::GLOBAL_PANIC_COUNT;

//----- (000000000000B9B0) ----------------------------------------------------
unsigned __int64 __fastcall core::ptr::drop_in_place<gimli::read::abbrev::Abbreviations>(_QWORD *a1)
{
  __int64 v1; // r14
  __int64 v2; // r15
  _QWORD *v3; // r12
  __int64 v4; // rsi

  v1 = a1[1];
  v2 = a1[2];
  if ( v2 )
  {
    v3 = (_QWORD *)(v1 + 16);
    do
    {
      if ( *(v3 - 2) )
      {
        v4 = *(v3 - 1);
        if ( v4 )
          _rust_dealloc(*v3, 16 * v4, 8LL);
      }
      v3 += 14;
      --v2;
    }
    while ( v2 );
  }
  if ( *a1 )
    _rust_dealloc(v1, 112LL * *a1, 8LL);
  return core::ptr::drop_in_place<alloc::collections::btree::map::BTreeMap<u64,gimli::read::abbrev::Abbreviation>>(a1 + 3);
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000BA40) ----------------------------------------------------
unsigned __int64 __fastcall core::ptr::drop_in_place<gimli::read::abbrev::AbbreviationsCache>(__int64 *a1)
{
  __int64 v1; // rcx
  __int64 v2; // rdx
  __int64 v3; // rax
  __int64 v4; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 i; // rdi
  unsigned __int64 v7; // rdi
  unsigned __int64 v8[2]; // [rsp+8h] [rbp-70h] BYREF
  __int64 v9; // [rsp+18h] [rbp-60h]
  __int64 v10[11]; // [rsp+20h] [rbp-58h] BYREF

  v1 = *a1;
  if ( *a1 )
  {
    v2 = a1[1];
    v3 = a1[2];
    v10[1] = 0LL;
    v10[2] = v1;
    v10[3] = v2;
    v10[5] = 0LL;
    v10[6] = v1;
    v10[7] = v2;
    v4 = 1LL;
  }
  else
  {
    v4 = 0LL;
    v3 = 0LL;
  }
  v10[0] = v4;
  v10[4] = v4;
  v10[8] = v3;
  result = alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(v8, v10);
  for ( i = v8[0]; v8[0]; i = v8[0] )
  {
    if ( *(_BYTE *)(i + 16 * v9) == 75 )
    {
      v7 = 16 * v9 + i;
      if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(v7 + 8)) )
        alloc::sync::Arc<T,A>::drop_slow((__int64 *)(v7 + 8));
    }
    result = alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(v8, v10);
  }
  return result;
}

//----- (000000000000BB20) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::vec::Vec<alloc::string::String>>(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v2; // r15
  _QWORD *v3; // r12
  __int64 v4; // rsi
  __int64 result; // rax

  v1 = a1[1];
  v2 = a1[2];
  if ( v2 )
  {
    v3 = (_QWORD *)(v1 + 8);
    do
    {
      v4 = *(v3 - 1);
      if ( v4 )
        _rust_dealloc(*v3, v4, 1LL);
      v3 += 3;
      --v2;
    }
    while ( v2 );
  }
  result = *a1;
  if ( *a1 )
    return _rust_dealloc(v1, 24 * result, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000BBB0) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::Library>(_QWORD *a1)
{
  __int64 result; // rax
  __int64 v2; // rsi

  if ( *a1 )
    result = _rust_dealloc(a1[1], *a1, 1LL);
  v2 = a1[3];
  if ( v2 )
    return _rust_dealloc(a1[4], 16 * v2, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000BBF0) ----------------------------------------------------
int __fastcall core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::Mapping>(__int64 a1)
{
  core::ptr::drop_in_place<addr2line::Context<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>((__int64 *)(a1 + 456));
  if ( *(_QWORD *)a1 )
    _rust_dealloc(*(_QWORD *)(a1 + 8), 24LL * *(_QWORD *)a1, 8LL);
  munmap(*(void **)(a1 + 512), *(_QWORD *)(a1 + 520));
  return core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::stash::Stash>((__int64 *)(a1 + 528));
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000BCA0) ----------------------------------------------------
void __fastcall core::ptr::drop_in_place<alloc::vec::Vec<addr2line::LineSequence>>(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // r15
  _QWORD *v3; // r12

  v1 = a1[1];
  v2 = a1[2];
  if ( v2 )
  {
    v3 = (_QWORD *)(v1 + 8);
    do
    {
      if ( *v3 )
        _rust_dealloc(*(v3 - 1), 24LL * *v3, 8LL);
      v3 += 4;
      --v2;
    }
    while ( v2 );
  }
  if ( *a1 )
    _rust_dealloc(v1, 32LL * *a1, 8LL);
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000BD30) ----------------------------------------------------
int __fastcall core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::stash::Stash>(__int64 *a1)
{
  __int64 v1; // r14
  __int64 v2; // r15
  _QWORD *v3; // r12
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // r14
  __int64 v7; // r15
  size_t *v8; // r12
  __int64 v9; // rsi

  v1 = a1[1];
  v2 = a1[2];
  if ( v2 )
  {
    v3 = (_QWORD *)(v1 + 8);
    do
    {
      v4 = *(v3 - 1);
      if ( v4 )
        _rust_dealloc(*v3, v4, 1LL);
      v3 += 3;
      --v2;
    }
    while ( v2 );
  }
  v5 = *a1;
  if ( *a1 )
    LODWORD(v5) = _rust_dealloc(v1, 24 * v5, 8LL);
  v6 = a1[4];
  v7 = a1[5];
  if ( v7 )
  {
    v8 = (size_t *)(v6 + 8);
    do
    {
      LODWORD(v5) = munmap((void *)*(v8 - 1), *v8);
      v8 += 2;
      --v7;
    }
    while ( v7 );
  }
  v9 = a1[3];
  if ( v9 )
    LODWORD(v5) = _rust_dealloc(v6, 16 * v9, 8LL);
  return v5;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000BE10) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::boxed::Box<[alloc::string::String]>>(__int64 a1, __int64 a2)
{
  _QWORD *v3; // r15
  __int64 v4; // r13
  __int64 v5; // rsi
  __int64 result; // rax

  if ( a2 )
  {
    v3 = (_QWORD *)(a1 + 8);
    v4 = a2;
    do
    {
      v5 = *(v3 - 1);
      if ( v5 )
        _rust_dealloc(*v3, v5, 1LL);
      v3 += 3;
      --v4;
    }
    while ( v4 );
    return _rust_dealloc(a1, 24 * a2, 8LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000BE90) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<std::panicking::begin_panic_handler::FormatStringPayload>(_QWORD *a1)
{
  __int64 result; // rax

  result = 2LL * *a1;
  if ( result )
    return _rust_dealloc(a1[1], *a1, 1LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000BEB0) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<(),std::io::error::Error>>(__int64 *a1)
{
  __int64 result; // rax

  if ( *a1 )
    return core::ptr::drop_in_place<std::io::error::Error>(a1);
  return result;
}

//----- (000000000000BEC0) ----------------------------------------------------
unsigned __int64 __fastcall core::ptr::drop_in_place<alloc::sync::ArcInner<gimli::read::abbrev::Abbreviations>>(
        _QWORD *a1)
{
  __int64 v1; // r14
  __int64 v2; // r15
  _QWORD *v3; // r12
  __int64 v4; // rsi
  __int64 v5; // rax

  v1 = a1[3];
  v2 = a1[4];
  if ( v2 )
  {
    v3 = (_QWORD *)(v1 + 16);
    do
    {
      if ( *(v3 - 2) )
      {
        v4 = *(v3 - 1);
        if ( v4 )
          _rust_dealloc(*v3, 16 * v4, 8LL);
      }
      v3 += 14;
      --v2;
    }
    while ( v2 );
  }
  v5 = a1[2];
  if ( v5 )
    _rust_dealloc(v1, 112 * v5, 8LL);
  return core::ptr::drop_in_place<alloc::collections::btree::map::BTreeMap<u64,gimli::read::abbrev::Abbreviation>>(a1 + 5);
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000BF50) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<core::result::Result<addr2line::Lines,gimli::read::Error>>(__int64 *a1)
{
  __int64 v1; // r14
  __int64 v2; // r15
  _QWORD *v3; // r12
  __int64 v4; // rbp
  __int64 v5; // rsi
  __int64 result; // rax
  __int64 v7; // r14
  __int64 v8; // rbx
  _QWORD *v9; // r15
  __int64 v10; // r13

  v1 = *a1;
  if ( *a1 )
  {
    v2 = a1[1];
    if ( v2 )
    {
      v3 = (_QWORD *)(v1 + 8);
      v4 = a1[1];
      do
      {
        v5 = *(v3 - 1);
        if ( v5 )
          _rust_dealloc(*v3, v5, 1LL);
        v3 += 3;
        --v4;
      }
      while ( v4 );
      result = _rust_dealloc(v1, 24 * v2, 8LL);
    }
    v7 = a1[3];
    if ( v7 )
    {
      v8 = a1[2];
      v9 = (_QWORD *)(v8 + 8);
      v10 = a1[3];
      do
      {
        if ( *v9 )
          _rust_dealloc(*(v9 - 1), 24LL * *v9, 8LL);
        v9 += 4;
        --v10;
      }
      while ( v10 );
      return _rust_dealloc(v8, 32 * v7, 8LL);
    }
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000C050) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<std::io::Write::write_fmt::Adapter<alloc::vec::Vec<u8>>>(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 8) )
    return core::ptr::drop_in_place<std::io::error::Error>((__int64 *)(a1 + 8));
  return result;
}

//----- (000000000000C070) ----------------------------------------------------
void *__fastcall core::ptr::drop_in_place<std::io::buffered::bufwriter::BufWriter<W>::flush_buf::BufGuard>(
        __int64 a1,
        unsigned __int64 a2)
{
  void *result; // rax
  size_t v3; // rbx

  if ( a2 )
  {
    result = *(void **)(a1 + 16);
    v3 = (size_t)result - a2;
    if ( (unsigned __int64)result < a2 )
      core::slice::index::slice_end_index_len_fail(a2, (__int64)result, (__int64)&off_58668);
    *(_QWORD *)(a1 + 16) = 0LL;
    if ( v3 )
    {
      result = memmove(*(void **)(a1 + 8), (const void *)(*(_QWORD *)(a1 + 8) + a2), v3);
      *(_QWORD *)(a1 + 16) = v3;
    }
  }
  return result;
}
// 58668: using guessed type char *off_58668;

//----- (000000000000C0D0) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<std::io::buffered::linewriter::LineWriter<std::io::stdio::StdoutRaw>>(
        __int64 a1)
{
  __int64 result; // rax
  __int64 v2[3]; // [rsp+0h] [rbp-18h] BYREF

  v2[0] = result;
  if ( !*(_BYTE *)(a1 + 24) )
  {
    result = std::io::buffered::bufwriter::BufWriter<W>::flush_buf(a1);
    v2[0] = result;
    if ( result )
      result = core::ptr::drop_in_place<std::io::error::Error>(v2);
  }
  if ( *(_QWORD *)a1 )
    return _rust_dealloc(*(_QWORD *)(a1 + 8), *(_QWORD *)a1, 1LL);
  return result;
}
// C0D3: variable 'result' is possibly undefined
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// C0D0: using guessed type __int64 var_18[3];

//----- (000000000000C140) ----------------------------------------------------
__int64 __fastcall core::str::<impl str>::split_once(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v5; // r14
  char v6; // dl
  int v7; // eax
  __int64 result; // rax
  __int64 v9; // rdx
  __int64 v10; // r15
  __int64 v11; // [rsp+8h] [rbp-60h] BYREF
  __int64 v12; // [rsp+10h] [rbp-58h]
  __int64 v13; // [rsp+18h] [rbp-50h]
  __int64 v14[4]; // [rsp+20h] [rbp-48h] BYREF
  int v15; // [rsp+40h] [rbp-28h]
  unsigned int v16; // [rsp+44h] [rbp-24h]
  char v17; // [rsp+48h] [rbp-20h]

  v5 = a2;
  v6 = 1;
  v7 = a4;
  if ( a4 >= 0x80 )
  {
    if ( a4 >= 0x800 )
    {
      if ( a4 >= 0x10000 )
      {
        v7 = ((a4 & 0x3F) << 24) + ((a4 >> 18) & 7 | (a4 >> 4) & 0x3F00 | (a4 << 10) & 0x3F0000) - 2139062032;
        v6 = 4;
      }
      else
      {
        v7 = ((a4 & 0x3F) << 16) + (a4 >> 12) + 4 * (a4 & 0xFC0) + 8421600;
        v6 = 3;
      }
    }
    else
    {
      v7 = ((a4 & 0x3F) << 8) + (a4 >> 6) + 32960;
      v6 = 2;
    }
  }
  v14[0] = a2;
  v14[1] = a3;
  v14[2] = 0LL;
  v14[3] = a3;
  v16 = a4;
  v17 = v6;
  v15 = v7;
  result = <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(&v11, v14);
  if ( v11 )
  {
    result = v12;
    v9 = a2 + v13;
    v10 = a3 - v13;
    a1[1] = v12;
    a1[2] = v9;
    a1[3] = v10;
  }
  else
  {
    v5 = 0LL;
  }
  *a1 = v5;
  return result;
}

//----- (000000000000C250) ----------------------------------------------------
unsigned __int8 *__fastcall core::str::<impl str>::trim_start_matches(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *result; // rax
  unsigned __int8 *v4; // rsi
  unsigned __int8 *v5; // rcx
  unsigned __int8 *v6; // r9
  char v7; // r10
  char v8; // r10
  unsigned __int8 *v9; // r8
  unsigned int v10; // r10d
  int v11; // r11d
  int v12; // ebp
  int v13; // ebx
  unsigned int v14; // r11d

  result = a1;
  if ( !a2 )
    return result;
  v4 = &a2[(_QWORD)a1];
  v5 = 0LL;
  v6 = a1;
  while ( 1 )
  {
    v9 = v6;
    v10 = *v6;
    if ( (v10 & 0x80u) == 0 )
    {
      ++v6;
      if ( v10 - 9 < 5 )
        goto LABEL_6;
      goto LABEL_18;
    }
    v11 = v10 & 0x1F;
    v12 = v6[1] & 0x3F;
    if ( (unsigned __int8)v10 <= 0xDFu )
    {
      v6 += 2;
      v10 = v12 | (v11 << 6);
      if ( v10 - 9 < 5 )
        goto LABEL_6;
      goto LABEL_18;
    }
    v13 = (v12 << 6) | v6[2] & 0x3F;
    if ( (unsigned __int8)v10 >= 0xF0u )
      break;
    v6 += 3;
    v10 = (v11 << 12) | v13;
    if ( v10 - 9 < 5 )
      goto LABEL_6;
LABEL_18:
    if ( v10 != 32 )
    {
      if ( v10 < 0x80 )
        return &a1[(_QWORD)v5];
      v14 = v10 >> 8;
      if ( v10 >> 8 > 0x1F )
      {
        if ( v14 != 32 )
        {
          if ( v14 != 48 )
            return &a1[(_QWORD)v5];
          v8 = v10 == 12288;
          goto LABEL_5;
        }
        v7 = core::unicode::unicode_data::white_space::WHITESPACE_MAP[(unsigned __int8)v10] >> 1;
      }
      else
      {
        if ( v14 )
        {
          if ( v14 != 22 )
            return &a1[(_QWORD)v5];
          v8 = v10 == 5760;
          goto LABEL_5;
        }
        v7 = core::unicode::unicode_data::white_space::WHITESPACE_MAP[(unsigned __int8)v10];
      }
      v8 = v7 & 1;
LABEL_5:
      if ( !v8 )
        return &a1[(_QWORD)v5];
    }
LABEL_6:
    v5 = &v6[v5 - v9];
    if ( v6 == v4 )
      goto LABEL_28;
  }
  v10 = ((v10 & 7) << 18) | (v13 << 6) | v6[3] & 0x3F;
  if ( v10 != 1114112 )
  {
    v6 += 4;
    if ( v10 - 9 < 5 )
      goto LABEL_6;
    goto LABEL_18;
  }
LABEL_28:
  v5 = a2;
  return &a1[(_QWORD)v5];
}
// 4D767: using guessed type _BYTE core::unicode::unicode_data::white_space::WHITESPACE_MAP[256];

//----- (000000000000C3E0) ----------------------------------------------------
__int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // r9
  unsigned __int64 v6; // r8
  __int64 v7; // r10
  __int64 v8; // r9
  __int64 v9; // r10
  __int128 v10; // [rsp+0h] [rbp-18h]

  result = a3 - 1;
  if ( a3 - 1 >= a2 )
    core::panicking::panic((__int64)aAssertionFaile_0, 46LL, (__int64)&off_584E8);
  if ( a3 < a2 )
  {
    result = a1 - 48;
    v4 = a1 + 24 * a3 - 24;
    do
    {
      v5 = 24 * a3;
      v6 = *(_QWORD *)(a1 + 24 * a3);
      if ( v6 < *(_QWORD *)(result + 24 * a3 + 24) )
      {
        v7 = a1 + v5;
        v8 = result + v5 + 24;
        v10 = *(_OWORD *)(a1 + 24 * a3 + 8);
        *(_QWORD *)(v7 + 16) = *(_QWORD *)(v8 + 16);
        *(_OWORD *)v7 = *(_OWORD *)v8;
        if ( a3 != 1 )
        {
          v9 = 1LL;
          v8 = v4;
          while ( v6 < *(_QWORD *)(v8 - 24) )
          {
            *(_QWORD *)(v8 + 16) = *(_QWORD *)(v8 - 24 + 16);
            *(_OWORD *)v8 = *(_OWORD *)(v8 - 24);
            ++v9;
            v8 -= 24LL;
            if ( a3 == v9 )
            {
              v8 = a1;
              break;
            }
          }
        }
        *(_QWORD *)v8 = v6;
        *(_OWORD *)(v8 + 8) = v10;
      }
      ++a3;
      v4 += 24LL;
    }
    while ( a3 != a2 );
  }
  return result;
}
// 584E8: using guessed type char *off_584E8;

//----- (000000000000C4D0) ----------------------------------------------------
unsigned __int64 __fastcall core::slice::sort::insertion_sort_shift_left(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  __int64 v4; // rcx
  unsigned __int64 v5; // r8
  __int64 v6; // r11
  __int64 v7; // r10
  unsigned __int64 v8; // r9
  _OWORD *v9; // rbx
  __int64 v10; // r10
  __int128 v11; // xmm0
  __int64 v12; // r11
  __int128 v13; // xmm0
  __int128 v14; // [rsp+0h] [rbp-28h]
  __int64 v15; // [rsp+10h] [rbp-18h]

  result = a3 - 1;
  if ( a3 - 1 >= a2 )
    core::panicking::panic((__int64)aAssertionFaile_0, 46LL, (__int64)&off_584E8);
  if ( a3 < a2 )
  {
    result = a1 - 64;
    v4 = a1 + 32 * a3 - 32;
    do
    {
      v5 = a3 + 1;
      v6 = 32 * a3;
      v7 = 32 * (a3 + 1);
      v8 = *(_QWORD *)(a1 + 32 * a3);
      if ( v8 < *(_QWORD *)(result + v7) )
      {
        v9 = (_OWORD *)(a1 + v6);
        v10 = result + v7;
        v15 = *(_QWORD *)(a1 + v6 + 24);
        v14 = *(_OWORD *)(a1 + v6 + 8);
        v11 = *(_OWORD *)v10;
        v9[1] = *(_OWORD *)(v10 + 16);
        *v9 = v11;
        if ( a3 != 1 )
        {
          v12 = 1LL;
          v10 = v4;
          while ( v8 < *(_QWORD *)(v10 - 32) )
          {
            v13 = *(_OWORD *)(v10 - 32);
            *(_OWORD *)(v10 + 16) = *(_OWORD *)(v10 - 32 + 16);
            *(_OWORD *)v10 = v13;
            ++v12;
            v10 -= 32LL;
            if ( a3 == v12 )
            {
              v10 = a1;
              break;
            }
          }
        }
        *(_QWORD *)v10 = v8;
        *(_OWORD *)(v10 + 8) = v14;
        *(_QWORD *)(v10 + 24) = v15;
      }
      v4 += 32LL;
      ++a3;
    }
    while ( v5 != a2 );
  }
  return result;
}
// 584E8: using guessed type char *off_584E8;

//----- (000000000000C5D0) ----------------------------------------------------
__int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // r10
  unsigned __int64 v5; // r9
  __int64 v6; // r11
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rcx
  _OWORD *v9; // r14
  __int64 v10; // rbx
  __int64 v11; // r11
  __int128 v12; // xmm0
  __int64 v13; // r14
  __int128 v14; // xmm0
  __int64 v15; // r15

  result = a3 - 1;
  if ( a3 - 1 >= a2 )
    core::panicking::panic((__int64)aAssertionFaile_0, 46LL, (__int64)&off_584E8);
  if ( a3 < a2 )
  {
    result = a1 + 32 * a3 - 32;
    do
    {
      v5 = a3++;
      v6 = 32 * v5;
      v4 = a1 + 32 * a3 - 64;
      v7 = *(_QWORD *)(a1 + 32 * v5);
      v8 = *(_QWORD *)(a1 + 32 * v5 + 16);
      if ( v8 < *(_QWORD *)(a1 + 32 * a3 - 48) || v8 <= *(_QWORD *)(a1 + 32 * a3 - 48) && v7 < *(_QWORD *)v4 )
      {
        v9 = (_OWORD *)(a1 + v6);
        v10 = *(_QWORD *)(a1 + v6 + 8);
        v11 = *(_QWORD *)(a1 + v6 + 24);
        v12 = *(_OWORD *)v4;
        v9[1] = *(_OWORD *)(v4 + 16);
        *v9 = v12;
        if ( v5 != 1 )
        {
          v13 = 1LL;
          v4 = result;
          while ( 1 )
          {
            v15 = v4 - 32;
            if ( v8 >= *(_QWORD *)(v4 - 16) && (v8 > *(_QWORD *)(v4 - 16) || v7 >= *(_QWORD *)v15) )
              break;
            v14 = *(_OWORD *)v15;
            *(_OWORD *)(v4 + 16) = *(_OWORD *)(v15 + 16);
            *(_OWORD *)v4 = v14;
            ++v13;
            v4 -= 32LL;
            if ( v5 == v13 )
            {
              v4 = a1;
              break;
            }
          }
        }
        *(_QWORD *)v4 = v7;
        *(_QWORD *)(v4 + 8) = v10;
        *(_QWORD *)(v4 + 16) = v8;
        *(_QWORD *)(v4 + 24) = v11;
      }
      result += 32LL;
    }
    while ( a3 != a2 );
  }
  return result;
}
// 584E8: using guessed type char *off_584E8;

//----- (000000000000C6F0) ----------------------------------------------------
unsigned __int64 __fastcall core::slice::sort::insertion_sort_shift_left(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  __int64 v4; // rcx
  unsigned __int64 v5; // r8
  __int64 v6; // r11
  __int64 v7; // r10
  unsigned __int64 v8; // r9
  _OWORD *v9; // rbx
  __int64 v10; // r10
  __int64 v11; // r11
  __int64 v12; // rbx

  result = a3 - 1;
  if ( a3 - 1 >= a2 )
    core::panicking::panic((__int64)aAssertionFaile_0, 46LL, (__int64)&off_584E8);
  if ( a3 < a2 )
  {
    result = a1 - 32;
    v4 = a1 + 16 * a3 - 16;
    do
    {
      v5 = a3 + 1;
      v6 = 16 * a3;
      v7 = 16 * (a3 + 1);
      v8 = *(_QWORD *)(a1 + 16 * a3);
      if ( v8 < *(_QWORD *)(result + v7) )
      {
        v9 = (_OWORD *)(a1 + v6);
        v10 = result + v7;
        v11 = *(_QWORD *)(a1 + v6 + 8);
        *v9 = *(_OWORD *)v10;
        if ( a3 != 1 )
        {
          v12 = 1LL;
          v10 = v4;
          while ( v8 < *(_QWORD *)(v10 - 16) )
          {
            *(_OWORD *)v10 = *(_OWORD *)(v10 - 16);
            ++v12;
            v10 -= 16LL;
            if ( a3 == v12 )
            {
              v10 = a1;
              break;
            }
          }
        }
        *(_QWORD *)v10 = v8;
        *(_QWORD *)(v10 + 8) = v11;
      }
      v4 += 16LL;
      ++a3;
    }
    while ( v5 != a2 );
  }
  return result;
}
// 584E8: using guessed type char *off_584E8;

//----- (000000000000C7D0) ----------------------------------------------------
__int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // r9
  unsigned __int64 v6; // r8
  __int64 v7; // r10
  __int64 v8; // r9
  __int64 v9; // r10
  __int128 v10; // [rsp+0h] [rbp-18h]

  result = a3 - 1;
  if ( a3 - 1 >= a2 )
    core::panicking::panic((__int64)aAssertionFaile_0, 46LL, (__int64)&off_584E8);
  if ( a3 < a2 )
  {
    result = a1 - 48;
    v4 = a1 + 24 * a3 - 24;
    do
    {
      v5 = 24 * a3;
      v6 = *(_QWORD *)(a1 + 24 * a3);
      if ( v6 < *(_QWORD *)(result + 24 * a3 + 24) )
      {
        v7 = a1 + v5;
        v8 = result + v5 + 24;
        v10 = *(_OWORD *)(a1 + 24 * a3 + 8);
        *(_QWORD *)(v7 + 16) = *(_QWORD *)(v8 + 16);
        *(_OWORD *)v7 = *(_OWORD *)v8;
        if ( a3 != 1 )
        {
          v9 = 1LL;
          v8 = v4;
          while ( v6 < *(_QWORD *)(v8 - 24) )
          {
            *(_QWORD *)(v8 + 16) = *(_QWORD *)(v8 - 24 + 16);
            *(_OWORD *)v8 = *(_OWORD *)(v8 - 24);
            ++v9;
            v8 -= 24LL;
            if ( a3 == v9 )
            {
              v8 = a1;
              break;
            }
          }
        }
        *(_QWORD *)v8 = v6;
        *(_OWORD *)(v8 + 8) = v10;
      }
      ++a3;
      v4 += 24LL;
    }
    while ( a3 != a2 );
  }
  return result;
}
// 584E8: using guessed type char *off_584E8;

//----- (000000000000C8C0) ----------------------------------------------------
__int64 __fastcall core::slice::sort::insertion_sort_shift_left(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  unsigned __int64 v5; // rcx
  __int64 v6; // r9
  __int64 v7; // r11
  unsigned __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r10
  __int128 v11; // xmm0
  __int64 v12; // r11
  __int128 v13; // xmm0
  __int128 v14; // [rsp+0h] [rbp-18h]

  result = a3 - 1;
  if ( a3 - 1 >= a2 )
    core::panicking::panic((__int64)aAssertionFaile_0, 46LL, (__int64)&off_584E8);
  if ( a3 < a2 )
  {
    result = a1 + 32 * a3 - 32;
    do
    {
      v5 = a3 + 1;
      v6 = 32 * (a3 + 1);
      v7 = 32 * a3;
      v8 = *(_QWORD *)(a1 + 32 * a3 + 16);
      if ( v8 < *(_QWORD *)(a1 + v6 - 48) )
      {
        v9 = a1 + v6;
        v14 = *(_OWORD *)(a1 + 32 * a3);
        v10 = *(_QWORD *)(a1 + v7 + 24);
        v11 = *(_OWORD *)(v9 - 64);
        *(_OWORD *)(a1 + v7 + 16) = *(_OWORD *)(v9 - 48);
        *(_OWORD *)(a1 + 32 * a3) = v11;
        if ( a3 == 1 )
        {
          v4 = v9 - 64;
        }
        else
        {
          v12 = 1LL;
          v4 = result;
          while ( v8 < *(_QWORD *)(v4 - 16) )
          {
            v13 = *(_OWORD *)(v4 - 32);
            *(_OWORD *)(v4 + 16) = *(_OWORD *)(v4 - 32 + 16);
            *(_OWORD *)v4 = v13;
            ++v12;
            v4 -= 32LL;
            if ( a3 == v12 )
            {
              v4 = a1;
              break;
            }
          }
        }
        *(_OWORD *)v4 = v14;
        *(_QWORD *)(v4 + 16) = v8;
        *(_QWORD *)(v4 + 24) = v10;
      }
      result += 32LL;
      ++a3;
    }
    while ( v5 != a2 );
  }
  return result;
}
// 584E8: using guessed type char *off_584E8;

//----- (000000000000C9C0) ----------------------------------------------------
unsigned __int64 __fastcall core::slice::sort::insertion_sort_shift_right(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  __int64 *v3; // rcx
  __int64 *v4; // rdi
  unsigned __int64 v5; // rsi
  bool v6; // cf
  __int128 v7; // [rsp+0h] [rbp-18h]

  if ( a2 < 2 )
    core::panicking::panic((__int64)aAssertionFaile_1, 58LL, (__int64)&off_58500);
  result = *a1;
  if ( a1[3] < (unsigned __int64)*a1 )
  {
    v3 = a1 + 3;
    v7 = *(_OWORD *)(a1 + 1);
    a1[2] = a1[5];
    *(_OWORD *)a1 = *(_OWORD *)(a1 + 3);
    if ( a2 != 2 && a1[6] < result )
    {
      v4 = a1 + 6;
      v5 = a2 - 2;
      while ( 1 )
      {
        *(v4 - 1) = v4[2];
        *(_OWORD *)(v4 - 3) = *(_OWORD *)v4;
        if ( !--v5 )
          break;
        v3 = v4;
        v6 = v4[3] < result;
        v4 += 3;
        if ( !v6 )
          goto LABEL_10;
      }
      v3 = v4;
    }
LABEL_10:
    *v3 = result;
    *(_OWORD *)(v3 + 1) = v7;
  }
  return result;
}
// 58500: using guessed type char *off_58500;

//----- (000000000000CA70) ----------------------------------------------------
void __fastcall core::slice::sort::recurse(__int64 a1, unsigned __int64 a2, _QWORD *a3, unsigned int a4)
{
  unsigned __int64 v4; // r15
  __int64 v5; // r12
  bool v6; // r14
  bool v7; // bp
  bool v8; // bp
  unsigned __int64 v9; // r13
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r15
  __int64 v12; // rax
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rdi
  __int64 v15; // r9
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // r10
  __int64 v18; // rbx
  unsigned __int64 v19; // r11
  __int64 v20; // rdx
  bool v21; // cf
  __int64 v22; // rdx
  __int64 v23; // rdi
  unsigned __int64 v24; // r8
  unsigned __int64 v25; // r9
  __int64 v26; // r10
  unsigned __int64 v27; // r11
  __int64 v28; // rsi
  bool v29; // cf
  __int64 v30; // rsi
  __int64 v31; // rdi
  unsigned __int64 v32; // r8
  unsigned __int64 v33; // r9
  __int64 v34; // r10
  unsigned __int64 v35; // r11
  __int64 v36; // rbx
  bool v37; // cf
  unsigned __int64 v38; // r9
  unsigned __int64 v39; // rsi
  unsigned __int64 v40; // rdi
  unsigned __int64 v41; // r8
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // rbx
  __int64 v44; // rax
  unsigned __int64 v45; // rax
  _QWORD *v46; // rcx
  _QWORD *v47; // r8
  __int128 v48; // xmm0
  __int64 v49; // rsi
  unsigned __int64 v50; // rax
  __int64 v51; // rcx
  __int64 v52; // r11
  unsigned __int64 v53; // rsi
  unsigned __int64 v54; // rcx
  unsigned __int64 v55; // rdi
  unsigned __int64 *v56; // r8
  unsigned __int64 v57; // r9
  unsigned __int64 v58; // r8
  __int64 v59; // r9
  __int64 v60; // r10
  unsigned __int64 v61; // rdi
  char v62; // al
  unsigned __int64 v63; // rsi
  __int64 v64; // rax
  __int64 v65; // rcx
  unsigned __int64 v66; // rcx
  unsigned __int64 v67; // r12
  unsigned __int64 *v68; // rdx
  unsigned __int64 v69; // rdi
  unsigned __int64 v70; // rdx
  unsigned __int64 v71; // r8
  unsigned __int64 v72; // r13
  __int64 v73; // r8
  unsigned __int64 v74; // rdi
  __int128 *v75; // r9
  __int128 *v76; // r14
  __int128 *v77; // r10
  __int128 *v78; // r15
  unsigned __int64 v79; // r11
  __int64 v80; // rax
  unsigned __int64 v81; // rax
  __int64 v82; // rcx
  unsigned __int64 v83; // rdx
  unsigned __int64 v84; // rax
  bool v85; // bl
  unsigned __int64 v86; // rbp
  signed __int64 v87; // rbx
  __int64 v88; // rcx
  unsigned __int64 v89; // rax
  __int64 v90; // rbp
  signed __int64 v91; // rbx
  __int64 v92; // rax
  __int64 v93; // rsi
  unsigned __int64 v94; // rax
  unsigned __int64 *v95; // rbp
  __int64 v96; // rbx
  unsigned __int64 v97; // rax
  __int64 v98; // rbp
  unsigned __int64 v99; // rcx
  char v100; // al
  _BYTE *v101; // r10
  _BYTE *v102; // r10
  _BYTE *v103; // r10
  char v104; // al
  unsigned __int64 v105; // r14
  _BOOL8 v106; // rcx
  _BYTE *v107; // r9
  _BOOL8 v108; // rcx
  __int64 v109; // rbx
  __int64 v110; // rax
  _QWORD *v111; // r11
  __int128 *v112; // r10
  __int64 v113; // rcx
  __int64 v114; // rdx
  __int64 v115; // rax
  __int64 v116; // rcx
  __int64 v117; // rax
  __int64 v118; // rcx
  __int64 v119; // rdx
  unsigned __int64 v120; // rax
  __int64 v121; // rcx
  unsigned __int64 v122; // rax
  __int64 v123; // rcx
  __int64 v124; // rax
  __int64 v125; // rax
  __int64 v126; // rcx
  unsigned __int64 v127; // r12
  __int64 v128; // rax
  __int64 v129; // rcx
  unsigned __int64 v130; // rcx
  __int64 v131; // rbx
  unsigned __int64 v132; // r12
  __int128 v134; // [rsp+10h] [rbp-1A8h]
  __int128 v135; // [rsp+10h] [rbp-1A8h]
  __int128 v136; // [rsp+10h] [rbp-1A8h]
  __int128 v137; // [rsp+10h] [rbp-1A8h]
  __int128 v138; // [rsp+10h] [rbp-1A8h]
  __int128 v139; // [rsp+10h] [rbp-1A8h]
  __int128 v140; // [rsp+10h] [rbp-1A8h]
  __int64 v141; // [rsp+20h] [rbp-198h]
  __int64 v142; // [rsp+20h] [rbp-198h]
  __int64 v143; // [rsp+20h] [rbp-198h]
  __int64 v144; // [rsp+20h] [rbp-198h]
  __int64 v145; // [rsp+20h] [rbp-198h]
  __int64 v146; // [rsp+20h] [rbp-198h]
  __int64 v147; // [rsp+20h] [rbp-198h]
  __int64 v148; // [rsp+30h] [rbp-188h]
  _QWORD *v149; // [rsp+38h] [rbp-180h]
  unsigned __int64 v150; // [rsp+40h] [rbp-178h]
  unsigned __int64 v151; // [rsp+40h] [rbp-178h]
  unsigned __int64 v152; // [rsp+48h] [rbp-170h]
  __int64 v153; // [rsp+58h] [rbp-160h]
  unsigned __int64 v154; // [rsp+60h] [rbp-158h]
  __int128 v155; // [rsp+70h] [rbp-148h]
  __int128 v156; // [rsp+80h] [rbp-138h] BYREF
  __int64 v157; // [rsp+90h] [rbp-128h]
  __int128 v158[11]; // [rsp+100h] [rbp-B8h] BYREF

  if ( a2 < 0x15 )
  {
    v4 = a2;
    v5 = a1;
    goto LABEL_3;
  }
  v150 = a2;
  v148 = a1;
  v6 = 1;
  v7 = 1;
  do
  {
    v8 = v6 && v7;
    v5 = v148;
    v9 = v150;
    v149 = a3;
    while ( 1 )
    {
      if ( !a4 )
      {
        core::slice::sort::heapsort((__int128 *)v5, v9);
        return;
      }
      if ( !v6 )
      {
        core::slice::sort::break_patterns(v5, v9);
        a3 = v149;
        --a4;
      }
      v10 = v9 >> 2;
      v11 = 2 * (v9 >> 2);
      v12 = 3 * (v9 >> 2);
      if ( v9 <= 0x31 )
      {
        v18 = 0LL;
      }
      else
      {
        v13 = v10 - 1;
        v14 = *(_QWORD *)(v5 + 24 * v10);
        if ( v14 >= *(_QWORD *)(v5 + 24 * v10 - 24) )
        {
          v16 = *(_QWORD *)(v5 + 24 * v10 - 24);
          v15 = 0LL;
          v17 = v9 >> 2;
        }
        else
        {
          v15 = 1LL;
          v16 = *(_QWORD *)(v5 + 24 * v10);
          v17 = v10 - 1;
          v13 = v9 >> 2;
          v14 = *(_QWORD *)(v5 + 24 * v10 - 24);
        }
        ++v10;
        v19 = *(_QWORD *)(v5 + 24 * v10);
        v20 = 0LL;
        v21 = v19 < v14;
        if ( v19 < v14 )
          v14 = *(_QWORD *)(v5 + 24 * v10);
        else
          v10 = v17;
        LOBYTE(v20) = v21;
        v22 = v15 + (v14 < v16) + v20;
        if ( v14 < v16 )
          v10 = v13;
        v23 = v11 - 1;
        v24 = *(_QWORD *)(v5 + 48 * (v9 >> 2) - 24);
        if ( *(_QWORD *)(v5 + 48 * (v9 >> 2)) >= v24 )
        {
          v25 = *(_QWORD *)(v5 + 48 * (v9 >> 2) - 24);
          v26 = 2 * (v9 >> 2);
          v24 = *(_QWORD *)(v5 + 48 * (v9 >> 2));
        }
        else
        {
          ++v22;
          v25 = *(_QWORD *)(v5 + 48 * (v9 >> 2));
          v26 = v11 - 1;
          v23 = 2 * (v9 >> 2);
        }
        v11 |= 1uLL;
        v27 = *(_QWORD *)(v5 + 24 * v11);
        v28 = 0LL;
        v29 = v27 < v24;
        if ( v27 < v24 )
          v24 = *(_QWORD *)(v5 + 24 * v11);
        else
          v11 = v26;
        LOBYTE(v28) = v29;
        v30 = v22 + (v24 < v25) + v28;
        if ( v24 < v25 )
          v11 = v23;
        v31 = v12 - 1;
        v32 = *(_QWORD *)(v5 + 72 * (v9 >> 2) - 24);
        if ( *(_QWORD *)(v5 + 72 * (v9 >> 2)) >= v32 )
        {
          v33 = *(_QWORD *)(v5 + 72 * (v9 >> 2) - 24);
          v34 = 3 * (v9 >> 2);
          v32 = *(_QWORD *)(v5 + 72 * (v9 >> 2));
        }
        else
        {
          ++v30;
          v33 = *(_QWORD *)(v5 + 72 * (v9 >> 2));
          v34 = v12 - 1;
          v31 = 3 * (v9 >> 2);
        }
        ++v12;
        v35 = *(_QWORD *)(v5 + 24 * v12);
        v36 = 0LL;
        v37 = v35 < v32;
        if ( v35 < v32 )
          v32 = *(_QWORD *)(v5 + 24 * v12);
        else
          v12 = v34;
        LOBYTE(v36) = v37;
        v18 = v30 + (v32 < v33) + v36;
        if ( v32 < v33 )
          v12 = v31;
        a3 = v149;
      }
      v38 = *(_QWORD *)(v5 + 24 * v11);
      v39 = *(_QWORD *)(v5 + 24 * v10);
      if ( v38 >= v39 )
      {
        v40 = *(_QWORD *)(v5 + 24 * v10);
        v41 = v11;
        v11 = v10;
        v39 = v38;
      }
      else
      {
        ++v18;
        v40 = *(_QWORD *)(v5 + 24 * v11);
        v41 = v10;
      }
      v42 = *(_QWORD *)(v5 + 24 * v12);
      v43 = (v42 < v39) + v18;
      if ( v42 < v39 )
      {
        v41 = v12;
        v39 = *(_QWORD *)(v5 + 24 * v12);
      }
      if ( v39 >= v40 )
      {
        v11 = v41;
        v44 = v43;
      }
      else
      {
        v44 = 1LL;
        if ( v43 >= 0xB )
        {
          v45 = v9 >> 1;
          v46 = (_QWORD *)(v5 + 16);
          v47 = (_QWORD *)(v5 + 24 * v9 - 8);
          do
          {
            v48 = *((_OWORD *)v46 - 1);
            *((_OWORD *)v46 - 1) = *((_OWORD *)v47 - 1);
            *((_OWORD *)v47 - 1) = v48;
            v49 = *v46;
            *v46 = *v47;
            *v47 = v49;
            v46 += 3;
            v47 -= 3;
            --v45;
          }
          while ( v45 );
          v11 = v9 + ~v11;
          if ( !v8 )
            goto LABEL_51;
          goto LABEL_67;
        }
      }
      if ( v44 != 0 || !v8 )
        goto LABEL_51;
LABEL_67:
      v62 = core::slice::sort::partial_insertion_sort((__int64 *)v5, v9);
      a3 = v149;
      if ( v62 )
        return;
LABEL_51:
      if ( !a3 )
      {
        v63 = v150;
        goto LABEL_71;
      }
      if ( v11 >= v9 )
        core::panicking::panic_bounds_check(v11, v9, (__int64)&off_58518);
      if ( *a3 < *(_QWORD *)(v5 + 24 * v11) )
        break;
      v50 = v5 + 24 * v11;
      v157 = *(_QWORD *)(v5 + 16);
      v156 = *(_OWORD *)v5;
      v51 = *(_QWORD *)(v50 + 16);
      *(_OWORD *)v5 = *(_OWORD *)v50;
      *(_QWORD *)(v5 + 16) = v51;
      *(_QWORD *)(v50 + 16) = v157;
      *(_OWORD *)v50 = v156;
      v52 = v5 + 24;
      v53 = v9 - 1;
      v54 = *(_QWORD *)v5;
      v158[0] = *(_OWORD *)(v5 + 8);
      v55 = 0LL;
      if ( v9 != 1 )
      {
LABEL_55:
        v56 = (unsigned __int64 *)(v52 + 24 * v55);
        while ( v54 >= *v56 )
        {
          ++v55;
          v56 += 3;
          if ( v53 == v55 )
          {
            v55 = v53;
            break;
          }
        }
      }
LABEL_59:
      v57 = v52 + 24 * v53;
      while ( v55 < --v53 )
      {
        v58 = v57 - 24;
        v21 = v54 < *(_QWORD *)(v57 - 24);
        v57 -= 24LL;
        if ( !v21 )
        {
          v59 = 3 * v55;
          v157 = *(_QWORD *)(v52 + 24 * v55 + 16);
          v156 = *(_OWORD *)(v52 + 24 * v55);
          v60 = *(_QWORD *)(v58 + 16);
          *(_OWORD *)(v52 + 8 * v59) = *(_OWORD *)v58;
          *(_QWORD *)(v52 + 8 * v59 + 16) = v60;
          *(_QWORD *)(v58 + 16) = v157;
          *(_OWORD *)v58 = v156;
          if ( ++v55 < v53 )
            goto LABEL_55;
          goto LABEL_59;
        }
      }
      v61 = v55 + 1;
      *(_QWORD *)v5 = v54;
      *(_OWORD *)(v5 + 8) = v158[0];
      v4 = v9 - v61;
      if ( v9 < v61 )
        core::slice::index::slice_start_index_len_fail(v61, v9, (__int64)&off_58530);
      v5 += 24 * v61;
      v9 -= v61;
      if ( v4 < 0x15 )
        goto LABEL_3;
    }
    v148 = v5;
    v63 = v9;
LABEL_71:
    if ( v11 >= v63 )
      core::panicking::panic_bounds_check(v11, v63, (__int64)&off_58590);
    v64 = 3 * v11;
    v157 = *(_QWORD *)(v148 + 16);
    v156 = *(_OWORD *)v148;
    v65 = *(_QWORD *)(v148 + 24 * v11 + 16);
    *(_OWORD *)v148 = *(_OWORD *)(v148 + 24 * v11);
    *(_QWORD *)(v148 + 16) = v65;
    *(_QWORD *)(v148 + 8 * v64 + 16) = v157;
    *(_OWORD *)(v148 + 8 * v64) = v156;
    v66 = v63 - 1;
    v67 = *(_QWORD *)v148;
    v155 = *(_OWORD *)(v148 + 8);
    v68 = (unsigned __int64 *)(v148 + 24);
    v69 = 0LL;
    while ( *v68 < v67 )
    {
      ++v69;
      v68 += 3;
      if ( v66 == v69 )
      {
        v69 = v63 - 1;
        break;
      }
    }
    v70 = v148 + 24 * v63;
    do
    {
      v71 = v66;
      v72 = v70;
      if ( v69 >= v66 )
        break;
      --v66;
      v70 -= 24LL;
    }
    while ( *(_QWORD *)(v72 - 24) >= v67 );
    v151 = v63;
    v152 = v71;
    if ( v69 > v71 )
      core::slice::index::slice_index_order_fail(v69, v71, (__int64)&off_585A8);
    v154 = v69;
    v73 = v148 + 24 + 24 * v69;
    v74 = 128LL;
    v75 = 0LL;
    v76 = 0LL;
    v77 = 0LL;
    v78 = 0LL;
    v79 = 128LL;
    v153 = v73;
    while ( 2 )
    {
      v83 = v72 - v73;
      if ( v72 - v73 < 0x1818 )
      {
        v84 = (unsigned __int16)v83 / 0x18u;
        v85 = v78 < v77 || v76 < v75;
        v86 = v84;
        if ( v85 )
          v86 = v84 - 128;
        if ( v78 >= v77 )
          v79 = v86;
        else
          v74 = v84 - 128;
        if ( !v85 )
        {
          v79 = (unsigned __int16)v83 / 0x30u;
          v74 = v84 - v79;
        }
      }
      if ( v78 == v77 )
      {
        if ( !v79 )
        {
          v78 = v158;
          v77 = v158;
          goto LABEL_96;
        }
        v78 = v158;
        if ( v79 >= 4 )
        {
          v77 = v158;
          v95 = (unsigned __int64 *)v73;
          v96 = 0LL;
          do
          {
            v100 = v96;
            *(_BYTE *)v77 = v96;
            v101 = (char *)v77 - (*v95 < v67) + 1;
            *v101 = v96 + 1;
            v102 = &v101[-(v95[3] < v67) + 1];
            v21 = v95[6] < v67;
            *v102 = v96 + 2;
            v103 = &v102[-v21 + 1];
            v96 += 4LL;
            *v103 = v100 + 3;
            v77 = (__int128 *)&v103[-(v95[9] < v67) + 1];
            v95 += 12;
          }
          while ( (v79 & 0xFFFFFFFFFFFFFFFCLL) != v96 );
          v78 = v158;
          v97 = v79 & 3;
          if ( (v79 & 3) == 0 )
            goto LABEL_96;
        }
        else
        {
          v77 = v158;
          v95 = (unsigned __int64 *)v73;
          LOBYTE(v96) = 0;
          v97 = v79 & 3;
          if ( (v79 & 3) == 0 )
            goto LABEL_96;
        }
        do
        {
          *(_BYTE *)v77 = v96;
          v77 = (__int128 *)((char *)v77 - (*v95 < v67) + 1);
          v95 += 3;
          LOBYTE(v96) = v96 + 1;
          --v97;
        }
        while ( v97 );
        v78 = v158;
      }
LABEL_96:
      if ( v76 == v75 )
      {
        if ( v74 )
        {
          if ( v74 >= 4 )
          {
            v75 = &v156;
            v104 = 0;
            v105 = v72;
            v98 = 0LL;
            do
            {
              *(_BYTE *)v75 = v104;
              v106 = *(_QWORD *)(v105 - 24) < v67;
              v21 = *(_QWORD *)(v105 - 48) < v67;
              *((_BYTE *)v75 + v106) = v104 + 1;
              v107 = (char *)v75 + v21 + v106;
              *v107 = v104 + 2;
              v108 = *(_QWORD *)(v105 - 72) < v67;
              v98 += 4LL;
              v107[v108] = v104 + 3;
              v75 = (__int128 *)&v107[(*(_QWORD *)(v105 - 96) < v67) + v108];
              v99 = v105 - 96;
              v104 = v98;
              v105 -= 96LL;
            }
            while ( (v74 & 0xFFFFFFFFFFFFFFFCLL) != v98 );
          }
          else
          {
            v75 = &v156;
            LOBYTE(v98) = 0;
            v99 = v72;
          }
          v76 = &v156;
          if ( (v74 & 3) != 0 )
          {
            v109 = 0LL;
            do
            {
              *(_BYTE *)v75 = v98;
              v75 = (__int128 *)((char *)v75 + (*(_QWORD *)(v99 + v109 - 24) < v67));
              LOBYTE(v98) = v98 + 1;
              v109 -= 24LL;
            }
            while ( v109 + 24 * (v74 & 3) );
            v76 = &v156;
          }
        }
        else
        {
          v76 = &v156;
          v75 = &v156;
        }
      }
      v87 = (char *)v75 - (char *)v76;
      if ( (char *)v77 - (char *)v78 < (unsigned __int64)((char *)v75 - (char *)v76) )
        v87 = (char *)v77 - (char *)v78;
      if ( v87 )
      {
        v141 = *(_QWORD *)(v73 + 24LL * *(unsigned __int8 *)v78 + 16);
        v134 = *(_OWORD *)(v73 + 24LL * *(unsigned __int8 *)v78);
        LOBYTE(v88) = *(_BYTE *)v76;
        v89 = ~(unsigned __int64)*(unsigned __int8 *)v76;
        v90 = 3LL * *(unsigned __int8 *)v78;
        *(_QWORD *)(v73 + 8 * v90 + 16) = *(_QWORD *)(v72 + 24 * v89 + 16);
        *(_OWORD *)(v73 + 8 * v90) = *(_OWORD *)(v72 + 24 * v89);
        if ( v87 != 1 )
        {
          v91 = v87 - 1;
          do
          {
            v92 = *((unsigned __int8 *)v78 + 1);
            v78 = (__int128 *)((char *)v78 + 1);
            v93 = 3 * v92;
            v94 = 3 * ~(unsigned __int64)(unsigned __int8)v88;
            *(_QWORD *)(v72 + 8 * v94 + 16) = *(_QWORD *)(v73 + 8 * v93 + 16);
            *(_OWORD *)(v72 + 8 * v94) = *(_OWORD *)(v73 + 8 * v93);
            v88 = *((unsigned __int8 *)v76 + 1);
            v76 = (__int128 *)((char *)v76 + 1);
            v89 = ~v88;
            *(_QWORD *)(v73 + 8 * v93 + 16) = *(_QWORD *)(v72 + 24 * ~v88 + 16);
            *(_OWORD *)(v73 + 8 * v93) = *(_OWORD *)(v72 + 24 * ~v88);
            --v91;
          }
          while ( v91 );
        }
        v80 = 3 * v89;
        *(_QWORD *)(v72 + 8 * v80 + 16) = v141;
        *(_OWORD *)(v72 + 8 * v80) = v134;
        v78 = (__int128 *)((char *)v78 + 1);
        v76 = (__int128 *)((char *)v76 + 1);
      }
      v81 = 0LL;
      if ( v78 == v77 )
        v81 = v79;
      v82 = -(__int64)v74;
      if ( v76 != v75 )
        v82 = 0LL;
      v73 += 24 * v81;
      v72 += 24 * v82;
      if ( v83 >= 0x1818 )
        continue;
      break;
    }
    if ( v78 >= v77 )
    {
      v111 = v149;
      if ( v76 < v75 )
      {
        v110 = (unsigned int)((_DWORD)v75 - (_DWORD)v76);
        if ( (((_BYTE)v75 - (_BYTE)v76) & 1) != 0 )
        {
          v112 = (__int128 *)((char *)v75 - 1);
          v120 = 3 * ~(unsigned __int64)*((unsigned __int8 *)v75 - 1);
          v145 = *(_QWORD *)(v73 + 16);
          v138 = *(_OWORD *)v73;
          v121 = *(_QWORD *)(v72 + 24 * ~(unsigned __int64)*((unsigned __int8 *)v75 - 1) + 16);
          *(_OWORD *)v73 = *(_OWORD *)(v72 + 24 * ~(unsigned __int64)*((unsigned __int8 *)v75 - 1));
          *(_QWORD *)(v73 + 16) = v121;
          *(_QWORD *)(v72 + 8 * v120 + 16) = v145;
          *(_OWORD *)(v72 + 8 * v120) = v138;
          v73 += 24LL;
          v110 = v73;
          v75 = (__int128 *)((char *)v75 - 1);
          if ( v75 == v76 )
            goto LABEL_138;
        }
        else
        {
          v112 = v75;
          v75 = (__int128 *)((char *)v75 - 1);
          if ( v75 == v76 )
            goto LABEL_138;
        }
        do
        {
          v122 = 3 * ~(unsigned __int64)*((unsigned __int8 *)v112 - 1);
          v146 = *(_QWORD *)(v73 + 16);
          v139 = *(_OWORD *)v73;
          v123 = *(_QWORD *)(v72 + 24 * ~(unsigned __int64)*((unsigned __int8 *)v112 - 1) + 16);
          *(_OWORD *)v73 = *(_OWORD *)(v72 + 24 * ~(unsigned __int64)*((unsigned __int8 *)v112 - 1));
          *(_QWORD *)(v73 + 16) = v123;
          *(_QWORD *)(v72 + 8 * v122 + 16) = v146;
          *(_OWORD *)(v72 + 8 * v122) = v139;
          v124 = *((unsigned __int8 *)v112 - 2);
          v112 = (__int128 *)((char *)v112 - 2);
          v125 = 3 * ~v124;
          v147 = *(_QWORD *)(v73 + 40);
          v140 = *(_OWORD *)(v73 + 24);
          v126 = *(_QWORD *)(v72 + 8 * v125 + 16);
          *(_OWORD *)(v73 + 24) = *(_OWORD *)(v72 + 8 * v125);
          *(_QWORD *)(v73 + 40) = v126;
          *(_QWORD *)(v72 + 8 * v125 + 16) = v147;
          *(_OWORD *)(v72 + 8 * v125) = v140;
          v73 += 48LL;
        }
        while ( v76 < v112 );
      }
      v110 = v73;
      goto LABEL_138;
    }
    v110 = (unsigned int)((_DWORD)v77 - (_DWORD)v78);
    v111 = v149;
    if ( (((_BYTE)v77 - (_BYTE)v78) & 1) != 0 )
    {
      v75 = (__int128 *)((char *)v77 - 1);
      v113 = 3LL * *((unsigned __int8 *)v77 - 1);
      v110 = v72 - 24;
      v142 = *(_QWORD *)(v73 + 24LL * *((unsigned __int8 *)v77 - 1) + 16);
      v135 = *(_OWORD *)(v73 + 24LL * *((unsigned __int8 *)v77 - 1));
      v114 = *(_QWORD *)(v72 - 8);
      *(_OWORD *)(v73 + 8 * v113) = *(_OWORD *)(v72 - 24);
      *(_QWORD *)(v73 + 8 * v113 + 16) = v114;
      *(_QWORD *)(v72 - 8) = v142;
      *(_OWORD *)(v72 - 24) = v135;
      v72 -= 24LL;
      if ( (__int128 *)((char *)v77 - 1) == v78 )
        goto LABEL_138;
    }
    else
    {
      v75 = v77;
      if ( (__int128 *)((char *)v77 - 1) == v78 )
        goto LABEL_138;
    }
    do
    {
      v115 = 3LL * *((unsigned __int8 *)v75 - 1);
      v143 = *(_QWORD *)(v73 + 24LL * *((unsigned __int8 *)v75 - 1) + 16);
      v136 = *(_OWORD *)(v73 + 24LL * *((unsigned __int8 *)v75 - 1));
      v116 = *(_QWORD *)(v72 - 8);
      *(_OWORD *)(v73 + 8 * v115) = *(_OWORD *)(v72 - 24);
      *(_QWORD *)(v73 + 8 * v115 + 16) = v116;
      *(_QWORD *)(v72 - 8) = v143;
      *(_OWORD *)(v72 - 24) = v136;
      v117 = *((unsigned __int8 *)v75 - 2);
      v75 = (__int128 *)((char *)v75 - 2);
      v118 = 3 * v117;
      v110 = v72 - 48;
      v144 = *(_QWORD *)(v73 + 8 * v118 + 16);
      v137 = *(_OWORD *)(v73 + 8 * v118);
      v119 = *(_QWORD *)(v72 - 32);
      *(_OWORD *)(v73 + 8 * v118) = *(_OWORD *)(v72 - 48);
      *(_QWORD *)(v73 + 8 * v118 + 16) = v119;
      *(_QWORD *)(v72 - 32) = v144;
      *(_OWORD *)(v72 - 48) = v137;
      v72 -= 48LL;
    }
    while ( v78 < v75 );
LABEL_138:
    v4 = v154 + (v110 - v153) / 0x18uLL;
    *(_QWORD *)v148 = v67;
    *(_OWORD *)(v148 + 8) = v155;
    v127 = v151 - v4;
    if ( v151 <= v4 )
      core::panicking::panic_bounds_check(v4, v151, (__int64)&off_585C0);
    v7 = v154 >= v152;
    v128 = 3 * v4;
    v157 = *(_QWORD *)(v148 + 16);
    v156 = *(_OWORD *)v148;
    v129 = *(_QWORD *)(v148 + 24 * v4 + 16);
    *(_OWORD *)v148 = *(_OWORD *)(v148 + 24 * v4);
    *(_QWORD *)(v148 + 16) = v129;
    *(_QWORD *)(v148 + 8 * v128 + 16) = v157;
    *(_OWORD *)(v148 + 8 * v128) = v156;
    v130 = v151 - v4;
    if ( v4 < v127 )
      v130 = v4;
    v6 = v130 >= v151 >> 3;
    v131 = v148 + 24 * v4 + 24;
    v132 = v127 - 1;
    if ( v4 >= v132 )
    {
      core::slice::sort::recurse(v148 + 24 * v4 + 24, v132, v148 + 24 * v4, a4, v73, v75);
      a3 = v149;
      v5 = v148;
    }
    else
    {
      core::slice::sort::recurse(v148, v4, v111, a4, v73, v75);
      a3 = (_QWORD *)(v148 + 24 * v4);
      v4 = v132;
      v5 = v131;
    }
    v150 = v4;
    v148 = v5;
  }
  while ( v4 >= 0x15 );
LABEL_3:
  if ( v4 > 1 )
    core::slice::sort::insertion_sort_shift_left(v5, v4, 1uLL);
}
// 58518: using guessed type char *off_58518;
// 58530: using guessed type char *off_58530;
// 58590: using guessed type char *off_58590;
// 585A8: using guessed type char *off_585A8;
// 585C0: using guessed type char *off_585C0;

//----- (000000000000D750) ----------------------------------------------------
void __fastcall core::option::Option<&T>::cloned(
        _QWORD *a1,
        _QWORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  unsigned int v8; // edx
  unsigned __int64 v9; // r8

  if ( a2 )
  {
    v6 = *a2;
    switch ( *a2 )
    {
      case 0LL:
      case 5LL:
      case 6LL:
      case 7LL:
      case 0xALL:
      case 0xBLL:
      case 0xCLL:
      case 0xDLL:
      case 0xELL:
      case 0xFLL:
      case 0x10LL:
      case 0x11LL:
      case 0x12LL:
      case 0x13LL:
      case 0x14LL:
      case 0x15LL:
      case 0x16LL:
      case 0x17LL:
      case 0x18LL:
      case 0x19LL:
      case 0x1ALL:
      case 0x1BLL:
      case 0x1CLL:
      case 0x1DLL:
      case 0x1ELL:
      case 0x27LL:
      case 0x2CLL:
      case 0x2DLL:
        v7 = a2[1];
        v8 = (unsigned int)v7 >> 8;
        a2 = (_QWORD *)(v7 >> 16);
        v9 = v7 & 0xFFFFFFFF00000000LL;
        break;
      case 1LL:
      case 8LL:
      case 0x1FLL:
        v7 = a2[1];
        a6 = a2[2];
        v8 = (unsigned int)v7 >> 8;
        a2 = (_QWORD *)(v7 >> 16);
        v9 = v7 & 0xFFFFFFFF00000000LL;
        break;
      case 2LL:
      case 9LL:
      case 0x20LL:
      case 0x21LL:
      case 0x22LL:
      case 0x23LL:
      case 0x24LL:
      case 0x25LL:
      case 0x28LL:
      case 0x29LL:
      case 0x2ALL:
      case 0x2BLL:
        LOBYTE(v7) = *((_BYTE *)a2 + 8);
        LODWORD(a2) = 0;
        v9 = 0LL;
        LOWORD(v8) = 0;
        break;
      case 3LL:
      case 0x26LL:
        LOWORD(v7) = *((_WORD *)a2 + 4);
        v8 = BYTE1(v7);
        LODWORD(a2) = 0;
        v9 = 0LL;
        break;
      case 4LL:
        LODWORD(v7) = *((_DWORD *)a2 + 2);
        v8 = (unsigned int)v7 >> 8;
        LODWORD(a2) = WORD1(v7);
        v9 = 0LL;
        break;
    }
    *a1 = v6;
    a1[1] = v9 | ((_DWORD)a2 << 16) | (unsigned int)(unsigned __int16)(((_WORD)v8 << 8) | (unsigned __int8)v7);
    a1[2] = a6;
  }
  else
  {
    *a1 = 46LL;
  }
}

//----- (000000000000D800) ----------------------------------------------------
__int64 __fastcall <*mut T as core::fmt::Debug>::fmt(unsigned __int64 *a1, __m128i *a2)
{
  return core::fmt::pointer_fmt_inner(*a1, a2);
}

//----- (000000000000D810) ----------------------------------------------------
__int64 __fastcall <&str as core::str::pattern::Pattern>::is_contained_in(
        _BYTE *s2,
        size_t n,
        char *s1,
        unsigned __int64 a4)
{
  unsigned __int8 v6; // al
  unsigned __int8 v7; // cl
  __int64 v8; // r13
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r13
  int v12; // eax
  char *v13; // r15
  size_t v14; // rbx
  int v15; // eax
  unsigned __int64 v16; // r11
  unsigned __int64 v17; // r9
  __int64 v18; // rdi
  unsigned __int64 v19; // rcx
  __int64 v20; // rbx
  __m128i v21; // xmm0
  __m128i v22; // xmm2
  __m128i v23; // xmm0
  __m128i v24; // xmm3
  size_t v25; // rcx
  char *v26; // r14
  __int64 v27; // rbp
  __m128i si128; // xmm8
  __m128i v29; // xmm6
  __m128i v30; // xmm4
  __m128i v31; // xmm9
  __m128i v32; // xmm7
  __m128i v33; // xmm5
  int v34; // edx
  int v35; // edx
  int v36; // edx
  int v37; // edx
  unsigned __int64 v38; // rax
  char v39; // al
  int v40; // eax
  char v41; // al
  int v42; // eax
  char v43; // al
  int v44; // eax
  char v45; // al
  int v46; // eax
  unsigned __int64 v47; // rax
  unsigned __int8 v48; // al
  int v49; // edx
  int v50; // eax
  __int64 v51; // rbx
  int v52; // edx
  unsigned __int64 v53; // rcx
  unsigned __int64 v54; // r13
  unsigned __int64 v55; // rbp
  bool v56; // zf
  unsigned __int64 v57; // rcx
  unsigned __int64 v58; // rdx
  __int64 v59; // r14
  unsigned __int64 v60; // rcx
  __int64 v61; // rbx
  unsigned __int64 v62; // r15
  __int64 v63; // r14
  __int64 v64; // rdi
  __int64 v65; // rcx
  char *v66; // r8
  __int64 v67; // rbp
  char v68; // r13
  unsigned __int64 v69; // rcx
  char *v70; // rbp
  char v71; // di
  bool v72; // bp
  int v73; // eax
  unsigned int v74; // esi
  int v75; // esi
  int v76; // r10d
  int v77; // r9d
  __int64 v79; // rax
  unsigned __int64 v80; // rdi
  unsigned __int64 v81; // r14
  char v82; // [rsp+0h] [rbp-148h]
  char v83; // [rsp+0h] [rbp-148h]
  char v84; // [rsp+0h] [rbp-148h]
  char v85; // [rsp+0h] [rbp-148h]
  __m128i v86; // [rsp+10h] [rbp-138h] BYREF
  __m128i v87; // [rsp+20h] [rbp-128h] BYREF
  __m128i v88; // [rsp+30h] [rbp-118h] BYREF
  __m128i v89; // [rsp+40h] [rbp-108h] BYREF
  char *v90; // [rsp+58h] [rbp-F0h] BYREF
  unsigned __int64 v91; // [rsp+60h] [rbp-E8h]
  _BYTE *v92; // [rsp+68h] [rbp-E0h]
  __int64 v93; // [rsp+70h] [rbp-D8h]
  __int64 v94; // [rsp+78h] [rbp-D0h]
  __int64 v95; // [rsp+80h] [rbp-C8h]
  unsigned __int64 v96; // [rsp+90h] [rbp-B8h]
  _BYTE *v97; // [rsp+A0h] [rbp-A8h]
  unsigned __int64 v98; // [rsp+A8h] [rbp-A0h]
  __int64 v99; // [rsp+B0h] [rbp-98h]
  unsigned __int64 v100; // [rsp+B8h] [rbp-90h]
  __m128i v101; // [rsp+C0h] [rbp-88h] BYREF
  __m128i v102; // [rsp+D0h] [rbp-78h] BYREF
  __int64 v103; // [rsp+E8h] [rbp-60h]
  __m128i v104; // [rsp+F0h] [rbp-58h] BYREF
  __m128i v105[4]; // [rsp+100h] [rbp-48h] BYREF

  if ( n >= a4 )
  {
    if ( n != a4 )
      goto LABEL_102;
    LOBYTE(v9) = bcmp(s2, s1, n) == 0;
    return (unsigned int)v9;
  }
  if ( !n )
    core::panicking::panic_bounds_check(0LL, 0LL, (__int64)&off_58330);
  v6 = *s2;
  if ( n == 2 )
  {
    if ( a4 < 0x11 )
      goto LABEL_15;
    v7 = s2[1];
    v8 = 1LL;
    goto LABEL_25;
  }
  v10 = 0LL;
  if ( n >= 4 )
    v10 = n - 4;
  v11 = n - 1;
  do
  {
    if ( v10 >= v11 + 1 )
    {
      core::str::pattern::StrSearcher::new((__int64)&v90, (__int64)s1, a4, s2, n);
      if ( v90 )
      {
        v16 = v96;
        v17 = v100 - 1;
        if ( v96 == -1LL )
        {
          v59 = v95;
          v60 = v95 + v17;
          if ( v95 + v17 >= v98 )
            goto LABEL_102;
          v61 = v94;
          v86.m128i_i64[0] = v93;
          v62 = v91 - 1;
          v87.m128i_i64[0] = v99 + v91 - 1;
          while ( !_bittest64(&v61, (unsigned __int8)v97[v60]) )
          {
            v63 = v100 + v59;
LABEL_73:
            v64 = v63;
LABEL_74:
            v60 = v64 + v17;
            LODWORD(v9) = 0;
            v59 = v64;
            if ( v64 + v17 >= v98 )
              return (unsigned int)v9;
          }
          v65 = 0LL;
          v66 = (char *)(v91 + v99);
          v67 = v59;
          while ( v91 + v65 < v100 )
          {
            if ( v91 + v67 >= v98 )
            {
              v81 = v91 + v59;
              if ( v98 > v81 )
                v81 = v98;
              core::panicking::panic_bounds_check(v81, v98, (__int64)&off_58390);
            }
            v68 = *v66;
            v64 = v67 + 1;
            ++v66;
            ++v65;
            v56 = v68 == v97[v91 + v67++];
            if ( !v56 )
              goto LABEL_74;
          }
          v69 = v62 + v59;
          v70 = (char *)v87.m128i_i64[0];
          v9 = 1 - v91;
          while ( v9 != 1 )
          {
            if ( v62 >= v100 )
              core::panicking::panic_bounds_check(-(__int64)v9, v100, (__int64)&off_58360);
            if ( v69 >= v98 )
              core::panicking::panic_bounds_check(v69, v98, (__int64)&off_58378);
            v71 = *v70;
            ++v9;
            --v70;
            v56 = v71 == v97[v69--];
            if ( !v56 )
            {
              v63 = v86.m128i_i64[0] + v59;
              goto LABEL_73;
            }
          }
        }
        else
        {
          v18 = v95;
          v19 = v95 + v17;
          if ( v95 + v17 >= v98 )
            goto LABEL_102;
          v20 = v94;
LABEL_50:
          while ( !_bittest64(&v20, (unsigned __int8)v97[v19]) )
          {
            v18 += v100;
LABEL_49:
            v16 = 0LL;
            v19 = v18 + v17;
            if ( v18 + v17 >= v98 )
              goto LABEL_102;
          }
          v53 = v16;
          if ( v91 > v16 )
            v53 = v91;
          v9 = (unsigned __int64)&v97[v18];
          v54 = v53;
          while ( v54 < v100 )
          {
            if ( v18 + v54 >= v98 )
            {
              v80 = v53 + v18;
              if ( v98 > v80 )
                v80 = v98;
              core::panicking::panic_bounds_check(v80, v98, (__int64)&off_58390);
            }
            v55 = v54 + 1;
            v56 = *(_BYTE *)(v99 + v54) == *(_BYTE *)(v9 + v54);
            ++v54;
            if ( !v56 )
            {
              v18 = v55 + v18 - v91;
              goto LABEL_49;
            }
          }
          v57 = v91;
          while ( v16 < v57 )
          {
            if ( --v57 >= v100 )
              core::panicking::panic_bounds_check(v57, v100, (__int64)&off_58360);
            v9 = v57 + v18;
            if ( v57 + v18 >= v98 )
              core::panicking::panic_bounds_check(v57 + v18, v98, (__int64)&off_58378);
            if ( *(_BYTE *)(v99 + v57) != v97[v9] )
            {
              v18 += v93;
              v16 = v100 - v93;
              v19 = v18 + v17;
              if ( v18 + v17 < v98 )
                goto LABEL_50;
              goto LABEL_102;
            }
          }
        }
LABEL_19:
        LOBYTE(v9) = 1;
        return (unsigned int)v9;
      }
      if ( BYTE2(v93) )
        goto LABEL_102;
      v58 = v91;
      if ( v91 )
      {
        if ( v91 >= v98 )
        {
          if ( v91 != v98 )
            goto LABEL_110;
        }
        else if ( (char)v97[v91] < -64 )
        {
          goto LABEL_110;
        }
      }
      if ( v91 == v98 )
      {
        LOBYTE(v9) = 1;
        if ( !(_BYTE)v93 )
          goto LABEL_102;
        return (unsigned int)v9;
      }
      LODWORD(v9) = (unsigned __int8)v97[v91];
      if ( (v9 & 0x80u) != 0LL )
      {
        v75 = v9 & 0x1F;
        v76 = v97[v91 + 1] & 0x3F;
        if ( (unsigned __int8)v9 < 0xE0u )
        {
          v74 = v76 | (v75 << 6);
        }
        else
        {
          v77 = (v76 << 6) | v97[v91 + 2] & 0x3F;
          if ( (unsigned __int8)v9 < 0xF0u )
          {
            v74 = v77 | (v75 << 12);
          }
          else
          {
            LODWORD(v9) = (v77 << 6) | v97[v91 + 3] & 0x3F;
            v74 = v9 | ((v75 & 7) << 18);
          }
        }
      }
      else
      {
        v74 = (unsigned __int8)v97[v91];
      }
      LOBYTE(v9) = 1;
      if ( (_BYTE)v93 )
        return (unsigned int)v9;
      if ( v74 == 1114112 )
        goto LABEL_102;
      v79 = 1LL;
      if ( v74 >= 0x80 )
      {
        v79 = 2LL;
        if ( v74 >= 0x800 )
          v79 = 4LL - (v74 < 0x10000);
      }
      v58 = v79 + v91;
      if ( !(v79 + v91) )
        return (unsigned int)v9;
      if ( v58 >= v98 )
      {
        if ( v58 == v98 )
          return (unsigned int)v9;
      }
      else if ( (char)v97[v58] > -65 )
      {
        return (unsigned int)v9;
      }
LABEL_110:
      core::str::slice_error_fail(v97, v98, v58, v98, (__int64)&off_58838);
    }
    if ( v11 >= n )
      core::panicking::panic_bounds_check(v11, n, (__int64)&off_58348);
    v7 = s2[v11--];
  }
  while ( v7 == v6 );
  if ( n + 15 <= a4 )
  {
    v8 = v11 + 1;
LABEL_25:
    v21 = _mm_cvtsi32_si128(v6);
    v22 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v21, v21), 0), 0);
    v23 = _mm_cvtsi32_si128(v7);
    v24 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v23, v23), 0), 0);
    v90 = s1;
    v91 = a4;
    v92 = s2 + 1;
    v103 = n - 1;
    v93 = n - 1;
    v87 = v22;
    v86 = v24;
    if ( n + 63 < a4 )
    {
      v25 = n + 127;
      v26 = &s1[v8 + 48];
      LODWORD(v9) = 0;
      v27 = 0LL;
      while ( 1 )
      {
        si128 = _mm_loadu_si128((const __m128i *)&s1[v27 + 16]);
        v29 = _mm_loadu_si128((const __m128i *)&s1[v27 + 32]);
        v30 = _mm_loadu_si128((const __m128i *)&s1[v27 + 48]);
        v31 = _mm_loadu_si128((const __m128i *)&v26[v27 - 32]);
        v32 = _mm_loadu_si128((const __m128i *)&v26[v27 - 16]);
        v33 = _mm_loadu_si128((const __m128i *)&v26[v27]);
        v34 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&s1[v8 + v27]), v24),
                  _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&s1[v27]), v22)));
        if ( v34 )
        {
          v82 = v9;
          v89 = v30;
          v88 = v33;
          v102 = v29;
          v101 = v32;
          v105[0] = si128;
          v104 = v31;
          v39 = core::str::pattern::simd_contains::{{closure}}(&v90, v27, v34, v9 & 1);
          v31 = _mm_load_si128(&v104);
          si128 = _mm_load_si128(v105);
          v32 = _mm_load_si128(&v101);
          v29 = _mm_load_si128(&v102);
          v33 = _mm_load_si128(&v88);
          v30 = _mm_load_si128(&v89);
          v25 = n + 127;
          v24 = _mm_load_si128(&v86);
          v22 = _mm_load_si128(&v87);
          LOBYTE(v40) = (v82 | v39) & 1;
          LODWORD(v9) = v40;
        }
        v35 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v31, v24), _mm_cmpeq_epi8(si128, v22)));
        if ( (_WORD)v35 )
        {
          v83 = v9;
          v89 = v30;
          v88 = v33;
          v102 = v29;
          v101 = v32;
          v41 = core::str::pattern::simd_contains::{{closure}}(&v90, v27 + 16, v35, v9 & 1);
          v32 = _mm_load_si128(&v101);
          v29 = _mm_load_si128(&v102);
          v33 = _mm_load_si128(&v88);
          v30 = _mm_load_si128(&v89);
          v25 = n + 127;
          v24 = _mm_load_si128(&v86);
          v22 = _mm_load_si128(&v87);
          LOBYTE(v42) = (v83 | v41) & 1;
          LODWORD(v9) = v42;
        }
        v36 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v32, v24), _mm_cmpeq_epi8(v29, v22)));
        if ( (_WORD)v36 )
        {
          v84 = v9;
          v89 = v30;
          v88 = v33;
          v43 = core::str::pattern::simd_contains::{{closure}}(&v90, v27 + 32, v36, v9 & 1);
          v33 = _mm_load_si128(&v88);
          v30 = _mm_load_si128(&v89);
          v25 = n + 127;
          v24 = _mm_load_si128(&v86);
          v22 = _mm_load_si128(&v87);
          LOBYTE(v44) = (v84 | v43) & 1;
          LODWORD(v9) = v44;
        }
        v37 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v33, v24), _mm_cmpeq_epi8(v30, v22)));
        if ( (_WORD)v37 )
        {
          v85 = v9;
          v45 = core::str::pattern::simd_contains::{{closure}}(&v90, v27 + 48, v37, v9 & 1);
          v25 = n + 127;
          v24 = _mm_load_si128(&v86);
          v22 = _mm_load_si128(&v87);
          LOBYTE(v46) = (v85 | v45) & 1;
          LODWORD(v9) = v46;
          v47 = n + 127 + v27;
          v27 += 64LL;
          if ( v47 >= a4 )
            goto LABEL_40;
        }
        else
        {
          v38 = v25 + v27;
          v27 += 64LL;
          if ( v38 >= a4 )
            goto LABEL_40;
        }
        if ( (v9 & 1) != 0 )
          goto LABEL_40;
      }
    }
    v27 = 0LL;
    LODWORD(v9) = 0;
LABEL_40:
    v48 = v9 & 1;
    if ( n + v27 + 15 < a4 && !v48 )
    {
      do
      {
        v49 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&s1[v8 + v27]), v24),
                  _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&s1[v27]), v22)));
        if ( v49 )
        {
          LOBYTE(v50) = core::str::pattern::simd_contains::{{closure}}(&v90, v27, v49, 0LL);
          v24 = _mm_load_si128(&v86);
          v22 = _mm_load_si128(&v87);
          LODWORD(v9) = v50;
        }
        v48 = v9 & 1;
        if ( n + 31 + v27 >= a4 )
          break;
        v27 += 16LL;
      }
      while ( !v48 );
    }
    v51 = a4 - v103;
    v52 = _mm_movemask_epi8(
            _mm_and_si128(
              _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&s1[v51 - 16 + v8]), v24),
              _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&s1[v51 - 16]), v22)));
    if ( v52 )
    {
      v72 = v48 != 0;
      LOBYTE(v73) = core::str::pattern::simd_contains::{{closure}}(&v90, v51 - 16, v52, v48);
      LODWORD(v9) = v73;
      LOBYTE(v9) = (v72 | v73) & 1;
    }
    else
    {
      LOBYTE(v9) = v9 & 1;
    }
    return (unsigned int)v9;
  }
LABEL_15:
  v12 = bcmp(s1, s2, n);
  LOBYTE(v9) = 1;
  if ( v12 )
  {
    v13 = s1 + 1;
    v14 = a4 - 1;
    while ( v14 >= n )
    {
      v15 = bcmp(v13++, s2, n);
      --v14;
      if ( !v15 )
        goto LABEL_19;
    }
LABEL_102:
    LODWORD(v9) = 0;
  }
  return (unsigned int)v9;
}
// DB6D: variable 'v40' is possibly undefined
// DBE1: variable 'v42' is possibly undefined
// DC31: variable 'v44' is possibly undefined
// DC69: variable 'v46' is possibly undefined
// DD03: variable 'v50' is possibly undefined
// DF57: variable 'v73' is possibly undefined
// E00C: variable 'v9' is possibly undefined
// 58330: using guessed type char *off_58330;
// 58348: using guessed type char *off_58348;
// 58360: using guessed type char *off_58360;
// 58378: using guessed type char *off_58378;
// 58390: using guessed type char *off_58390;
// 58838: using guessed type char *off_58838;
// D810: using guessed type __m128i var_108;
// D810: using guessed type __m128i var_78;
// D810: using guessed type __m128i var_48[4];

//----- (000000000000E110) ----------------------------------------------------
char __fastcall <alloc::string::String as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return <str as core::fmt::Debug>::fmt(*(unsigned __int8 **)(a1 + 8), *(_QWORD *)(a1 + 16), a2);
}

//----- (000000000000E130) ----------------------------------------------------
__int64 __fastcall <alloc::string::String as core::fmt::Write>::write_char(__int64 *a1, unsigned int a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  size_t v4; // r14
  __int64 v5; // r15
  int src; // [rsp+0h] [rbp-24h] BYREF

  src = HIDWORD(v2);
  if ( a2 >= 0x80 )
  {
    src = 0;
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(src) = (a2 >> 18) & 7 | 0xF0;
        BYTE1(src) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(src) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(src) = a2 & 0x3F | 0x80;
        v4 = 4LL;
      }
      else
      {
        LOBYTE(src) = (a2 >> 12) | 0xE0;
        BYTE1(src) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(src) = a2 & 0x3F | 0x80;
        v4 = 3LL;
      }
    }
    else
    {
      LOBYTE(src) = (a2 >> 6) | 0xC0;
      BYTE1(src) = a2 & 0x3F | 0x80;
      v4 = 2LL;
    }
    v5 = a1[2];
    if ( *a1 - v5 < v4 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, a1[2], v4);
      v5 = a1[2];
    }
    memcpy((void *)(v5 + a1[1]), &src, v4);
    a1[2] = v4 + v5;
  }
  else
  {
    v3 = a1[2];
    if ( v3 == *a1 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve_for_push(a1, a1[2]);
      v3 = a1[2];
    }
    *(_BYTE *)(a1[1] + v3) = a2;
    a1[2] = v3 + 1;
  }
  return 0LL;
}
// E136: variable 'v2' is possibly undefined

//----- (000000000000E260) ----------------------------------------------------
__int64 __fastcall <alloc::string::String as core::fmt::Write>::write_str(__int64 *a1, const void *a2, size_t a3)
{
  __int64 v4; // r15

  v4 = a1[2];
  if ( *a1 - v4 < a3 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, a1[2], a3);
    v4 = a1[2];
  }
  memcpy((void *)(v4 + a1[1]), a2, a3);
  a1[2] = a3 + v4;
  return 0LL;
}

//----- (000000000000E2C0) ----------------------------------------------------
unsigned __int64 __fastcall alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(
        unsigned __int64 *a1,
        _QWORD *a2)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // r14
  unsigned __int64 *v6; // rax
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // r15
  unsigned __int64 result; // rax
  unsigned __int64 v11; // rcx
  __int64 v12; // r8
  unsigned __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r14
  bool v16; // zf
  __int64 v17; // r15
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rdi
  __int64 v21; // rsi
  __int64 v22; // rsi
  __int64 v23; // rdx
  __int64 v24; // rcx
  _QWORD *v25; // r13
  __int64 v26; // rsi
  __int64 v27; // rdx
  unsigned __int64 v28; // rcx
  __int64 v29; // rsi
  unsigned __int64 *v30; // [rsp+10h] [rbp-38h]

  v3 = a2[8];
  if ( !v3 )
  {
    v14 = a2[1];
    v15 = a2[2];
    result = a2[3];
    v16 = *a2 == 0LL;
    *a2 = 0LL;
    if ( v16 )
    {
LABEL_24:
      *a1 = 0LL;
      return result;
    }
    if ( v14 )
    {
      v17 = v15;
      v15 = v14;
    }
    else
    {
      if ( result )
      {
        if ( (result & 7) != 0 )
        {
          v27 = 0LL;
          do
          {
            v15 = *(_QWORD *)(v15 + 1336);
            ++v27;
          }
          while ( (result & 7) != v27 );
          v28 = result - v27;
          v17 = 0LL;
          if ( result < 8 )
            goto LABEL_16;
        }
        else
        {
          v28 = result;
          v17 = 0LL;
          if ( result < 8 )
            goto LABEL_16;
        }
        do
        {
          v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v15 + 1336)
                                                                                                  + 1336LL)
                                                                                      + 1336LL)
                                                                          + 1336LL)
                                                              + 1336LL)
                                                  + 1336LL)
                                      + 1336LL)
                          + 1336LL);
          v28 -= 8LL;
        }
        while ( v28 );
        goto LABEL_16;
      }
      v17 = 0LL;
    }
LABEL_16:
    v18 = *(_QWORD *)(v15 + 1232);
    if ( v18 )
    {
      v19 = v17;
      v20 = v15;
      do
      {
        v15 = v18;
        v17 = v19 + 1;
        v21 = 1432LL;
        if ( !v19 )
          v21 = 1336LL;
        _rust_dealloc(v20, v21, 8LL);
        v18 = *(_QWORD *)(v15 + 1232);
        v19 = v17;
        v20 = v15;
      }
      while ( v18 );
    }
    v22 = 1432LL;
    if ( !v17 )
      v22 = 1336LL;
    result = _rust_dealloc(v15, v22, 8LL);
    goto LABEL_24;
  }
  a2[8] = v3 - 1;
  if ( !*a2 )
    core::option::unwrap_failed((__int64)&off_58650);
  v4 = a2[1];
  v5 = a2[3];
  v6 = a2 + 2;
  if ( v4 )
  {
    v7 = *v6;
    if ( v5 < *(unsigned __int16 *)(v4 + 1330) )
      goto LABEL_5;
LABEL_32:
    v30 = a1;
    v25 = a2;
    do
    {
      v9 = *(_QWORD *)(v4 + 1232);
      if ( !v9 )
      {
        v29 = 1432LL;
        if ( !v7 )
          v29 = 1336LL;
        _rust_dealloc(v4, v29, 8LL);
        core::option::unwrap_failed((__int64)&off_58638);
      }
      v8 = v7 + 1;
      v5 = *(unsigned __int16 *)(v4 + 1328);
      v26 = 1432LL;
      if ( !v7 )
        v26 = 1336LL;
      _rust_dealloc(v4, v26, 8LL);
      v4 = v9;
      v7 = v8;
    }
    while ( (unsigned __int16)v5 >= *(_WORD *)(v9 + 1330) );
    a2 = v25;
    a1 = v30;
    if ( v8 )
      goto LABEL_6;
    goto LABEL_38;
  }
  v4 = *v6;
  if ( v5 )
  {
    if ( (v5 & 7) == 0 )
    {
      v24 = a2[3];
      if ( v5 < 8 )
        goto LABEL_31;
      goto LABEL_30;
    }
    v23 = 0LL;
    do
    {
      v4 = *(_QWORD *)(v4 + 1336);
      ++v23;
    }
    while ( (a2[3] & 7LL) != v23 );
    v24 = v5 - v23;
    if ( v5 >= 8 )
    {
      do
      {
LABEL_30:
        v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 1336)
                                                                                               + 1336LL)
                                                                                   + 1336LL)
                                                                       + 1336LL)
                                                           + 1336LL)
                                               + 1336LL)
                                   + 1336LL)
                       + 1336LL);
        v24 -= 8LL;
      }
      while ( v24 );
    }
  }
LABEL_31:
  *a2 = 1LL;
  a2[1] = v4;
  *(_OWORD *)v6 = 0LL;
  v5 = 0LL;
  v7 = 0LL;
  if ( !*(_WORD *)(v4 + 1330) )
    goto LABEL_32;
LABEL_5:
  v8 = v7;
  v9 = v4;
  if ( v7 )
  {
LABEL_6:
    result = *(_QWORD *)(v9 + 8 * v5 + 1344);
    v11 = v8 - 1;
    if ( v8 == 1 )
      goto LABEL_12;
    if ( (v11 & 7) != 0 )
    {
      v12 = 0LL;
      do
      {
        result = *(_QWORD *)(result + 1336);
        ++v12;
      }
      while ( (v11 & 7) != v12 );
      v11 -= v12;
    }
    if ( v8 - 2 < 7 )
    {
LABEL_12:
      v13 = 0LL;
    }
    else
    {
      v13 = 0LL;
      do
      {
        result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 1336) + 1336LL)
                                                                                       + 1336LL)
                                                                           + 1336LL)
                                                               + 1336LL)
                                                   + 1336LL)
                                       + 1336LL)
                           + 1336LL);
        v11 -= 8LL;
      }
      while ( v11 );
    }
    goto LABEL_41;
  }
LABEL_38:
  v13 = v5 + 1;
  result = v9;
LABEL_41:
  a2[1] = result;
  a2[2] = 0LL;
  a2[3] = v13;
  *a1 = v9;
  a1[1] = v8;
  a1[2] = v5;
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 58638: using guessed type char *off_58638;
// 58650: using guessed type char *off_58650;

//----- (000000000000E6A0) ----------------------------------------------------
unsigned __int64 __fastcall alloc::collections::btree::map::IntoIter<K,V,A>::dying_next(
        unsigned __int64 *a1,
        _QWORD *a2)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // r14
  unsigned __int64 *v6; // rax
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // r15
  unsigned __int64 result; // rax
  unsigned __int64 v11; // rcx
  __int64 v12; // r8
  unsigned __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r14
  bool v16; // zf
  __int64 v17; // r15
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rdi
  __int64 v21; // rsi
  __int64 v22; // rsi
  __int64 v23; // rdx
  __int64 v24; // rcx
  _QWORD *v25; // r13
  __int64 v26; // rsi
  __int64 v27; // rdx
  unsigned __int64 v28; // rcx
  __int64 v29; // rsi
  unsigned __int64 *v30; // [rsp+10h] [rbp-38h]

  v3 = a2[8];
  if ( !v3 )
  {
    v14 = a2[1];
    v15 = a2[2];
    result = a2[3];
    v16 = *a2 == 0LL;
    *a2 = 0LL;
    if ( v16 )
    {
LABEL_24:
      *a1 = 0LL;
      return result;
    }
    if ( v14 )
    {
      v17 = v15;
      v15 = v14;
    }
    else
    {
      if ( result )
      {
        if ( (result & 7) != 0 )
        {
          v27 = 0LL;
          do
          {
            v15 = *(_QWORD *)(v15 + 280);
            ++v27;
          }
          while ( (result & 7) != v27 );
          v28 = result - v27;
          v17 = 0LL;
          if ( result < 8 )
            goto LABEL_16;
        }
        else
        {
          v28 = result;
          v17 = 0LL;
          if ( result < 8 )
            goto LABEL_16;
        }
        do
        {
          v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v15 + 280)
                                                                                                  + 280LL)
                                                                                      + 280LL)
                                                                          + 280LL)
                                                              + 280LL)
                                                  + 280LL)
                                      + 280LL)
                          + 280LL);
          v28 -= 8LL;
        }
        while ( v28 );
        goto LABEL_16;
      }
      v17 = 0LL;
    }
LABEL_16:
    v18 = *(_QWORD *)(v15 + 176);
    if ( v18 )
    {
      v19 = v17;
      v20 = v15;
      do
      {
        v15 = v18;
        v17 = v19 + 1;
        v21 = 376LL;
        if ( !v19 )
          v21 = 280LL;
        _rust_dealloc(v20, v21, 8LL);
        v18 = *(_QWORD *)(v15 + 176);
        v19 = v17;
        v20 = v15;
      }
      while ( v18 );
    }
    v22 = 376LL;
    if ( !v17 )
      v22 = 280LL;
    result = _rust_dealloc(v15, v22, 8LL);
    goto LABEL_24;
  }
  a2[8] = v3 - 1;
  if ( !*a2 )
    core::option::unwrap_failed((__int64)&off_58650);
  v4 = a2[1];
  v5 = a2[3];
  v6 = a2 + 2;
  if ( v4 )
  {
    v7 = *v6;
    if ( v5 < *(unsigned __int16 *)(v4 + 274) )
      goto LABEL_5;
LABEL_32:
    v30 = a1;
    v25 = a2;
    do
    {
      v9 = *(_QWORD *)(v4 + 176);
      if ( !v9 )
      {
        v29 = 376LL;
        if ( !v7 )
          v29 = 280LL;
        _rust_dealloc(v4, v29, 8LL);
        core::option::unwrap_failed((__int64)&off_58638);
      }
      v8 = v7 + 1;
      v5 = *(unsigned __int16 *)(v4 + 272);
      v26 = 376LL;
      if ( !v7 )
        v26 = 280LL;
      _rust_dealloc(v4, v26, 8LL);
      v4 = v9;
      v7 = v8;
    }
    while ( (unsigned __int16)v5 >= *(_WORD *)(v9 + 274) );
    a2 = v25;
    a1 = v30;
    if ( v8 )
      goto LABEL_6;
    goto LABEL_38;
  }
  v4 = *v6;
  if ( v5 )
  {
    if ( (v5 & 7) == 0 )
    {
      v24 = a2[3];
      if ( v5 < 8 )
        goto LABEL_31;
      goto LABEL_30;
    }
    v23 = 0LL;
    do
    {
      v4 = *(_QWORD *)(v4 + 280);
      ++v23;
    }
    while ( (a2[3] & 7LL) != v23 );
    v24 = v5 - v23;
    if ( v5 >= 8 )
    {
      do
      {
LABEL_30:
        v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 280)
                                                                                               + 280LL)
                                                                                   + 280LL)
                                                                       + 280LL)
                                                           + 280LL)
                                               + 280LL)
                                   + 280LL)
                       + 280LL);
        v24 -= 8LL;
      }
      while ( v24 );
    }
  }
LABEL_31:
  *a2 = 1LL;
  a2[1] = v4;
  *(_OWORD *)v6 = 0LL;
  v5 = 0LL;
  v7 = 0LL;
  if ( !*(_WORD *)(v4 + 274) )
    goto LABEL_32;
LABEL_5:
  v8 = v7;
  v9 = v4;
  if ( v7 )
  {
LABEL_6:
    result = *(_QWORD *)(v9 + 8 * v5 + 288);
    v11 = v8 - 1;
    if ( v8 == 1 )
      goto LABEL_12;
    if ( (v11 & 7) != 0 )
    {
      v12 = 0LL;
      do
      {
        result = *(_QWORD *)(result + 280);
        ++v12;
      }
      while ( (v11 & 7) != v12 );
      v11 -= v12;
    }
    if ( v8 - 2 < 7 )
    {
LABEL_12:
      v13 = 0LL;
    }
    else
    {
      v13 = 0LL;
      do
      {
        result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 280) + 280LL)
                                                                                       + 280LL)
                                                                           + 280LL)
                                                               + 280LL)
                                                   + 280LL)
                                       + 280LL)
                           + 280LL);
        v11 -= 8LL;
      }
      while ( v11 );
    }
    goto LABEL_41;
  }
LABEL_38:
  v13 = v5 + 1;
  result = v9;
LABEL_41:
  a2[1] = result;
  a2[2] = 0LL;
  a2[3] = v13;
  *a1 = v9;
  a1[1] = v8;
  a1[2] = v5;
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 58638: using guessed type char *off_58638;
// 58650: using guessed type char *off_58650;

//----- (000000000000EA80) ----------------------------------------------------
__int64 __fastcall alloc::vec::Vec<T,A>::push(__int64 *a1, __int64 a2)
{
  __int64 v3; // rsi
  __int64 result; // rax
  __int64 v5; // rcx

  v3 = a1[2];
  if ( v3 == *a1 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(a1, v3);
    v3 = a1[2];
  }
  result = a1[1];
  v5 = 3 * v3;
  *(_QWORD *)(result + 8 * v5 + 16) = *(_QWORD *)(a2 + 16);
  *(_OWORD *)(result + 8 * v5) = *(_OWORD *)a2;
  a1[2] = v3 + 1;
  return result;
}

//----- (000000000000EAD0) ----------------------------------------------------
__int64 __fastcall alloc::vec::Vec<T,A>::push(__int64 *a1, __int128 *a2)
{
  __int64 v3; // rsi
  __int64 result; // rax
  __int64 v5; // rcx
  __int128 v6; // xmm0
  __int128 v7; // xmm1
  __int128 v8; // xmm2

  v3 = a1[2];
  if ( v3 == *a1 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(a1, v3);
    v3 = a1[2];
  }
  result = a1[1];
  v5 = v3 << 6;
  v6 = *a2;
  v7 = a2[1];
  v8 = a2[2];
  *(_OWORD *)(result + v5 + 48) = a2[3];
  *(_OWORD *)(result + v5 + 32) = v8;
  *(_OWORD *)(result + v5 + 16) = v7;
  *(_OWORD *)(result + v5) = v6;
  a1[2] = v3 + 1;
  return result;
}

//----- (000000000000EB30) ----------------------------------------------------
unsigned __int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1)
{
  __int64 v1; // rbx
  volatile signed __int64 *v2; // rax
  __int64 v3; // r14
  unsigned __int64 result; // rax

  v1 = *a1;
  v2 = *(volatile signed __int64 **)(*a1 + 224);
  v3 = *a1;
  if ( v2 )
  {
    if ( !_InterlockedDecrement64(v2) )
      alloc::sync::Arc<T,A>::drop_slow(v1 + 224);
    v3 = *a1;
  }
  result = core::ptr::drop_in_place<gimli::read::abbrev::AbbreviationsCache>((__int64 *)(v1 + 232));
  if ( v3 != -1 && !_InterlockedDecrement64((volatile signed __int64 *)(v3 + 8)) )
    return _rust_dealloc(v3, 264LL, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000EBD0) ----------------------------------------------------
__int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1)
{
  __int64 v1; // rdi
  __int64 result; // rax

  v1 = *a1;
  if ( v1 != -1 && !_InterlockedDecrement64((volatile signed __int64 *)(v1 + 8)) )
    return _rust_dealloc(v1, 48LL, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000EC00) ----------------------------------------------------
unsigned __int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v2; // r14
  __int64 v3; // r15
  _QWORD *v4; // r12
  __int64 v5; // rsi
  __int64 v6; // rax
  unsigned __int64 result; // rax

  v1 = *a1;
  v2 = *(_QWORD *)(*a1 + 24);
  v3 = *(_QWORD *)(*a1 + 32);
  if ( v3 )
  {
    v4 = (_QWORD *)(v2 + 16);
    do
    {
      if ( *(v4 - 2) )
      {
        v5 = *(v4 - 1);
        if ( v5 )
          _rust_dealloc(*v4, 16 * v5, 8LL);
      }
      v4 += 14;
      --v3;
    }
    while ( v3 );
  }
  v6 = *(_QWORD *)(v1 + 16);
  if ( v6 )
    _rust_dealloc(v2, 112 * v6, 8LL);
  result = core::ptr::drop_in_place<alloc::collections::btree::map::BTreeMap<u64,gimli::read::abbrev::Abbreviation>>((__int64 *)(v1 + 40));
  if ( v1 != -1 && !_InterlockedDecrement64((volatile signed __int64 *)(v1 + 8)) )
    return _rust_dealloc(v1, 64LL, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000ECC0) ----------------------------------------------------
__int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rsi
  __int64 result; // rax

  v1 = *a1;
  v2 = *(_QWORD *)(*a1 + 24);
  if ( v2 )
    result = _rust_dealloc(*(_QWORD *)(v1 + 32), v2, 1LL);
  if ( v1 != -1 && !_InterlockedDecrement64((volatile signed __int64 *)(v1 + 8)) )
    return _rust_dealloc(v1, 48LL, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000ED00) ----------------------------------------------------
__int64 __fastcall alloc::sync::Arc<T,A>::drop_slow(__int64 *a1)
{
  __int64 v1; // rbx
  _BYTE *v2; // rdi
  __int64 v3; // rsi
  __int64 result; // rax

  v1 = *a1;
  v2 = *(_BYTE **)(*a1 + 24);
  if ( v2 )
  {
    v3 = *(_QWORD *)(v1 + 32);
    *v2 = 0;
    if ( v3 )
      result = _rust_dealloc(v2, v3, 1LL);
  }
  if ( v1 != -1 && !_InterlockedDecrement64((volatile signed __int64 *)(v1 + 8)) )
    return _rust_dealloc(v1, 48LL, 8LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000ED50) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 result; // rax

  if ( !a2 )
  {
    a1[1] = 0LL;
    goto LABEL_10;
  }
  if ( a4[1] )
  {
    v6 = a4[2];
    if ( v6 )
    {
      v7 = _rust_realloc(*a4, v6, a2, a3);
      if ( v7 )
        goto LABEL_5;
      goto LABEL_8;
    }
  }
  if ( !a3 )
  {
    v7 = a2;
    goto LABEL_5;
  }
  v7 = _rust_alloc(a3, a2);
  if ( !v7 )
  {
LABEL_8:
    a1[1] = a2;
    a1[2] = a3;
LABEL_10:
    result = 1LL;
    goto LABEL_11;
  }
LABEL_5:
  a1[1] = v7;
  a1[2] = a3;
  result = 0LL;
LABEL_11:
  *a1 = result;
  return result;
}
// EDD9: conditional instruction was optimized away because r15.8!=0
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000EDE0) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 < 0x555555555555556LL);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 24 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 24 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000EEB0) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 < 0x2AAAAAAAAAAAAABLL);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 48 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 48 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000EF80) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 >> 59 == 0);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 16 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 16 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F040) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 < 0x1745D1745D1745ELL);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 88 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 88 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F100) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 < 0x3D226357E16ECFLL);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 536 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 536 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F1C0) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 < 0x4BDA12F684BDA2LL);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 432 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 432 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F280) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 >> 60 == 0);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 8 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 8 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F340) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 >> 57 == 0);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = v3 << 6;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, v4 << 6, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F400) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 >> 58 == 0);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 32 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 32 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F4C0) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 2 * (unsigned int)(v2 >> 61 == 0);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 4 * v3;
    v6 = 2LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 4 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F580) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 < 0x1C71C71C71C71C8LL);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 72 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 72 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F650) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 < 0x24924924924924ALL);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 56 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 56 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (000000000000F710) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v4; // r14
  __int64 v5; // rax
  __int64 result; // rax
  __int64 v7; // [rsp+8h] [rbp-40h] BYREF
  __int64 v8; // [rsp+10h] [rbp-38h]
  __int64 v9; // [rsp+18h] [rbp-30h]
  __int64 v10[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( !v2 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 8LL;
  if ( v2 >= 9 )
    v4 = v2;
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = v3;
    v5 = 1LL;
  }
  else
  {
    v5 = 0LL;
  }
  v10[1] = v5;
  alloc::raw_vec::finish_grow(&v7, v4 >= 0, v4, v10);
  if ( v7 )
  {
    if ( v8 )
      alloc::alloc::handle_alloc_error(v8, v9);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v8;
  a1[1] = v8;
  *a1 = v4;
  return result;
}

//----- (000000000000F7C0) ----------------------------------------------------
_OWORD *__fastcall gimli::read::line::parse_file_v5(
        __int64 a1,
        unsigned __int64 *a2,
        unsigned int a3,
        __int64 a4,
        unsigned __int64 a5)
{
  __int64 v7; // r14
  __int64 v8; // rbx
  _OWORD *result; // rax
  __int64 v10; // rdx
  unsigned __int64 v11; // [rsp+8h] [rbp-90h]
  unsigned __int64 v12; // [rsp+10h] [rbp-88h]
  unsigned __int64 v13; // [rsp+18h] [rbp-80h]
  __int64 v14; // [rsp+28h] [rbp-70h]
  _OWORD *v15; // [rsp+30h] [rbp-68h]
  __int64 v16; // [rsp+38h] [rbp-60h]
  __int128 v17; // [rsp+40h] [rbp-58h]
  __int64 v18; // [rsp+50h] [rbp-48h] BYREF
  _OWORD *v19; // [rsp+58h] [rbp-40h]
  __int64 v20; // [rsp+60h] [rbp-38h]

  if ( !a5 )
    goto LABEL_31;
  v7 = 4 * a5;
  v17 = 0LL;
  v14 = 46LL;
  v8 = 0LL;
  v11 = 0LL;
  v12 = 0LL;
  v13 = 0LL;
  do
  {
    gimli::read::line::parse_attribute((__int64)&v18, a2, a3, *(_WORD *)(a4 + v8 + 2), a5);
    result = v19;
    v10 = v20;
    if ( v18 == 46 )
    {
      *(_QWORD *)(a1 + 8) = v19;
      *(_QWORD *)(a1 + 16) = v10;
      *(_QWORD *)a1 = 46LL;
      return result;
    }
    switch ( *(_WORD *)(a4 + v8) )
    {
      case 1:
        v15 = v19;
        v16 = v20;
        v14 = v18;
        break;
      case 2:
        switch ( v18 )
        {
          case 2LL:
            v11 = (unsigned __int8)v19;
            break;
          case 3LL:
            v11 = (unsigned __int16)v19;
            break;
          case 4LL:
            v11 = (unsigned int)v19;
            break;
          case 5LL:
          case 7LL:
            goto LABEL_27;
          case 6LL:
            if ( (__int64)v19 >= 0 )
LABEL_27:
              v11 = (unsigned __int64)v19;
            break;
          default:
            goto LABEL_4;
        }
        break;
      case 3:
        switch ( v18 )
        {
          case 2LL:
            v12 = (unsigned __int8)v19;
            break;
          case 3LL:
            v12 = (unsigned __int16)v19;
            break;
          case 4LL:
            v12 = (unsigned int)v19;
            break;
          case 5LL:
          case 7LL:
            goto LABEL_21;
          case 6LL:
            if ( (__int64)v19 >= 0 )
LABEL_21:
              v12 = (unsigned __int64)v19;
            break;
          default:
            goto LABEL_4;
        }
        break;
      case 4:
        switch ( v18 )
        {
          case 2LL:
            v13 = (unsigned __int8)v19;
            break;
          case 3LL:
            v13 = (unsigned __int16)v19;
            break;
          case 4LL:
            v13 = (unsigned int)v19;
            break;
          case 5LL:
          case 7LL:
            goto LABEL_25;
          case 6LL:
            if ( (__int64)v19 >= 0 )
LABEL_25:
              v13 = (unsigned __int64)v19;
            break;
          default:
            goto LABEL_4;
        }
        break;
      case 5:
        if ( (_DWORD)v18 == 1 && v20 == 16 )
          v17 = *v19;
        break;
      default:
        break;
    }
LABEL_4:
    v8 += 4LL;
  }
  while ( v7 != v8 );
  if ( v14 == 46 )
LABEL_31:
    core::option::unwrap_failed((__int64)&off_58680);
  result = (_OWORD *)a1;
  *(_QWORD *)a1 = v14;
  *(_QWORD *)(a1 + 8) = v15;
  *(_QWORD *)(a1 + 16) = v16;
  *(_QWORD *)(a1 + 24) = v11;
  *(_QWORD *)(a1 + 32) = v12;
  *(_QWORD *)(a1 + 40) = v13;
  *(_OWORD *)(a1 + 48) = v17;
  return result;
}
// F84D: variable 'a5' is possibly undefined
// F9C5: variable 'v15' is possibly undefined
// F9CE: variable 'v16' is possibly undefined
// 58680: using guessed type char *off_58680;

//----- (000000000000FA20) ----------------------------------------------------
__int64 __fastcall gimli::read::line::FileEntryFormat::parse(__int64 a1, __int64 a2)
{
  _BYTE *v3; // rax
  __int64 v4; // rbp
  __int64 v6; // rbp
  _BYTE *v7; // r12
  __int64 v8; // r13
  unsigned __int64 v9; // rdi
  __int64 v10; // rax
  __int16 v11; // cx
  __int64 v12; // rsi
  __int64 v13; // rdx
  __int64 v14; // rdx
  unsigned __int64 v15; // r15
  int v16; // ecx
  char v17; // r8
  __int64 v18; // rcx
  __int64 v19; // r13
  __int64 v20; // rcx
  __int16 v21; // di
  __int16 v22; // di
  __int64 v23; // r8
  unsigned __int16 v24; // dx
  __int64 result; // rax
  char v26; // al
  char v27; // al
  __int16 v28; // dx
  __int16 v29; // [rsp+4h] [rbp-64h]
  __int128 v30; // [rsp+8h] [rbp-60h] BYREF
  __int64 v31; // [rsp+18h] [rbp-50h]
  int v32; // [rsp+24h] [rbp-44h]
  __int64 v33; // [rsp+28h] [rbp-40h]
  __int64 v34; // [rsp+30h] [rbp-38h]

  v3 = *(_BYTE **)a2;
  v4 = *(_QWORD *)(a2 + 8);
  if ( !v4 )
  {
    *(_WORD *)(a1 + 8) = 19;
    *(_WORD *)(a1 + 14) = 0;
    *(_DWORD *)(a1 + 10) = 0;
    *(_QWORD *)(a1 + 16) = v3;
    result = 0x8000000000000000LL;
    *(_QWORD *)a1 = 0x8000000000000000LL;
    return result;
  }
  v6 = v4 - 1;
  v7 = v3 + 1;
  *(_QWORD *)a2 = v3 + 1;
  *(_QWORD *)(a2 + 8) = v6;
  v8 = (unsigned __int8)*v3;
  if ( !*v3 )
  {
    *(_QWORD *)&v30 = (unsigned __int8)*v3;
    *((_QWORD *)&v30 + 1) = 2LL;
    v31 = 0LL;
LABEL_31:
    *(_BYTE *)(a1 + 8) = 68;
    goto LABEL_35;
  }
  v9 = (unsigned int)(4 * v8);
  v10 = _rust_alloc(v9, 2LL);
  if ( !v10 )
    alloc::alloc::handle_alloc_error(2LL, (unsigned int)(4 * v8));
  *(_QWORD *)&v30 = v8;
  *((_QWORD *)&v30 + 1) = v10;
  v31 = 0LL;
  v12 = 0LL;
  v32 = 0;
  v13 = 0LL;
  v29 = v11;
  while ( 2 )
  {
    if ( !v6 )
    {
LABEL_33:
      v26 = 19;
      v9 = (unsigned __int64)v7;
LABEL_34:
      *(_BYTE *)(a1 + 8) = v26;
      *(_BYTE *)(a1 + 9) = 0;
      *(_WORD *)(a1 + 14) = 0;
      *(_DWORD *)(a1 + 10) = 0;
      *(_QWORD *)(a1 + 16) = v9;
      goto LABEL_35;
    }
    v34 = v13 + 1;
    v14 = 0LL;
    v15 = 0LL;
    v16 = 0;
    while ( 1 )
    {
      v17 = v7[v14];
      if ( v16 == 63 && (unsigned __int8)v17 >= 2u )
      {
        *(_QWORD *)a2 = &v7[v14 + 1];
        *(_QWORD *)(a2 + 8) = v6 + ~v14;
        v26 = 6;
        goto LABEL_34;
      }
      v15 |= (unsigned __int64)(v17 & 0x7F) << v16;
      if ( v17 >= 0 )
        break;
      v16 += 7;
      if ( v6 == ++v14 )
      {
        v7 += v6;
        *(_QWORD *)a2 = v7;
        *(_QWORD *)(a2 + 8) = 0LL;
        goto LABEL_33;
      }
    }
    v33 = v8;
    v18 = (__int64)&v7[v14 + 1];
    *(_QWORD *)a2 = v18;
    *(_QWORD *)(a2 + 8) = v6 + ~v14;
    v19 = 0xFFFFLL;
    if ( v15 < 0xFFFF )
      v19 = v15;
    if ( v6 - 1 == v14 )
      goto LABEL_40;
    v20 = v6 - v14;
    *(_QWORD *)a2 = &v7[v14 + 2];
    *(_QWORD *)(a2 + 8) = v6 - v14 - 2;
    v21 = v7[v14 + 1] & 0x7F;
    if ( (char)v7[v14 + 1] >= 0 )
    {
      v7 += v14 + 2;
      v6 = v6 - v14 - 2;
      v29 = v21;
      if ( v12 != (_QWORD)v30 )
        goto LABEL_26;
      goto LABEL_25;
    }
    if ( v6 - 2 == v14 )
    {
      v18 = (__int64)&v7[v14 + 2];
LABEL_40:
      v27 = 19;
      v28 = 0;
      goto LABEL_41;
    }
    *(_QWORD *)a2 = &v7[v14 + 3];
    *(_QWORD *)(a2 + 8) = v20 - 3;
    v22 = ((v7[v14 + 2] & 0x7F) << 7) | v21;
    if ( (char)v7[v14 + 2] >= 0 )
    {
      v7 += v14 + 3;
      v6 = v20 - 3;
      v29 = v22;
      if ( v12 != (_QWORD)v30 )
      {
LABEL_26:
        v32 += v19 == 1;
        *(_WORD *)(v10 + 4 * v12) = v19;
        *(_WORD *)(v10 + 4 * v12++ + 2) = v29;
        v31 = v12;
        v9 = v15;
        v8 = v33;
        v13 = v34;
        if ( v34 != v33 )
          continue;
        if ( v32 == 1 )
        {
          result = v31;
          *(_QWORD *)(a1 + 16) = v31;
          *(_OWORD *)a1 = v30;
          return result;
        }
        goto LABEL_31;
      }
LABEL_25:
      alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v30, v12);
      v10 = *((_QWORD *)&v30 + 1);
      v12 = v31;
      goto LABEL_26;
    }
    break;
  }
  if ( v6 - 3 == v14 )
  {
    v18 = (__int64)&v7[v14 + 3];
    goto LABEL_40;
  }
  v18 = v20 - 4;
  v23 = (__int64)&v7[v14 + 4];
  *(_QWORD *)a2 = v23;
  *(_QWORD *)(a2 + 8) = v18;
  v24 = (unsigned __int8)v7[v14 + 3];
  if ( v24 <= 3u )
  {
    v29 = (v24 << 14) | v22;
    v7 = (_BYTE *)v23;
    v6 = v18;
    if ( v12 != (_QWORD)v30 )
      goto LABEL_26;
    goto LABEL_25;
  }
  v27 = 6;
  v28 = v29;
LABEL_41:
  *(_BYTE *)(a1 + 8) = v27;
  *(_BYTE *)(a1 + 9) = 0;
  *(_WORD *)(a1 + 10) = v28;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = v18;
LABEL_35:
  result = 0x8000000000000000LL;
  *(_QWORD *)a1 = 0x8000000000000000LL;
  if ( (_QWORD)v30 )
    return _rust_dealloc(*((_QWORD *)&v30 + 1), 4 * v30, 2LL);
  return result;
}
// FAAC: variable 'v11' is possibly undefined
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (000000000000FDF0) ----------------------------------------------------
char __fastcall gimli::read::line::parse_attribute(
        __int64 a1,
        unsigned __int64 *a2,
        unsigned int a3,
        __int16 a4,
        unsigned __int64 a5)
{
  unsigned int v5; // edx
  unsigned __int64 v6; // rax
  unsigned __int16 *v7; // rdx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rcx
  bool v10; // cf
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rcx
  unsigned __int8 *v14; // r8
  unsigned __int64 v15; // rax
  unsigned __int8 *v16; // rdx
  unsigned __int64 v17; // r9
  int v18; // ecx
  char v19; // r10
  unsigned __int16 *v20; // rcx
  unsigned __int64 v21; // rdx
  unsigned int v22; // ecx
  unsigned __int64 v23; // rcx
  __int64 v24; // r9
  unsigned __int64 v25; // rsi
  unsigned __int64 v26; // rcx
  __int64 v27; // r9
  int v28; // ecx
  __int64 v29; // rax
  __int64 v30; // r10
  unsigned __int64 v31; // rcx
  unsigned __int64 v32; // rax
  int v33; // ecx
  char v34; // r10
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // rcx
  unsigned __int64 v37; // rcx
  unsigned __int64 v38; // rcx
  unsigned __int64 *v39; // rax
  unsigned __int64 v40; // rcx
  unsigned int *v41; // rdx
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // rcx
  unsigned __int64 v44; // rcx
  unsigned __int64 v45; // rcx
  __int64 v46; // rdx
  unsigned __int64 v47; // rcx
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // rdx
  unsigned __int64 v50; // r9
  __int64 v51; // r10
  int v52; // ecx
  char v53; // r11
  char v54; // cl
  unsigned __int64 v55; // rcx
  unsigned __int64 v56; // rcx
  unsigned __int64 v57; // rax
  unsigned __int64 v58; // rcx
  unsigned __int64 v59; // rax
  unsigned __int64 v60; // rcx
  unsigned __int64 v61; // rcx
  unsigned __int64 v62; // rcx
  unsigned __int64 v63; // rcx
  unsigned __int64 v64; // rcx
  int v65; // ecx
  int v66; // edx
  __int64 v67; // rdx
  unsigned __int64 v68; // r11
  _BYTE v70[15]; // [rsp+0h] [rbp-48h]
  _BYTE v71[15]; // [rsp+0h] [rbp-48h]
  _BYTE v72[15]; // [rsp+0h] [rbp-48h]
  _BYTE v73[15]; // [rsp+0h] [rbp-48h]
  __int128 v74; // [rsp+10h] [rbp-38h]
  __int128 v75; // [rsp+10h] [rbp-38h]
  __int128 v76; // [rsp+10h] [rbp-38h]
  __int128 v77; // [rsp+10h] [rbp-38h]
  __int128 v78; // [rsp+10h] [rbp-38h]
  int v79; // [rsp+23h] [rbp-25h]
  int v80; // [rsp+2Bh] [rbp-1Dh]
  int v81; // [rsp+33h] [rbp-15h]
  int v82; // [rsp+3Bh] [rbp-Dh]

  v5 = a3 >> 8;
  LOBYTE(v6) = a4;
  switch ( a4 )
  {
    case 3:
      v7 = (unsigned __int16 *)*a2;
      v8 = a2[1];
      if ( v8 > 1 )
      {
        v9 = v8 - 2;
        v6 = (unsigned __int64)(v7 + 1);
        *a2 = (unsigned __int64)(v7 + 1);
        a2[1] = v9;
        a5 = *v7;
        v10 = v9 < a5;
        v11 = v9 - a5;
        if ( !v10 )
          goto LABEL_60;
        goto LABEL_135;
      }
      *(_BYTE *)(a1 + 8) = 19;
      *(_WORD *)(a1 + 9) = 0;
      *(_BYTE *)(a1 + 11) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_QWORD *)(a1 + 16) = v7;
      *(_QWORD *)a1 = 46LL;
      return v6;
    case 4:
      v41 = (unsigned int *)*a2;
      v42 = a2[1];
      if ( v42 > 3 )
      {
        v43 = v42 - 4;
        v6 = (unsigned __int64)(v41 + 1);
        *a2 = (unsigned __int64)(v41 + 1);
        a2[1] = v43;
        a5 = *v41;
        v10 = v43 < a5;
        v11 = v43 - a5;
        if ( !v10 )
          goto LABEL_60;
        goto LABEL_135;
      }
      *(_BYTE *)(a1 + 8) = 19;
      *(_DWORD *)(a1 + 9) = 0;
      *(_BYTE *)(a1 + 15) = 0;
      *(_WORD *)(a1 + 13) = 0;
      *(_QWORD *)(a1 + 16) = v41;
      *(_QWORD *)a1 = 46LL;
      return v6;
    case 5:
      v6 = *a2;
      v37 = a2[1];
      if ( v37 <= 1 )
        goto LABEL_135;
      *a2 = v6 + 2;
      a2[1] = v37 - 2;
      LODWORD(v6) = *(unsigned __int16 *)v6;
      v22 = (unsigned int)v6 >> 8;
      v24 = 3LL;
      goto LABEL_79;
    case 6:
      v6 = *a2;
      v55 = a2[1];
      if ( v55 <= 3 )
        goto LABEL_75;
      *a2 = v6 + 4;
      a2[1] = v55 - 4;
      LODWORD(v6) = *(_DWORD *)v6;
      v22 = (unsigned int)v6 >> 8;
      LODWORD(v21) = WORD1(v6);
      v24 = 4LL;
      v25 = 0LL;
      goto LABEL_133;
    case 7:
      v39 = (unsigned __int64 *)*a2;
      v40 = a2[1];
      if ( v40 > 7 )
      {
        *a2 = (unsigned __int64)(v39 + 1);
        a2[1] = v40 - 8;
        v6 = *v39;
        v22 = (unsigned int)v6 >> 8;
        v21 = v6 >> 16;
        v25 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 5LL;
        goto LABEL_133;
      }
      *(_QWORD *)&v74 = 19LL;
      *((_QWORD *)&v74 + 1) = *a2;
      *(_BYTE *)(a1 + 8) = 19;
      *(_DWORD *)(a1 + 9) = 0;
      *(_BYTE *)(a1 + 15) = 0;
      v6 = HIDWORD(*(_QWORD *)((char *)&v74 + 1));
      *(_WORD *)(a1 + 13) = 0;
      *(_BYTE *)(a1 + 16) = BYTE8(v74);
      *(_BYTE *)(a1 + 23) = HIBYTE(v74);
      *(_WORD *)(a1 + 21) = *(_WORD *)((char *)&v74 + 13);
      *(_DWORD *)(a1 + 17) = *(_DWORD *)((char *)&v74 + 9);
      *(_QWORD *)a1 = 46LL;
      return v6;
    case 8:
      v6 = *a2;
      v38 = a2[1];
      if ( !v38 )
        goto LABEL_135;
      a5 = 0LL;
      while ( *(_BYTE *)(v6 + a5) )
      {
        if ( v38 == ++a5 )
          goto LABEL_135;
      }
      *a2 = v6 + a5 + 1;
      a2[1] = v38 + ~a5;
      v22 = (unsigned int)v6 >> 8;
      v21 = v6 >> 16;
      v25 = v6 & 0xFFFFFFFF00000000LL;
      v24 = 31LL;
      goto LABEL_133;
    case 9:
      v49 = *a2;
      v50 = a2[1];
      if ( !v50 )
      {
        v6 = *a2;
        v54 = 19;
        goto LABEL_130;
      }
      v6 = v49 + v50;
      v51 = 0LL;
      a5 = 0LL;
      v52 = 0;
      while ( 1 )
      {
        v53 = *(_BYTE *)(v49 + v51);
        if ( v52 == 63 && (unsigned __int8)v53 >= 2u )
        {
          v6 = v49 + v51 + 1;
          *a2 = v6;
          a2[1] = v50 + ~v51;
          v54 = 6;
          goto LABEL_130;
        }
        a5 |= (unsigned __int64)(v53 & 0x7F) << v52;
        if ( v53 >= 0 )
          break;
        v52 += 7;
        if ( v50 == ++v51 )
        {
          *a2 = v6;
          a2[1] = 0LL;
          v54 = 19;
LABEL_130:
          *(_BYTE *)(a1 + 8) = v54;
          *(_BYTE *)(a1 + 9) = 0;
          goto LABEL_131;
        }
      }
      v6 = v49 + v51 + 1;
      *a2 = v6;
      v68 = ~v51 + v50;
      a2[1] = v68;
      if ( v68 < a5 )
      {
LABEL_135:
        *(_QWORD *)(a1 + 8) = 19LL;
        *(_QWORD *)(a1 + 16) = v6;
        *(_QWORD *)a1 = 46LL;
        return v6;
      }
      v11 = v50 - a5 + ~v51;
      v46 = a5 + v51 + v49 + 1;
LABEL_61:
      *a2 = v46;
      a2[1] = v11;
      v22 = (unsigned int)v6 >> 8;
      v21 = v6 >> 16;
      v25 = v6 & 0xFFFFFFFF00000000LL;
      v24 = 1LL;
      goto LABEL_133;
    case 10:
      v16 = (unsigned __int8 *)*a2;
      v44 = a2[1];
      if ( !v44 )
      {
        *(_WORD *)(a1 + 8) = 19;
        goto LABEL_92;
      }
      v45 = v44 - 1;
      v6 = (unsigned __int64)(v16 + 1);
      *a2 = (unsigned __int64)(v16 + 1);
      a2[1] = v45;
      a5 = *v16;
      v10 = v45 < a5;
      v11 = v45 - a5;
      if ( v10 )
        goto LABEL_135;
LABEL_60:
      v46 = v6 + a5;
      goto LABEL_61;
    case 11:
      v6 = *a2;
      v48 = a2[1];
      if ( !v48 )
        goto LABEL_80;
      *a2 = v6 + 1;
      a2[1] = v48 - 1;
      LOBYTE(v6) = *(_BYTE *)v6;
      v24 = 2LL;
      goto LABEL_78;
    case 12:
      v6 = *a2;
      v31 = a2[1];
      if ( !v31 )
        goto LABEL_80;
      *a2 = v6 + 1;
      a2[1] = v31 - 1;
      LOBYTE(v6) = *(_BYTE *)v6 != 0;
      v24 = 9LL;
      goto LABEL_78;
    case 13:
      v16 = (unsigned __int8 *)*a2;
      v27 = *a2 + 1;
      a5 = a2[1] - 1;
      v28 = 0;
      v29 = 0LL;
      while ( a5 != -1LL )
      {
        *a2 = v27;
        a2[1] = a5;
        v30 = *(unsigned __int8 *)(v27 - 1);
        if ( v28 == 63 && v30 != 127 && *(_BYTE *)(v27 - 1) )
        {
          LOBYTE(v6) = 7;
          goto LABEL_91;
        }
        v29 |= (unsigned __int64)(v30 & 0x7F) << v28;
        v28 += 7;
        ++v16;
        ++v27;
        --a5;
        if ( (v30 & 0x80u) == 0LL )
        {
          v67 = -1LL << v28;
          if ( (unsigned __int8)v30 < 0x40u )
            v67 = 0LL;
          if ( v28 >= 64 )
            v67 = 0LL;
          v6 = v67 | v29;
          v22 = (unsigned int)v6 >> 8;
          v21 = v6 >> 16;
          v25 = v6 & 0xFFFFFFFF00000000LL;
          v24 = 6LL;
          goto LABEL_133;
        }
      }
      goto LABEL_42;
    case 14:
      if ( (_BYTE)v5 == 8 )
      {
        v35 = *a2;
        v36 = a2[1];
        if ( v36 > 7 )
        {
          *a2 = v35 + 8;
          a2[1] = v36 - 8;
          v6 = *(_QWORD *)v35;
LABEL_96:
          v22 = (unsigned int)v6 >> 8;
          v21 = v6 >> 16;
          v25 = v6 & 0xFFFFFFFF00000000LL;
          v24 = 26LL;
          goto LABEL_133;
        }
        *(_QWORD *)&v76 = 19LL;
        *((_QWORD *)&v76 + 1) = *a2;
        *(_DWORD *)&v71[8] = v35 >> 8;
        *(_DWORD *)&v71[11] = HIDWORD(*a2);
        *(_QWORD *)v71 = *(_QWORD *)((char *)&v76 + 1);
        v6 = *(_QWORD *)&v71[7];
      }
      else
      {
        v6 = *a2;
        v62 = a2[1];
        if ( v62 > 3 )
        {
          *a2 = v6 + 4;
          a2[1] = v62 - 4;
          v6 = *(unsigned int *)v6;
          goto LABEL_96;
        }
        *(_DWORD *)v71 = 0;
        v71[6] = 0;
        *(_WORD *)&v71[4] = 0;
      }
      v80 = *(_DWORD *)&v71[3];
      LOBYTE(v80) = v71[3];
      *(_BYTE *)(a1 + 8) = 19;
      v65 = *(_DWORD *)v71;
      v66 = v80;
      goto LABEL_128;
    case 15:
      v14 = (unsigned __int8 *)*a2;
      v32 = a2[1];
      if ( !v32 )
        goto LABEL_41;
      v16 = &v14[v32];
      v17 = 1 - v32;
      a5 = (unsigned __int64)(v14 + 1);
      v6 = 0LL;
      v33 = 0;
      while ( 1 )
      {
        v34 = *(_BYTE *)(a5 - 1);
        if ( v33 == 63 && (unsigned __int8)v34 >= 2u )
          goto LABEL_90;
        v6 |= (unsigned __int64)(v34 & 0x7F) << v33;
        if ( v34 >= 0 )
        {
          *a2 = a5;
          a2[1] = -(__int64)v17;
          v22 = (unsigned int)v6 >> 8;
          v21 = v6 >> 16;
          v25 = v6 & 0xFFFFFFFF00000000LL;
          v24 = 7LL;
          goto LABEL_133;
        }
        v33 += 7;
        ++v17;
        ++a5;
        if ( v17 == 1 )
        {
LABEL_40:
          *a2 = (unsigned __int64)v16;
          a2[1] = 0LL;
LABEL_42:
          LOBYTE(v6) = 19;
          goto LABEL_91;
        }
      }
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 24:
    case 25:
    case 27:
    case 28:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
      goto LABEL_17;
    case 23:
      if ( (_BYTE)v5 == 8 )
      {
        v59 = *a2;
        v60 = a2[1];
        if ( v60 > 7 )
        {
          *a2 = v59 + 8;
          a2[1] = v60 - 8;
          v6 = *(_QWORD *)v59;
LABEL_106:
          v22 = (unsigned int)v6 >> 8;
          v21 = v6 >> 16;
          v25 = v6 & 0xFFFFFFFF00000000LL;
          v24 = 10LL;
          goto LABEL_133;
        }
        *(_QWORD *)&v78 = 19LL;
        *((_QWORD *)&v78 + 1) = *a2;
        *(_DWORD *)&v73[8] = v59 >> 8;
        *(_DWORD *)&v73[11] = HIDWORD(*a2);
        *(_QWORD *)v73 = *(_QWORD *)((char *)&v78 + 1);
        v6 = *(_QWORD *)&v73[7];
      }
      else
      {
        v6 = *a2;
        v64 = a2[1];
        if ( v64 > 3 )
        {
          *a2 = v6 + 4;
          a2[1] = v64 - 4;
          v6 = *(unsigned int *)v6;
          goto LABEL_106;
        }
        *(_DWORD *)v73 = 0;
        v73[6] = 0;
        *(_WORD *)&v73[4] = 0;
      }
      v79 = *(_DWORD *)&v73[3];
      LOBYTE(v79) = v73[3];
      *(_BYTE *)(a1 + 8) = 19;
      v65 = *(_DWORD *)v73;
      v66 = v79;
      goto LABEL_128;
    case 26:
      goto LABEL_10;
    case 29:
      goto LABEL_7;
    case 30:
      v6 = *a2;
      v26 = a2[1];
      if ( v26 < 0x10 )
        goto LABEL_135;
      *a2 = v6 + 16;
      a2[1] = v26 - 16;
      v22 = (unsigned int)v6 >> 8;
      v21 = v6 >> 16;
      v25 = v6 & 0xFFFFFFFF00000000LL;
      v24 = 1LL;
      a5 = 16LL;
      goto LABEL_133;
    case 31:
      if ( (_BYTE)v5 == 8 )
      {
        v57 = *a2;
        v58 = a2[1];
        if ( v58 > 7 )
        {
          *a2 = v57 + 8;
          a2[1] = v58 - 8;
          v6 = *(_QWORD *)v57;
LABEL_103:
          v22 = (unsigned int)v6 >> 8;
          v21 = v6 >> 16;
          v25 = v6 & 0xFFFFFFFF00000000LL;
          v24 = 30LL;
          goto LABEL_133;
        }
        *(_QWORD *)&v77 = 19LL;
        *((_QWORD *)&v77 + 1) = *a2;
        *(_DWORD *)&v72[8] = v57 >> 8;
        *(_DWORD *)&v72[11] = HIDWORD(*a2);
        *(_QWORD *)v72 = *(_QWORD *)((char *)&v77 + 1);
        v6 = *(_QWORD *)&v72[7];
      }
      else
      {
        v6 = *a2;
        v63 = a2[1];
        if ( v63 > 3 )
        {
          *a2 = v6 + 4;
          a2[1] = v63 - 4;
          v6 = *(unsigned int *)v6;
          goto LABEL_103;
        }
        *(_DWORD *)v72 = 0;
        v72[6] = 0;
        *(_WORD *)&v72[4] = 0;
      }
      v82 = *(_DWORD *)&v72[3];
      LOBYTE(v82) = v72[3];
      *(_BYTE *)(a1 + 8) = 19;
      v65 = *(_DWORD *)v72;
      v66 = v82;
      goto LABEL_128;
    case 37:
      v6 = *a2;
      v56 = a2[1];
      if ( v56 )
      {
        *a2 = v6 + 1;
        a2[1] = v56 - 1;
        LOBYTE(v6) = *(_BYTE *)v6;
        v24 = 29LL;
LABEL_78:
        LOWORD(v22) = 0;
        goto LABEL_79;
      }
LABEL_80:
      *(_WORD *)(a1 + 8) = 19;
LABEL_131:
      *(_WORD *)(a1 + 14) = 0;
      *(_DWORD *)(a1 + 10) = 0;
      *(_QWORD *)(a1 + 16) = v6;
      *(_QWORD *)a1 = 46LL;
      return v6;
    case 38:
      v6 = *a2;
      v47 = a2[1];
      if ( v47 <= 1 )
      {
        *(_BYTE *)(a1 + 8) = 19;
        *(_WORD *)(a1 + 9) = 0;
        *(_BYTE *)(a1 + 11) = 0;
        *(_DWORD *)(a1 + 12) = 0;
        *(_QWORD *)(a1 + 16) = v6;
        *(_QWORD *)a1 = 46LL;
        return v6;
      }
      *a2 = v6 + 2;
      a2[1] = v47 - 2;
      LODWORD(v6) = *(unsigned __int16 *)v6;
      v22 = (unsigned int)v6 >> 8;
      v24 = 29LL;
LABEL_79:
      LODWORD(v21) = 0;
      v25 = 0LL;
      goto LABEL_133;
    case 39:
      v20 = (unsigned __int16 *)*a2;
      v6 = a2[1];
      if ( v6 > 2 )
      {
        *a2 = (unsigned __int64)v20 + 3;
        a2[1] = v6 - 3;
        LODWORD(v6) = *v20;
        LODWORD(v21) = *((unsigned __int8 *)v20 + 2);
        v22 = ((unsigned int)v6 | ((_DWORD)v21 << 16)) >> 8;
        goto LABEL_22;
      }
      *(_BYTE *)(a1 + 8) = 19;
      *(_BYTE *)(a1 + 15) = 0;
      *(_WORD *)(a1 + 13) = 0;
      *(_DWORD *)(a1 + 9) = 0;
      *(_QWORD *)(a1 + 16) = v20;
      *(_QWORD *)a1 = 46LL;
      return v6;
    case 40:
      v6 = *a2;
      v23 = a2[1];
      if ( v23 <= 3 )
      {
LABEL_75:
        *(_BYTE *)(a1 + 8) = 19;
        *(_DWORD *)(a1 + 9) = 0;
        *(_BYTE *)(a1 + 15) = 0;
        *(_WORD *)(a1 + 13) = 0;
        *(_QWORD *)(a1 + 16) = v6;
        *(_QWORD *)a1 = 46LL;
        return v6;
      }
      *a2 = v6 + 4;
      a2[1] = v23 - 4;
      LODWORD(v6) = *(_DWORD *)v6;
      v22 = (unsigned int)v6 >> 8;
      LODWORD(v21) = WORD1(v6);
LABEL_22:
      v24 = 29LL;
      v25 = 0LL;
      goto LABEL_133;
    default:
      if ( a4 == 7938 )
      {
LABEL_10:
        v14 = (unsigned __int8 *)*a2;
        v15 = a2[1];
        if ( !v15 )
        {
LABEL_41:
          v16 = v14;
          goto LABEL_42;
        }
        v16 = &v14[v15];
        v17 = 1 - v15;
        a5 = (unsigned __int64)(v14 + 1);
        v6 = 0LL;
        v18 = 0;
        while ( 1 )
        {
          v19 = *(_BYTE *)(a5 - 1);
          if ( v18 == 63 && (unsigned __int8)v19 >= 2u )
            break;
          v6 |= (unsigned __int64)(v19 & 0x7F) << v18;
          if ( v19 >= 0 )
          {
            *a2 = a5;
            a2[1] = -(__int64)v17;
            v22 = (unsigned int)v6 >> 8;
            v21 = v6 >> 16;
            v25 = v6 & 0xFFFFFFFF00000000LL;
            v24 = 29LL;
LABEL_133:
            *(_QWORD *)a1 = v24;
            v6 = v25 | ((_DWORD)v21 << 16) | (unsigned int)(unsigned __int16)(((_WORD)v22 << 8) | (unsigned __int8)v6);
            *(_QWORD *)(a1 + 8) = v6;
            *(_QWORD *)(a1 + 16) = a5;
            return v6;
          }
          v18 += 7;
          ++v17;
          ++a5;
          if ( v17 == 1 )
            goto LABEL_40;
        }
LABEL_90:
        *a2 = a5;
        a2[1] = -(__int64)v17;
        LOBYTE(v6) = 6;
LABEL_91:
        *(_BYTE *)(a1 + 8) = v6;
        *(_BYTE *)(a1 + 9) = 0;
LABEL_92:
        *(_WORD *)(a1 + 14) = 0;
        *(_DWORD *)(a1 + 10) = 0;
        *(_QWORD *)(a1 + 16) = v16;
        *(_QWORD *)a1 = 46LL;
      }
      else
      {
        if ( a4 != 7969 )
        {
LABEL_17:
          *(_BYTE *)(a1 + 8) = 12;
          *(_QWORD *)a1 = 46LL;
          return v6;
        }
LABEL_7:
        if ( (_BYTE)v5 == 8 )
        {
          v12 = *a2;
          v13 = a2[1];
          if ( v13 > 7 )
          {
            *a2 = v12 + 8;
            a2[1] = v13 - 8;
            v6 = *(_QWORD *)v12;
LABEL_89:
            v22 = (unsigned int)v6 >> 8;
            v21 = v6 >> 16;
            v25 = v6 & 0xFFFFFFFF00000000LL;
            v24 = 27LL;
            goto LABEL_133;
          }
          *(_QWORD *)&v75 = 19LL;
          *((_QWORD *)&v75 + 1) = *a2;
          *(_DWORD *)&v70[8] = v12 >> 8;
          *(_DWORD *)&v70[11] = HIDWORD(*a2);
          *(_QWORD *)v70 = *(_QWORD *)((char *)&v75 + 1);
          v6 = *(_QWORD *)&v70[7];
        }
        else
        {
          v6 = *a2;
          v61 = a2[1];
          if ( v61 > 3 )
          {
            *a2 = v6 + 4;
            a2[1] = v61 - 4;
            v6 = *(unsigned int *)v6;
            goto LABEL_89;
          }
          *(_DWORD *)v70 = 0;
          v70[6] = 0;
          *(_WORD *)&v70[4] = 0;
        }
        v81 = *(_DWORD *)&v70[3];
        LOBYTE(v81) = v70[3];
        *(_BYTE *)(a1 + 8) = 19;
        v65 = *(_DWORD *)v70;
        v66 = v81;
LABEL_128:
        *(_DWORD *)(a1 + 9) = v65;
        *(_DWORD *)(a1 + 12) = v66;
        *(_QWORD *)(a1 + 16) = v6;
        *(_QWORD *)a1 = 46LL;
      }
      return v6;
  }
}

//----- (0000000000010940) ----------------------------------------------------
__int64 __fastcall gimli::read::line::parse_directory_v5(
        __int64 a1,
        unsigned __int64 *a2,
        unsigned int a3,
        __int64 a4,
        unsigned __int64 a5)
{
  __int64 v7; // r14
  __int64 v8; // rbx
  __int64 v9; // r13
  __int64 result; // rax
  __int128 v11; // [rsp+20h] [rbp-58h]
  __int64 v12; // [rsp+30h] [rbp-48h] BYREF
  __int128 v13; // [rsp+38h] [rbp-40h]

  if ( !a5 )
    goto LABEL_10;
  v7 = 4 * a5;
  v8 = 46LL;
  v9 = 0LL;
  do
  {
    gimli::read::line::parse_attribute((__int64)&v12, a2, a3, *(_WORD *)(a4 + v9 + 2), a5);
    if ( v12 == 46 )
    {
      result = a1;
      *(_OWORD *)(a1 + 8) = v13;
      *(_QWORD *)a1 = 46LL;
      return result;
    }
    if ( *(_WORD *)(a4 + v9) == 1 )
    {
      v11 = v13;
      v8 = v12;
    }
    v9 += 4LL;
  }
  while ( v7 != v9 );
  if ( v8 == 46 )
LABEL_10:
    core::option::unwrap_failed((__int64)&off_58698);
  result = a1;
  *(_QWORD *)a1 = v8;
  *(_OWORD *)(a1 + 8) = v11;
  return result;
}
// 10999: variable 'a5' is possibly undefined
// 109F7: variable 'v11' is possibly undefined
// 58698: using guessed type char *off_58698;

//----- (0000000000010A20) ----------------------------------------------------
char __fastcall gimli::read::line::FileEntry<R,Offset>::parse(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r11
  __int64 v5; // r9
  __int64 v7; // rbx
  __int64 v8; // r10
  __int64 v9; // r8
  int v10; // ecx
  char v11; // bp
  __int64 v12; // rcx
  __int64 v13; // rbx
  char v14; // bp
  __int64 v15; // r14
  __int64 v16; // r15
  __int64 v17; // r12
  __int64 v18; // r9
  int v19; // ecx
  char v20; // r10

  v4 = *a2;
  v5 = a2[1];
  if ( !v5 )
  {
    v7 = *a2;
    LOBYTE(a4) = 19;
LABEL_10:
    *(_BYTE *)(a1 + 8) = a4;
    *(_BYTE *)(a1 + 9) = 0;
    *(_WORD *)(a1 + 14) = 0;
    *(_DWORD *)(a1 + 10) = 0;
    *(_QWORD *)(a1 + 16) = v7;
    goto LABEL_11;
  }
  v7 = v4 + v5;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0;
  while ( 1 )
  {
    v11 = *(_BYTE *)(v4 + v8);
    if ( v10 == 63 && (unsigned __int8)v11 >= 2u )
    {
      *a2 = v4 + v8 + 1;
      a2[1] = v5 + ~v8;
      LOBYTE(a4) = 6;
      goto LABEL_10;
    }
    v9 |= (unsigned __int64)(v11 & 0x7F) << v10;
    if ( v11 >= 0 )
      break;
    v10 += 7;
    if ( v5 == ++v8 )
    {
      *a2 = v7;
      a2[1] = 0LL;
      LOBYTE(a4) = 19;
      goto LABEL_10;
    }
  }
  v12 = v4 + v8 + 1;
  *a2 = v12;
  a2[1] = v5 - v8 - 1;
  if ( v5 - 1 == v8 )
  {
LABEL_19:
    LOBYTE(a4) = 19;
LABEL_21:
    *(_BYTE *)(a1 + 8) = a4;
    *(_BYTE *)(a1 + 9) = 0;
    *(_WORD *)(a1 + 14) = 0;
    *(_DWORD *)(a1 + 10) = 0;
    *(_QWORD *)(a1 + 16) = v12;
    goto LABEL_11;
  }
  v13 = 0LL;
  v12 = 0LL;
  while ( 1 )
  {
    v14 = *(_BYTE *)(v4 + v8 + 1);
    if ( (_DWORD)v12 == 63 && (unsigned __int8)v14 >= 2u )
    {
      *a2 = v4 + v8 + 2;
      a2[1] = v5 - v8 - 2;
      LOBYTE(a4) = 6;
      goto LABEL_21;
    }
    v13 |= (unsigned __int64)(v14 & 0x7F) << v12;
    if ( v14 >= 0 )
      break;
    v12 = (unsigned int)(v12 + 7);
    if ( v5 - 1 == ++v8 )
    {
      *a2 = v4 + v5;
      a2[1] = 0LL;
      v12 = v4 + v5;
      goto LABEL_19;
    }
  }
  v15 = v4 + v8 + 2;
  *a2 = v15;
  a2[1] = v5 - v8 - 2;
  if ( v5 - 2 == v8 )
  {
LABEL_29:
    LOBYTE(a4) = 19;
LABEL_31:
    *(_BYTE *)(a1 + 8) = a4;
    *(_BYTE *)(a1 + 9) = 0;
    *(_WORD *)(a1 + 14) = 0;
    *(_DWORD *)(a1 + 10) = 0;
    *(_QWORD *)(a1 + 16) = v15;
LABEL_11:
    *(_QWORD *)a1 = 46LL;
    return a4;
  }
  v16 = v8 - v5 + 3;
  v17 = v4 + v8 + 3;
  v15 = v5 + v4;
  v18 = 0LL;
  v19 = 0;
  while ( 1 )
  {
    v20 = *(_BYTE *)(v17 - 1);
    if ( v19 == 63 && (unsigned __int8)v20 >= 2u )
    {
      *a2 = v17;
      a2[1] = -v16;
      LOBYTE(a4) = 6;
      goto LABEL_31;
    }
    v18 |= (unsigned __int64)(v20 & 0x7F) << v19;
    if ( v20 >= 0 )
      break;
    v19 += 7;
    ++v16;
    ++v17;
    if ( v16 == 1 )
    {
      *a2 = v15;
      a2[1] = 0LL;
      goto LABEL_29;
    }
  }
  *a2 = v17;
  a2[1] = -v16;
  *(_QWORD *)a1 = 31LL;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = v9;
  *(_QWORD *)(a1 + 32) = v13;
  *(_QWORD *)(a1 + 40) = v18;
  *(_OWORD *)(a1 + 48) = 0LL;
  return a4;
}

//----- (0000000000010C70) ----------------------------------------------------
char __fastcall gimli::read::unit::parse_attribute(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4)
{
  unsigned __int64 v4; // r10
  unsigned __int64 v6; // rax
  unsigned __int16 v7; // r11
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // r12
  unsigned int v10; // ebp
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // r10
  unsigned __int64 v16; // r8
  int v17; // ecx
  char v18; // r9
  int v19; // ecx
  char v20; // r9
  int v21; // ecx
  __int64 v22; // rdx
  unsigned __int64 v23; // rsi
  __int64 v24; // r9
  int v25; // ecx
  char v26; // r9
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // r9
  int v29; // ecx
  __int64 v30; // rax
  unsigned __int64 v31; // r9
  int v32; // ecx
  char v33; // r9
  __int64 v34; // r14
  __int64 v35; // rdx
  int v36; // ecx
  char v37; // r11
  bool v38; // cf
  unsigned __int64 v39; // r9
  int v40; // ecx
  char v41; // r11
  __int64 v42; // rcx
  int v43; // edx
  int v44; // ecx
  char v45; // r9
  __int16 v46; // r8
  int v47; // ecx
  char v48; // r9
  __int64 v49; // rcx
  int v50; // ecx
  __int64 v51; // rdx
  unsigned __int64 v52; // r11
  unsigned __int64 v53; // r11
  unsigned __int64 v54; // rax
  __int64 v55; // r8
  __int64 v56; // r9
  __int128 v58; // [rsp+0h] [rbp-98h] BYREF
  _BYTE v59[15]; // [rsp+10h] [rbp-88h]
  _BYTE v60[7]; // [rsp+20h] [rbp-78h]
  _BYTE v61[7]; // [rsp+28h] [rbp-70h]
  _BYTE v62[7]; // [rsp+30h] [rbp-68h]
  _BYTE v63[7]; // [rsp+38h] [rbp-60h]
  _BYTE v64[7]; // [rsp+40h] [rbp-58h]
  _BYTE v65[7]; // [rsp+48h] [rbp-50h]
  _BYTE v66[7]; // [rsp+50h] [rbp-48h]
  _BYTE v67[7]; // [rsp+58h] [rbp-40h]
  unsigned __int64 *v68; // [rsp+60h] [rbp-38h]

  LODWORD(v6) = HIWORD(a3);
  v7 = *(_WORD *)(a4 + 10);
  v8 = *a2;
  v9 = a2[1];
  v10 = v7;
  while ( 2 )
  {
    v11 = v8;
    v12 = v9;
    switch ( (__int16)v10 )
    {
      case 1:
        v34 = a1;
        gimli::read::reader::Reader::read_address((__int64)&v58, a2, a3);
        if ( (_BYTE)v58 == 75 )
        {
          LOBYTE(v6) = BYTE8(v58);
          v21 = DWORD2(v58) >> 8;
          v22 = *((_QWORD *)&v58 + 1) >> 16;
          v23 = *((_QWORD *)&v58 + 1) & 0xFFFFFFFF00000000LL;
          v24 = 0LL;
          goto LABEL_157;
        }
        *(_DWORD *)&v60[3] = DWORD1(v58);
        *(_DWORD *)v60 = *(_DWORD *)((char *)&v58 + 1);
        v42 = *((_QWORD *)&v58 + 1);
        *(_BYTE *)(a1 + 8) = v58;
        LODWORD(v6) = *(_DWORD *)v60;
        v43 = *(_DWORD *)&v60[3];
        goto LABEL_221;
      case 2:
LABEL_171:
        *(_BYTE *)(a1 + 8) = 12;
        goto LABEL_239;
      case 3:
        if ( v9 < 2 )
          goto LABEL_109;
        v31 = v9 - 2;
        v6 = v8 + 2;
        *a2 = v8 + 2;
        a2[1] = v9 - 2;
        v4 = *(unsigned __int16 *)v8;
        goto LABEL_107;
      case 4:
        if ( v9 < 4 )
          goto LABEL_109;
        v31 = v9 - 4;
        v6 = v8 + 4;
        *a2 = v8 + 4;
        a2[1] = v9 - 4;
        v4 = *(unsigned int *)v8;
        goto LABEL_107;
      case 5:
        if ( v9 <= 1 )
          goto LABEL_109;
        *a2 = v8 + 2;
        a2[1] = v9 - 2;
        LOWORD(v6) = *(_WORD *)v8;
        v21 = HIBYTE(*(unsigned __int16 *)v8);
        v24 = 3LL;
        goto LABEL_155;
      case 6:
        if ( (a3 & 0xFF00) == 1024 )
        {
          switch ( *(_WORD *)(a4 + 8) )
          {
            case 2:
            case 0x10:
            case 0x19:
            case 0x2A:
            case 0x2C:
            case 0x40:
            case 0x43:
            case 0x46:
            case 0x48:
            case 0x4A:
            case 0x4D:
            case 0x55:
            case 0x79:
              break;
            case 0x38:
              LOBYTE(v6) = BYTE2(a3) & 0xFE;
              if ( (HIWORD(a3) & 0xFFFE) != 2 )
                goto LABEL_235;
              break;
            default:
              goto LABEL_235;
          }
          if ( v9 >= 4 )
          {
            *a2 = v8 + 4;
            a2[1] = v9 - 4;
            LODWORD(v6) = *(_DWORD *)v8;
            v21 = *(_DWORD *)v8 >> 8;
            LODWORD(v22) = HIWORD(*(_DWORD *)v8);
            v24 = 10LL;
            goto LABEL_156;
          }
        }
        else
        {
LABEL_235:
          if ( v9 >= 4 )
          {
            *a2 = v8 + 4;
            a2[1] = v9 - 4;
            LODWORD(v6) = *(_DWORD *)v8;
            v21 = *(_DWORD *)v8 >> 8;
            LODWORD(v22) = HIWORD(*(_DWORD *)v8);
            v24 = 4LL;
            goto LABEL_156;
          }
        }
LABEL_237:
        *(_BYTE *)(a1 + 8) = 19;
        *(_DWORD *)(a1 + 9) = 0;
        *(_BYTE *)(a1 + 15) = 0;
        *(_WORD *)(a1 + 13) = 0;
        goto LABEL_238;
      case 7:
        if ( (a3 & 0xFF00) == 2048 )
        {
          switch ( *(_WORD *)(a4 + 8) )
          {
            case 2:
            case 0x10:
            case 0x19:
            case 0x2A:
            case 0x2C:
            case 0x40:
            case 0x43:
            case 0x46:
            case 0x48:
            case 0x4A:
            case 0x4D:
            case 0x55:
            case 0x79:
              break;
            case 0x38:
              if ( (HIWORD(a3) & 0xFFFE) != 2 )
                goto LABEL_241;
              break;
            default:
              goto LABEL_241;
          }
          if ( v9 >= 8 )
          {
LABEL_122:
            *a2 = v8 + 8;
            a2[1] = v9 - 8;
            v6 = *(_QWORD *)v8;
LABEL_183:
            v21 = (unsigned int)v6 >> 8;
            v22 = v6 >> 16;
            v23 = v6 & 0xFFFFFFFF00000000LL;
            v24 = 10LL;
            goto LABEL_157;
          }
        }
        else
        {
LABEL_241:
          if ( v9 >= 8 )
          {
            *a2 = v8 + 8;
            a2[1] = v9 - 8;
            v6 = *(_QWORD *)v8;
            v21 = (unsigned int)*(_QWORD *)v8 >> 8;
            v22 = *(_QWORD *)v8 >> 16;
            v23 = *(_QWORD *)v8 & 0xFFFFFFFF00000000LL;
            v24 = 5LL;
            goto LABEL_157;
          }
        }
LABEL_243:
        *(_QWORD *)&v58 = 19LL;
        *((_QWORD *)&v58 + 1) = v8;
        v54 = *(_QWORD *)((char *)&v58 + 1);
        v55 = HIBYTE(*(_QWORD *)((char *)&v58 + 1));
        v56 = HIWORD(*(_QWORD *)((char *)&v58 + 1));
        *(_BYTE *)(a1 + 8) = 19;
        *(_DWORD *)(a1 + 9) = v54;
        *(_BYTE *)(a1 + 15) = v56;
        v6 = HIDWORD(v54);
        *(_WORD *)(a1 + 13) = v6;
        *(_BYTE *)(a1 + 16) = v55;
        *(_BYTE *)(a1 + 23) = HIBYTE(v8);
        *(_WORD *)(a1 + 21) = HIDWORD(v8) >> 8;
        *(_DWORD *)(a1 + 17) = v8 >> 8;
        goto LABEL_239;
      case 8:
        if ( !v9 )
          goto LABEL_109;
        v4 = 0LL;
        while ( *(_BYTE *)(v8 + v4) )
        {
          if ( v9 == ++v4 )
          {
LABEL_109:
            *(_QWORD *)(a1 + 8) = 19LL;
            goto LABEL_238;
          }
        }
        *a2 = v8 + v4 + 1;
        a2[1] = v9 + ~v4;
        v21 = (unsigned int)v8 >> 8;
        v22 = v8 >> 16;
        v23 = v8 & 0xFFFFFFFF00000000LL;
        v24 = 31LL;
        LOBYTE(v6) = v8;
        goto LABEL_157;
      case 9:
        if ( !v9 )
          goto LABEL_173;
        v6 = v8 + v9;
        v35 = 0LL;
        v4 = 0LL;
        v36 = 0;
        while ( 2 )
        {
          v37 = *(_BYTE *)(v8 + v35);
          if ( v36 == 63 && (unsigned __int8)v37 >= 2u )
          {
LABEL_204:
            v6 = v8 + v35 + 1;
            *a2 = v6;
            a2[1] = v9 + ~v35;
            v49 = 6LL;
          }
          else
          {
            v4 |= (unsigned __int64)(v37 & 0x7F) << v36;
            if ( v37 < 0 )
            {
              v36 += 7;
              if ( v9 == ++v35 )
              {
LABEL_116:
                *a2 = v6;
                a2[1] = 0LL;
                goto LABEL_174;
              }
              continue;
            }
            v6 = v8 + v35 + 1;
            *a2 = v6;
            v52 = ~v35 + v9;
            a2[1] = v52;
            if ( v52 >= v4 )
            {
              *a2 = v8 + v4 + v35 + 1;
              a2[1] = v9 - v4 + ~v35;
              v21 = (unsigned int)v6 >> 8;
              v22 = v6 >> 16;
              v23 = v6 & 0xFFFFFFFF00000000LL;
              v24 = 1LL;
LABEL_157:
              v46 = *(_WORD *)(a4 + 8);
              v6 = v23 | ((_DWORD)v22 << 16) | (unsigned int)(unsigned __int16)(((_WORD)v21 << 8) | (unsigned __int8)v6);
              *(_QWORD *)a1 = v24;
              *(_QWORD *)(a1 + 8) = v6;
              *(_QWORD *)(a1 + 16) = v4;
              *(_WORD *)(a1 + 24) = v46;
              return v6;
            }
LABEL_174:
            v49 = 19LL;
          }
          break;
        }
        *(_QWORD *)(a1 + 8) = v49;
        *(_QWORD *)(a1 + 16) = v6;
        goto LABEL_239;
      case 10:
        if ( !v9 )
          goto LABEL_109;
        v31 = v9 - 1;
        v6 = v8 + 1;
        *a2 = v8 + 1;
        a2[1] = v9 - 1;
        v4 = *(unsigned __int8 *)v8;
LABEL_107:
        v38 = v31 < v4;
        v39 = v31 - v4;
        if ( v38 )
        {
          v11 = v6;
          goto LABEL_109;
        }
        *a2 = v6 + v4;
        a2[1] = v39;
        v21 = (unsigned int)v6 >> 8;
        v22 = v6 >> 16;
        v23 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 1LL;
        goto LABEL_157;
      case 11:
        if ( !v9 )
          goto LABEL_132;
        *a2 = v8 + 1;
        a2[1] = v9 - 1;
        LOBYTE(v6) = *(_BYTE *)v8;
        v24 = 2LL;
        LOWORD(v21) = 0;
        goto LABEL_155;
      case 12:
        if ( !v9 )
          goto LABEL_132;
        *a2 = v8 + 1;
        a2[1] = v9 - 1;
        LOBYTE(v6) = *(_BYTE *)v8 != 0;
        v24 = 9LL;
        LOWORD(v21) = 0;
        goto LABEL_155;
      case 13:
        v27 = v8 + 1;
        v28 = v9 - 1;
        v29 = 0;
        v30 = 0LL;
        while ( 2 )
        {
          if ( v28 == -1LL )
          {
            LOBYTE(v6) = 19;
          }
          else
          {
            *a2 = v27;
            a2[1] = v28;
            v4 = *(unsigned __int8 *)(v27 - 1);
            if ( v29 != 63 || v4 == 127 || !*(_BYTE *)(v27 - 1) )
            {
              v30 |= (v4 & 0x7F) << v29;
              v29 += 7;
              ++v11;
              ++v27;
              --v28;
              if ( (v4 & 0x80u) == 0LL )
              {
                v51 = -1LL << v29;
                if ( (unsigned __int8)v4 < 0x40u )
                  v51 = 0LL;
                if ( v29 >= 64 )
                  v51 = 0LL;
                v6 = v51 | v30;
LABEL_203:
                v21 = (unsigned int)v6 >> 8;
                v22 = v6 >> 16;
                v23 = v6 & 0xFFFFFFFF00000000LL;
                v24 = 6LL;
                goto LABEL_157;
              }
              continue;
            }
            LOBYTE(v6) = 7;
          }
          break;
        }
        *(_BYTE *)(a1 + 8) = v6;
        *(_BYTE *)(a1 + 9) = 0;
LABEL_197:
        *(_WORD *)(a1 + 14) = 0;
        *(_DWORD *)(a1 + 10) = 0;
        goto LABEL_238;
      case 14:
        if ( BYTE1(a3) == 8 )
        {
          if ( v9 > 7 )
          {
            *a2 = v8 + 8;
            a2[1] = v9 - 8;
            v6 = *(_QWORD *)v8;
LABEL_187:
            v21 = (unsigned int)v6 >> 8;
            v22 = v6 >> 16;
            v23 = v6 & 0xFFFFFFFF00000000LL;
            v24 = 26LL;
            goto LABEL_157;
          }
          *(_QWORD *)&v58 = 19LL;
          *((_QWORD *)&v58 + 1) = v8;
          *(_DWORD *)&v59[8] = v8 >> 8;
          *(_DWORD *)&v59[11] = HIDWORD(v8);
          *(_QWORD *)v59 = *(_QWORD *)((char *)&v58 + 1);
          v11 = *(_QWORD *)&v59[7];
        }
        else
        {
          if ( v9 > 3 )
          {
            *a2 = v8 + 4;
            a2[1] = v9 - 4;
            v6 = *(unsigned int *)v8;
            goto LABEL_187;
          }
          *(_DWORD *)v59 = 0;
          v59[6] = 0;
          *(_WORD *)&v59[4] = 0;
        }
        *(_DWORD *)&v65[3] = *(_DWORD *)&v59[3];
        *(_DWORD *)v65 = *(_DWORD *)v59;
        *(_BYTE *)(a1 + 8) = 19;
        LODWORD(v6) = *(_DWORD *)v65;
        v50 = *(_DWORD *)&v65[3];
        goto LABEL_219;
      case 15:
        if ( !v9 )
          goto LABEL_166;
        v14 = v8 + v9;
        v15 = 1 - v9;
        v16 = v8 + 1;
        v6 = 0LL;
        v44 = 0;
        while ( 2 )
        {
          v45 = *(_BYTE *)(v16 - 1);
          if ( v44 == 63 && (unsigned __int8)v45 >= 2u )
            goto LABEL_168;
          v6 |= (unsigned __int64)(v45 & 0x7F) << v44;
          if ( v45 < 0 )
          {
            v44 += 7;
            ++v15;
            ++v16;
            if ( v15 == 1 )
              goto LABEL_165;
            continue;
          }
          break;
        }
        *a2 = v16;
        v4 = -(__int64)v15;
        a2[1] = v4;
        v21 = (unsigned int)v6 >> 8;
        v22 = v6 >> 16;
        v23 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 7LL;
        goto LABEL_157;
      case 16:
        v34 = a1;
        if ( HIWORD(a3) == 2 )
        {
          gimli::read::reader::Reader::read_sized_offset((__int64)&v58, a2, a3);
          if ( (_BYTE)v58 != 75 )
          {
            *(_DWORD *)&v62[3] = DWORD1(v58);
            *(_DWORD *)v62 = *(_DWORD *)((char *)&v58 + 1);
            v42 = *((_QWORD *)&v58 + 1);
            *(_BYTE *)(a1 + 8) = v58;
            LODWORD(v6) = *(_DWORD *)v62;
            v43 = *(_DWORD *)&v62[3];
LABEL_221:
            *(_DWORD *)(v34 + 9) = v6;
            *(_DWORD *)(v34 + 12) = v43;
            *(_QWORD *)(v34 + 16) = v42;
            *(_QWORD *)v34 = 46LL;
            return v6;
          }
        }
        else
        {
          gimli::read::reader::Reader::read_offset((__int64)&v58, a2, SBYTE1(a3));
          if ( (_BYTE)v58 != 75 )
          {
            *(_DWORD *)&v63[3] = DWORD1(v58);
            *(_DWORD *)v63 = *(_DWORD *)((char *)&v58 + 1);
            v42 = *((_QWORD *)&v58 + 1);
            *(_BYTE *)(a1 + 8) = v58;
            LODWORD(v6) = *(_DWORD *)v63;
            v43 = *(_DWORD *)&v63[3];
            goto LABEL_221;
          }
        }
        LOBYTE(v6) = BYTE8(v58);
        v21 = DWORD2(v58) >> 8;
        v22 = *((_QWORD *)&v58 + 1) >> 16;
        v23 = *((_QWORD *)&v58 + 1) & 0xFFFFFFFF00000000LL;
        v24 = 14LL;
        goto LABEL_157;
      case 17:
        if ( !v9 )
          goto LABEL_132;
        *a2 = v8 + 1;
        a2[1] = v9 - 1;
        LOBYTE(v6) = *(_BYTE *)v8;
        v24 = 13LL;
        LOWORD(v21) = 0;
        goto LABEL_155;
      case 18:
        if ( v9 <= 1 )
          goto LABEL_158;
        *a2 = v8 + 2;
        a2[1] = v9 - 2;
        LOWORD(v6) = *(_WORD *)v8;
        v21 = HIBYTE(*(unsigned __int16 *)v8);
        v24 = 13LL;
        goto LABEL_155;
      case 19:
        if ( v9 <= 3 )
          goto LABEL_237;
        *a2 = v8 + 4;
        a2[1] = v9 - 4;
        LODWORD(v6) = *(_DWORD *)v8;
        v21 = *(_DWORD *)v8 >> 8;
        LODWORD(v22) = HIWORD(*(_DWORD *)v8);
        v24 = 13LL;
        goto LABEL_156;
      case 20:
        if ( v9 <= 7 )
          goto LABEL_243;
        *a2 = v8 + 8;
        a2[1] = v9 - 8;
        v6 = *(_QWORD *)v8;
        goto LABEL_226;
      case 21:
        if ( !v9 )
          goto LABEL_166;
        v14 = v8 + v9;
        v15 = 1 - v9;
        v16 = v8 + 1;
        v6 = 0LL;
        v32 = 0;
        while ( 2 )
        {
          v33 = *(_BYTE *)(v16 - 1);
          if ( v32 == 63 && (unsigned __int8)v33 >= 2u )
            goto LABEL_168;
          v6 |= (unsigned __int64)(v33 & 0x7F) << v32;
          if ( v33 < 0 )
          {
            v32 += 7;
            ++v15;
            ++v16;
            if ( v15 == 1 )
              goto LABEL_165;
            continue;
          }
          break;
        }
        *a2 = v16;
        v4 = -(__int64)v15;
        a2[1] = v4;
LABEL_226:
        v21 = (unsigned int)v6 >> 8;
        v22 = v6 >> 16;
        v23 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 13LL;
        goto LABEL_157;
      case 22:
        if ( v9 )
        {
          v4 = v10;
          --v9;
          ++v8;
          *a2 = v11 + 1;
          a2[1] = v12 - 1;
          v10 = *(_BYTE *)v11 & 0x7F;
          if ( *(char *)v11 < 0 )
          {
            if ( v12 == 1 )
              goto LABEL_194;
            v9 = v12 - 2;
            v8 = v11 + 2;
            *a2 = v11 + 2;
            a2[1] = v12 - 2;
            v68 = a2;
            v10 = ((*(_BYTE *)(v11 + 1) & 0x7F) << 7) | (unsigned __int16)v10;
            if ( *(char *)(v11 + 1) < 0 )
            {
              if ( v12 == 2 )
              {
LABEL_194:
                LOBYTE(v6) = 19;
                LOWORD(v4) = 0;
                v11 = v8;
                goto LABEL_232;
              }
              v13 = v12 - 3;
              v8 = v11 + 3;
              *v68 = v11 + 3;
              a2[1] = v13;
              v11 = *(unsigned __int8 *)(v11 + 2);
              if ( (unsigned __int16)v11 > 3u )
              {
                LOBYTE(v6) = 6;
                goto LABEL_232;
              }
              v10 = ((unsigned __int16)v11 << 14) | (unsigned __int16)v10;
              v9 = v13;
            }
          }
          continue;
        }
        LOBYTE(v6) = 19;
        LOWORD(v4) = 0;
LABEL_232:
        *(_BYTE *)(a1 + 8) = v6;
        *(_BYTE *)(a1 + 9) = 0;
        *(_WORD *)(a1 + 10) = v4;
LABEL_233:
        *(_DWORD *)(a1 + 12) = 0;
LABEL_238:
        *(_QWORD *)(a1 + 16) = v11;
LABEL_239:
        *(_QWORD *)a1 = 46LL;
        return v6;
      case 23:
        if ( BYTE1(a3) == 8 )
        {
          if ( v9 > 7 )
            goto LABEL_122;
          *(_QWORD *)&v58 = 19LL;
          *((_QWORD *)&v58 + 1) = v8;
          *(_DWORD *)&v59[8] = v8 >> 8;
          *(_DWORD *)&v59[11] = HIDWORD(v8);
          *(_QWORD *)v59 = *(_QWORD *)((char *)&v58 + 1);
          v11 = *(_QWORD *)&v59[7];
        }
        else
        {
          if ( v9 > 3 )
          {
            *a2 = v8 + 4;
            a2[1] = v9 - 4;
            v6 = *(unsigned int *)v8;
            goto LABEL_183;
          }
          *(_DWORD *)v59 = 0;
          v59[6] = 0;
          *(_WORD *)&v59[4] = 0;
        }
        *(_DWORD *)&v61[3] = *(_DWORD *)&v59[3];
        *(_DWORD *)v61 = *(_DWORD *)v59;
        *(_BYTE *)(a1 + 8) = 19;
        LODWORD(v6) = *(_DWORD *)v61;
        v50 = *(_DWORD *)&v61[3];
        goto LABEL_219;
      case 24:
        if ( !v9 )
        {
LABEL_173:
          v6 = v8;
          goto LABEL_174;
        }
        v6 = v8 + v9;
        v35 = 0LL;
        v4 = 0LL;
        v40 = 0;
        while ( 2 )
        {
          v41 = *(_BYTE *)(v8 + v35);
          if ( v40 == 63 && (unsigned __int8)v41 >= 2u )
            goto LABEL_204;
          v4 |= (unsigned __int64)(v41 & 0x7F) << v40;
          if ( v41 < 0 )
          {
            v40 += 7;
            if ( v9 == ++v35 )
              goto LABEL_116;
            continue;
          }
          break;
        }
        v6 = v8 + v35 + 1;
        *a2 = v6;
        v53 = ~v35 + v9;
        a2[1] = v53;
        if ( v53 < v4 )
          goto LABEL_174;
        *a2 = v8 + v4 + v35 + 1;
        a2[1] = v9 - v4 + ~v35;
        v21 = (unsigned int)v6 >> 8;
        v22 = v6 >> 16;
        v23 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 8LL;
        goto LABEL_157;
      case 25:
        v24 = 9LL;
        LOWORD(v21) = 0;
        LOBYTE(v6) = 1;
        goto LABEL_155;
      case 26:
LABEL_21:
        if ( !v9 )
          goto LABEL_166;
        v14 = v8 + v9;
        v15 = 1 - v9;
        v16 = v8 + 1;
        v6 = 0LL;
        v19 = 0;
        while ( 2 )
        {
          v20 = *(_BYTE *)(v16 - 1);
          if ( v19 == 63 && (unsigned __int8)v20 >= 2u )
            goto LABEL_168;
          v6 |= (unsigned __int64)(v20 & 0x7F) << v19;
          if ( v20 < 0 )
          {
            v19 += 7;
            ++v15;
            ++v16;
            if ( v15 == 1 )
              goto LABEL_165;
            continue;
          }
          break;
        }
        *a2 = v16;
        v4 = -(__int64)v15;
        a2[1] = v4;
        v21 = (unsigned int)v6 >> 8;
        v22 = v6 >> 16;
        v23 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 29LL;
        goto LABEL_157;
      case 27:
LABEL_11:
        if ( !v9 )
          goto LABEL_166;
        v14 = v8 + v9;
        v15 = 1 - v9;
        v16 = v8 + 1;
        v6 = 0LL;
        v17 = 0;
        while ( 2 )
        {
          v18 = *(_BYTE *)(v16 - 1);
          if ( v17 == 63 && (unsigned __int8)v18 >= 2u )
            goto LABEL_168;
          v6 |= (unsigned __int64)(v18 & 0x7F) << v17;
          if ( v18 < 0 )
          {
            v17 += 7;
            ++v15;
            ++v16;
            if ( v15 == 1 )
              goto LABEL_165;
            continue;
          }
          break;
        }
        *a2 = v16;
        v4 = -(__int64)v15;
        a2[1] = v4;
        v21 = (unsigned int)v6 >> 8;
        v22 = v6 >> 16;
        v23 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 12LL;
        goto LABEL_157;
      case 28:
        if ( v9 <= 3 )
          goto LABEL_237;
        *a2 = v8 + 4;
        a2[1] = v9 - 4;
        LODWORD(v6) = *(_DWORD *)v8;
        v21 = *(_DWORD *)v8 >> 8;
        LODWORD(v22) = HIWORD(*(_DWORD *)v8);
        v24 = 15LL;
        goto LABEL_156;
      case 29:
LABEL_18:
        if ( BYTE1(a3) == 8 )
        {
          if ( v9 > 7 )
          {
            *a2 = v8 + 8;
            a2[1] = v9 - 8;
            v6 = *(_QWORD *)v8;
LABEL_33:
            v21 = (unsigned int)v6 >> 8;
            v22 = v6 >> 16;
            v23 = v6 & 0xFFFFFFFF00000000LL;
            v24 = 27LL;
            goto LABEL_157;
          }
          *(_QWORD *)&v58 = 19LL;
          *((_QWORD *)&v58 + 1) = v8;
          *(_DWORD *)&v59[8] = v8 >> 8;
          *(_DWORD *)&v59[11] = HIDWORD(v8);
          *(_QWORD *)v59 = *(_QWORD *)((char *)&v58 + 1);
          v11 = *(_QWORD *)&v59[7];
        }
        else
        {
          if ( v9 > 3 )
          {
            *a2 = v8 + 4;
            a2[1] = v9 - 4;
            v6 = *(unsigned int *)v8;
            goto LABEL_33;
          }
          *(_DWORD *)v59 = 0;
          v59[6] = 0;
          *(_WORD *)&v59[4] = 0;
        }
        *(_DWORD *)&v66[3] = *(_DWORD *)&v59[3];
        *(_DWORD *)v66 = *(_DWORD *)v59;
        *(_BYTE *)(a1 + 8) = 19;
        LODWORD(v6) = *(_DWORD *)v66;
        v50 = *(_DWORD *)&v66[3];
        goto LABEL_219;
      case 30:
        if ( v9 < 0x10 )
          goto LABEL_109;
        *a2 = v8 + 16;
        a2[1] = v9 - 16;
        v21 = (unsigned int)v8 >> 8;
        v22 = v8 >> 16;
        v23 = v8 & 0xFFFFFFFF00000000LL;
        v24 = 1LL;
        v4 = 16LL;
        LOBYTE(v6) = v8;
        goto LABEL_157;
      case 31:
        if ( BYTE1(a3) == 8 )
        {
          if ( v9 > 7 )
          {
            *a2 = v8 + 8;
            a2[1] = v9 - 8;
            v6 = *(_QWORD *)v8;
LABEL_191:
            v21 = (unsigned int)v6 >> 8;
            v22 = v6 >> 16;
            v23 = v6 & 0xFFFFFFFF00000000LL;
            v24 = 30LL;
            goto LABEL_157;
          }
          *(_QWORD *)&v58 = 19LL;
          *((_QWORD *)&v58 + 1) = v8;
          *(_DWORD *)&v59[8] = v8 >> 8;
          *(_DWORD *)&v59[11] = HIDWORD(v8);
          *(_QWORD *)v59 = *(_QWORD *)((char *)&v58 + 1);
          v11 = *(_QWORD *)&v59[7];
        }
        else
        {
          if ( v9 > 3 )
          {
            *a2 = v8 + 4;
            a2[1] = v9 - 4;
            v6 = *(unsigned int *)v8;
            goto LABEL_191;
          }
          *(_DWORD *)v59 = 0;
          v59[6] = 0;
          *(_WORD *)&v59[4] = 0;
        }
        *(_DWORD *)&v67[3] = *(_DWORD *)&v59[3];
        *(_DWORD *)v67 = *(_DWORD *)v59;
        *(_BYTE *)(a1 + 8) = 19;
        LODWORD(v6) = *(_DWORD *)v67;
        v50 = *(_DWORD *)&v67[3];
LABEL_219:
        *(_DWORD *)(a1 + 9) = v6;
        *(_DWORD *)(a1 + 12) = v50;
        goto LABEL_238;
      case 32:
        if ( v9 <= 7 )
          goto LABEL_243;
        *a2 = v8 + 8;
        a2[1] = v9 - 8;
        v6 = *(_QWORD *)v8;
        v21 = (unsigned int)*(_QWORD *)v8 >> 8;
        v22 = *(_QWORD *)v8 >> 16;
        v23 = *(_QWORD *)v8 & 0xFFFFFFFF00000000LL;
        v24 = 25LL;
        goto LABEL_157;
      case 33:
        if ( v7 == 33 )
        {
          v6 = *(_QWORD *)a4;
          goto LABEL_203;
        }
        *(_BYTE *)(a1 + 8) = 70;
        goto LABEL_239;
      case 34:
        if ( !v9 )
          goto LABEL_166;
        v14 = v8 + v9;
        v15 = 1 - v9;
        v16 = v8 + 1;
        v6 = 0LL;
        v47 = 0;
        while ( 1 )
        {
          v48 = *(_BYTE *)(v16 - 1);
          if ( v47 == 63 && (unsigned __int8)v48 >= 2u )
          {
LABEL_168:
            *a2 = v16;
            a2[1] = -(__int64)v15;
            LOBYTE(v6) = 6;
LABEL_169:
            *(_BYTE *)(a1 + 8) = v6;
            *(_BYTE *)(a1 + 9) = 0;
            *(_WORD *)(a1 + 14) = 0;
            *(_DWORD *)(a1 + 10) = 0;
            *(_QWORD *)(a1 + 16) = v14;
            goto LABEL_239;
          }
          v6 |= (unsigned __int64)(v48 & 0x7F) << v47;
          if ( v48 >= 0 )
            break;
          v47 += 7;
          ++v15;
          ++v16;
          if ( v15 == 1 )
          {
LABEL_165:
            *a2 = v14;
            a2[1] = 0LL;
LABEL_167:
            LOBYTE(v6) = 19;
            goto LABEL_169;
          }
        }
        *a2 = v16;
        v4 = -(__int64)v15;
        a2[1] = v4;
        v21 = (unsigned int)v6 >> 8;
        v22 = v6 >> 16;
        v23 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 19LL;
        goto LABEL_157;
      case 35:
        if ( !v9 )
        {
LABEL_166:
          v14 = v8;
          goto LABEL_167;
        }
        v14 = v8 + v9;
        v15 = 1 - v9;
        v16 = v8 + 1;
        v6 = 0LL;
        v25 = 0;
        while ( 2 )
        {
          v26 = *(_BYTE *)(v16 - 1);
          if ( v25 == 63 && (unsigned __int8)v26 >= 2u )
            goto LABEL_168;
          v6 |= (unsigned __int64)(v26 & 0x7F) << v25;
          if ( v26 < 0 )
          {
            v25 += 7;
            ++v15;
            ++v16;
            if ( v15 == 1 )
              goto LABEL_165;
            continue;
          }
          break;
        }
        *a2 = v16;
        v4 = -(__int64)v15;
        a2[1] = v4;
        v21 = (unsigned int)v6 >> 8;
        v22 = v6 >> 16;
        v23 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 24LL;
        goto LABEL_157;
      case 36:
        if ( v9 <= 7 )
          goto LABEL_243;
LABEL_57:
        *a2 = v8 + 8;
        a2[1] = v9 - 8;
        v6 = *(_QWORD *)v8;
LABEL_177:
        v21 = (unsigned int)v6 >> 8;
        v22 = v6 >> 16;
        v23 = v6 & 0xFFFFFFFF00000000LL;
        v24 = 15LL;
        goto LABEL_157;
      case 37:
        if ( !v9 )
          goto LABEL_132;
        *a2 = v8 + 1;
        a2[1] = v9 - 1;
        LOBYTE(v6) = *(_BYTE *)v8;
        v24 = 29LL;
        LOWORD(v21) = 0;
        goto LABEL_155;
      case 38:
        if ( v9 <= 1 )
          goto LABEL_158;
        *a2 = v8 + 2;
        a2[1] = v9 - 2;
        LOWORD(v6) = *(_WORD *)v8;
        v21 = HIBYTE(*(unsigned __int16 *)v8);
        v24 = 29LL;
        goto LABEL_155;
      case 39:
        if ( v9 <= 2 )
          goto LABEL_150;
        *a2 = v8 + 3;
        a2[1] = v9 - 3;
        LODWORD(v6) = *(unsigned __int16 *)v8;
        LODWORD(v22) = *(unsigned __int8 *)(v8 + 2);
        v21 = ((unsigned int)v6 | ((_DWORD)v22 << 16)) >> 8;
        v24 = 29LL;
        goto LABEL_156;
      case 40:
        if ( v9 <= 3 )
          goto LABEL_237;
        *a2 = v8 + 4;
        a2[1] = v9 - 4;
        LODWORD(v6) = *(_DWORD *)v8;
        v21 = *(_DWORD *)v8 >> 8;
        LODWORD(v22) = HIWORD(*(_DWORD *)v8);
        v24 = 29LL;
        goto LABEL_156;
      case 41:
        if ( v9 )
        {
          *a2 = v8 + 1;
          a2[1] = v9 - 1;
          LOBYTE(v6) = *(_BYTE *)v8;
          v24 = 12LL;
          LOWORD(v21) = 0;
          goto LABEL_155;
        }
LABEL_132:
        *(_WORD *)(a1 + 8) = 19;
        goto LABEL_197;
      case 42:
        if ( v9 <= 1 )
        {
LABEL_158:
          *(_BYTE *)(a1 + 8) = 19;
          *(_WORD *)(a1 + 9) = 0;
          *(_BYTE *)(a1 + 11) = 0;
          goto LABEL_233;
        }
        *a2 = v8 + 2;
        a2[1] = v9 - 2;
        LOWORD(v6) = *(_WORD *)v8;
        v21 = HIBYTE(*(unsigned __int16 *)v8);
        v24 = 12LL;
LABEL_155:
        LODWORD(v22) = 0;
        goto LABEL_156;
      case 43:
        if ( v9 <= 2 )
        {
LABEL_150:
          *(_BYTE *)(a1 + 8) = 19;
          *(_BYTE *)(a1 + 15) = 0;
          *(_WORD *)(a1 + 13) = 0;
          *(_DWORD *)(a1 + 9) = 0;
          goto LABEL_238;
        }
        *a2 = v8 + 3;
        a2[1] = v9 - 3;
        LODWORD(v6) = *(unsigned __int16 *)v8;
        LODWORD(v22) = *(unsigned __int8 *)(v8 + 2);
        v21 = ((unsigned int)v6 | ((_DWORD)v22 << 16)) >> 8;
        v24 = 12LL;
LABEL_156:
        v23 = 0LL;
        goto LABEL_157;
      case 44:
        if ( v9 <= 3 )
          goto LABEL_237;
        *a2 = v8 + 4;
        a2[1] = v9 - 4;
        LODWORD(v6) = *(_DWORD *)v8;
        v21 = *(_DWORD *)v8 >> 8;
        LODWORD(v22) = HIWORD(*(_DWORD *)v8);
        v24 = 12LL;
        goto LABEL_156;
      default:
        switch ( (__int16)v10 )
        {
          case 7937:
            goto LABEL_11;
          case 7938:
            goto LABEL_21;
          case 7968:
            if ( BYTE1(a3) == 8 )
            {
              if ( v9 > 7 )
                goto LABEL_57;
              *(_QWORD *)&v58 = 19LL;
              *((_QWORD *)&v58 + 1) = v8;
              *(_DWORD *)&v59[8] = v8 >> 8;
              *(_DWORD *)&v59[11] = HIDWORD(v8);
              *(_QWORD *)v59 = *(_QWORD *)((char *)&v58 + 1);
              v11 = *(_QWORD *)&v59[7];
            }
            else
            {
              if ( v9 > 3 )
              {
                *a2 = v8 + 4;
                a2[1] = v9 - 4;
                v6 = *(unsigned int *)v8;
                goto LABEL_177;
              }
              *(_DWORD *)v59 = 0;
              v59[6] = 0;
              *(_WORD *)&v59[4] = 0;
            }
            *(_DWORD *)&v64[3] = *(_DWORD *)&v59[3];
            *(_DWORD *)v64 = *(_DWORD *)v59;
            *(_BYTE *)(a1 + 8) = 19;
            LODWORD(v6) = *(_DWORD *)v64;
            v50 = *(_DWORD *)&v64[3];
            break;
          case 7969:
            goto LABEL_18;
          default:
            goto LABEL_171;
        }
        goto LABEL_219;
    }
  }
}
// 11796: variable 'v4' is possibly undefined

//----- (0000000000011FA0) ----------------------------------------------------
void __fastcall gimli::read::unit::skip_attributes(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  __int16 v5; // r10
  __int64 v6; // r8
  char *v7; // r13
  unsigned __int64 v8; // r15
  unsigned int v9; // r9d
  unsigned __int64 v10; // r11
  char *v11; // r12
  int v12; // ebx
  unsigned __int8 v13; // bp
  bool v14; // cf
  unsigned __int64 v15; // r12
  __int64 v16; // rbp
  int v17; // ecx
  char v18; // bl
  char *v19; // r11
  char *v21; // r11
  unsigned __int16 v22; // bp
  unsigned __int64 v23; // r15
  unsigned __int64 v24; // r12
  unsigned __int64 v25; // rbx
  unsigned __int16 v26; // r10
  unsigned __int64 v27; // r15
  __int64 v28; // r11
  char *v29; // rax
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // rcx
  char v32; // al
  char v33; // al
  __int16 v34; // cx
  __int16 v35; // [rsp+0h] [rbp-4Ch]
  char *v36; // [rsp+4h] [rbp-48h]
  char *v37; // [rsp+Ch] [rbp-40h]
  __int64 v38; // [rsp+14h] [rbp-38h]

  if ( !a5 )
  {
LABEL_85:
    *(_BYTE *)a1 = 75;
    return;
  }
  v6 = a4 + 16 * a5;
  v7 = *(char **)a2;
  v8 = *(_QWORD *)(a2 + 8);
  v9 = a3 >> 8;
  if ( (a3 & 0xFFFF0000) == 0x20000 )
    LOBYTE(v9) = a3;
  v10 = 0LL;
  v35 = v5;
  v11 = *(char **)a2;
  while ( 2 )
  {
    v12 = *(unsigned __int16 *)(a4 + 10);
    switch ( *(_WORD *)(a4 + 10) )
    {
      case 1:
        v13 = a3;
        goto LABEL_28;
      case 2:
      case 3:
      case 4:
      case 8:
      case 9:
      case 0xA:
      case 0xD:
      case 0xF:
      case 0x15:
      case 0x16:
      case 0x18:
      case 0x1A:
      case 0x1B:
      case 0x22:
      case 0x23:
        goto LABEL_14;
      case 5:
      case 0x12:
      case 0x26:
      case 0x2A:
        v13 = 2;
        goto LABEL_28;
      case 6:
      case 0x13:
      case 0x1C:
      case 0x28:
      case 0x2C:
        v13 = 4;
        goto LABEL_28;
      case 7:
      case 0x14:
      case 0x20:
      case 0x24:
        v13 = 8;
        goto LABEL_28;
      case 0xB:
      case 0xC:
      case 0x11:
      case 0x25:
      case 0x29:
        v13 = 1;
        goto LABEL_28;
      case 0xE:
      case 0x17:
      case 0x1D:
      case 0x1F:
        goto LABEL_11;
      case 0x10:
        v13 = v9;
        goto LABEL_28;
      case 0x19:
      case 0x21:
        v13 = 0;
        goto LABEL_28;
      case 0x1E:
        v13 = 16;
        goto LABEL_28;
      case 0x27:
      case 0x2B:
        v13 = 3;
        goto LABEL_28;
      default:
        if ( (unsigned int)(v12 - 7968) < 2 )
        {
LABEL_11:
          v13 = BYTE1(a3);
LABEL_28:
          v10 += v13;
          v16 = (__int64)v7;
LABEL_29:
          a4 += 16LL;
          v7 = (char *)v16;
          if ( a4 == v6 )
          {
            if ( v10 )
            {
              v29 = *(char **)a2;
              v30 = *(_QWORD *)(a2 + 8);
              v14 = v30 < v10;
              v31 = v30 - v10;
              if ( v14 )
              {
                *(_BYTE *)a1 = 19;
                *(_QWORD *)(a1 + 8) = v29;
                return;
              }
              *(_QWORD *)a2 = &v29[v10];
              *(_QWORD *)(a2 + 8) = v31;
            }
            goto LABEL_85;
          }
          continue;
        }
LABEL_14:
        if ( v10 )
        {
          v14 = v8 < v10;
          v8 -= v10;
          if ( v14 )
          {
            *(_BYTE *)a1 = 19;
            goto LABEL_90;
          }
          v11 += v10;
          *(_QWORD *)a2 = v11;
          *(_QWORD *)(a2 + 8) = v8;
        }
        v7 = v11;
        switch ( v12 )
        {
          case 3:
LABEL_62:
            if ( v8 <= 1 )
            {
              *(_BYTE *)a1 = 19;
              *(_WORD *)(a1 + 1) = 0;
              *(_BYTE *)(a1 + 3) = 0;
              goto LABEL_99;
            }
            v8 -= 2LL;
            v16 = (__int64)(v7 + 2);
            *(_QWORD *)a2 = v7 + 2;
            *(_QWORD *)(a2 + 8) = v8;
            v10 = *(unsigned __int16 *)v7;
            v11 = v7 + 2;
            goto LABEL_29;
          case 4:
LABEL_55:
            if ( v8 <= 3 )
            {
              *(_BYTE *)a1 = 19;
              *(_DWORD *)(a1 + 1) = 0;
              *(_BYTE *)(a1 + 7) = 0;
              *(_WORD *)(a1 + 5) = 0;
              goto LABEL_90;
            }
            v8 -= 4LL;
            v16 = (__int64)(v7 + 4);
            *(_QWORD *)a2 = v7 + 4;
            *(_QWORD *)(a2 + 8) = v8;
            v10 = *(unsigned int *)v7;
            v11 = v7 + 4;
            goto LABEL_29;
          case 5:
          case 6:
          case 7:
          case 11:
          case 12:
          case 14:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 23:
          case 25:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 33:
            goto LABEL_93;
          case 8:
LABEL_57:
            if ( !v8 )
              goto LABEL_91;
            v28 = 0LL;
            while ( v7[v28] )
            {
              if ( v8 == ++v28 )
              {
LABEL_91:
                *(_QWORD *)a1 = (unsigned __int64)v37 & 0xFFFFFFFFFFFFFF00LL | 0x13;
                goto LABEL_90;
              }
            }
            v16 = (__int64)&v7[v28 + 1];
            v8 += ~v28;
            *(_QWORD *)a2 = v16;
            *(_QWORD *)(a2 + 8) = v8;
            v11 = (char *)v16;
            v37 = v7;
            v10 = 0LL;
            goto LABEL_29;
          case 9:
          case 24:
LABEL_18:
            if ( !v8 )
              goto LABEL_87;
            v38 = a4;
            v15 = 1 - v8;
            v16 = (__int64)(v7 + 1);
            v10 = 0LL;
            v17 = 0;
            while ( 1 )
            {
              v18 = *(_BYTE *)(v16 - 1);
              if ( v17 == 63 && (unsigned __int8)v18 >= 2u )
              {
                *(_QWORD *)a2 = v16;
                *(_QWORD *)(a2 + 8) = -(__int64)v15;
                v32 = 6;
                v7 = v36;
                goto LABEL_88;
              }
              v10 |= (unsigned __int64)(*(_BYTE *)(v16 - 1) & 0x7F) << v17;
              if ( v18 >= 0 )
                break;
              v17 += 7;
              ++v15;
              ++v16;
              if ( v15 == 1 )
              {
                v7 += v8;
                *(_QWORD *)a2 = v7;
                *(_QWORD *)(a2 + 8) = 0LL;
LABEL_87:
                v32 = 19;
LABEL_88:
                *(_BYTE *)a1 = v32;
                *(_BYTE *)(a1 + 1) = 0;
LABEL_89:
                *(_WORD *)(a1 + 6) = 0;
                *(_DWORD *)(a1 + 2) = 0;
                goto LABEL_90;
              }
            }
            *(_QWORD *)a2 = v16;
            v24 = -(__int64)v15;
            *(_QWORD *)(a2 + 8) = v24;
            v8 = v24;
            v11 = (char *)v16;
            v36 = (char *)v10;
            a4 = v38;
            goto LABEL_29;
          case 10:
LABEL_64:
            if ( !v8 )
              goto LABEL_83;
            --v8;
            v16 = (__int64)(v7 + 1);
            *(_QWORD *)a2 = v7 + 1;
            *(_QWORD *)(a2 + 8) = v8;
            v10 = (unsigned __int8)*v7;
            v11 = v7 + 1;
            goto LABEL_29;
          case 13:
          case 15:
          case 21:
          case 26:
          case 27:
          case 34:
          case 35:
            goto LABEL_32;
          case 22:
            if ( !v8 )
            {
LABEL_94:
              v33 = 19;
              v34 = 0;
              goto LABEL_98;
            }
            v21 = v11 + 1;
            *(_QWORD *)a2 = v11 + 1;
            *(_QWORD *)(a2 + 8) = v8 - 1;
            v22 = *v11 & 0x7F;
            if ( *v11 < 0 )
            {
              if ( v8 != 1 )
              {
                v21 = v11 + 2;
                *(_QWORD *)a2 = v11 + 2;
                *(_QWORD *)(a2 + 8) = v8 - 2;
                v22 |= (v11[1] & 0x7F) << 7;
                if ( v11[1] >= 0 )
                {
                  v23 = v8 - 2;
                  goto LABEL_46;
                }
                if ( v8 != 2 )
                {
                  v23 = v8 - 3;
                  v21 = v11 + 3;
                  *(_QWORD *)a2 = v11 + 3;
                  *(_QWORD *)(a2 + 8) = v23;
                  if ( (unsigned __int8)v11[2] > 3u )
                  {
                    v33 = 6;
                    v34 = v35;
                    goto LABEL_98;
                  }
                  v22 |= (unsigned __int8)v11[2] << 14;
                  goto LABEL_46;
                }
              }
LABEL_97:
              v33 = 19;
              v34 = 0;
              v7 = v21;
              goto LABEL_98;
            }
            v23 = v8 - 1;
LABEL_46:
            v25 = v23;
            v26 = v22;
            while ( 2 )
            {
              v7 = v21;
              v8 = v25;
              v35 = v26;
              switch ( v26 )
              {
                case 1u:
                  v13 = a3;
                  goto LABEL_79;
                case 2u:
                  goto LABEL_93;
                case 3u:
                  goto LABEL_62;
                case 4u:
                  goto LABEL_55;
                case 5u:
                case 0x12u:
                case 0x26u:
                case 0x2Au:
                  v13 = 2;
                  goto LABEL_79;
                case 6u:
                case 0x13u:
                case 0x1Cu:
                case 0x28u:
                case 0x2Cu:
                  v13 = 4;
                  goto LABEL_79;
                case 7u:
                case 0x14u:
                case 0x20u:
                case 0x24u:
                  v13 = 8;
                  goto LABEL_79;
                case 8u:
                  goto LABEL_57;
                case 9u:
                case 0x18u:
                  goto LABEL_18;
                case 0xAu:
                  goto LABEL_64;
                case 0xBu:
                case 0xCu:
                case 0x11u:
                case 0x25u:
                case 0x29u:
                  v13 = 1;
                  goto LABEL_79;
                case 0xDu:
                case 0xFu:
                case 0x15u:
                case 0x1Au:
                case 0x1Bu:
                case 0x22u:
                case 0x23u:
                  goto LABEL_32;
                case 0xEu:
                case 0x17u:
                case 0x1Du:
                case 0x1Fu:
                  goto LABEL_71;
                case 0x10u:
                  v13 = v9;
                  goto LABEL_79;
                case 0x16u:
                  if ( !v25 )
                    goto LABEL_94;
                  --v25;
                  ++v21;
                  *(_QWORD *)a2 = v7 + 1;
                  *(_QWORD *)(a2 + 8) = v8 - 1;
                  v26 = *v7 & 0x7F;
                  if ( *v7 >= 0 )
                    continue;
                  if ( v8 == 1 )
                    goto LABEL_97;
                  v25 = v8 - 2;
                  v21 = v7 + 2;
                  *(_QWORD *)a2 = v7 + 2;
                  *(_QWORD *)(a2 + 8) = v8 - 2;
                  v26 |= (v7[1] & 0x7F) << 7;
                  if ( v7[1] >= 0 )
                    continue;
                  if ( v8 == 2 )
                    goto LABEL_97;
                  v27 = v8 - 3;
                  v21 = v7 + 3;
                  *(_QWORD *)a2 = v7 + 3;
                  *(_QWORD *)(a2 + 8) = v27;
                  if ( (unsigned __int8)v7[2] <= 3u )
                  {
                    v26 |= (unsigned __int8)v7[2] << 14;
                    v25 = v27;
                    continue;
                  }
                  v33 = 6;
                  v34 = 22;
LABEL_98:
                  *(_BYTE *)a1 = v33;
                  *(_BYTE *)(a1 + 1) = 0;
                  *(_WORD *)(a1 + 2) = v34;
LABEL_99:
                  *(_DWORD *)(a1 + 4) = 0;
LABEL_90:
                  *(_QWORD *)(a1 + 8) = v7;
                  return;
                case 0x19u:
                case 0x21u:
                  v13 = 0;
                  goto LABEL_79;
                case 0x1Eu:
                  v13 = 16;
                  goto LABEL_79;
                case 0x27u:
                case 0x2Bu:
                  v13 = 3;
                  goto LABEL_79;
                default:
                  if ( (unsigned int)v26 - 7937 < 2 )
                    goto LABEL_32;
                  if ( (unsigned int)v26 - 7968 >= 2 )
                    goto LABEL_93;
LABEL_71:
                  v13 = BYTE1(a3);
LABEL_79:
                  v11 = v21;
                  v10 = 0LL;
                  goto LABEL_28;
              }
            }
          default:
            if ( (unsigned int)(v12 - 7937) >= 2 )
            {
LABEL_93:
              *(_BYTE *)a1 = 12;
              return;
            }
LABEL_32:
            v19 = v7;
            do
            {
              v14 = v8-- == 0;
              if ( v14 )
              {
LABEL_83:
                *(_WORD *)a1 = 19;
                goto LABEL_89;
              }
              v16 = (__int64)(v19 + 1);
              *(_QWORD *)a2 = v19 + 1;
              *(_QWORD *)(a2 + 8) = v8;
              ++v7;
            }
            while ( *v19++ < 0 );
            v11 = (char *)v16;
            v10 = 0LL;
            goto LABEL_29;
        }
    }
  }
}
// 11FE8: variable 'v5' is possibly undefined
// 12438: variable 'v36' is possibly undefined
// 12471: variable 'v37' is possibly undefined

//----- (00000000000124E0) ----------------------------------------------------
__int64 __fastcall gimli::read::unit::parse_type_offset(__int64 a1, unsigned __int64 *a2, char a3)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rcx
  __int64 result; // rax
  unsigned int *v6; // rax
  unsigned __int64 v7; // rcx
  _BYTE v8[15]; // [rsp+0h] [rbp-20h]
  __int128 v9; // [rsp+10h] [rbp-10h]

  if ( a3 == 8 )
  {
    v3 = *a2;
    v4 = a2[1];
    if ( v4 > 7 )
    {
      *a2 = v3 + 8;
      a2[1] = v4 - 8;
      result = *(_QWORD *)v3;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 75;
      return result;
    }
    *(_QWORD *)&v9 = 19LL;
    *((_QWORD *)&v9 + 1) = *a2;
    *(_DWORD *)&v8[8] = v3 >> 8;
    *(_DWORD *)&v8[11] = HIDWORD(*a2);
    *(_QWORD *)v8 = *(_QWORD *)((char *)&v9 + 1);
  }
  else
  {
    v6 = (unsigned int *)*a2;
    v7 = a2[1];
    if ( v7 > 3 )
    {
      *a2 = (unsigned __int64)(v6 + 1);
      a2[1] = v7 - 4;
      result = *v6;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 75;
      return result;
    }
    *(_DWORD *)v8 = 0;
    v8[6] = 0;
    *(_WORD *)&v8[4] = 0;
    *(_QWORD *)&v8[7] = *a2;
  }
  *(_BYTE *)a1 = 19;
  result = *(_QWORD *)v8;
  *(_QWORD *)(a1 + 1) = *(_QWORD *)v8;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)&v8[7];
  return result;
}

//----- (0000000000012590) ----------------------------------------------------
char __fastcall gimli::read::unit::Attribute<R>::value(_QWORD *a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // eax
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rdx
  _QWORD *v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rdx
  char v10; // dl
  char v11; // dl
  char v12; // dl
  char v13; // dl
  char v14; // dl
  char v15; // dl
  __int16 v16; // dx
  char v17; // dl
  char v18; // dl
  char v19; // dl
  char v20; // dl
  __int64 v21; // rdx

  v3 = *(unsigned __int16 *)(a2 + 24);
  if ( v3 > 0x2130 )
  {
    switch ( v3 )
    {
      case 0x2131u:
        v4 = gimli::read::unit::AttributeValue<R,Offset>::udata_value((_QWORD *)a2);
        if ( v4 == 1 )
        {
          a1[1] = v21;
          *a1 = 45LL;
          return v4;
        }
        break;
      case 0x2132u:
LABEL_27:
        if ( *(_DWORD *)a2 == 10 )
        {
          v4 = *(_QWORD *)(a2 + 8);
          a1[1] = v4;
          *a1 = 23LL;
          return v4;
        }
        break;
      case 0x2133u:
LABEL_15:
        if ( *(_DWORD *)a2 == 10 )
        {
          v4 = *(_QWORD *)(a2 + 8);
          a1[1] = v4;
          *a1 = 11LL;
          return v4;
        }
        break;
    }
LABEL_77:
    LOBYTE(v4) = <gimli::read::unit::AttributeValue<R,Offset> as core::clone::Clone>::clone(a1, (__int64 *)a2);
    return v4;
  }
  switch ( *(_WORD *)(a2 + 24) )
  {
    case 2:
    case 0x19:
    case 0x2A:
    case 0x40:
    case 0x46:
    case 0x48:
    case 0x4A:
    case 0x4D:
      v4 = *(_QWORD *)a2;
      if ( *(_QWORD *)a2 == 1LL || (_DWORD)v4 == 8 )
        goto LABEL_70;
      if ( (_DWORD)v4 == 10 )
        goto LABEL_9;
      goto LABEL_77;
    case 9:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v14;
      *a1 = 43LL;
      return v4;
    case 0xB:
    case 0xC:
    case 0xD:
      v4 = *(_QWORD *)a2 - 1LL;
      switch ( *(_QWORD *)a2 )
      {
        case 1LL:
        case 8LL:
          goto LABEL_70;
        case 2LL:
          v4 = *(unsigned __int8 *)(a2 + 8);
          break;
        case 3LL:
          v4 = *(unsigned __int16 *)(a2 + 8);
          break;
        case 4LL:
          v4 = *(unsigned int *)(a2 + 8);
          break;
        case 5LL:
        case 7LL:
          v4 = *(_QWORD *)(a2 + 8);
          break;
        case 6LL:
          v4 = *(_QWORD *)(a2 + 8);
          if ( v4 < 0 )
            goto LABEL_77;
          break;
        default:
          goto LABEL_77;
      }
      a1[1] = v4;
      goto LABEL_76;
    case 0x10:
      if ( *(_DWORD *)a2 != 10 )
        goto LABEL_77;
      v4 = *(_QWORD *)(a2 + 8);
      a1[1] = v4;
      *a1 = 16LL;
      return v4;
    case 0x12:
    case 0x39:
    case 0x3B:
    case 0x57:
    case 0x59:
      v4 = gimli::read::unit::AttributeValue<R,Offset>::udata_value((_QWORD *)a2);
      if ( v4 != 1 )
        goto LABEL_77;
      a1[1] = v5;
LABEL_76:
      *a1 = 7LL;
      return v4;
    case 0x13:
      LOWORD(v4) = gimli::read::unit::AttributeValue<R,Offset>::u16_value((_QWORD *)a2, a2, a3);
      if ( (_WORD)v4 != 1 )
        goto LABEL_77;
      *((_WORD *)a1 + 4) = v16;
      *a1 = 38LL;
      return v4;
    case 0x17:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v17;
      *a1 = 36LL;
      return v4;
    case 0x20:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v18;
      *a1 = 42LL;
      return v4;
    case 0x22:
    case 0x2F:
    case 0x37:
    case 0x4E:
    case 0x4F:
    case 0x50:
    case 0x71:
    case 0x7E:
    case 0x7F:
    case 0x83:
    case 0x84:
    case 0x85:
    case 0x86:
      v4 = *(_QWORD *)a2;
      if ( *(_QWORD *)a2 != 1LL )
        goto LABEL_4;
      goto LABEL_70;
    case 0x2C:
    case 0x55:
      if ( *(_DWORD *)a2 != 10 )
        goto LABEL_77;
      v4 = *(_QWORD *)(a2 + 8);
      a1[1] = v4;
      *a1 = 22LL;
      return v4;
    case 0x2E:
    case 0x51:
      v7 = a1;
      v4 = gimli::read::unit::AttributeValue<R,Offset>::udata_value((_QWORD *)a2);
      if ( v4 == 1 )
        goto LABEL_32;
      v4 = *(_QWORD *)a2;
      if ( *(_QWORD *)a2 != 8LL && (_DWORD)v4 != 1 )
        goto LABEL_77;
      goto LABEL_70;
    case 0x32:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v11;
      *a1 = 35LL;
      return v4;
    case 0x33:
      v4 = gimli::read::unit::AttributeValue<R,Offset>::udata_value((_QWORD *)a2);
      if ( v4 != 1 )
        goto LABEL_77;
      a1[1] = v9;
      *a1 = 39LL;
      return v4;
    case 0x36:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v12;
      *a1 = 41LL;
      return v4;
    case 0x38:
      v7 = a1;
      v4 = gimli::read::unit::AttributeValue<R,Offset>::udata_value((_QWORD *)a2);
      if ( v4 == 1 )
      {
LABEL_32:
        v7[1] = v8;
        *v7 = 7LL;
      }
      else
      {
        v4 = *(_QWORD *)a2;
        if ( *(_QWORD *)a2 != 1LL )
        {
          if ( (_DWORD)v4 == 10 )
          {
LABEL_9:
            v4 = *(_QWORD *)(a2 + 8);
            a1[1] = v4;
            *a1 = 17LL;
            return v4;
          }
LABEL_4:
          if ( (_DWORD)v4 != 8 )
            goto LABEL_77;
        }
LABEL_70:
        *(_OWORD *)(a1 + 1) = *(_OWORD *)(a2 + 8);
        *a1 = 8LL;
      }
      break;
    case 0x3A:
    case 0x58:
      v4 = gimli::read::unit::AttributeValue<R,Offset>::udata_value((_QWORD *)a2);
      if ( v4 != 1 )
        goto LABEL_77;
      a1[1] = v6;
      *a1 = 44LL;
      return v4;
    case 0x3E:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v15;
      *a1 = 32LL;
      return v4;
    case 0x42:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v19;
      *a1 = 40LL;
      return v4;
    case 0x43:
      if ( *(_DWORD *)a2 != 10 )
        goto LABEL_77;
      v4 = *(_QWORD *)(a2 + 8);
      a1[1] = v4;
      *a1 = 20LL;
      return v4;
    case 0x4C:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v13;
      *a1 = 37LL;
      return v4;
    case 0x5E:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v20;
      *a1 = 33LL;
      return v4;
    case 0x65:
      LOBYTE(v4) = gimli::read::unit::AttributeValue<R,Offset>::u8_value((_QWORD *)a2);
      if ( (v4 & 1) == 0 )
        goto LABEL_77;
      *((_BYTE *)a1 + 8) = v10;
      *a1 = 34LL;
      return v4;
    case 0x72:
      if ( *(_DWORD *)a2 != 10 )
        goto LABEL_77;
      v4 = *(_QWORD *)(a2 + 8);
      a1[1] = v4;
      *a1 = 28LL;
      return v4;
    case 0x73:
      goto LABEL_15;
    case 0x74:
      goto LABEL_27;
    case 0x79:
      if ( *(_DWORD *)a2 != 10 )
        goto LABEL_77;
      v4 = *(_QWORD *)(a2 + 8);
      a1[1] = v4;
      *a1 = 21LL;
      return v4;
    case 0x8C:
      if ( *(_DWORD *)a2 != 10 )
        goto LABEL_77;
      v4 = *(_QWORD *)(a2 + 8);
      a1[1] = v4;
      *a1 = 18LL;
      return v4;
    default:
      goto LABEL_77;
  }
  return v4;
}
// 12630: variable 'v5' is possibly undefined
// 126C1: variable 'v6' is possibly undefined
// 1276B: variable 'v9' is possibly undefined
// 12796: variable 'v8' is possibly undefined
// 127E5: variable 'v10' is possibly undefined
// 12833: variable 'v11' is possibly undefined
// 12861: variable 'v12' is possibly undefined
// 1288F: variable 'v13' is possibly undefined
// 128DD: variable 'v14' is possibly undefined
// 1290B: variable 'v15' is possibly undefined
// 1295B: variable 'v16' is possibly undefined
// 129AA: variable 'v17' is possibly undefined
// 129D8: variable 'v18' is possibly undefined
// 12A06: variable 'v19' is possibly undefined
// 12A34: variable 'v20' is possibly undefined
// 12A60: variable 'v21' is possibly undefined

//----- (0000000000012AE0) ----------------------------------------------------
void __fastcall gimli::read::unit::EntriesCursor<R>::next_entry(__int64 *a1, __int64 a2)
{
  __int64 v2; // r15
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  bool v5; // cf
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r8
  __int64 v11; // r11
  __int64 v12; // r9
  __int64 v13; // rdx
  unsigned __int64 v14; // r10
  int v15; // ecx
  char v16; // bp
  __int64 v17; // rcx
  _QWORD *v18; // r12
  __int64 v19; // r13
  _QWORD *v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rbx
  __int64 v23; // r14
  __int64 v24; // rax
  __int64 v25; // r9
  __int64 v26; // r11
  __int64 v27; // rbx
  __int64 v28; // r14
  __int64 v29; // r15
  char v30; // r12
  __int64 v31; // [rsp+8h] [rbp-90h] BYREF
  __int64 v32; // [rsp+10h] [rbp-88h]
  _QWORD *v33; // [rsp+18h] [rbp-80h]
  __int64 v34; // [rsp+20h] [rbp-78h]
  _QWORD *v35; // [rsp+28h] [rbp-70h]
  __int128 v36; // [rsp+30h] [rbp-68h] BYREF
  int v37; // [rsp+48h] [rbp-50h] BYREF
  __int64 v38; // [rsp+50h] [rbp-48h]
  __int64 v39; // [rsp+58h] [rbp-40h]

  v2 = *(_QWORD *)(a2 + 32);
  if ( v2 )
  {
    if ( *(_QWORD *)(a2 + 72) )
    {
      v3 = *(_QWORD *)(a2 + 40);
      v4 = *(_QWORD *)(a2 + 80);
      v5 = v3 < v4;
      v6 = v3 - v4;
      if ( v5 )
      {
        v7 = 19LL;
LABEL_29:
        *a1 = v7;
        a1[1] = v2;
        return;
      }
      *(_QWORD *)a2 = v4 + v2;
      *(_QWORD *)(a2 + 8) = v6;
      if ( !v6 )
        goto LABEL_22;
    }
    else
    {
      v18 = (_QWORD *)(a2 + 32);
      v19 = *(_QWORD *)(a2 + 40);
      v20 = <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref(*(_QWORD **)(a2 + 48));
      v31 = v2;
      v32 = v19;
      v33 = v20;
      v34 = v21;
      v35 = (_QWORD *)(a2 + 32);
      if ( v21 )
      {
        v22 = (__int64)(v20 + 2);
        v23 = v21 - 1;
        while ( 1 )
        {
          v36 = *(_OWORD *)(v22 - 16);
          gimli::read::unit::parse_attribute(
            (__int64)&v37,
            (unsigned __int64 *)&v31,
            *(_DWORD *)(v35[3] + 72LL),
            (__int64)&v36);
          if ( v37 == 46 )
            break;
          v33 = (_QWORD *)v22;
          v34 = v23;
          v22 += 16LL;
          v5 = v23-- != 0;
          if ( !v5 )
          {
            v2 = v31;
            v18 = v35;
            goto LABEL_17;
          }
        }
        v7 = v38;
        v2 = v39;
        goto LABEL_29;
      }
LABEL_17:
      if ( !v18[5] )
      {
        v24 = v2 - *v18;
        v18[5] = 1LL;
        v18[6] = v24;
      }
      v6 = v32;
      *(_QWORD *)a2 = v2;
      *(_QWORD *)(a2 + 8) = v6;
      if ( !v6 )
      {
LABEL_22:
        *(_QWORD *)(a2 + 32) = 0LL;
        *(_QWORD *)(a2 + 88) = 0LL;
        *(_WORD *)a1 = 75;
        return;
      }
    }
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 8);
    if ( !v6 )
      goto LABEL_22;
  }
  v8 = *(_QWORD *)(a2 + 16);
  v9 = *(_QWORD **)(a2 + 24);
  v10 = *(_QWORD *)a2
      + *(_QWORD *)(v8 + 56)
      - *(_QWORD *)(v8 + 48)
      + 8LL * (*(_BYTE *)(v8 + 73) == 8)
      - *(_QWORD *)(v8 + 40)
      + 4;
  v11 = *(_QWORD *)a2 + v6;
  v12 = 1 - v6;
  v13 = *(_QWORD *)a2 + 1LL;
  v14 = 0LL;
  v15 = 0;
  while ( 1 )
  {
    v16 = *(_BYTE *)(v13 - 1);
    if ( v15 == 63 && (unsigned __int8)v16 >= 2u )
    {
      v17 = 6LL;
      goto LABEL_24;
    }
    v14 |= (unsigned __int64)(v16 & 0x7F) << v15;
    if ( v16 >= 0 )
      break;
    v15 += 7;
    ++v12;
    ++v13;
    if ( v12 == 1 )
    {
      v17 = 19LL;
LABEL_24:
      *(_QWORD *)a2 = aRustc9b00956e5;
      *(_QWORD *)(a2 + 8) = 0LL;
      *(_QWORD *)(a2 + 88) = 0LL;
      *(_QWORD *)(a2 + 32) = 0LL;
      *a1 = v17;
      a1[1] = v11;
      return;
    }
  }
  *(_QWORD *)a2 = v13;
  v25 = -v12;
  *(_QWORD *)(a2 + 8) = v25;
  if ( v14 )
  {
    if ( v14 - 1 >= v9[2] )
    {
      v11 = v9[3];
      v17 = 18LL;
      if ( v11 )
      {
        v27 = v9[4];
        while ( 1 )
        {
          v28 = -1LL;
          v29 = 0LL;
          do
          {
            if ( !(v29 + 112LL * *(unsigned __int16 *)(v11 + 1330)) )
            {
              v28 = *(unsigned __int16 *)(v11 + 1330);
              goto LABEL_41;
            }
            v30 = *(_QWORD *)(v11 + 8 * v28 + 1248) != v14;
            if ( *(_QWORD *)(v11 + 8 * v28 + 1248) > v14 )
              v30 = -1;
            ++v28;
            v29 -= 112LL;
          }
          while ( v30 == 1 );
          if ( !v30 )
          {
            v26 = v11 - v29 - 112;
            goto LABEL_43;
          }
LABEL_41:
          v5 = v27-- == 0;
          if ( v5 )
            break;
          v11 = *(_QWORD *)(v11 + 8 * v28 + 1336);
        }
      }
      goto LABEL_24;
    }
    v26 = v9[1] + 112 * (v14 - 1);
LABEL_43:
    *(_QWORD *)(a2 + 88) = *(_BYTE *)(v26 + 106) == 1;
    *(_QWORD *)(a2 + 32) = v13;
    *(_QWORD *)(a2 + 40) = v25;
    *(_QWORD *)(a2 + 48) = v26;
    *(_QWORD *)(a2 + 56) = v8;
    *(_QWORD *)(a2 + 64) = v10;
    *(_QWORD *)(a2 + 72) = 0LL;
  }
  else
  {
    *(_QWORD *)(a2 + 88) = -1LL;
    *(_QWORD *)(a2 + 32) = 0LL;
  }
  *(_WORD *)a1 = 331;
}
// 12BDE: variable 'v21' is possibly undefined
// 12AE0: using guessed type __int128 var_68;

//----- (0000000000012E10) ----------------------------------------------------
__int64 __fastcall gimli::read::unit::AttributeValue<R,Offset>::udata_value(_QWORD *a1)
{
  __int64 result; // rax

  switch ( *a1 )
  {
    case 2LL:
      result = 1LL;
      break;
    case 3LL:
      result = 1LL;
      break;
    case 4LL:
      result = 1LL;
      break;
    case 5LL:
    case 7LL:
      result = 1LL;
      break;
    case 6LL:
      result = 1LL;
      if ( (__int64)a1[1] < 0 )
        goto LABEL_7;
      break;
    default:
LABEL_7:
      result = 0LL;
      break;
  }
  return result;
}

//----- (0000000000012E70) ----------------------------------------------------
bool __fastcall gimli::read::unit::AttributeValue<R,Offset>::u8_value(_QWORD *a1)
{
  __int64 v1; // rdx
  bool result; // al

  switch ( *a1 )
  {
    case 2LL:
      v1 = *((unsigned __int8 *)a1 + 8);
      goto LABEL_6;
    case 3LL:
      v1 = *((unsigned __int16 *)a1 + 4);
      goto LABEL_6;
    case 4LL:
      v1 = *((unsigned int *)a1 + 2);
      goto LABEL_6;
    case 5LL:
    case 7LL:
      v1 = a1[1];
      goto LABEL_6;
    case 6LL:
      v1 = a1[1];
      if ( v1 < 0 )
        goto LABEL_8;
LABEL_6:
      result = (unsigned __int64)v1 < 0x100;
      break;
    default:
LABEL_8:
      result = 0;
      break;
  }
  return result;
}

//----- (0000000000012ED0) ----------------------------------------------------
__int64 __fastcall gimli::read::unit::AttributeValue<R,Offset>::u16_value(_QWORD *a1, __int64 a2, __int64 a3)
{
  char v3; // al

  switch ( *a1 )
  {
    case 2LL:
      a3 = *((unsigned __int8 *)a1 + 8);
      v3 = 1;
      break;
    case 3LL:
      a3 = *((unsigned __int16 *)a1 + 4);
      v3 = 1;
      break;
    case 4LL:
      a3 = *((unsigned int *)a1 + 2);
      v3 = 1;
      break;
    case 5LL:
    case 7LL:
      a3 = a1[1];
      v3 = 1;
      break;
    case 6LL:
      a3 = a1[1];
      v3 = 1;
      if ( a3 < 0 )
        goto LABEL_7;
      break;
    default:
LABEL_7:
      v3 = 0;
      break;
  }
  return (unsigned __int8)v3 & ((unsigned __int64)a3 < 0x10000);
}

//----- (0000000000012F30) ----------------------------------------------------
void __fastcall gimli::read::unit::DebugInfoUnitHeadersIter<R>::next(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // r15
  unsigned __int64 v3; // r14
  unsigned __int8 v4; // r10
  unsigned int v5; // r13d
  int v6; // edx
  __int64 v7; // r9
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rcx
  __int64 v12; // rax
  unsigned __int64 v13; // rdx
  unsigned __int8 v14; // r11
  unsigned __int64 v15; // rbp
  bool v16; // cf
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rax
  unsigned __int8 v20; // r8
  unsigned __int64 v21; // rax
  __int64 v22; // rcx
  int v23; // edx
  char v24; // cl
  unsigned __int64 v25; // r9
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // r8
  __m128i v28; // xmm0
  unsigned __int64 *v29; // rax
  unsigned __int64 *v30; // rax
  unsigned __int64 v31; // rax
  unsigned __int8 v32; // [rsp+Dh] [rbp-11Bh]
  unsigned __int8 v33; // [rsp+Eh] [rbp-11Ah]
  char v34; // [rsp+Fh] [rbp-119h]
  __int128 v35; // [rsp+10h] [rbp-118h] BYREF
  int v36; // [rsp+24h] [rbp-104h]
  unsigned __int64 v37; // [rsp+28h] [rbp-100h] BYREF
  unsigned __int64 v38; // [rsp+30h] [rbp-F8h]
  __int64 v39; // [rsp+38h] [rbp-F0h]
  __int64 v40; // [rsp+40h] [rbp-E8h]
  __int64 v41; // [rsp+48h] [rbp-E0h]
  __int64 v42; // [rsp+50h] [rbp-D8h]
  __int64 v43; // [rsp+58h] [rbp-D0h]
  __m128i v44; // [rsp+60h] [rbp-C8h]
  __m128i v45; // [rsp+70h] [rbp-B8h]
  __m128i v46; // [rsp+80h] [rbp-A8h]
  __m128i v47; // [rsp+90h] [rbp-98h]
  __m128i v48; // [rsp+A0h] [rbp-88h]
  __m128i inserted; // [rsp+B0h] [rbp-78h]
  __m128i v50; // [rsp+C0h] [rbp-68h]
  __m128i v51; // [rsp+D0h] [rbp-58h]
  __m128i v52; // [rsp+E0h] [rbp-48h]

  v2 = *(_QWORD *)(a2 + 8);
  if ( !v2 )
  {
    *(_QWORD *)a1 = 2LL;
    return;
  }
  v3 = *(_QWORD *)a2;
  if ( v2 < 4 )
  {
    LODWORD(v35) = 0;
    BYTE6(v35) = 0;
    WORD2(v35) = 0;
    v11 = 19LL;
    v12 = v3 >> 8;
    goto LABEL_8;
  }
  v4 = *(_BYTE *)(a2 + 16);
  v5 = *(unsigned __int16 *)(a2 + 21);
  v6 = *(unsigned __int8 *)(a2 + 23);
  v7 = *(unsigned int *)(a2 + 17);
  v8 = v2 - 4;
  v9 = v3 + 4;
  v10 = *(unsigned int *)v3;
  if ( *(_DWORD *)v3 >> 4 == 0xFFFFFFF )
  {
    if ( (_DWORD)v10 != -1 )
    {
      v11 = 16LL;
      v12 = 0LL;
LABEL_8:
      v13 = v11 >> 8;
LABEL_21:
      *(_QWORD *)a2 = aRustc9b00956e5;
      *(_QWORD *)(a2 + 8) = 0LL;
      *(_BYTE *)(a1 + 8) = v11;
      *(_DWORD *)(a1 + 9) = v13;
      *(_BYTE *)(a1 + 15) = BYTE6(v13);
      *(_WORD *)(a1 + 13) = WORD2(v13);
      *(_QWORD *)(a1 + 16) = (v12 << 8) | (unsigned __int8)v3;
      *(_QWORD *)a1 = 3LL;
      return;
    }
    if ( v8 < 8 )
    {
      *(_QWORD *)&v35 = 19LL;
      *((_QWORD *)&v35 + 1) = v3 + 4;
      v3 = HIBYTE(*(_QWORD *)((char *)&v35 + 1));
      v11 = (*(_QWORD *)((char *)&v35 + 1) << 8) | 0x13LL;
      v12 = v9 >> 8;
      goto LABEL_8;
    }
    v15 = *(_QWORD *)(v3 + 4);
    v14 = 8;
    v9 = v3 + 12;
    v17 = v2 - 12 - v15;
    if ( v2 - 12 < v15 )
      goto LABEL_10;
  }
  else
  {
    v14 = 4;
    v15 = *(unsigned int *)v3;
    v16 = v8 < v10;
    v17 = v8 - v10;
    if ( v16 )
    {
LABEL_10:
      v12 = v9 >> 8;
      LOBYTE(v11) = 19;
      LOBYTE(v18) = 0;
      v14 = 0;
      LOBYTE(v7) = 0;
LABEL_19:
      v4 = 0;
      LOBYTE(v15) = 0;
      LOBYTE(v17) = 0;
      v20 = 0;
      LOBYTE(v3) = v9;
      goto LABEL_20;
    }
  }
  *(_QWORD *)a2 = v9 + v15;
  *(_QWORD *)(a2 + 8) = v17;
  if ( v15 <= 1 )
  {
    LOWORD(v35) = 0;
    BYTE2(v35) = 0;
    v14 = 0;
    LOBYTE(v7) = 0;
    LOBYTE(v18) = 0;
    v12 = v9 >> 8;
    LOBYTE(v11) = 19;
    goto LABEL_19;
  }
  v36 = v6;
  v18 = v15 - 2;
  v19 = v9 + 2;
  LODWORD(v3) = *(unsigned __int16 *)v9;
  v20 = v3 - 2;
  if ( (unsigned __int16)(v3 - 2) >= 3u )
  {
    if ( (_WORD)v3 != 5 )
    {
      v12 = BYTE1(v3);
      LOBYTE(v11) = 17;
      goto LABEL_20;
    }
    if ( v15 == 2 )
    {
      LOBYTE(v3) = v9 + 2;
      v12 = v19 >> 8;
      LOBYTE(v11) = 19;
      LOBYTE(v18) = 0;
      v14 = 0;
      LOBYTE(v7) = 0;
      v4 = 0;
      LOBYTE(v15) = 0;
      LOBYTE(v17) = 0;
      v20 = 0;
      goto LABEL_20;
    }
    if ( v15 != 3 )
    {
      v32 = v4;
      v40 = v7;
      v42 = a2;
      v41 = a1;
      v39 = *(unsigned __int8 *)(v9 + 2);
      v37 = v9 + 4;
      v38 = v15 - 4;
      v9 = *(unsigned __int8 *)(v9 + 3);
      v33 = v14;
      LODWORD(v43) = v14;
      gimli::read::unit::parse_type_offset((__int64)&v35, &v37, v14);
      LOBYTE(v11) = v35;
      if ( (_BYTE)v35 == 75 )
      {
        v12 = 0LL;
        LOBYTE(v18) = v39 - 1;
        a1 = v41;
        a2 = v42;
        v20 = BYTE8(v35);
        switch ( (int)v39 )
        {
          case 1:
            v39 = *((_QWORD *)&v35 + 1);
            goto LABEL_45;
          case 2:
            v31 = v37;
            if ( v38 <= 7 )
            {
              *(_QWORD *)&v35 = 19LL;
              *((_QWORD *)&v35 + 1) = v37;
              v44 = _mm_loadl_epi64((const __m128i *)((char *)&v35 + 1));
              v20 = v44.m128i_u8[6];
              LOBYTE(v17) = v44.m128i_i8[5];
              LOBYTE(v15) = v44.m128i_i8[4];
              v4 = v44.m128i_u8[3];
              LOBYTE(v7) = v44.m128i_i8[2];
              LOBYTE(v18) = v44.m128i_i8[0];
              v14 = v44.m128i_u8[1];
              LOBYTE(v3) = v44.m128i_i8[7];
              goto LABEL_61;
            }
            v34 = v9;
            v39 = *((_QWORD *)&v35 + 1);
            v37 += 8LL;
            v38 -= 8LL;
            v9 = *(_QWORD *)v31;
            gimli::read::unit::parse_type_offset((__int64)&v35, &v37, v43);
            LOBYTE(v11) = v35;
            if ( (_BYTE)v35 == 75 )
            {
              v43 = *((_QWORD *)&v35 + 1);
              v12 = 1LL;
              goto LABEL_55;
            }
            inserted = _mm_insert_epi16(
                         _mm_cvtsi32_si128(*(unsigned int *)((char *)&v35 + 1)),
                         *(unsigned __int16 *)((char *)&v35 + 5),
                         2);
            v20 = BYTE7(v35);
            LOBYTE(v17) = inserted.m128i_i8[5];
            LOBYTE(v15) = inserted.m128i_i8[4];
            v4 = inserted.m128i_u8[3];
            LOBYTE(v7) = inserted.m128i_i8[2];
            LOBYTE(v18) = inserted.m128i_i8[0];
            v14 = inserted.m128i_u8[1];
            goto LABEL_41;
          case 3:
            v39 = *((_QWORD *)&v35 + 1);
            v12 = 2LL;
LABEL_45:
            v24 = v9;
            v7 = v40;
            v4 = v32;
            v14 = v33;
            v23 = v36;
            goto LABEL_31;
          case 4:
            v30 = (unsigned __int64 *)v37;
            v14 = v33;
            if ( v38 > 7 )
            {
              v39 = *((_QWORD *)&v35 + 1);
              v37 += 8LL;
              v38 -= 8LL;
              v24 = v9;
              v9 = *v30;
              v12 = 3LL;
              goto LABEL_48;
            }
            *(_QWORD *)&v35 = 19LL;
            *((_QWORD *)&v35 + 1) = v37;
            v12 = v37 >> 8;
            v45 = _mm_loadl_epi64((const __m128i *)((char *)&v35 + 1));
            v20 = v45.m128i_u8[6];
            LOBYTE(v17) = v45.m128i_i8[5];
            LOBYTE(v15) = v45.m128i_i8[4];
            v4 = v45.m128i_u8[3];
            LOBYTE(v7) = v45.m128i_i8[2];
            LOBYTE(v18) = v45.m128i_i8[0];
            v14 = v45.m128i_u8[1];
            LOBYTE(v11) = 19;
            LOBYTE(v3) = v45.m128i_i8[7];
            goto LABEL_20;
          case 5:
            v29 = (unsigned __int64 *)v37;
            v14 = v33;
            if ( v38 <= 7 )
            {
              *(_QWORD *)&v35 = 19LL;
              *((_QWORD *)&v35 + 1) = v37;
              v12 = v37 >> 8;
              v46 = _mm_loadl_epi64((const __m128i *)((char *)&v35 + 1));
              v20 = v46.m128i_u8[6];
              LOBYTE(v17) = v46.m128i_i8[5];
              LOBYTE(v15) = v46.m128i_i8[4];
              v4 = v46.m128i_u8[3];
              LOBYTE(v7) = v46.m128i_i8[2];
              LOBYTE(v18) = v46.m128i_i8[0];
              v14 = v46.m128i_u8[1];
              LOBYTE(v11) = 19;
              LOBYTE(v3) = v46.m128i_i8[7];
              goto LABEL_20;
            }
            v39 = *((_QWORD *)&v35 + 1);
            v37 += 8LL;
            v38 -= 8LL;
            v24 = v9;
            v9 = *v29;
            v12 = 4LL;
LABEL_48:
            v7 = v40;
            v4 = v32;
            v23 = v36;
            goto LABEL_31;
          case 6:
            v31 = v37;
            if ( v38 <= 7 )
            {
              *(_QWORD *)&v35 = 19LL;
              *((_QWORD *)&v35 + 1) = v37;
              v47 = _mm_loadl_epi64((const __m128i *)((char *)&v35 + 1));
              v20 = v47.m128i_u8[6];
              LOBYTE(v17) = v47.m128i_i8[5];
              LOBYTE(v15) = v47.m128i_i8[4];
              v4 = v47.m128i_u8[3];
              LOBYTE(v7) = v47.m128i_i8[2];
              LOBYTE(v18) = v47.m128i_i8[0];
              v14 = v47.m128i_u8[1];
              LOBYTE(v3) = v47.m128i_i8[7];
LABEL_61:
              v12 = v31 >> 8;
              LOBYTE(v11) = 19;
              goto LABEL_20;
            }
            v34 = v9;
            v39 = *((_QWORD *)&v35 + 1);
            v37 += 8LL;
            v38 -= 8LL;
            v9 = *(_QWORD *)v31;
            gimli::read::unit::parse_type_offset((__int64)&v35, &v37, v43);
            LOBYTE(v11) = v35;
            if ( (_BYTE)v35 != 75 )
            {
              v50 = _mm_insert_epi16(
                      _mm_cvtsi32_si128(*(unsigned int *)((char *)&v35 + 1)),
                      *(unsigned __int16 *)((char *)&v35 + 5),
                      2);
              v20 = BYTE7(v35);
              LOBYTE(v17) = v50.m128i_i8[5];
              LOBYTE(v15) = v50.m128i_i8[4];
              v4 = v50.m128i_u8[3];
              LOBYTE(v7) = v50.m128i_i8[2];
              LOBYTE(v18) = v50.m128i_i8[0];
              v14 = v50.m128i_u8[1];
              goto LABEL_41;
            }
            v43 = *((_QWORD *)&v35 + 1);
            v12 = 5LL;
LABEL_55:
            a1 = v41;
            a2 = v42;
            v7 = v40;
            v4 = v32;
            v14 = v33;
            v23 = v36;
            v24 = v34;
            break;
          default:
            LOBYTE(v11) = 63;
            goto LABEL_20;
        }
        goto LABEL_31;
      }
      v51 = _mm_insert_epi16(
              _mm_cvtsi32_si128(*(unsigned int *)((char *)&v35 + 1)),
              *(unsigned __int16 *)((char *)&v35 + 5),
              2);
      v20 = BYTE7(v35);
      LOBYTE(v17) = v51.m128i_i8[5];
      LOBYTE(v15) = v51.m128i_i8[4];
      v4 = v51.m128i_u8[3];
      LOBYTE(v7) = v51.m128i_i8[2];
      LOBYTE(v18) = v51.m128i_i8[0];
      v14 = v51.m128i_u8[1];
LABEL_41:
      LOBYTE(v3) = BYTE8(v35);
      v12 = *((_QWORD *)&v35 + 1) >> 8;
      a1 = v41;
      a2 = v42;
LABEL_20:
      v13 = _mm_insert_epi16(
              _mm_insert_epi16(
                _mm_cvtsi32_si128((unsigned __int8)v18 | (v14 << 8) | ((unsigned __int8)v7 << 16) | (v4 << 24)),
                (unsigned __int8)v15 | ((unsigned __int8)v17 << 8),
                2),
              v20,
              3).m128i_u64[0];
      goto LABEL_21;
    }
    v9 += 3LL;
    goto LABEL_10;
  }
  if ( (unsigned int)v10 >= 0xFFFFFFF0 )
  {
    if ( v18 > 7 )
    {
      v21 = v15 - 10;
      v22 = *(_QWORD *)(v9 + 2);
      v9 += 10LL;
      goto LABEL_29;
    }
    *(_QWORD *)&v35 = 19LL;
    *((_QWORD *)&v35 + 1) = v9 + 2;
    v28 = _mm_loadl_epi64((const __m128i *)((char *)&v35 + 1));
    v52 = v28;
    LOBYTE(v3) = v28.m128i_i8[7];
LABEL_35:
    v12 = v19 >> 8;
    v48 = v28;
    LOBYTE(v11) = 19;
    v20 = v28.m128i_u8[6];
    LOBYTE(v17) = v28.m128i_i8[5];
    LOBYTE(v15) = v28.m128i_i8[4];
    v4 = v28.m128i_u8[3];
    LOBYTE(v7) = v28.m128i_i8[2];
    LOBYTE(v18) = v28.m128i_i8[0];
    v14 = v28.m128i_u8[1];
    goto LABEL_20;
  }
  if ( v18 <= 3 )
  {
    v28 = 0LL;
    LOBYTE(v3) = v9 + 2;
    goto LABEL_35;
  }
  v21 = v15 - 6;
  v22 = *(unsigned int *)(v9 + 2);
  v9 += 6LL;
LABEL_29:
  v23 = v36;
  if ( !v21 )
    goto LABEL_10;
  v39 = v22;
  v37 = v9 + 1;
  v38 = v21 - 1;
  v24 = *(_BYTE *)v9;
  v12 = 0LL;
LABEL_31:
  v25 = ((unsigned __int64)((v23 << 16) | v5) << 32) | v7;
  v26 = v37;
  v27 = v38;
  *(_QWORD *)(a2 + 16) += v2 - v17;
  *(_QWORD *)a1 = 0LL;
  *(_BYTE *)(a1 + 8) = v4;
  *(_BYTE *)(a1 + 15) = BYTE6(v25);
  *(_WORD *)(a1 + 13) = WORD2(v25);
  *(_DWORD *)(a1 + 9) = v25;
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(a1 + 24) = v9;
  *(_QWORD *)(a1 + 32) = v43;
  *(_QWORD *)(a1 + 40) = v26;
  *(_QWORD *)(a1 + 48) = v27;
  *(_QWORD *)(a1 + 56) = v15;
  *(_QWORD *)(a1 + 64) = v39;
  *(_BYTE *)(a1 + 72) = v24;
  *(_BYTE *)(a1 + 73) = v14;
  *(_WORD *)(a1 + 74) = _mm_cvtsi128_si32(_mm_cvtsi32_si128(v3));
}
// 130A2: variable 'v14' is possibly undefined
// 130AD: variable 'v7' is possibly undefined
// 130B7: variable 'v4' is possibly undefined

//----- (00000000000137C0) ----------------------------------------------------
void *__fastcall gimli::read::dwarf::Unit<R>::new(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // rbx
  unsigned __int64 v5; // rax
  __int64 v6; // rcx
  volatile signed __int64 *v7; // r12
  unsigned __int64 v8; // r13
  __int64 v9; // r14
  __int64 v10; // rdi
  __int64 v11; // r8
  char v12; // r11
  bool v13; // cf
  bool v14; // of
  __int64 v15; // rt0
  char v16; // r14
  unsigned __int64 v17; // r15
  unsigned __int64 v18; // r14
  unsigned __int64 v19; // r12
  __int128 v20; // xmm0
  unsigned __int64 v21; // r13
  unsigned int v22; // edi
  unsigned __int64 v23; // r15
  __int64 v24; // rax
  __int64 v25; // rbp
  int v26; // ecx
  char v27; // dl
  unsigned __int64 v28; // r14
  __int64 v29; // r10
  __int64 v30; // r10
  _BYTE *v31; // r13
  unsigned __int8 *v32; // r8
  unsigned __int8 *v33; // r13
  __int64 v34; // r10
  int v35; // r14d
  unsigned __int16 v36; // bx
  __int64 v37; // rsi
  unsigned __int8 *v38; // rcx
  unsigned __int16 v39; // ax
  unsigned __int16 v40; // cx
  __int64 v41; // r10
  unsigned __int8 *v42; // r11
  int v43; // edx
  unsigned __int64 v44; // rdi
  __int64 v45; // rbx
  int v46; // ecx
  __int64 v47; // rdi
  __int64 v48; // rbx
  __int64 v49; // r8
  __int64 v50; // r9
  unsigned __int64 v51; // r8
  __int16 v52; // ax
  unsigned __int16 v53; // dx
  __m128i si128; // xmm0
  __m128i v55; // xmm0
  unsigned __int16 v56; // ax
  __int64 v57; // r14
  unsigned __int64 v58; // rdi
  unsigned __int64 v59; // r15
  __int64 v60; // rax
  __int64 v61; // r14
  __int64 v62; // rbx
  __int64 v63; // r13
  __int64 v64; // rbx
  _QWORD *v65; // r12
  __int64 v66; // rsi
  __m128i *v67; // rax
  __m128i v68; // xmm0
  __m128i v69; // xmm1
  __m128i v70; // xmm2
  __int64 v71; // rax
  __int64 v72; // rcx
  __int64 i; // rax
  __int64 v74; // rax
  __int64 v75; // rsi
  __int64 v76; // rsi
  __int64 v77; // rax
  __int128 v78; // xmm0
  bool v79; // dl
  bool v80; // r8
  _BOOL8 v81; // r9
  __int64 v82; // rdi
  bool v83; // zf
  __int64 v84; // rdx
  unsigned __int8 v85; // al
  __int64 *v86; // rbx
  __int64 v87; // r14
  __int64 v88; // rdi
  void *result; // rax
  __m128i *v90; // r15
  __int64 v91; // rax
  __int64 v92; // rdx
  __int64 v93; // r14
  __int64 v94; // r12
  __int64 v95; // rdx
  __m128i v96; // xmm0
  __int64 v97; // r14
  unsigned __int64 v98; // r13
  __int64 v99; // r12
  __int64 v100; // rcx
  __int64 v101; // rbp
  unsigned __int64 v102; // rbx
  _QWORD *v103; // rax
  unsigned __int64 v104; // rdi
  unsigned __int64 v105; // rdx
  unsigned __int64 v106; // rdx
  __int64 v107; // rax
  unsigned __int64 v108; // rdx
  unsigned __int64 v109; // r13
  unsigned __int8 v110; // r8
  unsigned __int64 v111; // rsi
  unsigned __int64 v112; // rax
  unsigned __int64 v113; // rcx
  unsigned __int64 v114; // r14
  unsigned __int64 v115; // rax
  char *v116; // rdi
  unsigned __int64 v117; // rax
  unsigned __int64 v118; // rcx
  unsigned __int64 v119; // rcx
  __int64 v120; // rcx
  char v121; // r9
  unsigned __int64 v122; // rdi
  __int64 v123; // r10
  __int64 v124; // rax
  unsigned __int64 v125; // r8
  unsigned __int64 v126; // rsi
  __int32 v127; // r10d
  __int16 v128; // r8
  __int8 v129; // r9
  _QWORD *v130; // rcx
  unsigned __int64 v131; // rdx
  unsigned __int64 v132; // rax
  _BYTE *v133; // rcx
  unsigned __int64 v134; // rdx
  __int64 v135; // rax
  _BYTE *v136; // rax
  unsigned __int64 v137; // rcx
  char v138; // dl
  unsigned __int64 v139; // rsi
  __int64 v140; // rdx
  unsigned __int64 v141; // rax
  unsigned __int64 v142; // r14
  __int64 v143; // rcx
  __int64 v144; // rsi
  __int64 v145; // rcx
  __int64 v146; // rax
  __int64 v147; // rdx
  __int64 v148; // rcx
  __int64 v149; // rsi
  __m128i v150; // xmm0
  char v151; // r13
  __int64 v152; // rsi
  __int64 v153; // rbx
  __m128i v154; // xmm0
  unsigned __int8 v155; // [rsp+5h] [rbp-593h]
  unsigned __int8 v156; // [rsp+6h] [rbp-592h]
  char v157; // [rsp+7h] [rbp-591h]
  __int64 v159; // [rsp+8h] [rbp-590h]
  char v160; // [rsp+8h] [rbp-590h]
  char v161; // [rsp+8h] [rbp-590h]
  __int64 v162; // [rsp+10h] [rbp-588h]
  __int64 v163; // [rsp+10h] [rbp-588h]
  bool v164; // [rsp+1Ch] [rbp-57Ch]
  char v165; // [rsp+1Dh] [rbp-57Bh]
  char v166; // [rsp+1Eh] [rbp-57Ah]
  char v167; // [rsp+1Fh] [rbp-579h]
  __int64 v168; // [rsp+20h] [rbp-578h]
  volatile signed __int64 *v169; // [rsp+28h] [rbp-570h]
  __int64 v170; // [rsp+28h] [rbp-570h]
  __int64 v171; // [rsp+28h] [rbp-570h]
  __int64 v172; // [rsp+30h] [rbp-568h]
  __int64 v173; // [rsp+30h] [rbp-568h]
  __int64 v174; // [rsp+30h] [rbp-568h]
  __int64 v175; // [rsp+38h] [rbp-560h] BYREF
  __int64 v176; // [rsp+40h] [rbp-558h]
  __int64 v177; // [rsp+48h] [rbp-550h]
  __m128i v178; // [rsp+50h] [rbp-548h] BYREF
  __int64 v179; // [rsp+60h] [rbp-538h]
  __m128i v180; // [rsp+68h] [rbp-530h] BYREF
  __int128 v181; // [rsp+78h] [rbp-520h]
  __int128 v182; // [rsp+88h] [rbp-510h]
  __int128 v183; // [rsp+98h] [rbp-500h]
  __int64 v184; // [rsp+A8h] [rbp-4F0h]
  __m128i v185; // [rsp+B8h] [rbp-4E0h]
  unsigned __int64 v186; // [rsp+C8h] [rbp-4D0h]
  __int64 v187; // [rsp+D0h] [rbp-4C8h]
  void *dest; // [rsp+D8h] [rbp-4C0h]
  unsigned __int64 v189; // [rsp+E0h] [rbp-4B8h]
  _QWORD *v190; // [rsp+E8h] [rbp-4B0h]
  int v191; // [rsp+F0h] [rbp-4A8h]
  __int16 v192; // [rsp+F4h] [rbp-4A4h]
  _BYTE *v193; // [rsp+F8h] [rbp-4A0h]
  _BYTE v194[15]; // [rsp+100h] [rbp-498h]
  __int128 v195; // [rsp+110h] [rbp-488h] BYREF
  __int64 v196; // [rsp+120h] [rbp-478h]
  unsigned __int64 v197; // [rsp+128h] [rbp-470h]
  unsigned __int64 v198; // [rsp+130h] [rbp-468h]
  unsigned int v199; // [rsp+13Ch] [rbp-45Ch]
  __m128i v200; // [rsp+140h] [rbp-458h] BYREF
  char v201[24]; // [rsp+150h] [rbp-448h] BYREF
  __int64 v202; // [rsp+168h] [rbp-430h]
  __m128i v203; // [rsp+170h] [rbp-428h] BYREF
  __int128 v204; // [rsp+180h] [rbp-418h]
  __int128 v205; // [rsp+190h] [rbp-408h]
  __int128 v206; // [rsp+1A0h] [rbp-3F8h]
  __int128 v207; // [rsp+1B0h] [rbp-3E8h]
  __int64 v208; // [rsp+1C0h] [rbp-3D8h]
  __m128i v209; // [rsp+1D0h] [rbp-3C8h] BYREF
  unsigned __int64 v210; // [rsp+1E0h] [rbp-3B8h]
  __int64 v211; // [rsp+1E8h] [rbp-3B0h]
  __int128 v212; // [rsp+1F0h] [rbp-3A8h] BYREF
  __int128 v213; // [rsp+200h] [rbp-398h]
  __int128 v214; // [rsp+210h] [rbp-388h]
  __int128 v215; // [rsp+220h] [rbp-378h]
  __int64 v216; // [rsp+230h] [rbp-368h]
  _BYTE src[424]; // [rsp+240h] [rbp-358h] BYREF
  int v218; // [rsp+3EAh] [rbp-1AEh]
  __int16 v219; // [rsp+3EEh] [rbp-1AAh]
  __m128i v220; // [rsp+3F0h] [rbp-1A8h] BYREF
  __m128i *v221; // [rsp+400h] [rbp-198h]
  __m128i v222; // [rsp+408h] [rbp-190h] BYREF
  __int128 v223; // [rsp+418h] [rbp-180h]
  __int128 v224; // [rsp+428h] [rbp-170h]
  __int128 v225; // [rsp+438h] [rbp-160h]
  __int128 v226; // [rsp+448h] [rbp-150h]
  __int64 v227; // [rsp+458h] [rbp-140h]
  _BYTE v228[64]; // [rsp+460h] [rbp-138h] BYREF
  __int128 v229; // [rsp+4A0h] [rbp-F8h]
  __int64 v230; // [rsp+4B0h] [rbp-E8h]
  unsigned __int64 v231; // [rsp+4B8h] [rbp-E0h]
  __m128i v232; // [rsp+4C0h] [rbp-D8h]
  __int128 v233; // [rsp+4D0h] [rbp-C8h]
  __int64 v234; // [rsp+4E0h] [rbp-B8h]
  __int128 v235; // [rsp+4F0h] [rbp-A8h]
  __int64 v236; // [rsp+500h] [rbp-98h]
  __m128i v237; // [rsp+510h] [rbp-88h] BYREF
  __m128i v238; // [rsp+520h] [rbp-78h] BYREF
  __int64 v239; // [rsp+538h] [rbp-60h] BYREF
  __m128i v240; // [rsp+540h] [rbp-58h]
  __int64 v241; // [rsp+550h] [rbp-48h] BYREF
  __m128i v242; // [rsp+558h] [rbp-40h]

  v3 = a2;
  v5 = *(_QWORD *)(a3 + 64);
  v6 = a2[27];
  v7 = (volatile signed __int64 *)*a2;
  v8 = a2[1];
  if ( v6 )
  {
    v9 = a2[28];
    while ( 1 )
    {
      v10 = -1LL;
      v11 = 0LL;
      do
      {
        if ( 16 * *(unsigned __int16 *)(v6 + 274) == v11 )
        {
          v10 = *(unsigned __int16 *)(v6 + 274);
          goto LABEL_11;
        }
        v12 = *(_QWORD *)(v6 + 8 * v10 + 192) != v5;
        if ( *(_QWORD *)(v6 + 8 * v10 + 192) > v5 )
          v12 = -1;
        ++v10;
        v11 += 16LL;
      }
      while ( v12 == 1 );
      if ( !v12 )
      {
        v14 = __OFSUB__(*(_BYTE *)(v6 + v11 - 16), 75);
        if ( *(_BYTE *)(v6 + v11 - 16) != 75 )
        {
          v18 = *(_QWORD *)(v6 + v11 - 16);
          v7 = *(volatile signed __int64 **)(v6 + v11 - 8);
          v17 = v18;
          goto LABEL_135;
        }
        v7 = *(volatile signed __int64 **)(v6 + v11 - 8);
        v15 = _InterlockedIncrement64(v7);
        if ( (v15 < 0) ^ v14 | (v15 == 0) )
          BUG();
        goto LABEL_137;
      }
LABEL_11:
      v13 = v9-- == 0;
      if ( v13 )
        break;
      v6 = *(_QWORD *)(v6 + 8 * v10 + 280);
    }
  }
  if ( v8 < v5 )
  {
    v16 = 19;
    v17 = 0LL;
    goto LABEL_134;
  }
  v19 = (unsigned __int64)v7 + v5;
  v200.m128i_i64[0] = 0LL;
  v200.m128i_i64[1] = 8LL;
  v202 = 0LL;
  v20 = 0LL;
  *(_OWORD *)v201 = 0LL;
  v21 = v8 - v5;
  dest = a1;
  v190 = a2;
  if ( !v21 )
    goto LABEL_85;
  v22 = 0;
  v23 = 0xFFFFFFFF00000000LL;
  while ( 2 )
  {
    v24 = 0LL;
    v25 = 0LL;
    v26 = 0;
    while ( 1 )
    {
      v27 = *(_BYTE *)(v19 + v24);
      LOBYTE(v28) = 6;
      if ( v26 == 63 && (unsigned __int8)v27 >= 2u )
        goto LABEL_104;
      v25 |= (unsigned __int64)(v27 & 0x7F) << v26;
      if ( v27 >= 0 )
        break;
      v26 += 7;
      if ( v21 == ++v24 )
      {
        v19 += v21;
        goto LABEL_85;
      }
    }
    if ( !v25 )
    {
      a1 = dest;
LABEL_97:
      v16 = v200.m128i_i8[8];
      v7 = *(volatile signed __int64 **)v201;
      v178 = _mm_loadu_si128((const __m128i *)&v201[8]);
      v179 = v202;
      if ( v200.m128i_i64[0] == 0x8000000000000000LL )
      {
        v17 = v200.m128i_i64[1] & 0xFFFFFFFFFFFFFF00LL;
        goto LABEL_134;
      }
      *(_QWORD *)&src[56] = v179;
      *(__m128i *)&src[40] = _mm_load_si128(&v178);
      *(_QWORD *)src = 1LL;
      *(_QWORD *)&src[8] = 1LL;
      *(__m128i *)&src[16] = v200;
      *(_QWORD *)&src[32] = *(_QWORD *)v201;
      v67 = (__m128i *)_rust_alloc(64LL, 8LL);
      if ( !v67 )
        alloc::alloc::handle_alloc_error(8LL, 64LL);
      v7 = (volatile signed __int64 *)v67;
      v68 = _mm_loadu_si128((const __m128i *)src);
      v69 = *(__m128i *)&src[16];
      v70 = *(__m128i *)&src[32];
      v67[3] = *(__m128i *)&src[48];
      v67[2] = v70;
      v67[1] = v69;
      *v67 = v68;
      LOBYTE(v18) = 75;
      goto LABEL_136;
    }
    if ( v21 - 1 == v24 )
    {
      v19 += v24 + 1;
      goto LABEL_85;
    }
    v29 = v21 - v24;
    LODWORD(v169) = *(_BYTE *)(v19 + v24 + 1) & 0x7F;
    if ( *(char *)(v19 + v24 + 1) < 0 )
    {
      if ( v21 - 2 == v24 )
      {
        v19 += v24 + 2;
        goto LABEL_85;
      }
      LODWORD(v169) = ((*(_BYTE *)(v19 + v24 + 2) & 0x7F) << 7) | *(_BYTE *)(v19 + v24 + 1) & 0x7F;
      if ( *(char *)(v19 + v24 + 2) < 0 )
      {
        if ( v21 - 3 == v24 )
        {
          v19 += v24 + 3;
          goto LABEL_85;
        }
        v32 = (unsigned __int8 *)(v19 + v24 + 3);
        if ( *v32 > 3u )
          goto LABEL_104;
        v31 = (_BYTE *)(v19 + v24 + 4);
        v30 = v29 - 4;
        LODWORD(v169) = (*v32 << 14) | (unsigned __int16)v169;
      }
      else
      {
        v30 = v29 - 3;
        v31 = (_BYTE *)(v19 + v24 + 3);
      }
    }
    else
    {
      v30 = v29 - 2;
      v31 = (_BYTE *)(v19 + v24 + 2);
    }
    if ( !(_WORD)v169 )
    {
      LOBYTE(v28) = 8;
LABEL_104:
      v56 = 0;
      goto LABEL_105;
    }
    if ( !v30 )
    {
      LOBYTE(v28) = 19;
      v22 = 0;
      v56 = 0;
      v19 = (unsigned __int64)v31;
      goto LABEL_105;
    }
    if ( *v31 >= 2u )
    {
      LOBYTE(v28) = 10;
      goto LABEL_104;
    }
    LOBYTE(v187) = *v31;
    v33 = v31 + 1;
    v34 = v30 - 1;
    *(_QWORD *)&src[32] = 0LL;
    *(_DWORD *)&src[40] = 0;
    *(_QWORD *)&src[48] = 0LL;
    *(_DWORD *)&src[56] = 0;
    *(_QWORD *)&src[64] = 0LL;
    *(_DWORD *)&src[72] = 0;
    *(_QWORD *)&src[80] = 0LL;
    *(_DWORD *)&src[88] = 0;
    *(_OWORD *)src = v20;
    *(_OWORD *)&src[12] = v20;
    v186 = 0LL;
    v35 = 0;
    v36 = 0;
    while ( 1 )
    {
      if ( !v34 )
      {
        v60 = 19LL;
        v44 = 0LL;
        v61 = 0LL;
        v62 = 0LL;
        v19 = (unsigned __int64)v33;
        goto LABEL_89;
      }
      v37 = v34 - 1;
      v38 = v33 + 1;
      v39 = *v33 & 0x7F;
      if ( (*v33 & 0x80u) != 0 )
      {
        if ( v34 == 1 )
          goto LABEL_94;
        v37 = v34 - 2;
        v38 = v33 + 2;
        v39 |= (v33[1] & 0x7F) << 7;
        if ( (v33[1] & 0x80u) != 0 )
        {
          if ( v34 == 2 )
            goto LABEL_94;
          v40 = *v38;
          if ( v40 > 3u )
          {
LABEL_112:
            v60 = 6LL;
            goto LABEL_88;
          }
          v39 |= v40 << 14;
          v38 = v33 + 3;
          v37 = v34 - 3;
        }
      }
      if ( !v39 )
        break;
      if ( !v37 )
        goto LABEL_94;
      v41 = v37 - 1;
      v42 = v38 + 1;
      v43 = *v38 & 0x7F;
      if ( (*v38 & 0x80u) != 0 )
      {
        if ( v37 == 1 )
          goto LABEL_87;
        v41 = v37 - 2;
        v42 = v38 + 2;
        v43 = ((v38[1] & 0x7F) << 7) | *v38 & 0x7F;
        if ( (v38[1] & 0x80u) != 0 )
        {
          if ( v37 == 2 )
          {
LABEL_87:
            v60 = 19LL;
            v19 = (unsigned __int64)v42;
            goto LABEL_88;
          }
          if ( *v42 > 3u )
            goto LABEL_112;
          v43 = (*v42 << 14) | (unsigned __int16)v43;
          v42 = v38 + 3;
          v41 = v37 - 3;
        }
      }
      if ( (_WORD)v43 != 33 )
      {
        v44 = (unsigned __int16)v43;
        if ( (_WORD)v43 )
        {
          v33 = v42;
          v172 = v41;
          v45 = 0LL;
          goto LABEL_71;
        }
        v60 = 9LL;
        v61 = 0LL;
        v62 = 0LL;
        goto LABEL_89;
      }
      v46 = 0;
      v33 = v42;
      v47 = v41;
      v48 = 0LL;
      do
      {
        v13 = v47-- == 0;
        if ( v13 )
        {
          v42 += v41;
          goto LABEL_87;
        }
        v49 = *v33;
        if ( v46 == 63 && v49 != 127 && *v33 )
        {
          v60 = 7LL;
          v44 = 0LL;
          v61 = 0LL;
          v62 = 0LL;
          goto LABEL_89;
        }
        ++v33;
        v48 |= (unsigned __int64)(v49 & 0x7F) << v46;
        v46 += 7;
      }
      while ( (v49 & 0x80u) != 0LL );
      v50 = -1LL << v46;
      if ( (unsigned __int8)v49 < 0x40u )
        v50 = 0LL;
      if ( v46 >= 64 )
        v50 = 0LL;
      v45 = v50 | v48;
      v172 = v47;
LABEL_71:
      v19 = (unsigned int)(v43 << 16) | v19 & 0xFFFFFFFF00000000LL | v39;
      v186 = v45 & 0xFFFFFFFF00000000LL;
      v35 = v45 & 0xFFFF0000;
      *(_QWORD *)&v195 = v45;
      v36 = v45 & 0xFF00;
      *((_QWORD *)&v195 + 1) = v19;
      gimli::read::abbrev::Attributes::push((__int64)src, &v195);
      v34 = v172;
    }
    if ( !v37 )
    {
LABEL_94:
      v60 = 19LL;
      v44 = 0LL;
      v61 = 0LL;
      v62 = 0LL;
      v19 = (unsigned __int64)v38;
      goto LABEL_89;
    }
    v51 = v19;
    v21 = v37 - 1;
    v19 = (unsigned __int64)(v38 + 1);
    v52 = *v38 & 0x7F;
    if ( (*v38 & 0x80u) == 0 )
      goto LABEL_79;
    if ( v37 == 1 )
      goto LABEL_293;
    v21 = v37 - 2;
    v19 = (unsigned __int64)(v38 + 2);
    v52 |= (v38[1] & 0x7F) << 7;
    if ( (v38[1] & 0x80u) == 0 )
      goto LABEL_79;
    if ( v37 == 2 )
    {
LABEL_293:
      v60 = 19LL;
LABEL_88:
      v44 = 0LL;
      v61 = 0LL;
      v62 = 0LL;
      goto LABEL_89;
    }
    v53 = *(unsigned __int8 *)v19;
    if ( v53 > 3u )
    {
      v60 = 6LL;
      v186 = 0LL;
      v35 = 0;
      v36 = 0;
      goto LABEL_118;
    }
    v52 |= v53 << 14;
    v19 = (unsigned __int64)(v38 + 3);
    v21 = v37 - 3;
LABEL_79:
    if ( v52 )
    {
      v60 = 13LL;
LABEL_118:
      v44 = v186 & 0xFFFFFFFF00000000LL;
      v61 = v35 & 0xFFFF0000;
      v62 = v36 & 0xFF00;
      v19 = v51;
LABEL_89:
      v57 = v60 | v61;
      v58 = v62 | v44;
      if ( *(_QWORD *)src && *(_QWORD *)&src[8] )
        _rust_dealloc(*(_QWORD *)&src[16], 16LL * *(_QWORD *)&src[8], 8LL);
      v28 = v58 | v57;
      goto LABEL_93;
    }
    v28 = *(_QWORD *)&src[8];
    v212 = *(_OWORD *)&src[24];
    v213 = *(_OWORD *)&src[40];
    v214 = *(_OWORD *)&src[56];
    v215 = *(_OWORD *)&src[72];
    v216 = *(_QWORD *)&src[88];
    if ( *(_QWORD *)src == 2LL )
    {
      v19 = *(_QWORD *)&src[16];
LABEL_93:
      v56 = v28 & 0xFF00;
      v22 = v28 & 0xFFFF0000;
      v59 = v28 & 0xFFFFFFFF00000000LL;
      goto LABEL_106;
    }
    v184 = v216;
    si128 = _mm_load_si128((const __m128i *)&v212);
    v183 = v215;
    v182 = v214;
    v181 = v213;
    v180 = si128;
    v178 = *(__m128i *)src;
    v179 = *(_QWORD *)&src[16];
    gimli::read::abbrev::Abbreviation::new((__int64)src, v25, (__int16)v169, v187, &v178);
    a1 = dest;
    v3 = v190;
    LOBYTE(v28) = src[8];
    *(_OWORD *)v228 = *(_OWORD *)&src[24];
    *(_OWORD *)&v228[16] = *(_OWORD *)&src[40];
    *(_OWORD *)&v228[32] = *(_OWORD *)&src[56];
    *(_OWORD *)&v228[48] = *(_OWORD *)&src[72];
    v229 = *(_OWORD *)&src[88];
    v230 = *(_QWORD *)&src[104];
    if ( *(_QWORD *)src == 3LL )
    {
      v56 = *(_WORD *)&src[8] & 0xFF00;
      v22 = *(_DWORD *)&src[8] & 0xFFFF0000;
      v59 = *(_QWORD *)&src[8] & 0xFFFFFFFF00000000LL;
      v19 = *(_QWORD *)&src[16];
      goto LABEL_106;
    }
    v208 = v230;
    v207 = v229;
    v206 = *(_OWORD *)&v228[48];
    v205 = *(_OWORD *)&v228[32];
    v204 = *(_OWORD *)&v228[16];
    v203 = *(__m128i *)v228;
    if ( *(_QWORD *)src == 2LL )
      goto LABEL_97;
    v220 = *(__m128i *)src;
    v221 = *(__m128i **)&src[16];
    v227 = v208;
    v226 = v207;
    v55 = _mm_load_si128(&v203);
    v225 = v206;
    v224 = v205;
    v223 = v204;
    v222 = v55;
    v22 = 0;
    v20 = 0LL;
    if ( (unsigned __int8)gimli::read::abbrev::Abbreviations::insert(v200.m128i_i64, v220.m128i_i64) )
    {
      v16 = 14;
      v17 = 0LL;
      v63 = v200.m128i_i64[1];
      v64 = *(_QWORD *)v201;
      if ( *(_QWORD *)v201 )
        goto LABEL_107;
    }
    else
    {
      if ( v21 )
        continue;
LABEL_85:
      LOBYTE(v28) = 19;
      v22 = 0;
      v56 = 0;
LABEL_105:
      v59 = 0LL;
LABEL_106:
      v169 = (volatile signed __int64 *)v19;
      v16 = v59 | v28;
      v17 = v22 & 0xFFFF0000 | v56 & 0xFF00 | v59 & 0xFFFFFFFFFFFFFF00LL;
      v63 = v200.m128i_i64[1];
      v64 = *(_QWORD *)v201;
      if ( *(_QWORD *)v201 )
      {
LABEL_107:
        v65 = (_QWORD *)(v63 + 16);
        do
        {
          if ( *(v65 - 2) )
          {
            v66 = *(v65 - 1);
            if ( v66 )
              _rust_dealloc(*v65, 16 * v66, 8LL);
          }
          v65 += 14;
          --v64;
        }
        while ( v64 );
      }
    }
    break;
  }
  if ( v200.m128i_i64[0] )
    _rust_dealloc(v63, 112 * v200.m128i_i64[0], 8LL);
  v7 = v169;
  if ( *(_QWORD *)&v201[8] )
  {
    v71 = v202;
    *(_QWORD *)&src[8] = 0LL;
    *(_OWORD *)&src[16] = *(_OWORD *)&v201[8];
    *(_QWORD *)&src[40] = 0LL;
    *(_OWORD *)&src[48] = *(_OWORD *)&v201[8];
    v72 = 1LL;
  }
  else
  {
    v72 = 0LL;
    v71 = 0LL;
  }
  *(_QWORD *)src = v72;
  *(_QWORD *)&src[32] = v72;
  *(_QWORD *)&src[64] = v71;
  alloc::collections::btree::map::IntoIter<K,V,A>::dying_next((unsigned __int64 *)&v178, src);
  for ( i = v178.m128i_i64[0]; v178.m128i_i64[0]; i = v178.m128i_i64[0] )
  {
    if ( *(_QWORD *)(i + 112 * v179) )
    {
      v74 = 112 * v179 + i;
      v75 = *(_QWORD *)(v74 + 8);
      if ( v75 )
        _rust_dealloc(*(_QWORD *)(v74 + 16), 16 * v75, 8LL);
    }
    alloc::collections::btree::map::IntoIter<K,V,A>::dying_next((unsigned __int64 *)&v178, src);
  }
  a1 = dest;
  v3 = v190;
LABEL_134:
  LOBYTE(v18) = v17 | v16;
LABEL_135:
  v23 = v17 >> 8;
LABEL_136:
  if ( (_BYTE)v18 != 75 )
  {
    *((_BYTE *)a1 + 8) = v18;
    *(_DWORD *)((char *)a1 + 9) = v23;
    result = (void *)HIWORD(v23);
    *((_BYTE *)a1 + 15) = BYTE6(v23);
    *(_WORD *)((char *)a1 + 13) = WORD2(v23);
    a1[2] = v7;
    *a1 = 2LL;
    return result;
  }
LABEL_137:
  v76 = *(_QWORD *)(a3 + 16);
  v77 = *(_QWORD *)(a3 + 24);
  *(_QWORD *)&src[64] = *(_QWORD *)(a3 + 64);
  v78 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)&src[48] = *(_OWORD *)(a3 + 48);
  *(_OWORD *)&src[32] = v78;
  v190 = v3;
  v79 = *((_BYTE *)v3 + 240) != 0;
  *(_OWORD *)src = *(_OWORD *)a3;
  *(_QWORD *)&src[16] = v76;
  *(_QWORD *)&src[24] = v77;
  v80 = WORD1(*(_QWORD *)(a3 + 72)) >= 5u;
  v81 = (*(_QWORD *)(a3 + 72) & 0xFF00) == 2048;
  v82 = 8 * v81 + 8;
  v83 = !v79 || !v80;
  if ( !v79 || !v80 )
    v82 = 0LL;
  *(_QWORD *)&src[72] = *(_QWORD *)(a3 + 72);
  v84 = 8 * v81 + 12;
  if ( v83 )
    v84 = 0LL;
  *(_QWORD *)&src[344] = v7;
  *(_QWORD *)&src[352] = 0LL;
  *(_QWORD *)&src[368] = 0LL;
  *(_QWORD *)&src[384] = 0LL;
  *(_QWORD *)&src[392] = v82;
  *(_QWORD *)&src[400] = 0LL;
  *(_QWORD *)&src[408] = v84;
  *(_QWORD *)&src[416] = v84;
  *(_QWORD *)&src[96] = 47LL;
  *(_QWORD *)&src[80] = (unsigned __int64)(v76 - 3) < 2;
  *(_QWORD *)&src[88] = v77;
  v220 = _mm_loadu_si128((const __m128i *)&src[40]);
  v221 = (__m128i *)src;
  v222 = (__m128i)(unsigned __int64)(v7 + 2);
  *(_QWORD *)&v226 = 0LL;
  gimli::read::unit::EntriesCursor<R>::next_entry(v178.m128i_i64, (__int64)&v220);
  v85 = v178.m128i_i8[0];
  if ( v178.m128i_i8[0] != 75 )
  {
LABEL_146:
    v88 = v178.m128i_i64[1];
    a1[1] = ((unsigned __int64)*(unsigned int *)((char *)v178.m128i_u32 + 2) << 16) | ((unsigned __int64)v178.m128i_u16[3] << 48) | (v178.m128i_u8[1] << 8) | (unsigned __int64)v85;
    a1[2] = v88;
LABEL_147:
    *a1 = 2LL;
    goto LABEL_148;
  }
  v86 = &v222.m128i_i64[1];
  while ( 1 )
  {
    v87 = v222.m128i_i64[1];
    if ( !v178.m128i_i8[1] )
      break;
    if ( v222.m128i_i64[1] )
      goto LABEL_162;
    gimli::read::unit::EntriesCursor<R>::next_entry(v178.m128i_i64, (__int64)&v220);
    v85 = v178.m128i_i8[0];
    if ( v178.m128i_i8[0] != 75 )
      goto LABEL_146;
  }
  if ( !v222.m128i_i64[1] )
  {
    *((_BYTE *)a1 + 8) = 66;
    goto LABEL_147;
  }
LABEL_162:
  v90 = (__m128i *)v223;
  v91 = (__int64)<gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref(*((_QWORD **)&v223 + 1));
  v178.m128i_i64[0] = v87;
  v178.m128i_i64[1] = (__int64)v90;
  v179 = v91;
  v180.m128i_i64[0] = v92;
  v180.m128i_i64[1] = (__int64)&v222.m128i_i64[1];
  dest = a1;
  if ( v92 )
  {
    v187 = *(_QWORD *)&src[80];
    v93 = v92 - 1;
    v94 = v91 + 16;
    v186 = 46LL;
    v159 = 0LL;
    v90 = &v203;
    v173 = 46LL;
    v170 = 46LL;
    do
    {
      v203 = *(__m128i *)(v94 - 16);
      gimli::read::unit::parse_attribute(
        (__int64)v228,
        (unsigned __int64 *)&v178,
        *(_DWORD *)(*(_QWORD *)(v180.m128i_i64[1] + 24) + 72LL),
        (__int64)&v203);
      if ( *(_QWORD *)v228 == 46LL )
      {
        v232 = _mm_loadu_si128((const __m128i *)&v228[8]);
        v103 = dest;
        *(__m128i *)((char *)dest + 8) = v232;
        *v103 = 2LL;
        goto LABEL_148;
      }
      v96 = _mm_loadu_si128((const __m128i *)&v228[8]);
      v179 = v94;
      v180.m128i_i64[0] = v93;
      v232 = v96;
      *(__m128i *)&v228[8] = v96;
      v91 = *(unsigned __int16 *)&v228[24];
      if ( *(unsigned __int16 *)&v228[24] <= 0x71u )
      {
        v91 = (unsigned int)*(unsigned __int16 *)&v228[24] - 3;
        switch ( *(_WORD *)&v228[24] )
        {
          case 3:
            gimli::read::unit::Attribute<R>::value(&v203, (__int64)v228, v95);
            v186 = v203.m128i_i64[0];
            v91 = (__int64)&v203.m128i_i64[1];
            v237 = _mm_loadu_si128((const __m128i *)&v203.m128i_u64[1]);
            break;
          case 0x10:
            gimli::read::unit::Attribute<R>::value(&v203, (__int64)v228, v95);
            if ( v203.m128i_i64[0] == 16 )
              v189 = v203.m128i_u64[1];
            v91 = v159;
            if ( v203.m128i_i32[0] == 16 )
              v91 = 1LL;
            v159 = v91;
            break;
          case 0x11:
            gimli::read::unit::Attribute<R>::value(&v203, (__int64)v228, v95);
            v91 = v203.m128i_i64[1];
            v211 = v203.m128i_i64[1];
            v170 = v203.m128i_i64[0];
            break;
          case 0x1B:
            gimli::read::unit::Attribute<R>::value(&v203, (__int64)v228, v95);
            v173 = v203.m128i_i64[0];
            v91 = (__int64)&v203.m128i_i64[1];
            v238 = _mm_loadu_si128((const __m128i *)&v203.m128i_u64[1]);
            break;
          default:
            break;
        }
      }
      else if ( *(unsigned __int16 *)&v228[24] > 0x2130u )
      {
        switch ( *(unsigned __int16 *)&v228[24] )
        {
          case 0x2131u:
            if ( !v187 )
            {
              gimli::read::unit::Attribute<R>::value(&v203, (__int64)v228, v95);
              if ( v203.m128i_i32[0] == 45 )
              {
                *(_QWORD *)&src[80] = 1LL;
                *(_QWORD *)&src[88] = v203.m128i_i64[1];
                v91 = 1LL;
              }
              else
              {
                v91 = 0LL;
              }
              v187 = v91;
            }
            break;
          case 0x2132u:
LABEL_183:
            LOBYTE(v91) = gimli::read::unit::Attribute<R>::value(&v203, (__int64)v228, v95);
            if ( v203.m128i_i32[0] == 23 )
            {
              v91 = v203.m128i_i64[1];
              *(_QWORD *)&src[416] = v203.m128i_i64[1];
            }
            break;
          case 0x2133u:
LABEL_181:
            LOBYTE(v91) = gimli::read::unit::Attribute<R>::value(&v203, (__int64)v228, v95);
            if ( v203.m128i_i32[0] == 11 )
            {
              v91 = v203.m128i_i64[1];
              *(_QWORD *)&src[400] = v203.m128i_i64[1];
            }
            break;
        }
      }
      else
      {
        v91 = (unsigned int)*(unsigned __int16 *)&v228[24] - 114;
        switch ( *(_WORD *)&v228[24] )
        {
          case 0x72:
            LOBYTE(v91) = gimli::read::unit::Attribute<R>::value(&v203, (__int64)v228, v95);
            if ( v203.m128i_i32[0] == 28 )
            {
              v91 = v203.m128i_i64[1];
              *(_QWORD *)&src[392] = v203.m128i_i64[1];
            }
            break;
          case 0x73:
            goto LABEL_181;
          case 0x74:
            goto LABEL_183;
          case 0x8C:
            LOBYTE(v91) = gimli::read::unit::Attribute<R>::value(&v203, (__int64)v228, v95);
            if ( v203.m128i_i32[0] == 18 )
            {
              v91 = v203.m128i_i64[1];
              *(_QWORD *)&src[408] = v203.m128i_i64[1];
            }
            break;
          default:
            break;
        }
      }
      v94 += 16LL;
      v13 = v93-- != 0;
    }
    while ( v13 );
    v86 = (__int64 *)v180.m128i_i64[1];
    v97 = v170;
    v98 = v159;
    v99 = v173;
    v100 = v186;
    if ( !*(_QWORD *)(v180.m128i_i64[1] + 40) )
    {
LABEL_195:
      v91 = v178.m128i_i64[0] - *v86;
      v86[5] = 1LL;
      v86[6] = v91;
    }
  }
  else
  {
    v97 = 46LL;
    v98 = 0LL;
    v99 = 46LL;
    v100 = 46LL;
    if ( !(_QWORD)v225 )
      goto LABEL_195;
  }
  v232 = _mm_load_si128((const __m128i *)&v212);
  if ( v100 != 46 )
  {
    v239 = v100;
    v240 = _mm_load_si128(&v237);
    v102 = (unsigned __int64)v190;
    v91 = gimli::read::dwarf::Dwarf<R>::attr_string(
            (__int64)&v220,
            v190,
            src[73],
            *(unsigned __int64 *)&src[392],
            &v239);
    if ( v220.m128i_i64[0] )
      v101 = 0LL;
    else
      v101 = v220.m128i_i64[1];
    v90 = v221;
    *(_QWORD *)&src[352] = v101;
    *(_QWORD *)&src[360] = v221;
    if ( v99 == 46 )
      goto LABEL_212;
LABEL_198:
    v241 = v99;
    v242 = _mm_load_si128(&v238);
    gimli::read::dwarf::Dwarf<R>::attr_string(
      (__int64)&v220,
      (_QWORD *)v102,
      src[73],
      *(unsigned __int64 *)&src[392],
      &v241);
    v91 = (__int64)v221;
    if ( v220.m128i_i64[0] )
      v99 = 0LL;
    else
      v99 = v220.m128i_i64[1];
    v104 = v189;
    *(_QWORD *)&src[368] = v99;
    *(_QWORD *)&src[376] = v221;
    if ( v98 )
    {
      v98 = *(_QWORD *)(v102 + 64);
      v105 = *(_QWORD *)(v102 + 72);
      v13 = v105 < v189;
      v106 = v105 - v189;
      if ( !v13 )
        goto LABEL_214;
      goto LABEL_209;
    }
LABEL_218:
    v174 = 47LL;
    v160 = 47;
    if ( *(_DWORD *)&src[96] == 47 )
      goto LABEL_227;
    goto LABEL_219;
  }
  v101 = 0LL;
  v102 = (unsigned __int64)v190;
  *(_QWORD *)&src[352] = 0LL;
  *(_QWORD *)&src[360] = v90;
  if ( v99 != 46 )
    goto LABEL_198;
LABEL_212:
  *(_QWORD *)&src[368] = 0LL;
  v104 = v189;
  if ( !v98 )
    goto LABEL_218;
  v99 = 0LL;
  v98 = *(_QWORD *)(v102 + 64);
  v108 = *(_QWORD *)(v102 + 72);
  v13 = v108 < v189;
  v106 = v108 - v189;
  if ( v13 )
  {
LABEL_209:
    v107 = 19LL;
    goto LABEL_249;
  }
LABEL_214:
  v109 = v104 + v98;
  if ( v106 < 4 )
  {
    v178.m128i_i32[0] = 0;
    v178.m128i_i8[6] = 0;
    v178.m128i_i16[2] = 0;
    v114 = 19LL;
    v115 = v109 & 0xFFFFFFFFFFFFFF00LL;
LABEL_233:
    LODWORD(v99) = (unsigned int)v114 >> 8;
    LODWORD(v90) = WORD1(v114);
    LODWORD(v101) = BYTE3(v114);
    v102 = HIDWORD(v114);
    v98 = v115 | (unsigned __int8)v109;
    goto LABEL_248;
  }
  v186 = v91;
  v110 = src[72];
  v111 = v106 - 4;
  v112 = v109 + 4;
  v113 = *(unsigned int *)v109;
  if ( *(_DWORD *)v109 >> 4 != 0xFFFFFFF )
  {
    v121 = 4;
    v122 = *(unsigned int *)v109;
    if ( v111 < v113 )
      goto LABEL_247;
    goto LABEL_235;
  }
  if ( (_DWORD)v113 != -1 )
  {
    v114 = 16LL;
    v115 = 0LL;
    goto LABEL_233;
  }
  if ( v111 < 8 )
  {
    v178.m128i_i64[0] = 19LL;
    v178.m128i_i64[1] = v109 + 4;
    v115 = v112 & 0xFFFFFFFFFFFFFF00LL;
    v109 = HIBYTE(*(unsigned __int64 *)((char *)v178.m128i_i64 + 1));
    v114 = (*(__int64 *)((char *)v178.m128i_i64 + 1) << 8) | 0x13;
    goto LABEL_233;
  }
  v122 = *(_QWORD *)(v109 + 4);
  v121 = 8;
  v112 = v109 + 12;
  if ( v106 - 12 < v122 )
    goto LABEL_247;
LABEL_235:
  if ( v122 <= 1 )
    goto LABEL_247;
  v123 = *(unsigned __int16 *)v112;
  if ( (unsigned __int16)(v123 - 6) < 0xFFFCu )
  {
    v98 = (unsigned __int16)v123;
    LOBYTE(v114) = 17;
    goto LABEL_248;
  }
  v131 = v122 - 2;
  v98 = v112 + 2;
  if ( (unsigned __int16)v123 <= 4u )
    goto LABEL_272;
  if ( v122 == 2 )
    goto LABEL_290;
  if ( v122 == 3 )
  {
    v112 += 3LL;
    goto LABEL_247;
  }
  if ( *(_BYTE *)(v112 + 3) )
  {
    LOBYTE(v114) = 65;
    goto LABEL_248;
  }
  v110 = *(_BYTE *)(v112 + 2);
  v131 = v122 - 4;
  v98 = v112 + 4;
LABEL_272:
  if ( (unsigned int)v113 < 0xFFFFFFF0 )
  {
    if ( v131 <= 3 )
    {
      *(_DWORD *)v194 = 0;
      *(_WORD *)&v194[4] = 0;
      v194[6] = 0;
      LOBYTE(v90) = 0;
      LOBYTE(v101) = 0;
      v102 = 0LL;
      LOBYTE(v99) = 0;
      goto LABEL_281;
    }
    v132 = v131 - 4;
    v133 = (_BYTE *)(v98 + 4);
    v175 = v98 + 4;
    v134 = *(unsigned int *)v98;
LABEL_277:
    v13 = v132 < v134;
    v135 = v132 - v134;
    if ( v13 )
    {
      LOBYTE(v114) = 19;
      v98 = (unsigned __int64)v133;
      goto LABEL_248;
    }
    v187 = v135;
    if ( !v134 )
    {
      LOBYTE(v114) = 19;
      LOBYTE(v90) = 0;
      LOBYTE(v101) = 0;
      v102 = 0LL;
      LOBYTE(v99) = 0;
      v98 = (unsigned __int64)v133;
      goto LABEL_248;
    }
    v136 = v133;
    v137 = v134 - 1;
    v176 = v134 - 1;
    if ( !*v136 )
    {
      LOBYTE(v114) = 26;
      goto LABEL_248;
    }
    v167 = *v136;
    v198 = v134;
    v155 = v121;
    v231 = v122;
    v156 = v110;
    v171 = v97;
    v193 = v136;
    v112 = (unsigned __int64)(v136 + 1);
    v157 = 1;
    v209.m128i_i64[0] = v123;
    if ( (unsigned __int16)v123 >= 4u )
    {
      if ( v134 == 1 )
        goto LABEL_247;
      v137 = v198 - 2;
      v176 = v198 - 2;
      v157 = v193[1];
      if ( !v157 )
      {
        LOBYTE(v114) = 27;
        goto LABEL_248;
      }
      v112 = (unsigned __int64)(v193 + 2);
    }
    if ( v137 )
    {
      v98 = v112 + 1;
      v175 = v112 + 1;
      if ( v137 == 1 )
        goto LABEL_290;
      v138 = *(_BYTE *)v112;
      v176 = v137 - 2;
      if ( v137 != 2 )
      {
        v166 = *(_BYTE *)(v112 + 1);
        v98 = v112 + 3;
        v175 = v112 + 3;
        v165 = *(_BYTE *)(v112 + 2);
        if ( !v165 )
        {
          LOBYTE(v114) = 28;
          goto LABEL_248;
        }
        v164 = v138 != 0;
        if ( v137 == 3 )
        {
LABEL_290:
          LOBYTE(v114) = 19;
          LOBYTE(v90) = 0;
          LOBYTE(v101) = 0;
          v102 = 0LL;
          LOBYTE(v99) = 0;
          goto LABEL_248;
        }
        v160 = *(_BYTE *)(v112 + 3);
        if ( !v160 )
        {
          LOBYTE(v114) = 29;
          goto LABEL_248;
        }
        v197 = v112 + 4;
        v139 = (unsigned __int8)(v160 - 1);
        v210 = v139;
        v140 = v137 - 4 - v139;
        if ( v137 - 4 < v139 )
        {
          LOBYTE(v114) = 19;
          LOBYTE(v90) = 0;
          LOBYTE(v101) = 0;
          v102 = 0LL;
          LOBYTE(v99) = 0;
          v98 = v197;
          goto LABEL_248;
        }
        v98 = v197 + v210;
        v175 = v197 + v210;
        v176 = v137 - 4 - v139;
        *(_QWORD *)&v195 = 0LL;
        *((_QWORD *)&v195 + 1) = 8LL;
        v196 = 0LL;
        if ( v209.m128i_i16[0] > 4u )
        {
          gimli::read::line::FileEntryFormat::parse((__int64)&v178, (__int64)&v175);
          v98 = v179;
          v185 = v178;
          if ( v178.m128i_i64[0] == 0x8000000000000000LL )
          {
            LOBYTE(v114) = v185.m128i_i8[8];
            LODWORD(v99) = (unsigned __int32)v185.m128i_i32[2] >> 8;
            LODWORD(v90) = HIWORD(v185.m128i_i32[2]);
            LODWORD(v101) = HIBYTE(v185.m128i_i32[2]);
            v102 = HIDWORD(v185.m128i_i64[1]);
            v161 = 1;
LABEL_338:
            if ( (_QWORD)v195 )
              _rust_dealloc(*((_QWORD *)&v195 + 1), 24 * v195, 8LL);
            if ( !((unsigned __int8)v161 | (v185.m128i_i64[0] == 0)) )
              _rust_dealloc(v185.m128i_i64[1], 4 * v185.m128i_i64[0], 2LL);
            goto LABEL_248;
          }
          gimli::read::reader::Reader::read_uleb128((__int64)&v178, &v175);
          LOBYTE(v114) = v178.m128i_i8[0];
          if ( v178.m128i_i8[0] == 75 )
          {
            v102 = v178.m128i_u64[1];
            if ( v178.m128i_i64[1] )
            {
              v99 = 0LL;
              while ( 1 )
              {
                gimli::read::line::parse_directory_v5(
                  (__int64)&v178,
                  (unsigned __int64 *)&v175,
                  v156 + (v155 << 8) + 327680,
                  v185.m128i_i64[1],
                  v98);
                LOBYTE(v114) = v178.m128i_i8[8];
                if ( v178.m128i_i64[0] == 46 )
                  break;
                v200 = v178;
                *(_QWORD *)v201 = v179;
                alloc::vec::Vec<T,A>::push((__int64 *)&v195, (__int64)&v200);
                if ( !--v102 )
                  goto LABEL_322;
              }
              LODWORD(v99) = (unsigned __int32)v178.m128i_i32[2] >> 8;
              LODWORD(v90) = HIWORD(v178.m128i_i32[2]);
              LODWORD(v101) = HIBYTE(v178.m128i_i32[2]);
              v102 = HIDWORD(v178.m128i_i64[1]);
              v161 = 0;
              v98 = v179;
              goto LABEL_338;
            }
            *(_QWORD *)&v212 = 0LL;
            *((_QWORD *)&v212 + 1) = 8LL;
            *(_QWORD *)&v213 = 0LL;
            v99 = 0LL;
            goto LABEL_343;
          }
          LOBYTE(v99) = v178.m128i_i8[1];
          LOBYTE(v90) = v178.m128i_i8[2];
          v98 = v178.m128i_u64[1];
          LODWORD(v101) = *(unsigned __int32 *)((char *)v178.m128i_i32 + 2) >> 8;
          v102 = (*(unsigned int *)((char *)v178.m128i_u32 + 2) | ((unsigned __int64)v178.m128i_u16[3] << 32)) >> 16;
        }
        else
        {
          if ( v140 )
          {
            v141 = v137 + v112;
            v185.m128i_i64[0] = 0LL;
            while ( 1 )
            {
              v142 = v98;
              v143 = 0LL;
              while ( 1 )
              {
                v144 = v98 + v143 + 1;
                if ( !*(_BYTE *)(v98 + v143) )
                  break;
                ++v143;
                if ( v144 == v141 )
                  goto LABEL_335;
              }
              v175 = v98 + v143 + 1;
              v176 = v140 + ~v143;
              if ( !v143 )
                break;
              v178.m128i_i64[1] = v98;
              v179 = v143;
              v178.m128i_i64[0] = 31LL;
              alloc::vec::Vec<T,A>::push((__int64 *)&v195, (__int64)&v178);
              v98 = v175;
              v140 = v176;
              v141 = v176 + v175;
              v102 = v142;
              if ( !v176 )
                goto LABEL_335;
            }
            v185.m128i_i64[1] = 2LL;
            v98 = 0LL;
LABEL_322:
            *(_QWORD *)&v212 = 0LL;
            *((_QWORD *)&v212 + 1) = 8LL;
            *(_QWORD *)&v213 = 0LL;
            if ( v209.m128i_i16[0] < 5u )
            {
              v145 = 31LL;
              if ( !v101 )
                v145 = 46LL;
              v174 = v145;
              v168 = v175;
              v146 = v176;
              if ( v176 )
              {
                v147 = v175 + v176;
                v177 = 0LL;
                while ( 1 )
                {
                  v163 = v168;
                  v148 = 0LL;
                  while ( *(_BYTE *)(v168 + v148) )
                  {
                    v149 = v148 + v168 + 1;
                    ++v148;
                    if ( v149 == v147 )
                      goto LABEL_360;
                  }
                  v175 = v148 + v168 + 1;
                  v176 = v146 + ~v148;
                  if ( !v148 )
                  {
                    v162 = 2LL;
                    v168 = 0LL;
                    goto LABEL_355;
                  }
                  gimli::read::line::FileEntry<R,Offset>::parse((__int64)&v178, &v175, v168, v148);
                  LOBYTE(v114) = v178.m128i_i8[8];
                  v168 = v179;
                  if ( v178.m128i_i64[0] == 46 )
                    break;
                  *(_QWORD *)&v228[56] = v182;
                  v150 = _mm_loadu_si128(&v180);
                  *(_OWORD *)&v228[40] = v181;
                  *(__m128i *)&v228[24] = v150;
                  *(__m128i *)v228 = v178;
                  *(_QWORD *)&v228[16] = v179;
                  alloc::vec::Vec<T,A>::push((__int64 *)&v212, (__int128 *)v228);
                  v146 = v176;
                  v168 = v175;
                  v147 = v176 + v175;
                  v102 = v163;
                  if ( !v176 )
                    goto LABEL_360;
                }
                LODWORD(v99) = (unsigned __int32)v178.m128i_i32[2] >> 8;
                LODWORD(v90) = HIWORD(v178.m128i_i32[2]);
                LODWORD(v101) = HIBYTE(v178.m128i_i32[2]);
                v102 = HIDWORD(v178.m128i_i64[1]);
                v162 = 2LL;
              }
              else
              {
LABEL_360:
                LODWORD(v99) = (unsigned int)v102 >> 8;
                LODWORD(v90) = WORD1(v102);
                LODWORD(v101) = BYTE3(v102);
                v102 >>= 32;
                v162 = 2LL;
                LOBYTE(v114) = 19;
              }
              v177 = 0LL;
              v151 = 0;
              v152 = v212;
              if ( !(_QWORD)v212 )
                goto LABEL_346;
              goto LABEL_345;
            }
LABEL_343:
            gimli::read::line::FileEntryFormat::parse((__int64)&v178, (__int64)&v175);
            v162 = v178.m128i_i64[1];
            v168 = v179;
            v177 = v178.m128i_i64[0];
            if ( v178.m128i_i64[0] == 0x8000000000000000LL )
            {
              LOBYTE(v114) = v178.m128i_i8[8];
              LODWORD(v99) = (unsigned __int32)v178.m128i_i32[2] >> 8;
              LODWORD(v90) = HIWORD(v178.m128i_i32[2]);
              LODWORD(v101) = HIBYTE(v178.m128i_i32[2]);
              v102 = HIDWORD(v178.m128i_i64[1]);
              v151 = 1;
              v152 = v212;
              if ( !(_QWORD)v212 )
              {
LABEL_346:
                if ( !((unsigned __int8)v151 | (v177 == 0)) )
                  _rust_dealloc(v162, 4 * v177, 2LL);
                v161 = 0;
                v98 = v168;
                goto LABEL_338;
              }
LABEL_345:
              _rust_dealloc(*((_QWORD *)&v212 + 1), v152 << 6, 8LL);
              goto LABEL_346;
            }
            gimli::read::reader::Reader::read_uleb128((__int64)&v178, &v175);
            LOBYTE(v114) = v178.m128i_i8[0];
            if ( v178.m128i_i8[0] != 75 )
            {
              LOBYTE(v99) = v178.m128i_i8[1];
              LOBYTE(v90) = v178.m128i_i8[2];
              v168 = v178.m128i_i64[1];
              LODWORD(v101) = *(unsigned __int32 *)((char *)v178.m128i_i32 + 2) >> 8;
              v102 = (*(unsigned int *)((char *)v178.m128i_u32 + 2) | ((unsigned __int64)v178.m128i_u16[3] << 32)) >> 16;
              v151 = 0;
              v152 = v212;
              if ( !(_QWORD)v212 )
                goto LABEL_346;
              goto LABEL_345;
            }
            v153 = v178.m128i_i64[1];
            v174 = 46LL;
            if ( v178.m128i_i64[1] )
            {
              v199 = v156 + (v155 << 8) + 327680;
              while ( 1 )
              {
                gimli::read::line::parse_file_v5((__int64)&v178, (unsigned __int64 *)&v175, v199, v162, v168);
                LOBYTE(v114) = v178.m128i_i8[8];
                if ( v178.m128i_i64[0] == 46 )
                  break;
                *(_QWORD *)&v224 = v182;
                v154 = _mm_loadu_si128(&v180);
                v223 = v181;
                v222 = v154;
                v220 = v178;
                v221 = (__m128i *)v179;
                alloc::vec::Vec<T,A>::push((__int64 *)&v212, (__int128 *)v220.m128i_i8);
                if ( !--v153 )
                  goto LABEL_355;
              }
              LODWORD(v99) = (unsigned __int32)v178.m128i_i32[2] >> 8;
              LODWORD(v90) = HIWORD(v178.m128i_i32[2]);
              LODWORD(v101) = HIBYTE(v178.m128i_i32[2]);
              v102 = HIDWORD(v178.m128i_i64[1]);
              v151 = 0;
              v168 = v179;
              v152 = v212;
              if ( !(_QWORD)v212 )
                goto LABEL_346;
              goto LABEL_345;
            }
LABEL_355:
            v209 = (__m128i)v209.m128i_u32[0];
            v193 += v198;
            v236 = v196;
            v235 = v195;
            v233 = v212;
            v234 = v213;
            v203 = 0LL;
            v204 = 0LL;
            *(_QWORD *)&v205 = 0LL;
            v192 = v219;
            v191 = v218;
            v102 = (unsigned __int64)v190;
            v97 = v171;
            v104 = v189;
            if ( *(_DWORD *)&src[96] == 47 )
            {
LABEL_227:
              *(_QWORD *)&src[96] = v174;
              *(_QWORD *)&src[104] = v101;
              *(_QWORD *)&src[112] = v90;
              *(_QWORD *)&src[152] = v205;
              *(_OWORD *)&src[136] = v204;
              *(__m128i *)&src[120] = v203;
              *(__m128i *)&src[160] = v185;
              *(_QWORD *)&src[176] = v98;
              *(_QWORD *)&src[200] = v236;
              *(_OWORD *)&src[184] = v235;
              *(_QWORD *)&src[208] = v177;
              *(_QWORD *)&src[216] = v162;
              *(_QWORD *)&src[224] = v168;
              *(_QWORD *)&src[248] = v234;
              *(_OWORD *)&src[232] = v233;
              *(_QWORD *)&src[256] = v197;
              *(_QWORD *)&src[264] = v210;
              *(_QWORD *)&src[272] = v193;
              *(_QWORD *)&src[280] = v187;
              *(_QWORD *)&src[288] = v104;
              *(_QWORD *)&src[296] = v231;
              *(_QWORD *)&src[304] = v198;
              *(_QWORD *)&src[312] = v99;
              *(_QWORD *)&src[320] = v186;
              src[328] = v156;
              src[329] = v155;
              *(_WORD *)&src[330] = _mm_cvtsi128_si32(_mm_load_si128(&v209));
              src[332] = v164;
              src[333] = v167;
              src[334] = v157;
              src[335] = v166;
              src[336] = v165;
              src[337] = v160;
              *(_WORD *)&src[342] = v192;
              *(_DWORD *)&src[338] = v191;
              v116 = (char *)dest;
              if ( v97 != 46 )
              {
                if ( v97 )
                {
                  if ( v97 == 12 )
                  {
                    v117 = *(_QWORD *)(v102 + 16);
                    v118 = *(_QWORD *)(v102 + 24);
                    v13 = v118 < *(_QWORD *)&src[400];
                    v119 = v118 - *(_QWORD *)&src[400];
                    if ( v13 )
                    {
                      *(__int64 *)((char *)v178.m128i_i64 + 7) = *(_QWORD *)(v102 + 16);
                      v120 = 19LL;
                    }
                    else
                    {
                      v117 += *(_QWORD *)&src[400];
                      v125 = src[72] * v211;
                      v126 = v119 - v125;
                      if ( v119 >= v125 )
                      {
                        v117 += v125;
                        switch ( src[72] )
                        {
                          case 1:
                            if ( v119 == v125 )
                            {
                              v178.m128i_i8[0] = 0;
                              *(__int16 *)((char *)&v178.m128i_i16[2] + 1) = 0;
                              *(__int32 *)((char *)v178.m128i_i32 + 1) = 0;
                              goto LABEL_242;
                            }
                            v124 = *(unsigned __int8 *)v117;
                            goto LABEL_239;
                          case 2:
                            if ( v126 > 1 )
                            {
                              v124 = *(unsigned __int16 *)v117;
                              goto LABEL_239;
                            }
                            v178.m128i_i16[0] = 0;
                            v178.m128i_i8[2] = 0;
                            *(__int32 *)((char *)v178.m128i_i32 + 3) = 0;
                            goto LABEL_242;
                          case 4:
                            if ( v126 > 3 )
                            {
                              v124 = *(unsigned int *)v117;
                              goto LABEL_239;
                            }
                            v178.m128i_i32[0] = 0;
                            v178.m128i_i8[6] = 0;
                            v178.m128i_i16[2] = 0;
                            goto LABEL_242;
                          case 8:
                            if ( v126 >= 8 )
                            {
                              v124 = *(_QWORD *)v117;
                              goto LABEL_239;
                            }
                            v220.m128i_i64[0] = 19LL;
                            v220.m128i_i64[1] = v117;
                            v178.m128i_i32[2] = v117 >> 8;
                            *(__int32 *)((char *)&v178.m128i_i32[2] + 3) = HIDWORD(v117);
                            v178.m128i_i64[0] = *(__int64 *)((char *)v220.m128i_i64 + 1);
                            v117 = HIBYTE(*(unsigned __int64 *)((char *)v220.m128i_i64 + 1));
                            break;
                          default:
                            v178.m128i_i8[0] = src[72];
                            v120 = 23LL;
                            LOBYTE(v117) = v178.m128i_i8[7];
                            goto LABEL_244;
                        }
                      }
                      else
                      {
LABEL_242:
                        *(__int64 *)((char *)v178.m128i_i64 + 7) = v117;
                      }
                      v120 = 19LL;
                    }
LABEL_244:
                    v127 = v178.m128i_i32[2];
                    v128 = v178.m128i_i16[6];
                    v129 = v178.m128i_i8[14];
                    *((_QWORD *)dest + 1) = v120 | ((unsigned __int64)((v178.m128i_u8[6] << 16) | (unsigned int)v178.m128i_u16[2]) << 40) | ((unsigned __int64)v178.m128i_u32[0] << 8);
                    v116[16] = v117;
                    v116[23] = v129;
                    *(_WORD *)(v116 + 21) = v128;
                    *(_DWORD *)(v116 + 17) = v127;
                    *(_QWORD *)v116 = 2LL;
                    goto LABEL_148;
                  }
                }
                else
                {
                  v124 = v211;
LABEL_239:
                  *(_QWORD *)&src[384] = v124;
                }
              }
              return memcpy(dest, src, 0x1A8uLL);
            }
LABEL_219:
            if ( *(_QWORD *)&src[160] )
              _rust_dealloc(*(_QWORD *)&src[168], 4LL * *(_QWORD *)&src[160], 2LL);
            if ( *(_QWORD *)&src[184] )
              _rust_dealloc(*(_QWORD *)&src[192], 24LL * *(_QWORD *)&src[184], 8LL);
            if ( *(_QWORD *)&src[208] )
              _rust_dealloc(*(_QWORD *)&src[216], 4LL * *(_QWORD *)&src[208], 2LL);
            v104 = v189;
            if ( *(_QWORD *)&src[232] )
            {
              _rust_dealloc(*(_QWORD *)&src[240], *(_QWORD *)&src[232] << 6, 8LL);
              v104 = v189;
            }
            goto LABEL_227;
          }
LABEL_335:
          LODWORD(v99) = (unsigned int)v102 >> 8;
          LODWORD(v90) = WORD1(v102);
          LODWORD(v101) = BYTE3(v102);
          v102 >>= 32;
          v185.m128i_i64[1] = 2LL;
          LOBYTE(v114) = 19;
          v185.m128i_i64[0] = 0LL;
        }
        v161 = 0;
        goto LABEL_338;
      }
      v112 += 2LL;
    }
LABEL_247:
    LOBYTE(v114) = 19;
    LOBYTE(v90) = 0;
    LOBYTE(v101) = 0;
    v102 = 0LL;
    LOBYTE(v99) = 0;
    v98 = v112;
    goto LABEL_248;
  }
  if ( v131 > 7 )
  {
    v132 = v131 - 8;
    v133 = (_BYTE *)(v98 + 8);
    v175 = v98 + 8;
    v134 = *(_QWORD *)v98;
    goto LABEL_277;
  }
  v178.m128i_i64[0] = 19LL;
  v178.m128i_i64[1] = v98;
  LOBYTE(v99) = 0;
  *(_DWORD *)&v194[8] = v98 >> 8;
  *(_DWORD *)&v194[11] = HIDWORD(v98);
  *(_QWORD *)v194 = *(__int64 *)((char *)v178.m128i_i64 + 1);
  v98 = *(_QWORD *)&v194[7];
  LOBYTE(v90) = 0;
  LOBYTE(v101) = 0;
  v102 = *(unsigned __int64 *)((char *)v178.m128i_i64 + 1) >> 24;
LABEL_281:
  LOBYTE(v114) = 19;
LABEL_248:
  v107 = (((v102 << 24) | ((unsigned __int8)v101 << 16) | ((unsigned __int8)v90 << 8) | (unsigned __int8)v99) << 8) | (unsigned __int8)v114;
LABEL_249:
  v130 = dest;
  *((_QWORD *)dest + 1) = v107;
  v130[2] = v98;
  *v130 = 2LL;
LABEL_148:
  result = *(void **)&src[344];
  if ( !_InterlockedDecrement64(*(volatile signed __int64 **)&src[344]) )
    result = (void *)alloc::sync::Arc<T,A>::drop_slow((__int64 *)&src[344]);
  if ( *(_DWORD *)&src[96] != 47 )
  {
    if ( *(_QWORD *)&src[160] )
      _rust_dealloc(*(_QWORD *)&src[168], 4LL * *(_QWORD *)&src[160], 2LL);
    result = *(void **)&src[184];
    if ( *(_QWORD *)&src[184] )
      result = (void *)_rust_dealloc(*(_QWORD *)&src[192], 24LL * *(_QWORD *)&src[184], 8LL);
    if ( *(_QWORD *)&src[208] )
      result = (void *)_rust_dealloc(*(_QWORD *)&src[216], 4LL * *(_QWORD *)&src[208], 2LL);
    if ( *(_QWORD *)&src[232] )
      return (void *)_rust_dealloc(*(_QWORD *)&src[240], *(_QWORD *)&src[232] << 6, 8LL);
  }
  return result;
}
// 142D4: variable 'v169' is possibly undefined
// 1471E: variable 'v92' is possibly undefined
// 1479E: variable 'v95' is possibly undefined
// 14C9F: variable 'v91' is possibly undefined
// 14E3E: variable 'v162' is possibly undefined
// 14E4B: variable 'v168' is possibly undefined
// 14EF3: variable 'v156' is possibly undefined
// 14EFF: variable 'v155' is possibly undefined
// 14F20: variable 'v164' is possibly undefined
// 14F2C: variable 'v167' is possibly undefined
// 14F38: variable 'v157' is possibly undefined
// 14F44: variable 'v166' is possibly undefined
// 14F50: variable 'v165' is possibly undefined
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 137C0: using guessed type __m128i var_78;

//----- (0000000000015FF0) ----------------------------------------------------
__int64 __fastcall gimli::read::dwarf::Dwarf<R>::attr_string(
        __int64 a1,
        _QWORD *a2,
        unsigned __int8 a3,
        unsigned __int64 a4,
        _QWORD *a5)
{
  char v5; // bl
  unsigned __int8 v6; // r10
  unsigned __int8 v7; // r11
  unsigned __int64 v8; // rdx
  __int64 v9; // rcx
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  __int64 i; // rdx
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // r9
  bool v15; // cf
  unsigned __int64 v16; // r9
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rcx
  __int64 result; // rax
  __int64 v20; // rax
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rax
  __int64 v30; // xmm0_8
  __int128 v31; // [rsp+10h] [rbp-28h]

  switch ( *a5 )
  {
    case 0x1ALL:
      v8 = a5[1];
      v9 = a2[12];
      v10 = a2[13];
      if ( v10 < v8 )
        goto LABEL_37;
      v9 += v8;
      v11 = v10 - v8;
      if ( !v11 )
        goto LABEL_37;
      for ( i = 0LL; i != v11; ++i )
      {
        if ( !*(_BYTE *)(v9 + i) )
          goto LABEL_38;
      }
      goto LABEL_37;
    case 0x1BLL:
      v20 = a2[26];
      if ( !v20 )
        goto LABEL_19;
      v21 = a5[1];
      v9 = *(_QWORD *)(v20 + 112);
      v22 = *(_QWORD *)(v20 + 120);
      if ( v22 < v21 )
        goto LABEL_37;
      v9 += v21;
      v23 = v22 - v21;
      if ( !v23 )
        goto LABEL_37;
      i = 0LL;
      while ( *(_BYTE *)(v9 + i) )
      {
        if ( v23 == ++i )
          goto LABEL_37;
      }
      goto LABEL_38;
    case 0x1DLL:
      v13 = a2[14];
      v14 = a2[15];
      v15 = v14 < a4;
      v16 = v14 - a4;
      if ( v15 || (v13 += a4, v17 = a5[1] * a3, v15 = v16 < v17, v16 -= v17, v15) )
      {
        v18 = v13 >> 8;
LABEL_11:
        *(_BYTE *)(a1 + 8) = 19;
        *(_BYTE *)(a1 + 15) = v5;
        *(_DWORD *)(a1 + 9) = v6 | (v7 << 8) | ((unsigned __int8)v16 << 16) | ((unsigned __int8)a5 << 24);
        *(_WORD *)(a1 + 13) = a3 | ((unsigned __int8)a2 << 8);
        *(_QWORD *)(a1 + 16) = (v18 << 8) | (unsigned __int8)v13;
        result = 1LL;
        *(_QWORD *)a1 = 1LL;
        return result;
      }
      v13 += v17;
      if ( a3 != 8 )
      {
        if ( v16 > 3 )
        {
          v27 = *(unsigned int *)v13;
          goto LABEL_32;
        }
        v18 = v13 >> 8;
        v30 = 0LL;
LABEL_41:
        v5 = BYTE6(v30);
        LOBYTE(a2) = BYTE5(v30);
        a3 = BYTE4(v30);
        LOBYTE(a5) = BYTE3(v30);
        LOBYTE(v16) = BYTE2(v30);
        v6 = v30;
        v7 = BYTE1(v30);
        goto LABEL_11;
      }
      if ( v16 <= 7 )
      {
        *(_QWORD *)&v31 = 19LL;
        BYTE8(v31) = v13;
        v30 = *(_QWORD *)((char *)&v31 + 1);
        v18 = ((unsigned __int64)((HIBYTE(v13) << 16) | (unsigned int)(unsigned __int16)(HIDWORD(v13) >> 8)) << 32) | (unsigned int)(v13 >> 8);
        goto LABEL_41;
      }
      v27 = *(_QWORD *)v13;
LABEL_32:
      v9 = a2[12];
      v28 = a2[13];
      if ( v28 >= v27 && (v9 += v27, (v29 = v28 - v27) != 0) )
      {
        i = 0LL;
        while ( *(_BYTE *)(v9 + i) )
        {
          if ( v29 == ++i )
            goto LABEL_37;
        }
LABEL_38:
        *(_QWORD *)(a1 + 8) = v9;
        result = 0LL;
        *(_QWORD *)(a1 + 16) = i;
        *(_QWORD *)a1 = 0LL;
      }
      else
      {
LABEL_37:
        *(_BYTE *)(a1 + 8) = 19;
        result = 1LL;
        *(_QWORD *)(a1 + 16) = v9;
        *(_QWORD *)a1 = 1LL;
      }
      return result;
    case 0x1ELL:
      v24 = a5[1];
      v9 = a2[10];
      v25 = a2[11];
      if ( v25 < v24 )
        goto LABEL_37;
      v9 += v24;
      v26 = v25 - v24;
      if ( !v26 )
        goto LABEL_37;
      i = 0LL;
      while ( *(_BYTE *)(v9 + i) )
      {
        if ( v26 == ++i )
          goto LABEL_37;
      }
      goto LABEL_38;
    case 0x1FLL:
      *(_OWORD *)(a1 + 8) = *(_OWORD *)(a5 + 1);
      result = 0LL;
      *(_QWORD *)a1 = 0LL;
      return result;
    default:
LABEL_19:
      *(_BYTE *)(a1 + 8) = 69;
      result = 1LL;
      *(_QWORD *)a1 = 1LL;
      return result;
  }
}
// 1608D: variable 'v5' is possibly undefined
// 16090: variable 'v6' is possibly undefined
// 16094: variable 'v7' is possibly undefined

//----- (0000000000016250) ----------------------------------------------------
void __fastcall gimli::read::index::UnitIndex<R>::parse(__int64 a1, unsigned int *a2, unsigned __int64 a3)
{
  __int64 v3; // rcx
  __int16 v4; // ax
  unsigned __int64 v5; // r8
  unsigned int v6; // ebx
  unsigned int v7; // ebp
  unsigned __int64 v8; // rdx
  unsigned int *v9; // r8
  unsigned __int64 v10; // r10
  bool v11; // cf
  unsigned __int64 v12; // rdx
  unsigned int *v13; // r11
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // rdx
  unsigned int v16; // esi
  unsigned int *v17; // r12
  unsigned int v18; // ecx
  unsigned __int64 v19; // r14
  unsigned __int64 v20; // r13
  unsigned __int8 v21; // r15
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  unsigned int v24; // ecx
  int v25; // r14d
  unsigned int *v26; // rcx
  unsigned __int8 v27; // r14
  char *v28; // r15
  unsigned int v29; // ecx
  unsigned int *v30; // r15
  unsigned __int64 v31; // r14
  unsigned int v32; // ecx
  int v33; // r14d
  unsigned int v34; // ecx
  int v35; // r14d
  unsigned int v36; // ecx
  int v37; // r14d
  unsigned int v38; // ecx
  int v39; // r14d
  unsigned int v40; // ecx
  int v41; // r14d
  unsigned int v42; // ecx
  int v43; // r14d
  unsigned int v44; // ecx
  unsigned int v45; // ecx
  unsigned int v46; // ecx
  unsigned int v47; // ecx
  unsigned int v48; // ecx
  unsigned int v49; // ecx
  int v50; // r14d
  unsigned int *v51; // [rsp+0h] [rbp-70h]
  unsigned __int64 v52; // [rsp+0h] [rbp-70h]
  unsigned __int64 v53; // [rsp+8h] [rbp-68h]
  unsigned __int64 v54; // [rsp+8h] [rbp-68h]
  unsigned __int64 v55; // [rsp+10h] [rbp-60h]
  unsigned __int64 v56; // [rsp+18h] [rbp-58h]
  unsigned __int64 v57; // [rsp+20h] [rbp-50h]
  unsigned __int64 v58; // [rsp+28h] [rbp-48h]
  unsigned __int64 v59; // [rsp+30h] [rbp-40h]
  unsigned __int64 v60; // [rsp+38h] [rbp-38h]

  if ( !a3 )
  {
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_QWORD *)(a1 + 24) = a2;
    *(_QWORD *)(a1 + 32) = 0LL;
    *(_QWORD *)(a1 + 40) = a2;
    *(_QWORD *)(a1 + 48) = 0LL;
    *(_QWORD *)(a1 + 56) = a2;
    *(_OWORD *)(a1 + 64) = 0LL;
    *(_DWORD *)(a1 + 80) = 0;
    *(_WORD *)(a1 + 84) = 5;
    return;
  }
  if ( a3 <= 3 )
    goto LABEL_13;
  v3 = *a2;
  v4 = 2;
  if ( v3 != 2 )
  {
    v4 = 5;
    if ( (_WORD)v3 != 5 )
    {
      *(_BYTE *)(a1 + 8) = 17;
      *(_QWORD *)(a1 + 16) = (unsigned __int16)v3;
      *(_BYTE *)a1 = 22;
      return;
    }
  }
  v5 = a3 & 0xFFFFFFFFFFFFFFFCLL;
  if ( (a3 & 0xFFFFFFFFFFFFFFFCLL) == 4 )
  {
    ++a2;
LABEL_13:
    *(_BYTE *)(a1 + 8) = 19;
    *(_DWORD *)(a1 + 9) = 0;
    *(_BYTE *)(a1 + 15) = 0;
    *(_WORD *)(a1 + 13) = 0;
    *(_QWORD *)(a1 + 16) = a2;
    *(_BYTE *)a1 = 22;
    return;
  }
  if ( v5 == 8 )
  {
    a2 += 2;
    goto LABEL_13;
  }
  if ( v5 == 12 )
  {
    a2 += 3;
    goto LABEL_13;
  }
  v6 = a2[3];
  if ( !v6
    || (v7 = a2[2], v6 <= v7)
    || (16843009
      * ((((v6 - ((v6 >> 1) & 0x55555555)) & 0x33333333)
        + (((v6 - ((v6 >> 1) & 0x55555555)) >> 2) & 0x33333333)
        + ((((v6 - ((v6 >> 1) & 0x55555555)) & 0x33333333) + (((v6 - ((v6 >> 1) & 0x55555555)) >> 2) & 0x33333333)) >> 4)) & 0xF0F0F0F)) >> 24 > 1 )
  {
    *(_BYTE *)(a1 + 8) = 72;
    goto LABEL_20;
  }
  v8 = a3 - 16;
  v9 = a2 + 4;
  v10 = 8LL * v6;
  v11 = v8 < v10;
  v12 = v8 - v10;
  if ( v11 )
  {
    *(_QWORD *)(a1 + 8) = 19LL;
    *(_QWORD *)(a1 + 16) = v9;
    goto LABEL_20;
  }
  v13 = &v9[v10 / 4];
  v14 = 4LL * v6;
  v11 = v12 < v14;
  v15 = v12 - v14;
  if ( v11 )
  {
    *(_QWORD *)(a1 + 8) = 19LL;
    *(_QWORD *)(a1 + 16) = v13;
    goto LABEL_20;
  }
  v16 = a2[1];
  if ( v16 > 8 )
  {
    *(_BYTE *)(a1 + 8) = 71;
    goto LABEL_20;
  }
  v17 = &v13[v14 / 4];
  if ( !v16 )
  {
    v21 = 0;
    LOWORD(v60) = 0;
    LOBYTE(v59) = 0;
    LODWORD(v58) = 0;
    LOBYTE(v57) = 0;
    LOBYTE(v56) = 0;
    LOBYTE(v20) = 0;
    v54 = 0LL;
    goto LABEL_36;
  }
  if ( (_DWORD)v3 != 2 )
  {
    if ( v15 <= 3 )
      goto LABEL_42;
    v24 = *v17 - 1;
    if ( v24 >= 8 )
      goto LABEL_41;
    v25 = 253;
    if ( !_bittest(&v25, v24) )
      goto LABEL_41;
    v52 = v15 - 4;
    v30 = v17 + 1;
    v53 = 0x110D130B08000707LL;
    v55 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v24);
    if ( v16 == 1 )
    {
      LOWORD(v60) = 0;
    }
    else
    {
      v26 = v17 + 1;
      if ( v52 < 4 )
        goto LABEL_43;
      v32 = v17[1] - 1;
      if ( v32 > 7 )
        goto LABEL_41;
      v33 = 253;
      if ( !_bittest(&v33, v32) )
        goto LABEL_41;
      v52 = v15 - 8;
      v30 = v17 + 2;
      v60 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v32);
      if ( v16 != 2 )
      {
        v26 = v17 + 2;
        if ( v52 < 4 )
          goto LABEL_43;
        v34 = v17[2] - 1;
        if ( v34 > 7 )
          goto LABEL_41;
        v35 = 253;
        if ( !_bittest(&v35, v34) )
          goto LABEL_41;
        v52 = v15 - 12;
        v30 = v17 + 3;
        v59 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v34);
        if ( v16 != 3 )
        {
          v26 = v17 + 3;
          if ( v52 < 4 )
            goto LABEL_43;
          v36 = v17[3] - 1;
          if ( v36 > 7 )
            goto LABEL_41;
          v37 = 253;
          if ( !_bittest(&v37, v36) )
            goto LABEL_41;
          v52 = v15 - 16;
          v30 = v17 + 4;
          v58 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v36);
          if ( v16 != 4 )
          {
            v26 = v17 + 4;
            if ( v52 < 4 )
              goto LABEL_43;
            v38 = v17[4] - 1;
            if ( v38 > 7 )
              goto LABEL_41;
            v39 = 253;
            if ( !_bittest(&v39, v38) )
              goto LABEL_41;
            v52 = v15 - 20;
            v30 = v17 + 5;
            v57 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v38);
            if ( v16 != 5 )
            {
              v26 = v17 + 5;
              if ( v52 < 4 )
                goto LABEL_43;
              v40 = v17[5] - 1;
              if ( v40 > 7 )
                goto LABEL_41;
              v41 = 253;
              if ( !_bittest(&v41, v40) )
                goto LABEL_41;
              v52 = v15 - 24;
              v30 = v17 + 6;
              v56 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v40);
              if ( v16 != 6 )
              {
                v26 = v17 + 6;
                if ( v52 >= 4 )
                {
                  v42 = v17[6] - 1;
                  if ( v42 > 7 )
                    goto LABEL_41;
                  v43 = 253;
                  if ( !_bittest(&v43, v42) )
                    goto LABEL_41;
                  v20 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v42);
                  if ( v16 == 7 )
                  {
                    v54 = 0LL;
                    v15 -= 28LL;
                    v17 += 7;
                    v21 = v55;
                    goto LABEL_36;
                  }
                  v26 = v17 + 7;
                  if ( v15 - 28 >= 4 )
                  {
                    v49 = v17[7] - 1;
                    if ( v49 <= 7 )
                    {
                      v50 = 253;
                      if ( _bittest(&v50, v49) )
                      {
                        v15 -= 32LL;
                        v17 += 8;
                        goto LABEL_104;
                      }
                    }
                    goto LABEL_41;
                  }
                }
LABEL_43:
                *(_BYTE *)(a1 + 8) = 19;
                *(_DWORD *)(a1 + 9) = 0;
                *(_BYTE *)(a1 + 15) = 0;
                *(_WORD *)(a1 + 13) = 0;
                *(_QWORD *)(a1 + 16) = v26;
                goto LABEL_20;
              }
LABEL_59:
              LOBYTE(v20) = 0;
              v54 = 0LL;
              v15 = v52;
              goto LABEL_60;
            }
LABEL_58:
            LOBYTE(v56) = 0;
            goto LABEL_59;
          }
LABEL_57:
          LOBYTE(v57) = 0;
          goto LABEL_58;
        }
LABEL_56:
        LODWORD(v58) = 0;
        goto LABEL_57;
      }
    }
    LOBYTE(v59) = 0;
    goto LABEL_56;
  }
  if ( v15 < 4 )
  {
LABEL_42:
    v26 = &v13[v14 / 4];
    goto LABEL_43;
  }
  v18 = *v17 - 1;
  if ( v18 > 7 )
    goto LABEL_41;
  v51 = v17 + 1;
  v19 = v15 - 4;
  v53 = 0xD0C130A08001507LL;
  v55 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v18);
  if ( v16 == 1 )
  {
    LOWORD(v60) = 0;
    LOBYTE(v59) = 0;
    LODWORD(v58) = 0;
LABEL_32:
    LOBYTE(v57) = 0;
LABEL_33:
    LOBYTE(v56) = 0;
LABEL_34:
    LOBYTE(v20) = 0;
    v54 = 0LL;
    v15 = v19;
    v17 = v51;
    v21 = v55;
    goto LABEL_36;
  }
  if ( v19 < 4 )
    goto LABEL_105;
  v29 = *v51 - 1;
  if ( v29 > 7 )
    goto LABEL_41;
  v30 = v17 + 2;
  v31 = v15 - 8;
  v60 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v29);
  if ( v16 == 2 )
  {
    LOBYTE(v59) = 0;
LABEL_51:
    LODWORD(v58) = 0;
    LOBYTE(v57) = 0;
    LOBYTE(v56) = 0;
    LOBYTE(v20) = 0;
LABEL_52:
    v54 = 0LL;
    v15 = v31;
LABEL_60:
    v17 = v30;
    v21 = v55;
    goto LABEL_36;
  }
  if ( v31 < 4 )
    goto LABEL_106;
  v44 = *v30 - 1;
  if ( v44 > 7 )
    goto LABEL_41;
  v30 = v17 + 3;
  v31 = v15 - 12;
  v59 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v44);
  if ( v16 == 3 )
    goto LABEL_51;
  if ( v31 < 4 )
    goto LABEL_106;
  v45 = *v30 - 1;
  if ( v45 > 7 )
    goto LABEL_41;
  v51 = v17 + 4;
  v19 = v15 - 16;
  v58 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v45);
  if ( v16 == 4 )
    goto LABEL_32;
  if ( v19 < 4 )
    goto LABEL_105;
  v46 = *v51 - 1;
  if ( v46 > 7 )
    goto LABEL_41;
  v51 = v17 + 5;
  v19 = v15 - 20;
  v57 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v46);
  if ( v16 == 5 )
    goto LABEL_33;
  if ( v19 < 4 )
    goto LABEL_105;
  v47 = *v51 - 1;
  if ( v47 > 7 )
  {
LABEL_41:
    *(_BYTE *)(a1 + 8) = 74;
    goto LABEL_20;
  }
  v51 = v17 + 6;
  v19 = v15 - 24;
  v56 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v47);
  if ( v16 == 6 )
    goto LABEL_34;
  if ( v19 < 4 )
  {
LABEL_105:
    v26 = v51;
    goto LABEL_43;
  }
  v48 = *v51 - 1;
  if ( v48 > 7 )
    goto LABEL_41;
  v30 = v17 + 7;
  v31 = v15 - 28;
  v20 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v48);
  if ( v16 == 7 )
    goto LABEL_52;
  if ( v31 < 4 )
  {
LABEL_106:
    v26 = v30;
    goto LABEL_43;
  }
  v49 = *v30 - 1;
  if ( v49 > 7 )
    goto LABEL_41;
  v17 += 8;
  v15 -= 32LL;
LABEL_104:
  v54 = v53 >> (8 * (unsigned __int8)v49);
  v21 = v55;
LABEL_36:
  v22 = v7 * (unsigned __int64)(4 * v16);
  v11 = v15 < v22;
  v23 = v15 - v22;
  if ( v11 )
  {
    *(_QWORD *)(a1 + 8) = 19LL;
    *(_QWORD *)(a1 + 16) = v17;
  }
  else
  {
    v27 = v21;
    v28 = (char *)v17 + v22;
    if ( v23 >= v22 )
    {
      *(_QWORD *)a1 = (v54 << 56) | ((unsigned __int64)(unsigned __int8)v20 << 48) | ((unsigned __int64)(unsigned __int8)v56 << 40) | ((unsigned __int64)(unsigned __int8)v57 << 32) | (unsigned int)((_DWORD)v58 << 24) | ((unsigned __int8)v59 << 16) | (unsigned __int16)((_WORD)v60 << 8) | v27;
      *(_QWORD *)(a1 + 8) = v9;
      *(_QWORD *)(a1 + 16) = v10;
      *(_QWORD *)(a1 + 24) = v13;
      *(_QWORD *)(a1 + 32) = v14;
      *(_QWORD *)(a1 + 40) = v17;
      *(_QWORD *)(a1 + 48) = v22;
      *(_QWORD *)(a1 + 56) = v28;
      *(_QWORD *)(a1 + 64) = v22;
      *(_DWORD *)(a1 + 72) = _mm_cvtsi128_si32(_mm_cvtsi32_si128(v16));
      *(_DWORD *)(a1 + 76) = _mm_cvtsi128_si32(_mm_cvtsi32_si128(v7));
      *(_DWORD *)(a1 + 80) = _mm_cvtsi128_si32(_mm_cvtsi32_si128(v6));
      *(_WORD *)(a1 + 84) = v4;
      return;
    }
    *(_QWORD *)(a1 + 8) = 19LL;
    *(_QWORD *)(a1 + 16) = v28;
  }
LABEL_20:
  *(_BYTE *)a1 = 22;
}

//----- (0000000000016AA0) ----------------------------------------------------
unsigned __int64 __fastcall gimli::read::reader::Reader::read_offset(__int64 a1, unsigned __int64 *a2, char a3)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rcx
  __int64 v7; // [rsp+0h] [rbp-18h]
  __int128 v8; // [rsp+8h] [rbp-10h]

  if ( a3 == 8 )
  {
    v3 = *a2;
    v4 = a2[1];
    if ( v4 <= 7 )
    {
      *(_QWORD *)&v8 = 19LL;
      *((_QWORD *)&v8 + 1) = *a2;
      LODWORD(v7) = v3 >> 8;
      *(_DWORD *)((char *)&v7 + 3) = HIDWORD(*a2);
      *(_QWORD *)(a1 + 1) = *(_QWORD *)((char *)&v8 + 1);
      result = (unsigned int)v7;
      *(_DWORD *)(a1 + 9) = v7;
      *(_DWORD *)(a1 + 12) = *(_DWORD *)((char *)&v7 + 3);
      *(_BYTE *)a1 = 19;
    }
    else
    {
      *a2 = v3 + 8;
      a2[1] = v4 - 8;
      result = *(_QWORD *)v3;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 75;
    }
  }
  else
  {
    result = *a2;
    v6 = a2[1];
    if ( v6 <= 3 )
    {
      *(_DWORD *)(a1 + 1) = 0;
      *(_BYTE *)(a1 + 7) = 0;
      *(_WORD *)(a1 + 5) = 0;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 19;
    }
    else
    {
      *a2 = result + 4;
      a2[1] = v6 - 4;
      result = *(unsigned int *)result;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 75;
    }
  }
  return result;
}

//----- (0000000000016B50) ----------------------------------------------------
char __fastcall gimli::read::reader::Reader::read_address(__int64 a1, unsigned __int64 *a2, char a3)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rcx
  __int64 v9; // [rsp+0h] [rbp-18h]
  __int128 v10; // [rsp+8h] [rbp-10h]

  LOBYTE(v3) = a3 - 1;
  switch ( a3 )
  {
    case 1:
      v3 = *a2;
      v4 = a2[1];
      if ( v4 )
      {
        *a2 = v3 + 1;
        a2[1] = v4 - 1;
        v3 = *(unsigned __int8 *)v3;
        *(_QWORD *)(a1 + 8) = v3;
        *(_BYTE *)a1 = 75;
      }
      else
      {
        *(_WORD *)a1 = 19;
        *(_WORD *)(a1 + 6) = 0;
        *(_DWORD *)(a1 + 2) = 0;
        *(_QWORD *)(a1 + 8) = v3;
      }
      break;
    case 2:
      v3 = *a2;
      v6 = a2[1];
      if ( v6 <= 1 )
      {
        *(_WORD *)(a1 + 1) = 0;
        *(_BYTE *)(a1 + 3) = 0;
        *(_DWORD *)(a1 + 4) = 0;
        *(_QWORD *)(a1 + 8) = v3;
        *(_BYTE *)a1 = 19;
      }
      else
      {
        *a2 = v3 + 2;
        a2[1] = v6 - 2;
        v3 = *(unsigned __int16 *)v3;
        *(_QWORD *)(a1 + 8) = v3;
        *(_BYTE *)a1 = 75;
      }
      break;
    case 4:
      v3 = *a2;
      v5 = a2[1];
      if ( v5 <= 3 )
      {
        *(_DWORD *)(a1 + 1) = 0;
        *(_BYTE *)(a1 + 7) = 0;
        *(_WORD *)(a1 + 5) = 0;
        *(_QWORD *)(a1 + 8) = v3;
        *(_BYTE *)a1 = 19;
      }
      else
      {
        *a2 = v3 + 4;
        a2[1] = v5 - 4;
        v3 = *(unsigned int *)v3;
        *(_QWORD *)(a1 + 8) = v3;
        *(_BYTE *)a1 = 75;
      }
      break;
    case 8:
      v3 = *a2;
      v7 = a2[1];
      if ( v7 < 8 )
      {
        *(_QWORD *)&v10 = 19LL;
        *((_QWORD *)&v10 + 1) = *a2;
        LODWORD(v9) = v3 >> 8;
        *(_DWORD *)((char *)&v9 + 3) = HIDWORD(*a2);
        *(_QWORD *)(a1 + 1) = *(_QWORD *)((char *)&v10 + 1);
        *(_DWORD *)(a1 + 9) = v9;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)((char *)&v9 + 3);
        LOBYTE(v3) = 19;
        *(_BYTE *)a1 = 19;
      }
      else
      {
        *a2 = v3 + 8;
        a2[1] = v7 - 8;
        *(_QWORD *)(a1 + 8) = *(_QWORD *)v3;
        LOBYTE(v3) = 75;
        *(_BYTE *)a1 = 75;
      }
      break;
    default:
      *(_BYTE *)a1 = 23;
      *(_BYTE *)(a1 + 1) = a3;
      break;
  }
  return v3;
}

//----- (0000000000016CA0) ----------------------------------------------------
__int64 __fastcall gimli::read::reader::Reader::read_uleb128(__int64 a1, __int64 *a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 result; // rax
  __int64 v5; // r8
  __int64 v6; // rdx
  __int64 v7; // r9
  int v8; // ecx
  char v9; // r10

  v2 = *a2;
  v3 = a2[1];
  if ( v3 )
  {
    result = v2 + v3;
    v5 = 1 - v3;
    v6 = v2 + 1;
    v7 = 0LL;
    v8 = 0;
    while ( 1 )
    {
      v9 = *(_BYTE *)(v6 - 1);
      if ( v8 == 63 && (unsigned __int8)v9 >= 2u )
      {
        *a2 = v6;
        a2[1] = -v5;
        *(_BYTE *)a1 = 6;
        return result;
      }
      v7 |= (unsigned __int64)(v9 & 0x7F) << v8;
      if ( v9 >= 0 )
        break;
      v8 += 7;
      ++v5;
      ++v6;
      if ( v5 == 1 )
      {
        *a2 = result;
        a2[1] = 0LL;
        goto LABEL_9;
      }
    }
    *a2 = v6;
    a2[1] = -v5;
    *(_QWORD *)(a1 + 8) = v7;
    *(_BYTE *)a1 = 75;
  }
  else
  {
    result = *a2;
LABEL_9:
    *(_WORD *)a1 = 19;
    *(_WORD *)(a1 + 6) = 0;
    *(_DWORD *)(a1 + 2) = 0;
    *(_QWORD *)(a1 + 8) = result;
  }
  return result;
}

//----- (0000000000016D50) ----------------------------------------------------
__int64 __fastcall gimli::read::reader::Reader::read_sized_offset(__int64 a1, unsigned __int64 *a2, char a3)
{
  unsigned __int8 *v3; // rax
  unsigned __int8 *v4; // rcx
  __int64 result; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rcx
  char v10; // al
  _BYTE v11[15]; // [rsp+0h] [rbp-20h]
  __int128 v12; // [rsp+10h] [rbp-10h]

  switch ( a3 )
  {
    case 1:
      v3 = (unsigned __int8 *)*a2;
      v4 = (unsigned __int8 *)a2[1];
      if ( !v4 )
      {
        v11[0] = 0;
        *(_WORD *)&v11[5] = 0;
        *(_DWORD *)&v11[1] = 0;
        goto LABEL_15;
      }
      *a2 = (unsigned __int64)(v3 + 1);
      a2[1] = (unsigned __int64)(v4 - 1);
      result = *v3;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 75;
      break;
    case 2:
      v3 = (unsigned __int8 *)*a2;
      v7 = a2[1];
      if ( v7 <= 1 )
      {
        *(_WORD *)v11 = 0;
        v11[2] = 0;
        *(_DWORD *)&v11[3] = 0;
        goto LABEL_15;
      }
      *a2 = (unsigned __int64)(v3 + 2);
      a2[1] = v7 - 2;
      result = *(unsigned __int16 *)v3;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 75;
      break;
    case 4:
      v3 = (unsigned __int8 *)*a2;
      v6 = a2[1];
      if ( v6 <= 3 )
      {
        *(_DWORD *)v11 = 0;
        v11[6] = 0;
        *(_WORD *)&v11[4] = 0;
LABEL_15:
        *(_QWORD *)&v11[7] = v3;
        goto LABEL_16;
      }
      *a2 = (unsigned __int64)(v3 + 4);
      a2[1] = v6 - 4;
      result = *(unsigned int *)v3;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 75;
      break;
    case 8:
      v8 = *a2;
      v9 = a2[1];
      if ( v9 < 8 )
      {
        *(_QWORD *)&v12 = 19LL;
        *((_QWORD *)&v12 + 1) = *a2;
        *(_DWORD *)&v11[8] = v8 >> 8;
        *(_DWORD *)&v11[11] = HIDWORD(*a2);
        *(_QWORD *)v11 = *(_QWORD *)((char *)&v12 + 1);
LABEL_16:
        v10 = 19;
        goto LABEL_17;
      }
      *a2 = v8 + 8;
      a2[1] = v9 - 8;
      result = *(_QWORD *)v8;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 75;
      break;
    default:
      v11[0] = a3;
      v10 = 24;
LABEL_17:
      *(_BYTE *)a1 = v10;
      result = *(_QWORD *)v11;
      *(_QWORD *)(a1 + 1) = *(_QWORD *)v11;
      *(_QWORD *)(a1 + 8) = *(_QWORD *)&v11[7];
      break;
  }
  return result;
}
// 16E86: variable 'v11' is possibly undefined

//----- (0000000000016EA0) ----------------------------------------------------
char __fastcall gimli::read::aranges::ArangeHeader<R,Offset>::parse(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // r10
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  __int64 v8; // rax
  char v9; // r8
  unsigned __int64 v10; // r9
  bool v11; // cf
  unsigned int *v12; // r10
  unsigned int v13; // esi
  unsigned __int64 v14; // r11
  unsigned __int64 v15; // r10
  unsigned __int64 v16; // r11
  __int64 v17; // r10
  unsigned __int64 v18; // r11
  char v19; // bl
  char v20; // bp
  unsigned __int8 v21; // r14
  unsigned __int64 v22; // r11
  char v23; // al
  bool v24; // zf
  unsigned __int64 v25; // r11
  __int128 v27; // [rsp+0h] [rbp-48h]
  __int128 v28; // [rsp+0h] [rbp-48h]
  _BYTE v29[15]; // [rsp+10h] [rbp-38h]
  int v30; // [rsp+23h] [rbp-25h]

  v3 = *a2;
  v4 = a2[1];
  if ( v4 < 4 )
  {
    v8 = 19LL;
    v6 = v3 >> 8;
    goto LABEL_6;
  }
  v5 = v4 - 4;
  v6 = v3 + 4;
  *a2 = v3 + 4;
  a2[1] = v4 - 4;
  v7 = *(unsigned int *)v3;
  if ( *(_DWORD *)v3 >> 4 != 0xFFFFFFF )
  {
    v9 = 4;
    v10 = v7;
    v11 = v5 < v7;
    v12 = (unsigned int *)(v5 - v7);
    if ( v11 )
      goto LABEL_15;
    goto LABEL_8;
  }
  if ( (_DWORD)v7 == -1 )
  {
    if ( v5 < 8 )
    {
      *(_QWORD *)&v27 = 19LL;
      BYTE8(v27) = v3 + 4;
      v6 >>= 8;
      v3 = HIBYTE(*(_QWORD *)((char *)&v27 + 1));
      v8 = (*(_QWORD *)((char *)&v27 + 1) << 8) | 0x13LL;
      goto LABEL_6;
    }
    v18 = v4 - 12;
    v6 = v3 + 12;
    *a2 = v3 + 12;
    a2[1] = v18;
    v10 = *(_QWORD *)(v3 + 4);
    v9 = 8;
    v12 = (unsigned int *)(v18 - v10);
    if ( v18 < v10 )
      goto LABEL_15;
LABEL_8:
    *a2 = v6 + v10;
    a2[1] = (unsigned __int64)v12;
    if ( v10 > 1 )
    {
      v13 = *(unsigned __int16 *)v6;
      if ( (*(_WORD *)v6 & 0xFFFE) != 2 )
      {
        LOBYTE(v7) = *(_WORD *)v6;
        *(_BYTE *)a1 = 17;
        *(_QWORD *)(a1 + 8) = (unsigned __int16)v13;
        goto LABEL_17;
      }
      v14 = v10 - 2;
      v15 = v6 + 2;
      if ( (unsigned int)v7 < 0xFFFFFFF0 )
      {
        if ( v14 > 3 )
        {
          v16 = v10 - 6;
          v17 = *(unsigned int *)(v6 + 2);
          v6 += 6LL;
          goto LABEL_22;
        }
        *(_DWORD *)v29 = 0;
        v29[6] = 0;
        *(_WORD *)&v29[4] = 0;
      }
      else
      {
        if ( v14 > 7 )
        {
          v16 = v10 - 10;
          v17 = *(_QWORD *)(v6 + 2);
          v6 += 10LL;
LABEL_22:
          if ( v16 )
          {
            if ( v16 != 1 )
            {
              v19 = *(_BYTE *)v6;
              LOBYTE(v7) = (unsigned int)v7 >= 0xFFFFFFF0;
              if ( *(char *)v6 < 0
                || (v20 = *(_BYTE *)(v6 + 1), v21 = v20 + 2 * v19, __CFADD__(v20, 2 * v19))
                || !(v20 + 2 * v19) )
              {
                *(_BYTE *)a1 = 48;
                goto LABEL_17;
              }
              v22 = v16 - 2;
              v6 += 2LL;
              v23 = (unsigned __int8)(v9 + 8 * v7 + 8) % v21;
              v24 = v23 == 0;
              LOBYTE(v7) = v21 - v23;
              if ( v24 )
                LOBYTE(v7) = 0;
              v11 = v22 < (unsigned __int8)v7;
              v25 = v22 - (unsigned __int8)v7;
              if ( !v11 )
              {
                *(_QWORD *)a1 = (unsigned __int8)v7 + v6;
                *(_QWORD *)(a1 + 8) = v25;
                *(_QWORD *)(a1 + 16) = a3;
                *(_QWORD *)(a1 + 24) = v10;
                *(_QWORD *)(a1 + 32) = v17;
                *(_BYTE *)(a1 + 40) = v19;
                *(_BYTE *)(a1 + 41) = v9;
                LOWORD(v7) = _mm_cvtsi128_si32(_mm_cvtsi32_si128(v13));
                *(_WORD *)(a1 + 42) = v7;
                *(_BYTE *)(a1 + 44) = v20;
                return v7;
              }
              *(_BYTE *)a1 = 19;
              goto LABEL_16;
            }
            ++v6;
          }
          *(_WORD *)a1 = 19;
          *(_WORD *)(a1 + 6) = 0;
          *(_DWORD *)(a1 + 2) = 0;
LABEL_16:
          *(_QWORD *)(a1 + 8) = v6;
          goto LABEL_17;
        }
        *(_QWORD *)&v28 = 19LL;
        BYTE8(v28) = v6 + 2;
        *(_DWORD *)&v29[8] = v15 >> 8;
        *(_DWORD *)&v29[11] = (v6 + 2) >> 32;
        *(_QWORD *)v29 = *(_QWORD *)((char *)&v28 + 1);
        v15 = *(_QWORD *)&v29[7];
      }
      v30 = *(_DWORD *)&v29[3];
      LOBYTE(v30) = v29[3];
      *(_BYTE *)a1 = 19;
      LOBYTE(v7) = v29[0];
      *(_DWORD *)(a1 + 1) = *(_DWORD *)v29;
      *(_DWORD *)(a1 + 4) = v30;
      *(_QWORD *)(a1 + 8) = v15;
      goto LABEL_17;
    }
LABEL_15:
    *(_QWORD *)a1 = 19LL;
    goto LABEL_16;
  }
  v8 = 16LL;
LABEL_6:
  *(_QWORD *)a1 = v8;
  *(_BYTE *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 9) = v6;
  v7 = HIWORD(v6);
  *(_BYTE *)(a1 + 15) = BYTE6(v6);
  *(_WORD *)(a1 + 13) = WORD2(v6);
LABEL_17:
  *(_BYTE *)(a1 + 41) = 3;
  return v7;
}

//----- (0000000000017130) ----------------------------------------------------
unsigned __int64 __fastcall gimli::read::rnglists::RngListIter<R>::next(_QWORD *a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rsi
  unsigned __int64 *v4; // rbp
  __int64 v5; // r15
  _BYTE *v6; // rdi
  unsigned __int64 v7; // rax
  __int64 v8; // r9
  unsigned __int64 v9; // rcx
  unsigned int v10; // r8d
  __int64 v11; // rax
  _BYTE *v12; // r8
  __int64 v13; // rdx
  int v14; // ecx
  unsigned __int8 v15; // dl
  __int64 v16; // r12
  unsigned __int64 result; // rax
  unsigned __int64 v18; // rsi
  unsigned __int64 v19; // rdx
  __int64 v20; // rcx
  unsigned __int64 v21; // r12
  __int64 v22; // r11
  int v23; // ecx
  char v24; // r10
  int v25; // ecx
  char v26; // r10
  __int64 v27; // r11
  __int64 v28; // r10
  int v29; // ecx
  __int64 v30; // r10
  __int64 v31; // rsi
  __int64 v32; // rdx
  __int64 v33; // rax
  __int64 v34; // r8
  __int64 v35; // rdi
  int v36; // ecx
  char v37; // r9
  __int64 v38; // r9
  __int64 v39; // rbp
  int v40; // ecx
  char v41; // bl
  unsigned __int64 v42; // rsi
  unsigned __int64 v43; // rcx
  bool v44; // cf
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rsi
  __int64 v48; // r10
  __int64 v49; // rbp
  int v50; // ecx
  char v51; // bl
  __int64 v52; // rbp
  __int64 v53; // rbp
  int v54; // ecx
  char v55; // bl
  unsigned __int64 v56; // rsi
  unsigned __int8 v57; // r15
  unsigned __int64 v58; // rdx
  unsigned __int64 v59; // rcx
  unsigned __int64 v60; // rsi
  unsigned __int64 v61; // rsi
  unsigned __int64 v62; // r10
  unsigned __int64 v63; // rcx
  unsigned __int64 v64; // rcx
  unsigned __int64 v65; // rax
  unsigned __int64 v66; // rax
  unsigned __int64 v67; // r9
  unsigned __int64 v68; // rcx
  __int64 v69; // rcx
  char v70; // dl
  char v71; // r10
  char v72; // al
  unsigned __int64 v73; // rdi
  unsigned __int64 v74; // rcx
  char v75; // si
  _BYTE *v76; // rdi
  _QWORD *v77; // rcx
  _QWORD *v78; // rcx
  unsigned __int64 v79; // rdx
  _QWORD *v80; // rcx
  _BYTE v81[15]; // [rsp+0h] [rbp-88h]
  __int128 v82; // [rsp+10h] [rbp-78h] BYREF
  unsigned __int64 *v83; // [rsp+20h] [rbp-68h]
  __int64 v84; // [rsp+28h] [rbp-60h]
  __int64 v85; // [rsp+30h] [rbp-58h]
  _QWORD *v86; // [rsp+38h] [rbp-50h]
  __int64 v87; // [rsp+40h] [rbp-48h]
  __int64 v88; // [rsp+48h] [rbp-40h]
  __int64 v89; // [rsp+50h] [rbp-38h]

  v2 = a2;
  v86 = a1;
  v3 = *(_QWORD *)(a2 + 40);
  if ( !v3 )
  {
LABEL_157:
    result = (unsigned __int64)v86;
    *v86 = 0LL;
    return result;
  }
  v4 = (unsigned __int64 *)(v2 + 32);
  while ( 2 )
  {
    v5 = *(unsigned int *)(v2 + 48);
    if ( !*(_BYTE *)(v2 + 52) )
    {
      gimli::read::reader::Reader::read_address((__int64)&v82, v4, v5);
      v15 = v82;
      if ( (_BYTE)v82 == 75 )
      {
        v84 = v2;
        v16 = *((_QWORD *)&v82 + 1);
        gimli::read::reader::Reader::read_address((__int64)&v82, v4, v5);
        v15 = v82;
        if ( (_BYTE)v82 == 75 )
        {
          result = *((_QWORD *)&v82 + 1);
          v2 = v84;
          if ( !(v16 | *((_QWORD *)&v82 + 1)) )
          {
LABEL_156:
            *(_QWORD *)(v2 + 32) = aRustc9b00956e5;
            *(_QWORD *)(v2 + 40) = 0LL;
            goto LABEL_157;
          }
          v18 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * *(_BYTE *)(v84 + 48));
          v19 = v18 - (*(_WORD *)(v84 + 50) < 5u);
          if ( v16 != 0xFFFFFFFFFFFFFFFFLL >> (-8 * (unsigned __int8)v5) )
          {
            v20 = *(_QWORD *)(v84 + 16);
            if ( v20 == v19 )
              goto LABEL_82;
            goto LABEL_17;
          }
LABEL_20:
          *(_QWORD *)(v2 + 16) = result;
          goto LABEL_82;
        }
        v9 = ((unsigned __int64)((BYTE7(v82) << 16) | (unsigned int)*(unsigned __int16 *)((char *)&v82 + 5)) << 32) | *(unsigned int *)((char *)&v82 + 1);
        v8 = *((_QWORD *)&v82 + 1);
        v2 = v84;
      }
      else
      {
        v9 = ((unsigned __int64)((BYTE7(v82) << 16) | (unsigned int)*(unsigned __int16 *)((char *)&v82 + 5)) << 32) | *(unsigned int *)((char *)&v82 + 1);
        v8 = *((_QWORD *)&v82 + 1);
      }
      v7 = (v9 & 0xFFFFFFFFFFFF00LL) >> 8;
      goto LABEL_153;
    }
    v6 = *(_BYTE **)(v2 + 32);
    v7 = v3 - 1;
    v8 = (__int64)(v6 + 1);
    *(_QWORD *)(v2 + 32) = v6 + 1;
    *(_QWORD *)(v2 + 40) = v3 - 1;
    LOBYTE(v9) = *v6;
    v10 = WORD1(v5);
    switch ( *v6 )
    {
      case 0:
        goto LABEL_156;
      case 1:
        if ( v3 == 1 )
          goto LABEL_149;
        v11 = 2 - v3;
        v12 = v6 + 2;
        v13 = 0LL;
        v14 = 0;
        while ( 2 )
        {
          v8 = (unsigned __int8)*(v12 - 1);
          if ( v14 == 63 && (unsigned __int8)v8 >= 2u )
          {
            v7 = 0LL;
            v15 = 6;
LABEL_152:
            LOBYTE(v9) = 0;
            goto LABEL_153;
          }
          v13 |= (unsigned __int64)(v8 & 0x7F) << v14;
          if ( (v8 & 0x80u) != 0LL )
          {
            v14 += 7;
            ++v11;
            ++v12;
            if ( v11 == 1 )
              goto LABEL_148;
            continue;
          }
          break;
        }
        *(_QWORD *)(v2 + 32) = v12;
        *(_QWORD *)(v2 + 40) = -v11;
        v42 = *(_QWORD *)(v2 + 24);
        result = *(_QWORD *)v2;
        v43 = *(_QWORD *)(v2 + 8);
        v44 = v43 < v42;
        v45 = v43 - v42;
        if ( v44 )
          goto LABEL_175;
        result += v42;
        v46 = (unsigned __int8)v5 * v13;
        v47 = v45 - v46;
        if ( v45 < v46 )
          goto LABEL_175;
        result += v46;
        switch ( (char)v5 )
        {
          case 1:
            if ( v45 == v46 )
              goto LABEL_174;
            result = *(unsigned __int8 *)result;
            goto LABEL_20;
          case 2:
            if ( v47 > 1 )
            {
              result = *(unsigned __int16 *)result;
              goto LABEL_102;
            }
            *(_WORD *)v81 = 0;
            v81[2] = 0;
            *(_DWORD *)&v81[3] = 0;
            goto LABEL_105;
          case 4:
            if ( v47 <= 3 )
            {
              *(_DWORD *)v81 = 0;
              v81[6] = 0;
              *(_WORD *)&v81[4] = 0;
LABEL_105:
              v69 = 19LL;
              v70 = 0;
            }
            else
            {
              result = *(unsigned int *)result;
LABEL_102:
              v69 = 75LL;
              v70 = 1;
            }
            if ( !v70 )
              goto LABEL_176;
            goto LABEL_20;
          case 8:
            if ( v47 < 8 )
            {
              *(_QWORD *)&v82 = 19LL;
              *((_QWORD *)&v82 + 1) = result;
              *(_DWORD *)&v81[8] = result >> 8;
              *(_DWORD *)&v81[11] = HIDWORD(result);
              *(_QWORD *)v81 = *(_QWORD *)((char *)&v82 + 1);
              v69 = 19LL;
LABEL_186:
              result = *(_QWORD *)&v81[7];
              goto LABEL_176;
            }
            result = *(_QWORD *)result;
            break;
          default:
            v81[0] = v5;
            v69 = 23LL;
            goto LABEL_176;
        }
        goto LABEL_20;
      case 2:
        if ( v3 == 1 )
          goto LABEL_149;
        v27 = 0LL;
        v28 = 0LL;
        v29 = 0;
        while ( 2 )
        {
          v8 = (unsigned __int8)v6[v27 + 1];
          v15 = 6;
          if ( v29 == 63 && (unsigned __int8)v8 >= 2u )
            goto LABEL_150;
          v28 |= (unsigned __int64)(v8 & 0x7F) << v29;
          if ( (v8 & 0x80u) != 0LL )
          {
            v29 += 7;
            if ( v7 == ++v27 )
              goto LABEL_148;
            continue;
          }
          break;
        }
        v8 = (__int64)&v6[v27 + 2];
        *(_QWORD *)(v2 + 32) = v8;
        *(_QWORD *)(v2 + 40) = v3 - v27 - 2;
        if ( v3 - 2 == v27 )
          goto LABEL_149;
        v84 = v5;
        v83 = v4;
        v38 = 0LL;
        v39 = v27;
        v40 = 0;
        while ( 2 )
        {
          v41 = v6[v39 + 2];
          if ( v40 == 63 && (unsigned __int8)v41 >= 2u )
          {
            v7 = 0LL;
            LOBYTE(v9) = 0;
            v8 = v87;
            goto LABEL_153;
          }
          v38 |= (unsigned __int64)(v6[v39 + 2] & 0x7F) << v40;
          if ( v41 < 0 )
          {
            v40 += 7;
            if ( v3 - 2 == ++v39 )
            {
              *(_QWORD *)(v2 + 32) = &v6[v3];
              *(_QWORD *)(v2 + 40) = 0LL;
              v8 = (__int64)&v6[v3];
              goto LABEL_149;
            }
            continue;
          }
          break;
        }
        *(_QWORD *)(v2 + 32) = &v6[v39 + 3];
        v57 = v84;
        v58 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * (unsigned __int8)v84);
        *(_QWORD *)(v2 + 40) = v3 - v39 - 3;
        v19 = v58 - ((unsigned __int16)v10 < 5u);
        v59 = *(_QWORD *)(v2 + 24);
        result = *(_QWORD *)v2;
        v60 = *(_QWORD *)(v2 + 8);
        v44 = v60 < v59;
        v61 = v60 - v59;
        if ( v44 || (result += v59, v62 = v57 * v28, v63 = v61 - v62, v61 < v62) )
        {
          v69 = 19LL;
          v21 = result;
          goto LABEL_173;
        }
        v21 = result + v62;
        switch ( v57 )
        {
          case 1u:
            v4 = v83;
            if ( v61 == v62 )
              goto LABEL_181;
            v21 = *(unsigned __int8 *)v21;
            goto LABEL_127;
          case 2u:
            v4 = v83;
            if ( v63 > 1 )
            {
              v21 = *(unsigned __int16 *)v21;
              goto LABEL_116;
            }
            *(_WORD *)v81 = 0;
            v81[2] = 0;
            *(_DWORD *)&v81[3] = 0;
            goto LABEL_125;
          case 4u:
            v4 = v83;
            if ( v63 <= 3 )
            {
              *(_DWORD *)v81 = 0;
              v81[6] = 0;
              *(_WORD *)&v81[4] = 0;
LABEL_125:
              v69 = 19LL;
              v71 = 0;
            }
            else
            {
              v21 = *(unsigned int *)v21;
LABEL_116:
              v69 = 75LL;
              v71 = 1;
            }
            if ( !v71 )
              goto LABEL_173;
LABEL_127:
            v73 = v38 * v57;
            v74 = v61 - v73;
            if ( v61 < v73 )
              goto LABEL_175;
            break;
          case 8u:
            v4 = v83;
            if ( v63 < 8 )
              goto LABEL_180;
            v21 = *(_QWORD *)v21;
            goto LABEL_127;
          default:
            v81[0] = v57;
            goto LABEL_184;
        }
        result += v73;
        switch ( v57 )
        {
          case 1u:
            if ( v61 == v73 )
            {
LABEL_174:
              v81[0] = 0;
              *(_WORD *)&v81[5] = 0;
              *(_DWORD *)&v81[1] = 0;
LABEL_175:
              v69 = 19LL;
LABEL_176:
              v19 = ((unsigned __int64)((v81[6] << 16) | (unsigned int)*(unsigned __int16 *)&v81[4]) << 32) | *(unsigned int *)v81;
LABEL_177:
              v79 = v69 | (v19 << 8);
              v80 = v86;
              v86[1] = v79;
              v80[2] = result;
              *v80 = 2LL;
              return result;
            }
            result = *(unsigned __int8 *)result;
LABEL_147:
            v30 = v85;
            v87 = v38;
LABEL_81:
            v85 = v30;
            if ( v21 != v19 )
            {
              if ( v21 <= result )
              {
                v78 = v86;
                *v86 = 1LL;
                v78[1] = v21;
                v78[2] = result;
                return result;
              }
              result = (unsigned __int64)aRustc9b00956e5;
              *(_QWORD *)(v2 + 32) = aRustc9b00956e5;
              *(_QWORD *)(v2 + 40) = 0LL;
              v69 = 48LL;
              goto LABEL_177;
            }
LABEL_82:
            v3 = *(_QWORD *)(v2 + 40);
            if ( !v3 )
              goto LABEL_157;
            break;
          case 2u:
            if ( v74 > 1 )
            {
              result = *(unsigned __int16 *)result;
              goto LABEL_137;
            }
            *(_WORD *)v81 = 0;
            v81[2] = 0;
            *(_DWORD *)&v81[3] = 0;
            goto LABEL_145;
          case 4u:
            if ( v74 > 3 )
            {
              result = *(unsigned int *)result;
              goto LABEL_137;
            }
            *(_DWORD *)v81 = 0;
            v81[6] = 0;
            *(_WORD *)&v81[4] = 0;
LABEL_145:
            v69 = 19LL;
            v75 = 0;
            goto LABEL_146;
          case 8u:
            if ( v74 < 8 )
            {
              *(_QWORD *)&v82 = 19LL;
              *((_QWORD *)&v82 + 1) = result;
              *(_DWORD *)&v81[11] = HIDWORD(result);
              *(_DWORD *)&v81[8] = result >> 8;
              *(_QWORD *)v81 = *(_QWORD *)((char *)&v82 + 1);
              v69 = 19LL;
              v75 = 0;
              result = *(_QWORD *)&v81[7];
            }
            else
            {
              result = *(_QWORD *)result;
              *(_QWORD *)&v81[7] = result;
LABEL_137:
              v69 = 75LL;
              v75 = 1;
            }
LABEL_146:
            if ( v75 )
              goto LABEL_147;
            goto LABEL_176;
          default:
            v81[0] = v57;
            v69 = 23LL;
            goto LABEL_186;
        }
        continue;
      case 3:
        if ( v3 == 1 )
          goto LABEL_149;
        v22 = 0LL;
        v8 = 0LL;
        v23 = 0;
        while ( 2 )
        {
          v24 = v6[v22 + 1];
          v15 = 6;
          if ( v23 == 63 && (unsigned __int8)v24 >= 2u )
            goto LABEL_150;
          v8 |= (unsigned __int64)(v24 & 0x7F) << v23;
          if ( v24 < 0 )
          {
            v23 += 7;
            if ( v7 == ++v22 )
              goto LABEL_148;
            continue;
          }
          break;
        }
        v48 = (__int64)&v6[v22 + 2];
        *(_QWORD *)(v2 + 32) = v48;
        *(_QWORD *)(v2 + 40) = v3 - v22 - 2;
        if ( v3 - 2 == v22 )
          goto LABEL_165;
        v84 = v5;
        v83 = v4;
        v30 = 0LL;
        v49 = v22;
        v50 = 0;
        break;
      case 4:
        if ( v3 == 1 )
          goto LABEL_149;
        v8 = 0LL;
        v16 = 0LL;
        v25 = 0;
        while ( 1 )
        {
          v26 = v6[v8 + 1];
          v15 = 6;
          if ( v25 == 63 && (unsigned __int8)v26 >= 2u )
            break;
          v16 |= (unsigned __int64)(v26 & 0x7F) << v25;
          if ( v26 >= 0 )
          {
            v83 = v4;
            v52 = (__int64)&v6[v8 + 2];
            *(_QWORD *)(v2 + 32) = v52;
            *(_QWORD *)(v2 + 40) = v3 - v8 - 2;
            if ( v3 - 2 == v8 )
            {
LABEL_166:
              v15 = 19;
              v7 = 0LL;
              LOBYTE(v9) = 0;
              v8 = v52;
              goto LABEL_153;
            }
            v84 = v5;
            result = 0LL;
            v53 = v8;
            v54 = 0;
            while ( 1 )
            {
              v55 = v6[v53 + 2];
              if ( v54 == 63 && (unsigned __int8)v55 >= 2u )
              {
                v7 = 0LL;
                LOBYTE(v9) = 0;
                v8 = v88;
                goto LABEL_153;
              }
              result |= (unsigned __int64)(v55 & 0x7F) << v54;
              if ( v55 >= 0 )
                break;
              v54 += 7;
              if ( v3 - 2 == ++v53 )
              {
                *(_QWORD *)(v2 + 32) = &v6[v3];
                *(_QWORD *)(v2 + 40) = 0LL;
                v52 = (__int64)&v6[v3];
                goto LABEL_166;
              }
            }
            *(_QWORD *)(v2 + 32) = &v6[v53 + 3];
            *(_QWORD *)(v2 + 40) = v3 - v53 - 3;
            v18 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * (unsigned __int8)v84);
            v19 = v18 - (WORD1(v5) < 5u);
            v88 = result;
            v4 = v83;
            v20 = *(_QWORD *)(v2 + 16);
            if ( v20 == v19 )
              goto LABEL_82;
LABEL_17:
            v21 = v18 & (v20 + v16);
            result = v18 & (v20 + result);
LABEL_80:
            v30 = v85;
            goto LABEL_81;
          }
          v25 += 7;
          if ( v7 == ++v8 )
          {
LABEL_148:
            v76 = &v6[v3];
            *(_QWORD *)(v2 + 32) = v76;
            *(_QWORD *)(v2 + 40) = 0LL;
            v8 = (__int64)v76;
LABEL_149:
            v15 = 19;
            v7 = 0LL;
            LOBYTE(v9) = 0;
            goto LABEL_153;
          }
        }
LABEL_150:
        v7 = 0LL;
        goto LABEL_152;
      case 5:
        gimli::read::reader::Reader::read_address((__int64)&v82, v4, v5);
        v15 = v82;
        if ( (_BYTE)v82 != 75 )
          goto LABEL_161;
        result = *((_QWORD *)&v82 + 1);
        goto LABEL_20;
      case 6:
        gimli::read::reader::Reader::read_address((__int64)&v82, v4, v5);
        v15 = v82;
        if ( (_BYTE)v82 != 75 )
          goto LABEL_161;
        v21 = *((_QWORD *)&v82 + 1);
        gimli::read::reader::Reader::read_address((__int64)&v82, v4, v5);
        v15 = v82;
        if ( (_BYTE)v82 != 75 )
          goto LABEL_161;
        result = *((_QWORD *)&v82 + 1);
        v19 = (0xFFFFFFFFFFFFFFFFLL >> (-8 * *(_BYTE *)(v2 + 48))) - (*(_WORD *)(v2 + 50) < 5u);
        v30 = v85;
        goto LABEL_81;
      case 7:
        gimli::read::reader::Reader::read_address((__int64)&v82, v4, v5);
        v15 = v82;
        if ( (_BYTE)v82 != 75 )
        {
LABEL_161:
          LOBYTE(v9) = BYTE1(v82);
          v7 = *(unsigned int *)((char *)&v82 + 2) | ((unsigned __int64)WORD3(v82) << 32);
          v8 = *((_QWORD *)&v82 + 1);
          goto LABEL_153;
        }
        v31 = *(_QWORD *)(v2 + 32);
        v32 = *(_QWORD *)(v2 + 40);
        if ( !v32 )
          goto LABEL_155;
        v21 = *((_QWORD *)&v82 + 1);
        v33 = 1 - v32;
        v34 = v31 + 1;
        v35 = 0LL;
        v36 = 0;
        while ( 1 )
        {
          v37 = *(_BYTE *)(v34 - 1);
          if ( v36 == 63 && (unsigned __int8)v37 >= 2u )
          {
            *(_QWORD *)(v2 + 32) = v34;
            *(_QWORD *)(v2 + 40) = -v33;
            v15 = 6;
            v7 = 0LL;
            LOBYTE(v9) = 0;
            v8 = v89;
            goto LABEL_153;
          }
          v35 |= (unsigned __int64)(v37 & 0x7F) << v36;
          if ( v37 >= 0 )
            break;
          v36 += 7;
          ++v33;
          ++v34;
          if ( v33 == 1 )
          {
            v31 += v32;
            *(_QWORD *)(v2 + 32) = v31;
            *(_QWORD *)(v2 + 40) = 0LL;
LABEL_155:
            v15 = 19;
            v7 = 0LL;
            LOBYTE(v9) = 0;
            v8 = v31;
            goto LABEL_153;
          }
        }
        *(_QWORD *)(v2 + 32) = v34;
        *(_QWORD *)(v2 + 40) = -v33;
        v56 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * *(_BYTE *)(v2 + 48));
        v19 = v56 - (*(_WORD *)(v2 + 50) < 5u);
        result = v56 & (v35 + v21);
        v89 = v35;
        goto LABEL_80;
      default:
        v15 = 48;
        goto LABEL_153;
    }
    break;
  }
  do
  {
    v51 = v6[v49 + 2];
    if ( v50 == 63 && (unsigned __int8)v51 >= 2u )
    {
      v7 = 0LL;
      LOBYTE(v9) = 0;
      v8 = v85;
      goto LABEL_153;
    }
    v30 |= (unsigned __int64)(v51 & 0x7F) << v50;
    if ( v51 >= 0 )
    {
      *(_QWORD *)(v2 + 32) = &v6[v49 + 3];
      *(_QWORD *)(v2 + 40) = v3 - v49 - 3;
      v19 = (0xFFFFFFFFFFFFFFFFLL >> (-8 * (unsigned __int8)v84)) - (WORD1(v5) < 5u);
      v64 = *(_QWORD *)(v2 + 24);
      v21 = *(_QWORD *)v2;
      v65 = *(_QWORD *)(v2 + 8);
      v44 = v65 < v64;
      v66 = v65 - v64;
      if ( v44 || (v21 += v64, v67 = (unsigned __int8)v84 * v8, v68 = v66 - v67, v66 < v67) )
      {
        v69 = 19LL;
      }
      else
      {
        v21 += v67;
        switch ( (char)v84 )
        {
          case 1:
            v4 = v83;
            if ( v66 != v67 )
            {
              v21 = *(unsigned __int8 *)v21;
LABEL_141:
              result = (0xFFFFFFFFFFFFFFFFLL >> (-8 * (unsigned __int8)v84)) & (v21 + v30);
              goto LABEL_81;
            }
LABEL_181:
            v81[0] = 0;
            *(_WORD *)&v81[5] = 0;
            *(_DWORD *)&v81[1] = 0;
            v69 = 19LL;
            break;
          case 2:
            v4 = v83;
            if ( v68 > 1 )
            {
              v21 = *(unsigned __int16 *)v21;
              goto LABEL_121;
            }
            *(_WORD *)v81 = 0;
            v81[2] = 0;
            *(_DWORD *)&v81[3] = 0;
            goto LABEL_139;
          case 4:
            v4 = v83;
            if ( v68 <= 3 )
            {
              *(_DWORD *)v81 = 0;
              v81[6] = 0;
              *(_WORD *)&v81[4] = 0;
LABEL_139:
              v69 = 19LL;
              v72 = 0;
            }
            else
            {
              v21 = *(unsigned int *)v21;
LABEL_121:
              v69 = 75LL;
              v72 = 1;
            }
            if ( v72 )
              goto LABEL_141;
            break;
          case 8:
            v4 = v83;
            if ( v68 >= 8 )
            {
              v21 = *(_QWORD *)v21;
              goto LABEL_141;
            }
LABEL_180:
            *(_QWORD *)&v82 = 19LL;
            *((_QWORD *)&v82 + 1) = v21;
            *(_DWORD *)&v81[8] = v21 >> 8;
            *(_DWORD *)&v81[11] = HIDWORD(v21);
            *(_QWORD *)v81 = *(_QWORD *)((char *)&v82 + 1);
            v69 = 19LL;
            v21 = *(_QWORD *)&v81[7];
            break;
          default:
            v81[0] = v84;
LABEL_184:
            v69 = 23LL;
            break;
        }
      }
LABEL_173:
      v19 = ((unsigned __int64)((v81[6] << 16) | (unsigned int)*(unsigned __int16 *)&v81[4]) << 32) | *(unsigned int *)v81;
      result = v21;
      goto LABEL_177;
    }
    v50 += 7;
    ++v49;
  }
  while ( v3 - 2 != v49 );
  *(_QWORD *)(v2 + 32) = &v6[v3];
  *(_QWORD *)(v2 + 40) = 0LL;
  v48 = (__int64)&v6[v3];
LABEL_165:
  v15 = 19;
  v7 = 0LL;
  LOBYTE(v9) = 0;
  v8 = v48;
LABEL_153:
  result = (v7 << 16) | ((unsigned __int8)v9 << 8) | v15;
  *(_QWORD *)(v2 + 32) = aRustc9b00956e5;
  *(_QWORD *)(v2 + 40) = 0LL;
  v77 = v86;
  v86[1] = result;
  v77[2] = v8;
  *v77 = 2LL;
  return result;
}
// 17D5A: variable 'v81' is possibly undefined

//----- (0000000000017E80) ----------------------------------------------------
char __fastcall <alloc::string::String as core::fmt::Display>::fmt(__int64 a1, __int64 a2)
{
  return <str as core::fmt::Display>::fmt(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), a2);
}

//----- (0000000000017EA0) ----------------------------------------------------
bool __fastcall <core::result::Result<T,E> as core::fmt::Debug>::fmt(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rax
  _QWORD *v4; // [rsp+0h] [rbp-8h] BYREF

  v4 = (_QWORD *)v2;
  if ( *a1 )
  {
    v4 = a1;
    return core::fmt::Formatter::debug_tuple_field1_finish(a2, (__int64)aErr, 3LL, (__int64)&v4, (__int64)&off_58788);
  }
  else
  {
    v4 = a1;
    return core::fmt::Formatter::debug_tuple_field1_finish(a2, (__int64)aOk, 2LL, (__int64)&v4, (__int64)&off_58768);
  }
}
// 17EA0: variable 'v2' is possibly undefined
// 58768: using guessed type __int64 (__fastcall *off_58768)();
// 58788: using guessed type __int64 (__fastcall *off_58788)();

//----- (0000000000017F00) ----------------------------------------------------
__int64 __fastcall <core::str::iter::Chars as core::iter::traits::iterator::Iterator>::next(unsigned __int8 **a1)
{
  unsigned __int8 *v1; // rcx
  unsigned __int8 v2; // dl
  int v4; // eax
  int v5; // r8d
  int v6; // esi

  v1 = *a1;
  if ( *a1 == a1[1] )
    return 1114112LL;
  *a1 = v1 + 1;
  v2 = *v1;
  if ( (*v1 & 0x80u) == 0 )
    return *v1;
  v4 = v2 & 0x1F;
  *a1 = v1 + 2;
  v5 = v1[1] & 0x3F;
  if ( v2 <= 0xDFu )
    return v5 | (unsigned int)(v4 << 6);
  *a1 = v1 + 3;
  v6 = (v5 << 6) | v1[2] & 0x3F;
  if ( v2 < 0xF0u )
    return v6 | (unsigned int)(v4 << 12);
  *a1 = v1 + 4;
  return (v6 << 6) | v1[3] & 0x3F | ((unsigned __int8)(v2 & 7) << 18);
}

//----- (0000000000017F80) ----------------------------------------------------
__int64 __fastcall <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(
        __int64 *a1,
        __int64 *a2)
{
  unsigned __int64 v2; // r13
  size_t v3; // r12
  __int64 result; // rax
  unsigned __int64 v5; // rdx
  __int64 v7; // rsi
  size_t v8; // r15
  unsigned __int8 v9; // bl
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  size_t v14; // rbp
  __int64 v15; // [rsp+10h] [rbp-48h]
  size_t v16; // [rsp+18h] [rbp-40h]

  v2 = a2[3];
  v3 = a2[2];
  result = 0LL;
  v5 = v2 - v3;
  if ( v2 >= v3 )
  {
    v16 = a2[1];
    if ( v2 <= v16 )
    {
      v15 = *a2;
      v7 = *a2 + v3;
      v8 = *((unsigned __int8 *)a2 + 40);
      v9 = *((_BYTE *)a2 + v8 + 31);
      if ( v8 > 4 )
      {
        while ( 1 )
        {
          if ( v5 >= 0x10 )
          {
            result = core::slice::memchr::memchr_aligned(v9, v7, v5);
            v10 = v11;
            if ( result != 1 )
              goto LABEL_27;
          }
          else
          {
            v10 = 0LL;
            if ( v2 == v3 )
            {
LABEL_10:
              result = 0LL;
              goto LABEL_27;
            }
            while ( *(_BYTE *)(v7 + v10) != v9 )
            {
              if ( v5 == ++v10 )
                goto LABEL_10;
            }
          }
          v3 += v10 + 1;
          a2[2] = v3;
          if ( v3 >= v8 && v3 <= v16 )
            core::slice::index::slice_end_index_len_fail(v8, 4LL, (__int64)&off_58850);
          v7 = v15 + v3;
          v5 = v2 - v3;
          if ( v2 < v3 )
            goto LABEL_28;
        }
      }
      do
      {
        if ( v5 >= 0x10 )
        {
          result = core::slice::memchr::memchr_aligned(v9, v7, v5);
          v12 = v13;
          if ( result != 1 )
            goto LABEL_27;
        }
        else
        {
          v12 = 0LL;
          if ( v2 == v3 )
          {
LABEL_21:
            result = 0LL;
LABEL_27:
            a2[2] = v2;
            goto LABEL_29;
          }
          while ( *(_BYTE *)(v7 + v12) != v9 )
          {
            if ( v5 == ++v12 )
              goto LABEL_21;
          }
        }
        v3 += v12 + 1;
        a2[2] = v3;
        v14 = v3 - v8;
        if ( v3 >= v8 && v3 <= v16 && !bcmp((const void *)(v15 + v14), a2 + 4, v8) )
        {
          a1[1] = v14;
          a1[2] = v3;
          result = 1LL;
          goto LABEL_29;
        }
        v7 = v15 + v3;
        v5 = v2 - v3;
      }
      while ( v2 >= v3 );
LABEL_28:
      result = 0LL;
    }
  }
LABEL_29:
  *a1 = result;
  return result;
}
// 18045: variable 'v11' is possibly undefined
// 18109: variable 'v13' is possibly undefined
// 58850: using guessed type char *off_58850;

//----- (00000000000181A0) ----------------------------------------------------
__int64 __fastcall <gimli::read::unit::AttributeValue<R,Offset> as core::clone::Clone>::clone(_QWORD *a1, __int64 *a2)
{
  __int64 result; // rax

  result = *a2;
  a1[1] = a2[1];
  *a1 = result;
  return result;
}

//----- (00000000000181F0) ----------------------------------------------------
__int64 __fastcall <gimli::read::line::LineProgramHeader<R,Offset> as core::clone::Clone>::clone(
        __int64 a1,
        __int64 *a2,
        double a3,
        __m128 a4)
{
  __int128 v6; // xmm0
  const void *v7; // r14
  unsigned __int64 v8; // rbp
  size_t v9; // r12
  __int64 v10; // rax
  char *v11; // rdi
  const void *v12; // r14
  unsigned __int64 v13; // rcx
  __int64 v14; // r12
  void *v15; // rax
  const void *v16; // r14
  unsigned __int64 v17; // rbp
  size_t v18; // r12
  void *v19; // rax
  const void *v20; // r14
  unsigned __int64 v21; // rbx
  size_t v22; // r12
  void *v23; // rax
  unsigned __int64 v24; // r8
  __int64 result; // rax
  __int64 v26; // rcx
  __int64 v27; // rdx
  __int64 v28; // rsi
  __int64 v29; // rdi
  char *v30; // r10
  unsigned __int64 v31; // r11
  __int128 v32; // xmm2
  unsigned __int64 v33; // r8
  unsigned int v34; // r9d
  unsigned __int64 v35; // r10
  unsigned __int64 v36; // r11
  char v37; // [rsp+17h] [rbp-81h]
  unsigned __int64 v38; // [rsp+18h] [rbp-80h]
  char *v39; // [rsp+20h] [rbp-78h]
  unsigned __int64 v40; // [rsp+28h] [rbp-70h]
  int v41; // [rsp+34h] [rbp-64h]
  void *v42; // [rsp+38h] [rbp-60h]
  void *v43; // [rsp+40h] [rbp-58h]
  void *v44; // [rsp+48h] [rbp-50h]
  __int64 v45; // [rsp+50h] [rbp-48h]
  __int64 v46; // [rsp+58h] [rbp-40h]
  __int64 v47; // [rsp+60h] [rbp-38h]

  v41 = *((_DWORD *)a2 + 58);
  v6 = *((_OWORD *)a2 + 12);
  v45 = a2[26];
  v37 = *((_BYTE *)a2 + 241);
  v47 = a2[20];
  v46 = a2[21];
  v7 = (const void *)a2[9];
  v8 = a2[10];
  if ( v8 )
  {
    if ( v8 > 0x1FFFFFFFFFFFFFFFLL )
      alloc::raw_vec::capacity_overflow();
    v9 = 4 * v8;
    v10 = _rust_alloc(4 * v8, 2LL);
    if ( !v10 )
      alloc::alloc::handle_alloc_error(2LL, 4 * v8);
    v11 = (char *)v10;
  }
  else
  {
    v11 = (char *)&dword_0 + 2;
    v9 = 0LL;
  }
  v39 = v11;
  memcpy(v11, v7, v9);
  v12 = (const void *)a2[12];
  v13 = a2[13];
  v40 = v8;
  v38 = v13;
  if ( v13 )
  {
    if ( v13 > 0x555555555555555LL )
      alloc::raw_vec::capacity_overflow();
    v14 = 24 * v13;
    v15 = (void *)_rust_alloc(24 * v13, 8LL);
    if ( !v15 )
      alloc::alloc::handle_alloc_error(8LL, v14);
  }
  else
  {
    v15 = &byte_8;
    v14 = 0LL;
  }
  v43 = v15;
  memcpy(v15, v12, v14);
  v16 = (const void *)a2[15];
  v17 = a2[16];
  if ( v17 )
  {
    if ( v17 > 0x1FFFFFFFFFFFFFFFLL )
      alloc::raw_vec::capacity_overflow();
    v18 = 4 * v17;
    v19 = (void *)_rust_alloc(4 * v17, 2LL);
    if ( !v19 )
      alloc::alloc::handle_alloc_error(2LL, 4 * v17);
  }
  else
  {
    v19 = &dword_0 + 2;
    v18 = 0LL;
  }
  v42 = v19;
  memcpy(v19, v16, v18);
  v20 = (const void *)a2[18];
  v21 = a2[19];
  if ( v21 )
  {
    if ( v21 >> 57 )
      alloc::raw_vec::capacity_overflow();
    v22 = v21 << 6;
    v23 = (void *)_rust_alloc(v21 << 6, 8LL);
    if ( !v23 )
      alloc::alloc::handle_alloc_error(8LL, v21 << 6);
  }
  else
  {
    v23 = &byte_8;
    v22 = 0LL;
  }
  v44 = v23;
  memcpy(v23, v20, v22);
  result = *a2;
  v26 = a2[22];
  v27 = a2[23];
  v28 = a2[27];
  v29 = a2[28];
  if ( *a2 == 46 )
  {
    v30 = v39;
    v31 = v38;
    v32 = v6;
  }
  else
  {
    switch ( result )
    {
      case 0LL:
      case 5LL:
      case 6LL:
      case 7LL:
      case 10LL:
      case 11LL:
      case 12LL:
      case 13LL:
      case 14LL:
      case 15LL:
      case 16LL:
      case 17LL:
      case 18LL:
      case 19LL:
      case 20LL:
      case 21LL:
      case 22LL:
      case 23LL:
      case 24LL:
      case 25LL:
      case 26LL:
      case 27LL:
      case 28LL:
      case 29LL:
      case 30LL:
      case 39LL:
      case 44LL:
      case 45LL:
        v33 = a2[1];
        v34 = (unsigned int)v33 >> 8;
        v35 = v33 >> 16;
        v36 = v33 & 0xFFFFFFFF00000000LL;
        break;
      case 1LL:
      case 8LL:
      case 31LL:
        v33 = a2[1];
        v20 = (const void *)a2[2];
        v34 = (unsigned int)v33 >> 8;
        v35 = v33 >> 16;
        v36 = v33 & 0xFFFFFFFF00000000LL;
        break;
      case 2LL:
      case 9LL:
      case 32LL:
      case 33LL:
      case 34LL:
      case 35LL:
      case 36LL:
      case 37LL:
      case 40LL:
      case 41LL:
      case 42LL:
      case 43LL:
        LOBYTE(v33) = *((_BYTE *)a2 + 8);
        v36 = 0LL;
        LODWORD(v35) = 0;
        LOWORD(v34) = 0;
        break;
      case 3LL:
      case 38LL:
        LOWORD(v33) = *((_WORD *)a2 + 4);
        v34 = BYTE1(v33);
        v36 = 0LL;
        LODWORD(v35) = 0;
        break;
      case 4LL:
        LODWORD(v33) = *((_DWORD *)a2 + 2);
        v34 = (unsigned int)v33 >> 8;
        LODWORD(v35) = WORD1(v33);
        v36 = 0LL;
        break;
    }
    v32 = v6;
    a4 = *(__m128 *)(a2 + 3);
    v22 = a2[5];
    v6 = *((_OWORD *)a2 + 3);
    v24 = v36 | ((_DWORD)v35 << 16) | (unsigned int)(unsigned __int16)(((_WORD)v34 << 8) | (unsigned __int8)v33);
    v30 = v39;
    v31 = v38;
  }
  *(_DWORD *)(a1 + 232) = v41;
  *(_OWORD *)(a1 + 192) = v32;
  *(_QWORD *)(a1 + 208) = v45;
  *(_DWORD *)(a1 + 236) = *((_DWORD *)a2 + 59);
  *(_BYTE *)(a1 + 240) = *((_BYTE *)a2 + 240);
  *(_BYTE *)(a1 + 241) = v37;
  *(_QWORD *)(a1 + 160) = v47;
  *(_QWORD *)(a1 + 168) = v46;
  *(_QWORD *)(a1 + 64) = v40;
  *(_QWORD *)(a1 + 72) = v30;
  *(_QWORD *)(a1 + 80) = v40;
  *(_QWORD *)(a1 + 88) = v31;
  *(_QWORD *)(a1 + 96) = v43;
  *(_QWORD *)(a1 + 104) = v31;
  *(_QWORD *)(a1 + 112) = v17;
  *(_QWORD *)(a1 + 120) = v42;
  *(_QWORD *)(a1 + 128) = v17;
  *(_QWORD *)(a1 + 136) = v21;
  *(_QWORD *)(a1 + 144) = v44;
  *(_QWORD *)(a1 + 152) = v21;
  *(_QWORD *)(a1 + 176) = v26;
  *(_QWORD *)(a1 + 184) = v27;
  *(_QWORD *)(a1 + 216) = v28;
  *(_QWORD *)(a1 + 224) = v29;
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a1 + 8) = v24;
  *(_QWORD *)(a1 + 16) = v20;
  *(__m128 *)(a1 + 24) = a4;
  *(_QWORD *)(a1 + 40) = v22;
  *(_OWORD *)(a1 + 48) = v6;
  return result;
}
// 1858D: variable 'v24' is possibly undefined
// 0: using guessed type int dword_0;
// 8: using guessed type char;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);

//----- (00000000000186B0) ----------------------------------------------------
__int64 __fastcall addr2line::render_file(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v9; // rsi
  __int64 result; // rax
  const void *v11; // r14
  size_t v12; // rbp
  __int64 v13; // rcx
  _QWORD *v14; // rbx
  __int64 v15; // rax
  void *v16; // r15
  unsigned __int64 v17; // rax
  _QWORD *v18; // r15
  _QWORD *v19; // rbx
  unsigned __int64 v20; // rax
  _QWORD *v21; // rsi
  _QWORD *v22; // rsi
  _QWORD *v23; // rsi
  __int64 v24; // rax
  size_t v25; // rsi
  size_t v26; // rdx
  __int64 v27; // r14
  __int64 v28; // r14
  __int64 v29; // [rsp+0h] [rbp-A8h]
  __int64 v30; // [rsp+8h] [rbp-A0h] BYREF
  size_t n[2]; // [rsp+10h] [rbp-98h]
  __int128 v32; // [rsp+20h] [rbp-88h] BYREF
  __int64 v33; // [rsp+30h] [rbp-78h]
  _QWORD *v34; // [rsp+38h] [rbp-70h]
  _QWORD *v35; // [rsp+40h] [rbp-68h]
  __int64 v36; // [rsp+48h] [rbp-60h] BYREF
  size_t v37; // [rsp+50h] [rbp-58h]
  size_t v38; // [rsp+58h] [rbp-50h]
  _QWORD v39[9]; // [rsp+60h] [rbp-48h] BYREF

  v34 = (_QWORD *)a3;
  v9 = *(_QWORD *)(a2 + 368);
  v29 = a2;
  if ( v9 )
  {
    alloc::string::String::from_utf8_lossy(&v30, v9, *(_QWORD *)(a2 + 376));
    result = v30;
    v11 = (const void *)n[0];
    v12 = n[1];
    if ( v30 == 0x8000000000000001LL )
    {
      a1[1] = n[0];
      a1[2] = v12;
      *a1 = 0x8000000000000000LL;
      return result;
    }
    v13 = (__int64)a1;
    v14 = (_QWORD *)a5;
    if ( v30 == 0x8000000000000000LL )
    {
      v35 = a1;
      if ( n[1] )
      {
        if ( (n[1] & 0x8000000000000000LL) != 0LL )
          alloc::raw_vec::capacity_overflow();
        v15 = _rust_alloc(n[1], 1LL);
        if ( !v15 )
          alloc::alloc::handle_alloc_error(1LL, v12);
        v16 = (void *)v15;
      }
      else
      {
        v16 = &dword_0 + 1;
      }
      memcpy(v16, v11, v12);
      *(_QWORD *)&v32 = v12;
      v11 = v16;
      v13 = (__int64)v35;
    }
    else
    {
      *(_QWORD *)&v32 = v30;
    }
  }
  else
  {
    v13 = (__int64)a1;
    v14 = (_QWORD *)a5;
    *(_QWORD *)&v32 = 0LL;
    v11 = &dword_0 + 1;
    v12 = 0LL;
  }
  *((_QWORD *)&v32 + 1) = v11;
  v33 = v12;
  v17 = v34[3];
  v18 = v14;
  v19 = (_QWORD *)v13;
  if ( v17 )
  {
    if ( *(_WORD *)(a4 + 234) >= 5u )
    {
      v22 = 0LL;
      if ( *(_QWORD *)(a4 + 104) > v17 )
        v22 = (_QWORD *)(*(_QWORD *)(a4 + 96) + 24 * v17);
      core::option::Option<&T>::cloned(v39, v22, a3, *(_QWORD *)(a4 + 96) + 24 * v17, a5, a6);
      if ( LODWORD(v39[0]) == 46 )
        goto LABEL_22;
    }
    else
    {
      v20 = v17 - 1;
      v21 = 0LL;
      if ( v20 < *(_QWORD *)(a4 + 104) )
        v21 = (_QWORD *)(*(_QWORD *)(a4 + 96) + 24 * v20);
      core::option::Option<&T>::cloned(v39, v21, a3, *(_QWORD *)(a4 + 96) + 24 * v20, a5, a6);
      if ( LODWORD(v39[0]) == 46 )
        goto LABEL_22;
    }
    result = gimli::read::dwarf::Dwarf<R>::attr_string(
               (__int64)&v30,
               v18,
               *(_BYTE *)(v29 + 73),
               *(_QWORD *)(v29 + 392),
               v39);
    v25 = n[0];
    v26 = n[1];
    if ( v30
      || (alloc::string::String::from_utf8_lossy(&v30, n[0], n[1]),
          v27 = v30,
          v25 = n[0],
          v26 = n[1],
          result = 0x8000000000000001LL,
          v30 == 0x8000000000000001LL) )
    {
LABEL_31:
      v19[1] = v25;
      v19[2] = v26;
      *v19 = 0x8000000000000000LL;
      if ( (_QWORD)v32 )
        return _rust_dealloc(*((_QWORD *)&v32 + 1), v32, 1LL);
      return result;
    }
    addr2line::path_push((__int64 *)&v32, (unsigned __int8 *)n[0], n[1]);
    if ( 2 * v27 )
    {
      _rust_dealloc(v25, v27, 1LL);
      v23 = v34;
      v24 = *v34;
      switch ( *v34 )
      {
        case 0LL:
        case 5LL:
        case 6LL:
        case 7LL:
        case 0xALL:
        case 0xBLL:
        case 0xCLL:
        case 0xDLL:
        case 0xELL:
        case 0xFLL:
        case 0x10LL:
        case 0x11LL:
        case 0x12LL:
        case 0x13LL:
        case 0x14LL:
        case 0x15LL:
        case 0x16LL:
        case 0x17LL:
        case 0x18LL:
        case 0x19LL:
        case 0x1ALL:
        case 0x1BLL:
        case 0x1CLL:
        case 0x1DLL:
        case 0x1ELL:
        case 0x27LL:
        case 0x2CLL:
        case 0x2DLL:
          goto LABEL_23;
        case 1LL:
        case 8LL:
        case 0x1FLL:
          goto LABEL_37;
        case 2LL:
        case 9LL:
        case 0x20LL:
        case 0x21LL:
        case 0x22LL:
        case 0x23LL:
        case 0x24LL:
        case 0x25LL:
        case 0x28LL:
        case 0x29LL:
        case 0x2ALL:
        case 0x2BLL:
          goto LABEL_28;
        case 3LL:
        case 0x26LL:
          goto LABEL_38;
        case 4LL:
          goto LABEL_39;
      }
    }
  }
LABEL_22:
  v23 = v34;
  v24 = *v34;
  switch ( *v34 )
  {
    case 0LL:
    case 5LL:
    case 6LL:
    case 7LL:
    case 0xALL:
    case 0xBLL:
    case 0xCLL:
    case 0xDLL:
    case 0xELL:
    case 0xFLL:
    case 0x10LL:
    case 0x11LL:
    case 0x12LL:
    case 0x13LL:
    case 0x14LL:
    case 0x15LL:
    case 0x16LL:
    case 0x17LL:
    case 0x18LL:
    case 0x19LL:
    case 0x1ALL:
    case 0x1BLL:
    case 0x1CLL:
    case 0x1DLL:
    case 0x1ELL:
    case 0x27LL:
    case 0x2CLL:
    case 0x2DLL:
LABEL_23:
      n[0] = v23[1];
      break;
    case 1LL:
    case 8LL:
    case 0x1FLL:
LABEL_37:
      *(_OWORD *)n = *(_OWORD *)(v23 + 1);
      break;
    case 2LL:
    case 9LL:
    case 0x20LL:
    case 0x21LL:
    case 0x22LL:
    case 0x23LL:
    case 0x24LL:
    case 0x25LL:
    case 0x28LL:
    case 0x29LL:
    case 0x2ALL:
    case 0x2BLL:
LABEL_28:
      LOBYTE(n[0]) = *((_BYTE *)v23 + 8);
      break;
    case 3LL:
    case 0x26LL:
LABEL_38:
      LOWORD(n[0]) = *((_WORD *)v23 + 4);
      break;
    case 4LL:
LABEL_39:
      LODWORD(n[0]) = *((_DWORD *)v23 + 2);
      break;
  }
  v30 = v24;
  result = gimli::read::dwarf::Dwarf<R>::attr_string(
             (__int64)&v36,
             v18,
             *(_BYTE *)(v29 + 73),
             *(_QWORD *)(v29 + 392),
             &v30);
  v25 = v37;
  v26 = v38;
  if ( v36 )
    goto LABEL_31;
  alloc::string::String::from_utf8_lossy(&v30, v37, v38);
  v28 = v30;
  v25 = n[0];
  v26 = n[1];
  result = 0x8000000000000001LL;
  if ( v30 == 0x8000000000000001LL )
    goto LABEL_31;
  addr2line::path_push((__int64 *)&v32, (unsigned __int8 *)n[0], n[1]);
  if ( 2 * v28 )
    _rust_dealloc(v25, v28, 1LL);
  result = v33;
  v19[2] = v33;
  *(_OWORD *)v19 = v32;
  return result;
}
// 187F3: variable 'a3' is possibly undefined
// 187F3: variable 'a5' is possibly undefined
// 187F3: variable 'a6' is possibly undefined
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 186B0: using guessed type _QWORD var_48[9];

//----- (0000000000018A70) ----------------------------------------------------
__int64 __fastcall addr2line::Context<R>::find_unit(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, char a4)
{
  unsigned __int64 v4; // r8
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // r9
  __int64 v10; // rax
  unsigned __int64 v11; // r8
  __int64 v12; // rax
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // r9
  bool v17; // cf
  unsigned __int64 v18; // rdx
  __int64 result; // rax
  unsigned __int64 v20; // rcx
  unsigned __int64 v21; // r8

  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v4 = a2[6];
      if ( v4 )
      {
        v5 = a2[5];
        v6 = 0LL;
        v7 = a2[6];
        while ( 1 )
        {
          v8 = v6 + (v4 >> 1);
          v9 = *(_QWORD *)(v5 + 432 * v8 + 424);
          if ( v9 == a3 )
            break;
          if ( v9 > a3 )
            v7 = v8;
          if ( v9 < a3 )
            v6 = v8 + 1;
          v4 = v7 - v6;
          if ( v7 <= v6 )
          {
            if ( !v6 )
              break;
            v10 = 432 * v6 + v5 - 432;
            if ( *(_QWORD *)v10 )
              break;
            goto LABEL_24;
          }
        }
      }
    }
  }
  else
  {
    v11 = a2[4];
    if ( v11 )
    {
      v12 = a2[3];
      v13 = 0LL;
      v14 = a2[4];
      while ( 1 )
      {
        v15 = v13 + (v11 >> 1);
        v16 = *(_QWORD *)(v12 + 536 * v15 + 424);
        if ( v16 == a3 )
          break;
        if ( v16 > a3 )
          v14 = v15;
        if ( v16 < a3 )
          v13 = v15 + 1;
        v11 = v14 - v13;
        if ( v14 <= v13 )
        {
          if ( v13 )
          {
            v10 = 536 * v13 + v12 - 536;
            if ( !*(_QWORD *)v10 )
            {
LABEL_24:
              v17 = a3 < *(_QWORD *)(v10 + 8);
              v18 = a3 - *(_QWORD *)(v10 + 8);
              if ( !v17 )
              {
                v20 = *(_QWORD *)(v10 + 48);
                v21 = *(_QWORD *)(v10 + 56) - v20 + 8LL * (*(_BYTE *)(v10 + 73) == 8) + 4;
                if ( v18 >= v21 && v18 - v21 < v20 )
                {
                  a1[1] = v10;
                  a1[2] = v18;
                  result = 0LL;
                  *a1 = 0LL;
                  return result;
                }
              }
            }
          }
          break;
        }
      }
    }
  }
  *((_BYTE *)a1 + 8) = 55;
  result = 1LL;
  *a1 = 1LL;
  return result;
}

//----- (0000000000018BB0) ----------------------------------------------------
_QWORD *__fastcall addr2line::ResUnit<R>::dwarf_and_unit_dwo(_QWORD *a1, __int64 a2, volatile signed __int64 **a3)
{
  unsigned __int64 v3; // rbx
  unsigned __int8 v4; // bp
  unsigned __int8 v5; // r13
  __int64 v6; // r15
  _QWORD *v7; // r14
  volatile signed __int64 *v8; // r12
  char v9; // al
  __int64 v10; // rax
  __int64 v11; // r13
  __int16 v12; // r15
  __int64 v13; // rdx
  _QWORD *v14; // rbp
  __int64 v15; // rbp
  __int64 v16; // rbx
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rcx
  unsigned __int64 v20; // rcx
  _QWORD *v21; // rdx
  char v22; // al
  __int64 v23; // rcx
  _QWORD *v24; // rdx
  _QWORD *result; // rax
  int v26; // ecx
  volatile signed __int64 *v27; // rdx
  unsigned __int8 v28; // [rsp+Eh] [rbp-14Ah]
  unsigned __int8 v29; // [rsp+Fh] [rbp-149h]
  __int64 v30; // [rsp+10h] [rbp-148h] BYREF
  __int64 v31; // [rsp+18h] [rbp-140h]
  _QWORD *v32; // [rsp+20h] [rbp-138h]
  __int64 v33; // [rsp+28h] [rbp-130h]
  __int64 *v34; // [rsp+30h] [rbp-128h]
  __int64 v35; // [rsp+38h] [rbp-120h] BYREF
  __int64 v36; // [rsp+40h] [rbp-118h]
  _QWORD *v37; // [rsp+48h] [rbp-110h]
  __int64 v38; // [rsp+50h] [rbp-108h]
  _BYTE v39[7]; // [rsp+58h] [rbp-100h]
  __int64 v40; // [rsp+60h] [rbp-F8h]
  _QWORD *v41; // [rsp+68h] [rbp-F0h]
  unsigned __int64 v42; // [rsp+70h] [rbp-E8h]
  _QWORD *v43; // [rsp+78h] [rbp-E0h]
  volatile signed __int64 **v44; // [rsp+80h] [rbp-D8h]
  volatile signed __int64 *v45; // [rsp+88h] [rbp-D0h]
  __int64 v46; // [rsp+90h] [rbp-C8h]
  __int64 v47; // [rsp+98h] [rbp-C0h]
  __int64 v48; // [rsp+A0h] [rbp-B8h]
  __int64 v49; // [rsp+A8h] [rbp-B0h]
  __int128 v50; // [rsp+B0h] [rbp-A8h] BYREF
  __int64 v51; // [rsp+C0h] [rbp-98h]
  __int64 v52; // [rsp+C8h] [rbp-90h]
  __int64 v53[5]; // [rsp+D0h] [rbp-88h] BYREF
  __int64 v54; // [rsp+F8h] [rbp-60h]
  __int64 v55; // [rsp+100h] [rbp-58h]
  __int64 v56; // [rsp+108h] [rbp-50h]
  __int128 v57[4]; // [rsp+110h] [rbp-48h] BYREF

  v7 = (_QWORD *)a2;
  v43 = a1;
  v44 = a3;
  v45 = *a3;
  v8 = v45 + 2;
  v9 = *(_BYTE *)(a2 + 512);
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v9 != 76 )
      {
        if ( v9 == 75 )
        {
          v21 = *(_QWORD **)(a2 + 520);
          if ( v21 )
          {
            v8 = (volatile signed __int64 *)(*v21 + 16LL);
            v22 = 2;
            v23 = 0LL;
            v7 = v21 + 1;
          }
          else
          {
            v22 = 0;
            v23 = 0LL;
          }
        }
        else
        {
          v8 = *(volatile signed __int64 **)(a2 + 512);
          v22 = *(_BYTE *)(a2 + 520);
          *(_DWORD *)&v39[3] = *(_DWORD *)(a2 + 524);
          *(_DWORD *)v39 = *(_DWORD *)(a2 + 521);
          v23 = 1LL;
        }
        v24 = v43;
        *v43 = v23;
        v24[1] = v8;
        *((_BYTE *)v24 + 16) = v22;
        result = (_QWORD *)*(unsigned int *)v39;
        v26 = *(_DWORD *)&v39[3];
        *(_DWORD *)((char *)v24 + 17) = *(_DWORD *)v39;
        *((_DWORD *)v24 + 5) = v26;
        v24[3] = v7;
        v24[6] = 0LL;
        return result;
      }
      if ( *(_QWORD *)(a2 + 80) )
        break;
      *(_BYTE *)(a2 + 512) = 75;
      v9 = 75;
      *(_QWORD *)(a2 + 520) = 0LL;
    }
    v49 = *(_QWORD *)(a2 + 368);
    if ( v49 )
      v47 = *(_QWORD *)(a2 + 376);
    v48 = *(_QWORD *)(a2 + 88);
    v10 = *(_QWORD *)(a2 + 344) + 16LL;
    v50 = *(_OWORD *)(a2 + 40);
    v51 = a2;
    v52 = v10;
    v53[0] = 0LL;
    v56 = 0LL;
    gimli::read::unit::EntriesCursor<R>::next_entry(&v30, (__int64)&v50);
    if ( (_BYTE)v30 != 75 )
    {
      v3 = *(unsigned int *)((char *)&v30 + 2) | ((unsigned __int64)HIWORD(v30) << 32);
      v6 = v31;
      v4 = BYTE1(v30);
      v5 = v30;
LABEL_26:
      v20 = v5 | (unsigned __int64)(v4 << 8) | (v3 << 16);
      v40 = v6;
      goto LABEL_30;
    }
    if ( BYTE1(v30) )
    {
      v11 = v53[0];
      if ( !v53[0] )
        core::option::unwrap_failed((__int64)&off_586F8);
      v12 = 118;
      if ( *(_WORD *)(a2 + 74) < 5u )
        v12 = 8496;
      v46 = v53[1];
      v14 = <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v53[2]);
      v30 = v11;
      v31 = v46;
      v32 = v14;
      v33 = v13;
      v34 = v53;
      if ( v13 )
      {
        v15 = (__int64)(v14 + 2);
        v16 = v13 - 1;
        do
        {
          if ( v16 == -1 )
          {
            v18 = (__int64)v34;
            if ( !v34[5] )
            {
              v19 = v30 - *v34;
              v34[5] = 1LL;
              *(_QWORD *)(v18 + 48) = v19;
            }
            goto LABEL_25;
          }
          v57[0] = *(_OWORD *)(v15 - 16);
          gimli::read::unit::parse_attribute(
            (__int64)&v35,
            (unsigned __int64 *)&v30,
            *(_DWORD *)(v34[3] + 72),
            (__int64)v57);
          if ( v35 == 46 )
          {
            v5 = v36;
            v4 = BYTE1(v36);
            v3 = *(unsigned int *)((char *)&v36 + 2) | ((unsigned __int64)HIWORD(v36) << 32);
            v6 = (__int64)v37;
            goto LABEL_26;
          }
          v32 = (_QWORD *)v15;
          v33 = v16;
          v15 += 16LL;
          --v16;
        }
        while ( v12 != (_WORD)v38 );
        v31 = v36;
        v32 = v37;
        v30 = v35;
        v33 = v38;
        gimli::read::unit::Attribute<R>::value(&v35, (__int64)&v30, (__int64)v37);
        v17 = v35;
        v5 = v36;
        v4 = BYTE1(v36);
        v3 = *(unsigned int *)((char *)&v36 + 2) | ((unsigned __int64)HIWORD(v36) << 32);
        v6 = (__int64)v37;
        v41 = v37;
        v42 = v3;
        v28 = BYTE1(v36);
        v29 = v36;
        if ( v35 == 47 )
          goto LABEL_26;
      }
      else
      {
        if ( !v54 )
        {
          v54 = 1LL;
          v55 = v11 - v53[0];
        }
LABEL_25:
        v17 = 46LL;
        v6 = (__int64)v41;
        v3 = v42;
        v4 = v28;
        v5 = v29;
      }
    }
    else
    {
      v17 = 46LL;
    }
    v30 = v17;
    LOBYTE(v31) = v5;
    BYTE1(v31) = v4;
    *(_DWORD *)((char *)&v31 + 2) = v3;
    HIWORD(v31) = WORD2(v3);
    v32 = (_QWORD *)v6;
    if ( v17 == 46 )
      break;
    gimli::read::dwarf::Dwarf<R>::attr_string((__int64)&v50, v8, *(_BYTE *)(a2 + 73), *(_QWORD *)(a2 + 392), &v30);
    v20 = *((_QWORD *)&v50 + 1);
    v40 = v51;
    if ( !(_QWORD)v50 )
      goto LABEL_39;
LABEL_30:
    v9 = *(_BYTE *)(a2 + 512);
    if ( v9 == 76 )
    {
      *(_BYTE *)(a2 + 512) = v20;
      *(_BYTE *)(a2 + 519) = HIBYTE(v20);
      *(_WORD *)(a2 + 517) = HIDWORD(v20) >> 8;
      *(_DWORD *)(a2 + 513) = v20 >> 8;
      v9 = v20;
      *(_QWORD *)(a2 + 520) = v40;
    }
  }
  v20 = 0LL;
LABEL_39:
  v27 = v45;
  if ( _InterlockedIncrement64(v45) <= 0 )
    BUG();
  result = v43;
  *v43 = v27;
  result[1] = v48;
  result[2] = v49;
  result[3] = v47;
  result[4] = v20;
  result[5] = v40;
  result[6] = a2;
  result[7] = a2;
  result[8] = v44;
  return result;
}
// 18D0C: variable 'v13' is possibly undefined
// 18EE6: variable 'v28' is possibly undefined
// 18EEB: variable 'v29' is possibly undefined
// 18F55: variable 'v5' is possibly undefined
// 18F5A: variable 'v4' is possibly undefined
// 18F5F: variable 'v3' is possibly undefined
// 18F6F: variable 'v6' is possibly undefined
// 586F8: using guessed type char *off_586F8;
// 18BB0: using guessed type __int128 var_48[4];

//----- (0000000000019120) ----------------------------------------------------
__int64 __fastcall addr2line::ResUnit<R>::find_function_or_location::{{closure}}(
        __int64 a1,
        _QWORD *a2,
        __int64 a3,
        __m128 a4,
        __m128i a5)
{
  __int64 v5; // r13
  _QWORD *v6; // r14
  __int64 result; // rax
  int v8; // ecx
  unsigned int *v9; // rbp
  __int64 v10; // r12
  unsigned __int64 v11; // rbx
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // rbx
  unsigned __int64 v15; // rsi
  __int64 v16; // rcx
  int v17; // r8d
  unsigned __int64 v18; // r12
  unsigned __int64 v19; // rdx
  __int64 v20; // r15
  __int64 v21; // rbp
  __int64 v22; // rsi
  __int64 v23; // r13
  __int64 v24; // rdi
  __int64 v25; // r8
  unsigned __int64 v26; // rdx
  int v27; // ecx
  char v28; // r9
  __int64 v29; // rdi
  __int64 v30; // rcx
  __int64 v31; // rsi
  __int64 v32; // rdi
  __int64 v33; // r8
  char v34; // r11
  __int64 v35; // rdx
  __int64 v36; // rbx
  __int64 v37; // r15
  _QWORD *v38; // rax
  __int64 v39; // rdx
  __int64 v40; // rdx
  unsigned __int64 v41; // rcx
  __int64 v42; // rax
  __int64 v43; // rax
  __int64 v44; // rax
  char *v45; // rcx
  unsigned __int8 *v46; // rax
  __int64 v47; // rax
  char *v48; // rcx
  unsigned __int8 *v49; // rax
  unsigned __int64 v50; // rax
  unsigned __int8 *v51; // rcx
  __int8 v52; // al
  unsigned __int8 *v53; // rcx
  unsigned __int64 v54; // rcx
  __int64 v55; // rax
  __int64 v56; // rcx
  __int64 v57; // rax
  char v58; // cl
  unsigned __int32 v59; // ebx
  unsigned __int64 v60; // rcx
  __int64 v61; // rsi
  unsigned __int8 **v62; // rax
  unsigned __int8 *v63; // r15
  __int64 v64; // rax
  __int64 v65; // rcx
  __int128 v66; // kr00_16
  unsigned __int64 v67; // rsi
  __int64 v68; // rax
  __int64 v69; // rcx
  __m128i v70; // xmm2
  unsigned __int8 v71; // al
  __int64 v72; // rbx
  _QWORD *v73; // r14
  __int64 v74; // rdi
  __int64 v75; // rax
  unsigned __int64 v76; // r12
  __int64 v77; // rax
  void *v78; // rbx
  __int64 v79; // rax
  unsigned __int64 v80; // r8
  unsigned __int64 v81; // r10
  char *v82; // rbx
  const __m128i *v83; // r14
  unsigned __int64 v84; // r11
  unsigned __int64 v85; // rcx
  __int64 v86; // rsi
  unsigned __int64 *v87; // rdi
  unsigned __int64 v88; // rdx
  unsigned __int64 v89; // rbx
  unsigned __int64 v90; // rax
  unsigned __int64 v91; // r15
  unsigned __int64 v92; // r14
  char *v93; // rax
  char *v94; // r15
  unsigned __int64 v95; // r8
  unsigned __int64 i; // rax
  unsigned __int64 *v97; // rdx
  unsigned __int64 v98; // r9
  unsigned __int64 v99; // rbx
  unsigned __int64 v100; // rcx
  __m128i *v101; // rdx
  unsigned __int64 v102; // r11
  __m128 *v103; // rsi
  __int64 v104; // r8
  __int64 v105; // rax
  const __m128i *v106; // rsi
  char *v107; // r12
  char *v108; // r15
  __int64 v109; // rcx
  unsigned __int64 v110; // rax
  unsigned __int64 v111; // rsi
  unsigned __int64 v112; // r9
  unsigned __int64 v113; // rcx
  unsigned __int64 v114; // rdi
  __int64 v115; // r15
  __int64 v116; // rcx
  unsigned __int64 v117; // rsi
  __int64 v118; // r14
  unsigned __int64 v119; // rdx
  __m128 *v120; // rbp
  __m128 *v121; // r12
  __int64 v122; // rbx
  const __m128i *v123; // r13
  __m128 *v124; // rax
  const __m128i *v125; // rcx
  __int64 v126; // r13
  char *v127; // rbx
  unsigned __int64 v128; // rax
  __int64 v129; // rcx
  _BOOL8 v130; // rdi
  bool v131; // dl
  const __m128i *v132; // r8
  unsigned __int64 *v133; // rax
  unsigned __int64 v134; // rsi
  __int64 v135; // r15
  __int64 v136; // r14
  __int64 v137; // rsi
  __int64 v138; // rbp
  __int64 v139; // r13
  __int64 v140; // rsi
  __int64 v141; // rbx
  unsigned __int64 v142; // r12
  unsigned __int64 v143; // rcx
  _QWORD *v144; // r15
  unsigned __int64 v145; // rdx
  unsigned __int64 v146; // rsi
  unsigned __int64 v147; // r8
  unsigned __int64 v148; // rcx
  __int64 v149; // r8
  unsigned __int64 v150; // rdi
  unsigned __int64 v151; // r9
  unsigned __int64 v152; // rdi
  unsigned __int64 v153; // rsi
  __int64 v154; // r12
  __int64 v155; // rbx
  int v156; // ebp
  int v157; // ecx
  char *v158; // rsi
  unsigned __int64 v159; // r13
  __int64 v160; // rax
  unsigned __int64 v161; // r15
  _BOOL8 v162; // rcx
  unsigned __int64 v163; // rdx
  char *v164; // rsi
  _QWORD *v165; // rdx
  __int64 v166; // r9
  __int64 v167; // r13
  unsigned __int64 v168; // rsi
  unsigned __int64 v169; // rax
  int v170; // ecx
  __int64 v171; // r12
  __int64 v172; // r14
  _QWORD *v173; // rsi
  __int64 v174; // rdx
  __int64 v175; // r14
  __int64 v176; // rcx
  int v177; // edx
  __int128 v178; // xmm1
  __int64 v179; // rax
  unsigned __int64 v180; // rcx
  unsigned __int64 v181; // rsi
  unsigned __int64 v182; // rdx
  unsigned __int64 v183; // rdi
  unsigned __int64 v184; // r10
  unsigned __int64 v185; // rdx
  unsigned __int64 v186; // r8
  unsigned __int64 v187; // r9
  __int64 v188; // rsi
  unsigned __int64 v189; // r8
  unsigned __int64 v190; // rdi
  unsigned __int64 v191; // r10
  __int64 v192; // r8
  unsigned __int64 v193; // r11
  __int64 v194; // rdi
  __int64 v195; // rdi
  __int64 v196; // rcx
  __int64 v197; // rsi
  char v198; // r11
  __int64 v199; // rdx
  __int64 v200; // r14
  __int64 v201; // r12
  __int64 v202; // rdx
  char *v203; // rbp
  __int64 v204; // rax
  __m128 *v205; // r15
  __int64 v206; // rax
  char *v207; // r12
  unsigned __int64 v208; // r14
  unsigned __int64 v209; // r13
  unsigned __int64 v210; // r10
  char *v211; // rcx
  __int64 v212; // rax
  unsigned __int64 *v213; // rdi
  unsigned __int64 v214; // rdx
  unsigned __int64 v215; // r8
  unsigned __int64 v216; // rsi
  unsigned __int64 v217; // rsi
  unsigned __int64 *v218; // rdx
  unsigned __int64 v219; // r9
  unsigned __int64 *v220; // rax
  unsigned __int64 v221; // r9
  bool v222; // cc
  unsigned __int64 v223; // r9
  unsigned __int64 v224; // rcx
  __m128i *v225; // rax
  __m128 *v226; // rdx
  __m128 v227; // xmm0
  unsigned __int64 v228; // rbx
  char *v229; // rax
  char *v230; // r15
  __int64 v231; // rax
  __m128 *v232; // rsi
  char *v233; // r13
  _QWORD *v234; // r9
  __int64 v235; // rcx
  unsigned __int64 v236; // rax
  unsigned __int64 v237; // rsi
  unsigned __int64 v238; // r10
  unsigned __int64 v239; // rcx
  unsigned __int64 v240; // rdi
  __int64 v241; // rcx
  unsigned __int64 v242; // r13
  __int64 v243; // r15
  unsigned __int64 v244; // rax
  __m128 *v245; // rbp
  __int64 v246; // rbx
  __m128 *v247; // r12
  __int64 v248; // r13
  __int64 v249; // r14
  unsigned __int64 v250; // rbx
  __m128 *v251; // r13
  unsigned __int64 v252; // r14
  unsigned __int64 v253; // rax
  bool v254; // cf
  bool v255; // zf
  __m128 *v256; // rax
  bool v257; // al
  __int64 v258; // rcx
  void *v259; // r14
  unsigned __int64 v260; // r13
  unsigned __int64 v261; // rdx
  bool v262; // al
  __m128 *v263; // rcx
  unsigned __int8 *v264; // rdi
  __int64 v265; // r15
  unsigned __int64 v266; // rcx
  unsigned __int8 v267; // dl
  unsigned __int64 v268; // rax
  unsigned __int64 v269; // rdx
  char **v270; // rsi
  __int64 v271; // rdi
  char **v272; // rsi
  __int64 v273; // rdi
  __int64 v274; // rdi
  __int64 v275; // rsi
  __int64 v276; // rdi
  __int64 v277; // rsi
  __int64 v279; // [rsp+0h] [rbp-318h]
  __int64 v280; // [rsp+8h] [rbp-310h]
  unsigned __int64 v281; // [rsp+8h] [rbp-310h]
  __int64 v282; // [rsp+8h] [rbp-310h]
  __int64 v283; // [rsp+8h] [rbp-310h]
  unsigned __int64 v284; // [rsp+8h] [rbp-310h]
  unsigned __int64 v285; // [rsp+8h] [rbp-310h]
  __int64 v286; // [rsp+8h] [rbp-310h]
  _BYTE v287[15]; // [rsp+10h] [rbp-308h]
  __int64 v288; // [rsp+20h] [rbp-2F8h]
  char *v289; // [rsp+20h] [rbp-2F8h]
  unsigned __int64 v290; // [rsp+28h] [rbp-2F0h]
  __int64 v291; // [rsp+28h] [rbp-2F0h]
  __m256i v292; // [rsp+30h] [rbp-2E8h] BYREF
  unsigned __int64 v293; // [rsp+50h] [rbp-2C8h]
  unsigned __int8 *v294; // [rsp+58h] [rbp-2C0h]
  unsigned __int8 *v295; // [rsp+60h] [rbp-2B8h]
  void *src; // [rsp+68h] [rbp-2B0h]
  void *dest; // [rsp+70h] [rbp-2A8h]
  unsigned __int64 v298; // [rsp+78h] [rbp-2A0h]
  void *v299; // [rsp+80h] [rbp-298h]
  unsigned __int64 v300; // [rsp+88h] [rbp-290h]
  _QWORD *v301; // [rsp+90h] [rbp-288h]
  unsigned __int64 v302; // [rsp+98h] [rbp-280h]
  unsigned __int64 v303; // [rsp+A0h] [rbp-278h] BYREF
  unsigned __int64 v304; // [rsp+A8h] [rbp-270h]
  unsigned __int64 v305; // [rsp+B0h] [rbp-268h]
  unsigned __int64 v306; // [rsp+B8h] [rbp-260h]
  unsigned __int64 v307; // [rsp+C0h] [rbp-258h]
  unsigned __int64 v308; // [rsp+C8h] [rbp-250h]
  unsigned __int64 v309; // [rsp+D0h] [rbp-248h]
  unsigned __int8 *v310; // [rsp+D8h] [rbp-240h]
  unsigned __int64 v311; // [rsp+E0h] [rbp-238h]
  unsigned __int64 v312; // [rsp+E8h] [rbp-230h] BYREF
  __int64 v313; // [rsp+F0h] [rbp-228h]
  unsigned __int64 v314; // [rsp+F8h] [rbp-220h]
  char **v315; // [rsp+100h] [rbp-218h]
  unsigned __int64 v316; // [rsp+108h] [rbp-210h]
  __m128i v317; // [rsp+110h] [rbp-208h] BYREF
  __int128 v318; // [rsp+120h] [rbp-1F8h]
  __int64 v319; // [rsp+130h] [rbp-1E8h]
  __int64 v320; // [rsp+138h] [rbp-1E0h]
  unsigned __int64 v321; // [rsp+140h] [rbp-1D8h]
  __int64 v322; // [rsp+148h] [rbp-1D0h]
  unsigned __int64 v323; // [rsp+150h] [rbp-1C8h]
  unsigned __int64 v324; // [rsp+158h] [rbp-1C0h]
  _QWORD *v325; // [rsp+160h] [rbp-1B8h]
  __int64 v326; // [rsp+168h] [rbp-1B0h]
  __int64 v327; // [rsp+170h] [rbp-1A8h]
  __int64 v328; // [rsp+178h] [rbp-1A0h]
  char **v329; // [rsp+180h] [rbp-198h]
  unsigned __int64 v330; // [rsp+188h] [rbp-190h] BYREF
  __int64 v331; // [rsp+190h] [rbp-188h]
  unsigned __int64 v332; // [rsp+198h] [rbp-180h]
  __int64 v333; // [rsp+1A0h] [rbp-178h]
  __int64 v334; // [rsp+1A8h] [rbp-170h]
  __int64 v335; // [rsp+1B0h] [rbp-168h]
  __m128i *v336; // [rsp+1B8h] [rbp-160h]
  __int64 v337; // [rsp+1C0h] [rbp-158h]
  unsigned __int64 v338; // [rsp+1C8h] [rbp-150h]
  unsigned __int64 v339; // [rsp+1D0h] [rbp-148h]
  __m128i v340; // [rsp+1D8h] [rbp-140h] BYREF
  __m128 v341; // [rsp+1E8h] [rbp-130h]
  __m128i v342; // [rsp+1F8h] [rbp-120h] BYREF
  __int128 v343; // [rsp+208h] [rbp-110h]
  __int64 v344; // [rsp+218h] [rbp-100h]
  __m128 v345; // [rsp+2D0h] [rbp-48h]

  v5 = a1;
  v6 = *(_QWORD **)(a3 + 8);
  result = *(unsigned __int8 *)(a3 + 16);
  if ( *(_QWORD *)a3 )
  {
    *(_QWORD *)(a1 + 16) = v6;
    *(_BYTE *)(a1 + 24) = result;
    result = *(unsigned int *)(a3 + 17);
    v8 = *(_DWORD *)(a3 + 20);
    *(_DWORD *)(a1 + 25) = result;
    *(_DWORD *)(a1 + 28) = v8;
LABEL_3:
    *(_DWORD *)(v5 + 8) = 3;
    return result;
  }
  LOBYTE(v324) = *(_BYTE *)(a3 + 16);
  v9 = *(unsigned int **)(a3 + 24);
  v10 = *a2;
  v255 = *(_QWORD *)(*a2 + 472LL) == 0LL;
  v301 = v6;
  if ( !v255 )
  {
    v11 = v10 + 480;
    if ( !*(_QWORD *)(v10 + 480) )
      goto LABEL_258;
    goto LABEL_259;
  }
  v325 = a2;
  v330 = 0LL;
  v331 = 8LL;
  v332 = 0LL;
  v312 = 0LL;
  v313 = 8LL;
  v314 = 0LL;
  v12 = *((_QWORD *)v9 + 43) + 16LL;
  v13 = *((_QWORD *)v9 + 6);
  v317.m128i_i64[0] = *((_QWORD *)v9 + 5);
  v317.m128i_i64[1] = v13;
  *(_QWORD *)&v318 = v9;
  *((_QWORD *)&v318 + 1) = v12;
  v319 = 0LL;
  v288 = v10;
  v299 = v9;
  if ( !v13 )
    goto LABEL_244;
  v14 = v9[18];
  v15 = *((_QWORD *)v9 + 52);
  v16 = v6[24];
  dest = (void *)v6[25];
  v309 = (unsigned __int64)dest - v15;
  LODWORD(v293) = v14 & 0xFF00;
  v17 = 0;
  LODWORD(v326) = WORD1(v14);
  v18 = 0LL;
  if ( WORD1(v14) < 5u )
    v18 = v15;
  v336 = (__m128i *)v16;
  v323 = v15;
  v307 = v16 + v15;
  LOBYTE(v17) = WORD1(v14) >= 5u;
  v290 = 0LL;
  if ( !*((_BYTE *)v6 + 240) )
    v18 = 0LL;
  v19 = *((_QWORD *)v9 + 50);
  v316 = v6[3];
  v300 = v316 - v19;
  LODWORD(v321) = v17;
  src = (void *)BYTE1(v14);
  v306 = v6[2];
  v302 = v19;
  v310 = (unsigned __int8 *)(v19 + v306);
  v298 = v14;
  v280 = (unsigned __int8)v14;
  v308 = (unsigned int)(16 * v17);
  v322 = v308 + 8;
  v315 = (char **)*((_QWORD *)v9 + 48);
  v20 = 8LL;
  v329 = (char **)&v340;
  v21 = 0LL;
LABEL_13:
  v22 = v317.m128i_i64[0];
  v23 = v317.m128i_i64[0]
      + *(_QWORD *)(v318 + 56)
      + 8LL * (*(_BYTE *)(v318 + 73) == 8)
      - (*(_QWORD *)(v318 + 40)
       + *(_QWORD *)(v318 + 48))
      + 4;
  v24 = 1 - v13;
  v25 = v317.m128i_i64[0] + 1;
  v26 = 0LL;
  v27 = 0;
  while ( 1 )
  {
    v28 = *(_BYTE *)(v25 - 1);
    if ( v27 == 63 && (unsigned __int8)v28 >= 2u )
    {
      v317.m128i_i64[0] = v25;
      v317.m128i_i64[1] = -v24;
      v71 = 6;
      goto LABEL_139;
    }
    v26 |= (unsigned __int64)(v28 & 0x7F) << v27;
    if ( v28 >= 0 )
      break;
    v27 += 7;
    ++v24;
    ++v25;
    if ( v24 == 1 )
    {
      v22 = v13 + v317.m128i_i64[0];
      v317 = (__m128i)(unsigned __int64)(v13 + v317.m128i_i64[0]);
      v71 = 19;
      goto LABEL_139;
    }
  }
  v317.m128i_i64[0] = v25;
  v317.m128i_i64[1] = -v24;
  if ( !v26 )
  {
    --v319;
    v335 = 0LL;
    v5 = a1;
    goto LABEL_125;
  }
  v254 = v26 - 1 < *(_QWORD *)(*((_QWORD *)&v318 + 1) + 16LL);
  v328 = v20;
  if ( v254 )
  {
    v29 = *(_QWORD *)(*((_QWORD *)&v318 + 1) + 8LL) + 112 * (v26 - 1);
    goto LABEL_35;
  }
  v30 = *(_QWORD *)(*((_QWORD *)&v318 + 1) + 24LL);
  v71 = 18;
  if ( !v30 )
  {
LABEL_159:
    v22 = v335;
LABEL_139:
    v292.m256i_i16[4] = v71;
    v292.m256i_i16[7] = 0;
    *(__int32 *)((char *)&v292.m256i_i32[2] + 2) = 0;
    v292.m256i_i64[2] = v22;
LABEL_140:
    v292.m256i_i64[0] = 0LL;
    v5 = a1;
LABEL_141:
    v10 = v288;
    goto LABEL_142;
  }
  v31 = *(_QWORD *)(*((_QWORD *)&v318 + 1) + 32LL);
LABEL_25:
  v32 = -1LL;
  v33 = 0LL;
  do
  {
    if ( !(v33 + 112LL * *(unsigned __int16 *)(v30 + 1330)) )
    {
      v32 = *(unsigned __int16 *)(v30 + 1330);
LABEL_33:
      v254 = v31-- == 0;
      if ( v254 )
        goto LABEL_159;
      v30 = *(_QWORD *)(v30 + 8 * v32 + 1336);
      goto LABEL_25;
    }
    v34 = *(_QWORD *)(v30 + 8 * v32 + 1248) != v26;
    if ( *(_QWORD *)(v30 + 8 * v32 + 1248) > v26 )
      v34 = -1;
    ++v32;
    v33 -= 112LL;
  }
  while ( v34 == 1 );
  if ( v34 )
    goto LABEL_33;
  v29 = v30 - v33 - 112;
  v20 = v328;
LABEL_35:
  if ( *(_BYTE *)(v29 + 106) == 1 )
    ++v319;
  v255 = *(_WORD *)(v29 + 104) == 46;
  v335 = v29;
  if ( !v255 )
  {
    v38 = <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v29);
    gimli::read::unit::skip_attributes((__int64)&v340, (__int64)&v317, *(_DWORD *)(v318 + 72), (__int64)v38, v39);
    v5 = a1;
    if ( v340.m128i_i8[0] != 75 )
    {
      a4 = (__m128)_mm_loadu_si128(&v340);
      *(__m128 *)&v292.m256i_u64[1] = a4;
      v292.m256i_i64[0] = 0LL;
      goto LABEL_141;
    }
    goto LABEL_125;
  }
  v311 = (unsigned __int64)<gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v29);
  if ( !v35 )
    goto LABEL_124;
  v36 = 16 * v35;
  v37 = 0LL;
  v334 = 0LL;
  v333 = 0LL;
  v337 = 0LL;
  v327 = 0LL;
  while ( 1 )
  {
    a4 = (__m128)_mm_loadu_si128((const __m128i *)(v311 + v37));
    *(__m128 *)v292.m256i_i8 = a4;
    gimli::read::unit::parse_attribute(
      (__int64)&v340,
      (unsigned __int64 *)&v317,
      *(_DWORD *)(v318 + 72),
      (__int64)&v292);
    if ( v340.m128i_i32[0] == 46 )
    {
      a4 = (__m128)_mm_loadu_si128((const __m128i *)&v340.m128i_u64[1]);
      *(__m128 *)&v292.m256i_u64[1] = a4;
      goto LABEL_140;
    }
    if ( v341.m128_u16[4] != 17 )
      break;
    gimli::read::unit::Attribute<R>::value(&v303, (__int64)&v340, v40);
    if ( !v303 )
    {
      v334 = 1LL;
      v294 = (unsigned __int8 *)v304;
      goto LABEL_43;
    }
    if ( (_DWORD)v303 == 12 )
    {
      if ( v316 < v302 )
      {
LABEL_480:
        LOBYTE(v264) = v306;
        *(_QWORD *)&v287[7] = v306;
        goto LABEL_481;
      }
      v47 = v280 * v304;
      v48 = (char *)(v300 - v280 * v304);
      if ( v300 < v280 * v304 )
        goto LABEL_482;
      v294 = &v310[v47];
      switch ( (int)v280 )
      {
        case 1:
          if ( v300 == v47 )
          {
            v287[0] = 0;
            *(_WORD *)&v287[5] = 0;
            *(_DWORD *)&v287[1] = 0;
            v264 = v294;
LABEL_483:
            *(_QWORD *)&v287[7] = v264;
            v52 = 19;
            goto LABEL_484;
          }
          v49 = (unsigned __int8 *)*v294;
LABEL_83:
          v294 = v49;
LABEL_99:
          v334 = 1LL;
          break;
        case 2:
          if ( (unsigned __int64)v48 > 1 )
          {
            v51 = (unsigned __int8 *)*(unsigned __int16 *)v294;
            goto LABEL_86;
          }
          *(_WORD *)v287 = 0;
          v287[2] = 0;
          *(_DWORD *)&v287[3] = 0;
          goto LABEL_97;
        case 4:
          if ( (unsigned __int64)v48 <= 3 )
          {
            *(_DWORD *)v287 = 0;
            v287[6] = 0;
            *(_WORD *)&v287[4] = 0;
LABEL_97:
            v52 = 19;
            v51 = v294;
          }
          else
          {
            v51 = (unsigned __int8 *)*(unsigned int *)v294;
LABEL_86:
            v52 = 75;
            v294 = v51;
          }
          *(_QWORD *)&v287[7] = v51;
          if ( v52 == 75 )
            goto LABEL_99;
          LOBYTE(v264) = (_BYTE)v294;
          goto LABEL_484;
        case 8:
          if ( (unsigned __int64)v48 < 8 )
          {
            v292.m256i_i64[0] = 19LL;
            v268 = (unsigned __int64)v294;
            goto LABEL_514;
          }
          v49 = *(unsigned __int8 **)v294;
          goto LABEL_83;
        default:
LABEL_506:
          v287[0] = v298;
          v52 = 23;
          LOBYTE(v264) = v287[7];
          goto LABEL_484;
      }
    }
LABEL_43:
    v37 += 16LL;
    if ( v36 == v37 )
    {
      if ( v327 )
      {
        v54 = *(_QWORD *)((char *)v6 + v322 + 176);
        v55 = *(_QWORD *)((char *)v6 + v308 + 176);
        v254 = v54 < v338;
        v56 = v54 - v338;
        v20 = v328;
        if ( v254 )
        {
          v58 = 19;
          LOBYTE(v59) = 0;
          v269 = 0LL;
          goto LABEL_515;
        }
        v340.m128i_i64[0] = v306;
        v340.m128i_i64[1] = v316;
        v341.m128_u64[0] = (unsigned __int64)v315;
        v341.m128_u64[1] = v302;
        v342.m128i_i64[0] = v338 + v55;
        v342.m128i_i64[1] = v56;
        LOWORD(v343) = v298;
        WORD1(v343) = v326;
        BYTE4(v343) = v321;
        gimli::read::rnglists::RngListIter<R>::next(&v292, (__int64)&v340);
        v57 = v292.m256i_i64[0];
        if ( v292.m256i_i64[0] == 2 )
        {
LABEL_108:
          v58 = v292.m256i_i8[8];
          v59 = (unsigned __int32)v292.m256i_i32[2] >> 8;
          if ( v292.m256i_i8[8] != 75 )
          {
            v55 = v292.m256i_i64[2];
            v269 = (unsigned __int64)v292.m256i_i64[1] >> 16;
LABEL_515:
            v292.m256i_i8[8] = v58;
            v292.m256i_i8[9] = v59;
            *(__int32 *)((char *)&v292.m256i_i32[2] + 2) = v269;
            v292.m256i_i16[7] = WORD2(v269);
            v292.m256i_i64[2] = v55;
            goto LABEL_140;
          }
        }
        else
        {
          LOBYTE(v59) = 0;
          while ( v57 == 1 )
          {
            v65 = v20;
            v66 = *(_OWORD *)&v292.m256i_u64[1];
            if ( v292.m256i_i64[1] < (unsigned __int64)v292.m256i_i64[2] )
            {
              v67 = v290;
              if ( v290 == v312 )
              {
                alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v312, v290);
                v65 = v313;
                v67 = v314;
              }
              v64 = 3 * v67;
              *(_OWORD *)(v65 + 8 * v64) = v66;
              *(_QWORD *)(v65 + 8 * v64 + 16) = v21;
              v290 = v67 + 1;
              v314 = v67 + 1;
              LOBYTE(v59) = 1;
            }
            v6 = v301;
            v20 = v65;
            gimli::read::rnglists::RngListIter<R>::next(&v292, (__int64)&v340);
            v57 = v292.m256i_i64[0];
            if ( v292.m256i_i64[0] == 2 )
              goto LABEL_108;
          }
        }
        if ( (_BYTE)v59 )
          goto LABEL_133;
LABEL_124:
        v5 = a1;
        goto LABEL_125;
      }
      v20 = v328;
      if ( !v334 )
        goto LABEL_124;
      if ( v333 )
      {
        if ( v294 < v295 )
        {
          if ( v290 == v312 )
          {
            alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v312, v290);
            v290 = v314;
          }
          v60 = v290;
          v61 = v313;
          v62 = (unsigned __int8 **)(v313 + 24 * v290);
          v63 = v295;
LABEL_132:
          *v62 = v294;
          v62[1] = v63;
          v62[2] = (unsigned __int8 *)v21;
          v290 = v60 + 1;
          v314 = v60 + 1;
          v20 = v61;
LABEL_133:
          v340 = (__m128i)(unsigned __int64)v23;
          if ( v21 == v330 )
          {
            alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v330, v21);
            v5 = a1;
            v21 = v332;
          }
          else
          {
            v5 = a1;
          }
          v68 = v331;
          v69 = 9 * v21;
          *(_QWORD *)(v331 + 8 * v69 + 64) = v344;
          a4 = (__m128)_mm_loadu_si128(&v340);
          a5 = (__m128i)v341;
          v70 = v342;
          *(_OWORD *)(v68 + 8 * v69 + 48) = v343;
          *(__m128i *)(v68 + 8 * v69 + 32) = v70;
          *(__m128i *)(v68 + 8 * v69 + 16) = a5;
          *(__m128 *)(v68 + 8 * v69) = a4;
          v332 = ++v21;
          goto LABEL_125;
        }
        goto LABEL_124;
      }
      if ( !v337 )
        goto LABEL_124;
      v63 = &v294[v339];
      if ( v294 < &v294[v339] )
      {
        if ( v290 == v312 )
        {
          alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v312, v290);
          v290 = v314;
        }
        v60 = v290;
        v61 = v313;
        v62 = (unsigned __int8 **)(v313 + 24 * v290);
        v6 = v301;
        goto LABEL_132;
      }
      v5 = a1;
      v20 = v328;
LABEL_125:
      v13 = v317.m128i_i64[1];
      if ( !v317.m128i_i64[1] )
      {
        v309 = v313;
        v76 = v290;
        if ( v290 < 0x15 )
        {
          if ( v290 > 1 )
            core::slice::sort::insertion_sort_shift_left(v309, v290, 1uLL);
LABEL_244:
          v135 = v331;
          v136 = v332;
          if ( v330 <= v332 )
          {
            v138 = v5;
          }
          else
          {
            v137 = 72 * v330;
            v138 = v5;
            if ( v332 )
            {
              v135 = _rust_realloc(v331, v137, 8LL, 72 * v332);
              if ( !v135 )
                alloc::alloc::handle_alloc_error(8LL, 72 * v136);
            }
            else
            {
              _rust_dealloc(v331, v137, 8LL);
              v135 = 8LL;
            }
          }
          result = v312;
          v139 = v314;
          if ( v312 <= v314 )
          {
            v141 = v313;
          }
          else
          {
            v140 = 24 * v312;
            if ( v314 )
            {
              v300 = 24 * v312;
              v283 = 24 * v314;
              result = _rust_realloc(v313, v140, 8LL, 24 * v314);
              v141 = result;
              if ( !result )
                alloc::alloc::handle_alloc_error(8LL, v283);
            }
            else
            {
              v141 = 8LL;
              result = _rust_dealloc(v313, v140, 8LL);
            }
          }
          v292.m256i_i64[0] = v135;
          v292.m256i_i64[1] = v136;
          v292.m256i_i64[2] = v141;
          v292.m256i_i64[3] = v139;
          v5 = v138;
          v6 = v301;
          v9 = (unsigned int *)v299;
          v10 = v288;
          if ( *(_QWORD *)(v288 + 472) )
            goto LABEL_156;
LABEL_257:
          *(_QWORD *)(v10 + 472) = 1LL;
          v11 = v10 + 480;
          a4 = (__m128)_mm_loadu_si128((const __m128i *)&v292);
          a5 = *(__m128i *)&v292.m256i_u64[2];
          *(__m128 *)(v10 + 480) = a4;
          *(__m128i *)(v10 + 496) = a5;
          a2 = v325;
          if ( !*(_QWORD *)(v10 + 480) )
            goto LABEL_258;
          goto LABEL_259;
        }
        v321 = 3 * ((4 * v290) & 0xFFFFFFFFFFFFFFF8LL);
        v77 = _rust_alloc(v321, 8LL);
        if ( !v77 )
          core::option::unwrap_failed((__int64)&off_58430);
        v78 = (void *)v77;
        v79 = _rust_alloc(256LL, 8LL);
        dest = v78;
        if ( !v79 )
          core::option::unwrap_failed((__int64)&off_58448);
        v308 = v309 + 48;
        v322 = v309 + 16;
        v326 = v309 - 8;
        v306 = v309 - 24;
        v298 = 16LL;
        v80 = 0LL;
        v315 = &off_583D0;
        v81 = 0LL;
        v82 = (char *)v79;
        while ( 2 )
        {
          while ( 2 )
          {
            v84 = v80;
            v85 = v76 - v80;
            v86 = 3 * v80;
            v87 = (unsigned __int64 *)(v309 + 24 * v80);
            src = v82;
            if ( v76 - v80 < 2 )
            {
              v88 = v76 - v80;
              goto LABEL_169;
            }
            v95 = v87[3];
            if ( v95 >= *v87 )
            {
              v88 = 2LL;
              if ( v85 != 2 )
              {
                v133 = (unsigned __int64 *)(v308 + 8 * v86);
                do
                {
                  v134 = v95;
                  v95 = *v133;
                  if ( *v133 < v134 )
                    goto LABEL_169;
                  ++v88;
                  v133 += 3;
                }
                while ( v85 != v88 );
                v88 = v85;
              }
LABEL_169:
              v80 = v88 + v84;
            }
            else
            {
              i = 2LL;
              if ( v85 != 2 )
              {
                v97 = (unsigned __int64 *)(v308 + 8 * v86);
                for ( i = 2LL; i != v85; ++i )
                {
                  v98 = v95;
                  v95 = *v97;
                  if ( *v97 >= v98 )
                    goto LABEL_187;
                  v97 += 3;
                }
                i = v85;
              }
LABEL_187:
              v80 = v84 + i;
              if ( __CFADD__(v84, i) )
              {
                v276 = v84;
                v277 = v84 + i;
LABEL_538:
                core::slice::index::slice_index_order_fail(v276, v277, (__int64)v315);
              }
              if ( v80 > v76 )
                core::slice::index::slice_end_index_len_fail(v84 + i, v76, (__int64)&off_583D0);
              v88 = 1LL;
              if ( i >= 2 )
              {
                v99 = v84;
                v100 = i >> 1;
                v101 = (__m128i *)(v322 + 8 * v86);
                v102 = v84 + i;
                v103 = (__m128 *)(v326 + 24 * v80);
                do
                {
                  a4 = (__m128)_mm_loadu_si128(v101 - 1);
                  a5 = (__m128i)v103[-1];
                  v101[-1] = a5;
                  v103[-1] = a4;
                  v104 = v101->m128i_i64[0];
                  v101->m128i_i64[0] = v103->m128_u64[0];
                  v103->m128_u64[0] = v104;
                  v101 = (__m128i *)((char *)v101 + 24);
                  v103 = (__m128 *)((char *)v103 - 24);
                  --v100;
                }
                while ( v100 );
                v88 = i;
                v80 = v102;
                v84 = v99;
              }
            }
            v89 = v80 - v84;
            if ( v80 < v84 || v80 > v76 )
              core::panicking::panic((__int64)aAssertionFaile, 44LL, (__int64)&off_584A0);
            v281 = v84;
            if ( v80 < v76 && v88 < 0xA )
            {
              v90 = v84 + 10;
              if ( v84 + 10 >= v76 )
                v90 = v76;
              if ( v84 > 0xFFFFFFFFFFFFFFF5LL )
              {
                v276 = v84;
                v277 = v90;
                v315 = &off_584B8;
                goto LABEL_538;
              }
              v91 = v81;
              v89 = v90 - v84;
              v293 = v90;
              core::slice::sort::insertion_sort_shift_left((__int64)v87, v90 - v84, (v88 == 0) + v88);
              v84 = v281;
              v80 = v293;
              v81 = v91;
            }
            v293 = v80;
            if ( v81 == v298 )
            {
              v298 = 2 * v81;
              v92 = v81;
              v93 = (char *)_rust_alloc(32 * v81, 8LL);
              if ( !v93 )
                core::option::unwrap_failed((__int64)&off_58460);
              v94 = v93;
              memcpy(v93, src, 16 * v92);
              _rust_dealloc(src, 16 * v92, 8LL);
              v76 = v290;
              v81 = v92;
              v80 = v293;
              v84 = v281;
            }
            else
            {
              v94 = (char *)src;
            }
            v105 = 16 * v81;
            *(_QWORD *)&v94[v105] = v89;
            *(_QWORD *)&v94[v105 + 8] = v84;
            ++v81;
            v82 = v94;
            if ( v81 < 2 )
            {
              v83 = (const __m128i *)dest;
              if ( v80 >= v76 )
                goto LABEL_243;
              continue;
            }
            break;
          }
          v83 = (const __m128i *)dest;
          src = v94;
LABEL_199:
          v109 = 16 * (v81 - 1);
          v110 = *(_QWORD *)&v82[v109];
          if ( v110 + *(_QWORD *)&v82[v109 + 8] == v76 || (v111 = *(_QWORD *)&v82[16 * v81 - 32], v111 <= v110) )
          {
            if ( v81 != 2 )
            {
              v112 = v81 - 3;
              v113 = *(_QWORD *)&v82[16 * v81 - 48];
              goto LABEL_208;
            }
LABEL_209:
            v112 = v81 - 2;
          }
          else
          {
            if ( v81 == 2 )
            {
              v81 = 2LL;
              goto LABEL_242;
            }
            v112 = v81 - 3;
            v113 = *(_QWORD *)&v82[16 * v81 - 48];
            if ( v113 > v111 + v110 )
            {
              if ( v81 <= 3 )
              {
                v81 = 3LL;
LABEL_242:
                v80 = v293;
                if ( v293 >= v76 )
                {
LABEL_243:
                  _rust_dealloc(v82, 16 * v298, 8LL);
                  _rust_dealloc(v83, v321, 8LL);
                  goto LABEL_244;
                }
                continue;
              }
              if ( *(_QWORD *)&v82[16 * v81 - 64] > v113 + v111 )
                goto LABEL_242;
            }
LABEL_208:
            if ( v113 >= v110 )
              goto LABEL_209;
          }
          break;
        }
        if ( v81 <= v112 )
        {
          v340.m128i_i64[0] = (__int64)&off_582D0;
          v272 = &off_583E8;
LABEL_525:
          v273 = (__int64)v329;
          v329[1] = (_BYTE *)(&dword_0 + 1);
          *(_QWORD *)(v273 + 16) = aRustc9b00956e5;
          *(_OWORD *)(v273 + 24) = 0LL;
          core::panicking::panic_fmt(v273, (__int64)v272);
        }
        if ( v81 <= v112 + 1 )
        {
          v340.m128i_i64[0] = (__int64)&off_582D0;
          v272 = &off_58400;
          goto LABEL_525;
        }
        v114 = *(_QWORD *)&v82[16 * v112 + 8];
        v115 = 16 * (v112 + 1);
        v116 = *(_QWORD *)&v82[v115];
        v117 = v116 + *(_QWORD *)&v82[v115 + 8];
        v118 = v117 - v114;
        if ( v117 < v114 )
          core::slice::index::slice_index_order_fail(v114, v117, (__int64)&off_58418);
        if ( v117 > v76 )
          core::slice::index::slice_end_index_len_fail(v116 + *(_QWORD *)&v82[v115 + 8], v290, (__int64)&off_58418);
        v310 = *(unsigned __int8 **)&v82[v115];
        v302 = v112;
        v311 = v81;
        v300 = v81 - 1;
        v316 = 16 * v112;
        v119 = *(_QWORD *)&v82[16 * v112];
        v323 = v114;
        v120 = (__m128 *)(v309 + 24 * v114);
        v121 = (__m128 *)((char *)v120 + 24 * v119);
        v307 = 3 * v117;
        v122 = v118 - v119;
        v282 = v119;
        if ( v118 - v119 >= v119 )
        {
          v126 = 24 * v119;
          v127 = (char *)dest;
          memcpy(dest, v120, 24 * v119);
          v123 = (const __m128i *)&v127[v126];
          if ( v282 > 0 )
          {
            v82 = (char *)src;
            if ( v118 <= v282 )
            {
              v83 = (const __m128i *)dest;
              goto LABEL_197;
            }
            v128 = v309 + 8 * v307;
            v83 = (const __m128i *)dest;
            v106 = (const __m128i *)dest;
            do
            {
              v129 = 0LL;
              v130 = v121->m128_u64[0] >= v106->m128i_i64[0];
              v131 = v121->m128_u64[0] < v106->m128i_i64[0];
              v132 = v106;
              if ( v121->m128_u64[0] < v106->m128i_i64[0] )
                v132 = (const __m128i *)v121;
              v120[1].m128_u64[0] = v132[1].m128i_u64[0];
              a4 = (__m128)_mm_loadu_si128(v132);
              *v120 = a4;
              v120 = (__m128 *)((char *)v120 + 24);
              v106 = (const __m128i *)((char *)v106 + 24 * v130);
              if ( v106 >= v123 )
                break;
              LOBYTE(v129) = v131;
              v121 = (__m128 *)((char *)v121 + 24 * v129);
            }
            while ( (unsigned __int64)v121 < v128 );
LABEL_198:
            v107 = &v82[v316];
            v108 = &v82[v115];
            memcpy(v120, v106, (char *)v123 - (char *)v106);
            *(_QWORD *)v108 = &v310[v282];
            *((_QWORD *)v108 + 1) = v323;
            memmove(v107, v107 + 16, 16 * (~v302 + v311));
            v81 = v300;
            v5 = a1;
            v76 = v290;
            if ( v300 <= 1 )
            {
              v81 = 1LL;
              goto LABEL_242;
            }
            goto LABEL_199;
          }
          v83 = (const __m128i *)dest;
        }
        else
        {
          v83 = (const __m128i *)dest;
          memcpy(dest, (char *)v120 + 24 * v119, 24 * v122);
          v123 = (const __m128i *)((char *)v83 + 24 * v122);
          if ( v282 > 0 && v122 > 0 )
          {
            v124 = (__m128 *)(v306 + 8 * v307);
            v82 = (char *)src;
            do
            {
              v254 = v123[-2].m128i_i64[1] < v121[-2].m128_u64[1];
              v121 = (__m128 *)((char *)v121 - 24 * v254);
              v123 = (const __m128i *)((char *)v123 + 24 * v254 - 24);
              v125 = v123;
              if ( v254 )
                v125 = (const __m128i *)v121;
              v124[1].m128_u64[0] = v125[1].m128i_u64[0];
              a4 = (__m128)_mm_loadu_si128(v125);
              *v124 = a4;
              if ( v121 <= v120 )
                break;
              v124 = (__m128 *)((char *)v124 - 24);
            }
            while ( v123 > v83 );
            v120 = v121;
LABEL_197:
            v106 = v83;
            goto LABEL_198;
          }
          v120 = v121;
        }
        v106 = v83;
        v82 = (char *)src;
        goto LABEL_198;
      }
      goto LABEL_13;
    }
  }
  if ( v341.m128_u16[4] != 18 )
  {
    if ( v341.m128_u16[4] != 85 )
      goto LABEL_43;
    gimli::read::unit::Attribute<R>::value(&v292, (__int64)&v340, v40);
    if ( v292.m256i_i64[0] == 22 )
    {
      v50 = v18 + v292.m256i_i64[1];
LABEL_77:
      v327 = 1LL;
      goto LABEL_78;
    }
    if ( v292.m256i_i32[0] != 24 )
    {
      v327 = 0LL;
      v50 = v338;
LABEL_78:
      v338 = v50;
      goto LABEL_43;
    }
    if ( (unsigned __int64)dest < v323 )
    {
      v266 = 19LL;
      v267 = (unsigned __int8)v336;
      v42 = (__int64)v336;
    }
    else
    {
      v41 = v309 - (_QWORD)src * v292.m256i_i64[1];
      if ( v309 >= (__int64)src * v292.m256i_i64[1] )
      {
        v42 = v307 + (_QWORD)src * v292.m256i_i64[1];
        if ( (_DWORD)v293 == 2048 )
        {
          if ( v41 > 7 )
          {
            v43 = *(_QWORD *)v42;
LABEL_76:
            v50 = v323 + v43;
            goto LABEL_77;
          }
          v303 = 19LL;
          v304 = v307 + (_QWORD)src * v292.m256i_i64[1];
          a4 = (__m128)_mm_loadl_epi64((const __m128i *)((char *)&v303 + 1));
          v345 = a4;
          v267 = a4.m128_u8[7];
        }
        else
        {
          if ( v41 > 3 )
          {
            v43 = *(unsigned int *)v42;
            goto LABEL_76;
          }
          a4 = 0LL;
          v267 = v307 + (_BYTE)src * v292.m256i_i8[8];
        }
        v5 = a1;
        v10 = v288;
        v266 = (a4.m128_u64[0] << 8) | 0x13;
LABEL_504:
        v292.m256i_i64[1] = v266;
        v292.m256i_i64[2] = v42 & 0xFFFFFFFFFFFFFF00LL | v267;
        v292.m256i_i64[0] = 0LL;
        goto LABEL_142;
      }
      v266 = 19LL;
      v42 = v307;
      v267 = v307;
    }
    v5 = a1;
    v10 = v288;
    goto LABEL_504;
  }
  gimli::read::unit::Attribute<R>::value(&v303, (__int64)&v340, v40);
  if ( !v303 )
  {
    v333 = 1LL;
    v295 = (unsigned __int8 *)v304;
    goto LABEL_43;
  }
  if ( (_DWORD)v303 == 7 )
  {
    v337 = 1LL;
    v339 = v304;
    goto LABEL_43;
  }
  if ( (_DWORD)v303 != 12 )
    goto LABEL_43;
  if ( v316 < v302 )
    goto LABEL_480;
  v44 = v280 * v304;
  v45 = (char *)(v300 - v280 * v304);
  if ( v300 < v280 * v304 )
  {
LABEL_482:
    v264 = v310;
    goto LABEL_483;
  }
  v295 = &v310[v44];
  switch ( (int)v280 )
  {
    case 1:
      if ( v300 == v44 )
      {
        v287[0] = 0;
        *(_WORD *)&v287[5] = 0;
        *(_DWORD *)&v287[1] = 0;
        v264 = v295;
        goto LABEL_483;
      }
      v46 = (unsigned __int8 *)*v295;
      goto LABEL_91;
    case 2:
      if ( (unsigned __int64)v45 > 1 )
      {
        v53 = (unsigned __int8 *)*(unsigned __int16 *)v295;
        goto LABEL_94;
      }
      *(_WORD *)v287 = 0;
      v287[2] = 0;
      *(_DWORD *)&v287[3] = 0;
      goto LABEL_102;
    case 4:
      if ( (unsigned __int64)v45 <= 3 )
      {
        *(_DWORD *)v287 = 0;
        v287[6] = 0;
        *(_WORD *)&v287[4] = 0;
LABEL_102:
        v52 = 19;
        v53 = v295;
      }
      else
      {
        v53 = (unsigned __int8 *)*(unsigned int *)v295;
LABEL_94:
        v52 = 75;
        v295 = v53;
      }
      *(_QWORD *)&v287[7] = v53;
      if ( v52 == 75 )
        goto LABEL_104;
      LOBYTE(v264) = (_BYTE)v295;
      goto LABEL_484;
    case 8:
      if ( (unsigned __int64)v45 >= 8 )
      {
        v46 = *(unsigned __int8 **)v295;
LABEL_91:
        v295 = v46;
LABEL_104:
        v333 = 1LL;
        goto LABEL_43;
      }
      v292.m256i_i64[0] = 19LL;
      v268 = (unsigned __int64)v295;
LABEL_514:
      v292.m256i_i64[1] = v268;
      *(_DWORD *)&v287[11] = HIDWORD(v268);
      *(_DWORD *)&v287[8] = v268 >> 8;
      *(_QWORD *)v287 = *(__int64 *)((char *)v292.m256i_i64 + 1);
      v264 = (unsigned __int8 *)HIBYTE(*(unsigned __int64 *)((char *)v292.m256i_i64 + 1));
LABEL_481:
      v52 = 19;
LABEL_484:
      v5 = a1;
      v10 = v288;
      v292.m256i_i32[3] = *(_DWORD *)&v287[3];
      *(__int32 *)((char *)&v292.m256i_i32[2] + 1) = *(_DWORD *)v287;
      v292.m256i_i8[8] = v52;
      v292.m256i_i8[16] = (char)v264;
      *(__int32 *)((char *)&v292.m256i_i32[4] + 1) = *(_DWORD *)&v287[8];
      v292.m256i_i8[23] = v287[14];
      *(__int16 *)((char *)&v292.m256i_i16[10] + 1) = *(_WORD *)&v287[12];
      v292.m256i_i64[0] = 0LL;
LABEL_142:
      if ( v312 )
        _rust_dealloc(v313, 24 * v312, 8LL);
      v72 = v331;
      if ( v21 )
      {
        v73 = (_QWORD *)(v331 + 40);
        do
        {
          if ( *(v73 - 4) )
          {
            v74 = *(v73 - 3);
            if ( v74 )
            {
              v75 = *(v73 - 2);
              if ( v75 )
                _rust_dealloc(v74, 48 * v75, 8LL);
              if ( *v73 )
                _rust_dealloc(*(v73 - 1), 32LL * *v73, 8LL);
            }
          }
          v73 += 9;
          --v21;
        }
        while ( v21 );
      }
      result = v330;
      if ( v330 )
        result = _rust_dealloc(v72, 72 * v330, 8LL);
      v6 = v301;
      v9 = (unsigned int *)v299;
      if ( !*(_QWORD *)(v10 + 472) )
        goto LABEL_257;
LABEL_156:
      v11 = v10 + 480;
      result = core::ptr::drop_in_place<core::result::Result<addr2line::function::Functions<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>,gimli::read::Error>>(v292.m256i_i64);
      a2 = v325;
      if ( *(_QWORD *)(v10 + 480) )
        goto LABEL_259;
LABEL_258:
      result = *(unsigned __int8 *)(v10 + 488);
      v11 = *(_QWORD *)(v10 + 496);
      if ( (_BYTE)result != 75 )
      {
        *(_BYTE *)(v5 + 16) = result;
        result = *(unsigned int *)(v10 + 489);
        v157 = *(_DWORD *)(v10 + 492);
        *(_DWORD *)(v5 + 17) = result;
        *(_DWORD *)(v5 + 20) = v157;
        *(_QWORD *)(v5 + 24) = v11;
        goto LABEL_3;
      }
LABEL_259:
      v142 = a2[2];
      v143 = *(_QWORD *)(v11 + 24);
      if ( !v143 )
      {
        v144 = 0LL;
        v155 = *a2;
        v156 = 2;
        if ( *(_DWORD *)(*a2 + 96LL) == 47 )
          goto LABEL_333;
        goto LABEL_295;
      }
      v325 = a2;
      result = *(_QWORD *)(v11 + 16);
      v144 = 0LL;
      v145 = 0LL;
      v146 = v143;
      while ( 2 )
      {
        v148 = v145 + (v143 >> 1);
        v149 = 3 * v148;
        v150 = *(_QWORD *)(result + 24 * v148);
        v151 = *(_QWORD *)(result + 24 * v148 + 8);
        if ( v150 <= v142 && v151 > v142 )
        {
          v152 = *(_QWORD *)(result + 24 * v148 + 16);
          v153 = *(_QWORD *)(v11 + 8);
          if ( v152 >= v153 )
            core::panicking::panic_bounds_check(v152, v153, (__int64)&off_58898);
          result = *(_QWORD *)v11;
          v143 = 9 * v152;
          v154 = *(_QWORD *)v11 + 72 * v152;
          if ( *(_QWORD *)(v154 + 8) )
          {
            v144 = (_QWORD *)(v154 + 16);
            goto LABEL_293;
          }
          v279 = v5;
          v158 = *(char **)(result + 72 * v152);
          v159 = *((_QWORD *)v9 + 6);
          v160 = *((_QWORD *)v9 + 7);
          v161 = *((unsigned __int8 *)v9 + 73);
          v162 = (_BYTE)v161 == 8;
          v163 = v160 - v159 + 8 * v162 + 4;
          src = v158;
          v254 = (unsigned __int64)v158 < v163;
          v164 = &v158[-v163];
          v307 = v154;
          if ( v254 || (v152 = v159 - (_QWORD)v164, v159 <= (unsigned __int64)v164) )
          {
            LOBYTE(v171) = 56;
            result = 0LL;
            v143 = 0LL;
            v167 = (__int64)v9;
            goto LABEL_288;
          }
          v11 = v325[1];
          v165 = (_QWORD *)*((_QWORD *)v9 + 43);
          v149 = (__int64)(v165 + 2);
          v166 = *((_QWORD *)v9 + 5);
          v317.m128i_i64[0] = (__int64)&v164[v166];
          v317.m128i_i64[1] = v159 - (_QWORD)v164;
          *(_QWORD *)&v318 = v9;
          *((_QWORD *)&v318 + 1) = v165 + 2;
          v319 = 0LL;
          v167 = v166 + v159;
          v168 = (unsigned __int64)src + -v160 + -8 * v162 - 4;
          v169 = 0LL;
          v170 = 0;
          while ( 1 )
          {
            v152 = *(unsigned __int8 *)(v167 + v168);
            if ( v170 == 63 && (unsigned __int8)v152 > 1u )
            {
              LOBYTE(v171) = 6;
              goto LABEL_287;
            }
            v152 = (unsigned __int8)v152;
            v149 = (v152 & 0x7F) << v170;
            v169 |= v149;
            if ( (v152 & 0x80u) == 0LL )
              break;
            v170 += 7;
            if ( !++v168 )
            {
              LOBYTE(v171) = 19;
              goto LABEL_287;
            }
          }
          v317.m128i_i64[0] = v168 + v167 + 1;
          v317.m128i_i64[1] = ~v168;
          if ( !v169 )
            core::option::unwrap_failed((__int64)&off_588C8);
          if ( v169 - 1 < v165[4] )
          {
            v195 = v165[3] + 112 * (v169 - 1);
            goto LABEL_351;
          }
          v152 = v165[5];
          LOBYTE(v171) = 18;
          if ( !v152 )
          {
LABEL_287:
            result = 0LL;
            v143 = 0LL;
            goto LABEL_288;
          }
          v196 = v165[6];
LABEL_341:
          v197 = -1LL;
          v149 = 0LL;
          do
          {
            if ( !(v149 + 112LL * *(unsigned __int16 *)(v152 + 1330)) )
            {
              v197 = *(unsigned __int16 *)(v152 + 1330);
LABEL_349:
              v254 = v196-- == 0;
              if ( v254 )
                goto LABEL_287;
              v152 = *(_QWORD *)(v152 + 8 * v197 + 1336);
              goto LABEL_341;
            }
            v198 = *(_QWORD *)(v152 + 8 * v197 + 1248) != v169;
            if ( *(_QWORD *)(v152 + 8 * v197 + 1248) > v169 )
              v198 = -1;
            ++v197;
            v149 -= 112LL;
          }
          while ( v198 == 1 );
          if ( v198 )
            goto LABEL_349;
          v195 = v152 - v149 - 112;
LABEL_351:
          v300 = v11;
          if ( *(_BYTE *)(v195 + 106) == 1 )
            v319 = 1LL;
          v11 = (unsigned __int64)<gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v195);
          LODWORD(v311) = (unsigned __int8)v324;
          v299 = v9;
          if ( v199 )
          {
            v284 = *((_QWORD *)v9 + 49);
            v200 = 16 * v199;
            v201 = 0LL;
            LODWORD(v324) = (unsigned __int8)v161;
            v293 = 0LL;
            while ( 1 )
            {
              a4 = (__m128)_mm_loadu_si128((const __m128i *)(v11 + v201));
              *(__m128 *)v292.m256i_i8 = a4;
              v152 = (unsigned __int64)&v340;
              gimli::read::unit::parse_attribute(
                (__int64)&v340,
                (unsigned __int64 *)&v317,
                *(_DWORD *)(v318 + 72),
                (__int64)&v292);
              if ( v340.m128i_i32[0] == 46 )
              {
                v171 = v340.m128i_i64[1];
                v167 = v341.m128_u64[0];
LABEL_384:
                v143 = v171 & 0xFFFFFFFFFFFFFF00LL;
                result = v171 & 0xFFFFFFFFFFFF0000LL;
                v6 = v301;
LABEL_288:
                if ( *(_QWORD *)(v307 + 8) )
                {
                  v144 = (_QWORD *)(v307 + 16);
                  v5 = v279;
                  v154 = v307;
                  goto LABEL_293;
                }
                v172 = 0LL;
LABEL_291:
                v173 = (_QWORD *)v307;
                *(_QWORD *)(v307 + 8) = 1LL;
                v144 = v173 + 2;
                v173[2] = v172;
                v143 = (unsigned __int16)v143 & 0xFF00;
                v174 = (unsigned __int8)v171;
                v154 = (__int64)v173;
                v173[3] = result & 0xFFFFFFFFFFFF0000LL | v143 | v174;
                v173[4] = v167;
                v173[5] = v11;
                result = (__int64)src;
                v173[6] = src;
                v173[7] = v149;
                v173[8] = v152;
                goto LABEL_292;
              }
              if ( v341.m128_u16[4] > 0x46u )
                break;
              if ( v341.m128_u16[4] == 3 )
              {
                if ( !v293 )
                {
                  gimli::read::unit::Attribute<R>::value(&v292, (__int64)&v340, v202);
                  gimli::read::dwarf::Dwarf<R>::attr_string((__int64)&v303, v301, v324, v284, &v292);
                  if ( v303 )
                  {
                    v293 = 0LL;
                  }
                  else
                  {
                    v293 = v304;
                    v161 = v305;
                  }
                  v308 = v161;
                }
                goto LABEL_358;
              }
              if ( v341.m128_u16[4] == 49 )
                goto LABEL_357;
LABEL_358:
              v201 += 16LL;
              if ( v200 == v201 )
                goto LABEL_374;
            }
            if ( v341.m128_u16[4] != 71 )
            {
              if ( v341.m128_u16[4] == 110 || v341.m128_u16[4] == 8199 )
              {
                gimli::read::unit::Attribute<R>::value(&v292, (__int64)&v340, v202);
                gimli::read::dwarf::Dwarf<R>::attr_string((__int64)&v303, v301, v324, v284, &v292);
                if ( !v303 )
                {
                  v308 = v305;
                  v293 = v304;
                }
              }
              goto LABEL_358;
            }
LABEL_357:
            if ( !v293 )
            {
              gimli::read::unit::Attribute<R>::value(&v292, (__int64)&v340, v202);
              v152 = (unsigned __int64)&v303;
              addr2line::function::name_attr(
                &v303,
                v292.m256i_i64[0],
                v292.m256i_u64[1],
                v311,
                (__int64)v299,
                (_QWORD *)v300,
                v301,
                16LL);
              v293 = v304;
              v308 = v305;
              if ( v303 )
              {
                v171 = v293;
                v167 = v308;
                goto LABEL_384;
              }
            }
            goto LABEL_358;
          }
          v293 = 0LL;
LABEL_374:
          v303 = 0LL;
          v304 = 8LL;
          v305 = 0LL;
          v292.m256i_i64[0] = 0LL;
          *(_OWORD *)&v292.m256i_u64[1] = 8uLL;
          v11 = (unsigned __int64)&v340;
          v152 = (unsigned __int64)&v340;
          v6 = v301;
          addr2line::function::Function<R>::parse_children(
            (__int64)&v340,
            (unsigned __int64 *)&v317,
            0LL,
            v311,
            (__int64)v299,
            (_QWORD *)v300,
            (__int64)v301,
            (__int64 *)&v303,
            v292.m256i_i64,
            0LL);
          if ( v340.m128i_i8[0] != 75 )
          {
            v167 = v340.m128i_i64[1];
            v171 = v340.m128i_i64[0];
            if ( v292.m256i_i64[0] )
            {
              v152 = v292.m256i_u64[1];
              _rust_dealloc(v292.m256i_i64[1], 32 * v292.m256i_i64[0], 8LL);
            }
            if ( v303 )
            {
              v152 = v304;
              _rust_dealloc(v304, 48 * v303, 8LL);
            }
            v143 = v171 & 0xFFFFFFFFFFFFFF00LL;
            result = v171 & 0xFFFFFFFFFFFF0000LL;
            goto LABEL_288;
          }
          v203 = (char *)v292.m256i_i64[2];
          v291 = v292.m256i_i64[1];
          if ( v292.m256i_i64[2] < 0x15uLL )
          {
            if ( v292.m256i_i64[2] > 1uLL )
              core::slice::sort::insertion_sort_shift_left(v292.m256i_i64[1], v292.m256i_u64[2], 1uLL);
LABEL_475:
            v171 = v305;
            if ( v303 <= v305 )
            {
              v172 = v304;
            }
            else if ( v305 )
            {
              v172 = _rust_realloc(v304, 48 * v303, 8LL, 48 * v305);
              if ( !v172 )
                alloc::alloc::handle_alloc_error(8LL, 48 * v171);
            }
            else
            {
              v172 = 8LL;
              _rust_dealloc(v304, 48 * v303, 8LL);
            }
            v11 = v292.m256i_u64[2];
            if ( v292.m256i_i64[0] <= (unsigned __int64)v292.m256i_i64[2] )
            {
              v167 = v292.m256i_i64[1];
            }
            else
            {
              v265 = 32 * v292.m256i_i64[0];
              if ( v292.m256i_i64[2] )
              {
                v167 = _rust_realloc(v292.m256i_i64[1], v265, 8LL, 32 * v292.m256i_i64[2]);
                if ( !v167 )
                  alloc::alloc::handle_alloc_error(8LL, 32 * v11);
              }
              else
              {
                v167 = 8LL;
                _rust_dealloc(v292.m256i_i64[1], v265, 8LL);
              }
            }
            result = v307;
            if ( !*(_QWORD *)(v307 + 8) )
            {
              LOWORD(v143) = v171 & 0xFF00;
              result = v171 & 0xFFFFFFFFFFFF0000LL;
              v152 = v308;
              v149 = v293;
              goto LABEL_291;
            }
            if ( v171 )
              result = _rust_dealloc(v172, 48 * v171, 8LL);
            v154 = v307;
            v144 = (_QWORD *)(v307 + 16);
            if ( v11 )
              result = _rust_dealloc(v167, 32 * v11, 8LL);
LABEL_292:
            v5 = v279;
            v6 = v301;
LABEL_293:
            if ( *v144 )
            {
              v142 = v325[2];
              v155 = *v325;
              v156 = 2;
              if ( *(_DWORD *)(*v325 + 96LL) != 47 )
                goto LABEL_295;
              goto LABEL_333;
            }
            v176 = *(_QWORD *)(v154 + 32);
            *(_BYTE *)(v5 + 16) = *(_BYTE *)(v154 + 24);
            result = *(unsigned int *)(v154 + 25);
            v177 = *(_DWORD *)(v154 + 28);
            *(_DWORD *)(v5 + 17) = result;
            *(_DWORD *)(v5 + 20) = v177;
            *(_QWORD *)(v5 + 24) = v176;
            goto LABEL_3;
          }
          v336 = &v340;
          v315 = (char **)((16 * v292.m256i_i64[2]) & 0x7FFFFFFFFFFFFFE0LL);
          v204 = _rust_alloc(v315, 8LL);
          if ( !v204 )
            core::option::unwrap_failed((__int64)&off_58430);
          v205 = (__m128 *)v204;
          v206 = _rust_alloc(256LL, 8LL);
          v299 = v205;
          if ( !v206 )
            core::option::unwrap_failed((__int64)&off_58448);
          v207 = (char *)v206;
          v322 = v291 + 80;
          v326 = v291 + 16;
          v321 = v291 - 16;
          v309 = v291 - 32;
          v306 = 16LL;
          v208 = 0LL;
          v329 = &off_583D0;
          v209 = 0LL;
          dest = v203;
          while ( 2 )
          {
            v210 = v208;
            v211 = &v203[-v208];
            v212 = 32 * v208;
            v213 = (unsigned __int64 *)(v291 + 32 * v208);
            if ( (unsigned __int64)&v203[-v208] >= 2 )
            {
              v215 = v213[6];
              if ( v215 < v213[2] || (v216 = v213[4], v215 <= v213[2]) && v216 < *v213 )
              {
                v217 = 2LL;
                if ( v211 != (_BYTE *)&dword_0 + 2 )
                {
                  v218 = (unsigned __int64 *)(v212 + v322);
                  while ( 1 )
                  {
                    v219 = v215;
                    v215 = *v218;
                    if ( *v218 >= v219 && (*v218 > v219 || *(v218 - 2) >= *(v218 - 6)) )
                      break;
                    ++v217;
                    v218 += 4;
                    if ( v211 == (char *)v217 )
                    {
                      v217 = (unsigned __int64)&v203[-v208];
                      break;
                    }
                  }
                }
                v208 += v217;
                if ( __CFADD__(v210, v217) )
                {
                  v274 = v210;
                  v275 = v210 + v217;
LABEL_532:
                  core::slice::index::slice_index_order_fail(v274, v275, (__int64)v329);
                }
                if ( v208 > (unsigned __int64)v203 )
                  core::slice::index::slice_end_index_len_fail(v208, (__int64)v203, (__int64)&off_583D0);
                v214 = 1LL;
                if ( v217 >= 2 )
                {
                  v224 = v217 >> 1;
                  v225 = (__m128i *)(v326 + v212);
                  v226 = (__m128 *)(v321 + 32 * v208);
                  do
                  {
                    v227 = (__m128)v225[-1];
                    v225[-1] = (__m128i)v226[-1];
                    v226[-1] = v227;
                    a4 = (__m128)_mm_loadu_si128(v225);
                    a5 = *(__m128i *)v226;
                    *v225 = *(__m128i *)v226;
                    *v226 = a4;
                    v225 += 2;
                    v226 -= 2;
                    --v224;
                  }
                  while ( v224 );
                  v214 = v217;
                }
                goto LABEL_418;
              }
              v214 = 2LL;
              if ( v211 != (_BYTE *)&dword_0 + 2 )
              {
                v220 = (unsigned __int64 *)(v322 + v212);
                while ( 1 )
                {
                  v221 = v215;
                  v215 = *v220;
                  v222 = *v220 <= v221;
                  if ( *v220 < v221 )
                    break;
                  v223 = *(v220 - 2);
                  if ( v222 && v223 < v216 )
                    break;
                  ++v214;
                  v220 += 4;
                  v216 = v223;
                  if ( v211 == (char *)v214 )
                    goto LABEL_392;
                }
              }
            }
            else
            {
LABEL_392:
              v214 = (unsigned __int64)&v203[-v208];
            }
            v208 += v214;
LABEL_418:
            v228 = v208 - v210;
            if ( v208 < v210 || v208 > (unsigned __int64)v203 )
              core::panicking::panic((__int64)aAssertionFaile, 44LL, (__int64)&off_584A0);
            v285 = v210;
            if ( v208 < (unsigned __int64)v203 && v214 < 0xA )
            {
              v208 = v210 + 10;
              if ( v210 + 10 >= (unsigned __int64)v203 )
                v208 = (unsigned __int64)v203;
              if ( v210 > 0xFFFFFFFFFFFFFFF5LL )
              {
                v274 = v210;
                v275 = v208;
                v329 = &off_584B8;
                goto LABEL_532;
              }
              v228 = v208 - v210;
              core::slice::sort::insertion_sort_shift_left((__int64)v213, v208 - v210, (v214 == 0) + v214);
            }
            if ( v209 == v306 )
            {
              v306 = 2 * v209;
              v229 = (char *)_rust_alloc(32 * v209, 8LL);
              if ( !v229 )
                core::option::unwrap_failed((__int64)&off_58460);
              v230 = v229;
              memcpy(v229, v207, 16 * v209);
              _rust_dealloc(v207, 16 * v209, 8LL);
              v207 = v230;
              v205 = (__m128 *)v299;
              v203 = (char *)dest;
            }
            v231 = 16 * v209;
            *(_QWORD *)&v207[v231] = v228;
            *(_QWORD *)&v207[v231 + 8] = v285;
            if ( ++v209 < 2 )
              goto LABEL_390;
            v298 = v208;
            v289 = v207;
            while ( 1 )
            {
              v234 = (_QWORD *)v209;
              v235 = 16 * (v209 - 1);
              v236 = *(_QWORD *)&v207[v235];
              if ( (char *)(v236 + *(_QWORD *)&v207[v235 + 8]) != v203 )
              {
                v237 = *(_QWORD *)&v207[16 * v209 - 32];
                if ( v237 > v236 )
                  break;
              }
              if ( v209 != 2 )
              {
                v238 = v209 - 3;
                v239 = *(_QWORD *)&v207[16 * v209 - 48];
                goto LABEL_443;
              }
LABEL_444:
              v238 = v209 - 2;
LABEL_445:
              if ( v209 <= v238 )
              {
                v340.m128i_i64[0] = (__int64)&off_582D0;
                v270 = &off_583E8;
                goto LABEL_518;
              }
              v324 = v209 - 1;
              if ( v209 <= v238 + 1 )
              {
                v340.m128i_i64[0] = (__int64)&off_582D0;
                v270 = &off_58400;
LABEL_518:
                v271 = (__int64)v336;
                v336->m128i_i64[1] = 1LL;
                *(_QWORD *)(v271 + 16) = aRustc9b00956e5;
                *(_OWORD *)(v271 + 24) = 0LL;
                core::panicking::panic_fmt(v271, (__int64)v270);
              }
              v240 = *(_QWORD *)&v207[16 * v238 + 8];
              v241 = 16 * (v238 + 1);
              v242 = *(_QWORD *)&v207[v241] + *(_QWORD *)&v207[v241 + 8];
              v243 = v242 - v240;
              if ( v242 < v240 )
                core::slice::index::slice_index_order_fail(v240, v242, (__int64)&off_58418);
              if ( v242 > (unsigned __int64)v203 )
                core::slice::index::slice_end_index_len_fail(v242, (__int64)dest, (__int64)&off_58418);
              v310 = *(unsigned __int8 **)&v207[v241];
              v316 = 16 * (v238 + 1);
              v311 = v238;
              v300 = (unsigned __int64)v234;
              v302 = 16 * v238;
              v244 = *(_QWORD *)&v207[16 * v238];
              v323 = v240;
              v245 = (__m128 *)(v291 + 32 * v240);
              v246 = 32 * v244;
              v247 = &v245[2 * v244];
              v248 = 32 * v242;
              v249 = v243 - v244;
              v286 = v244;
              if ( v243 - v244 >= v244 )
              {
                v259 = v299;
                memcpy(v299, v245, 32 * v244);
                v250 = (unsigned __int64)v259 + v246;
                if ( v286 <= 0 )
                {
                  v205 = (__m128 *)v299;
                  goto LABEL_471;
                }
                v252 = v302;
                if ( v243 > v286 )
                {
                  v260 = v291 + v248;
                  v205 = (__m128 *)v299;
                  v232 = (__m128 *)v299;
                  do
                  {
                    v261 = v232[1].m128_u64[0];
                    v262 = 1;
                    v263 = v247;
                    if ( v247[1].m128_u64[0] >= v261 )
                    {
                      v263 = v247;
                      v262 = v247[1].m128_u64[0] <= v261 && v247->m128_u64[0] < v232->m128_u64[0];
                      if ( !v262 )
                        v263 = v232;
                    }
                    a4 = (__m128)_mm_loadu_si128((const __m128i *)v263);
                    a5 = (__m128i)v263[1];
                    v245[1] = (__m128)a5;
                    *v245 = a4;
                    v245 += 2;
                    v232 += 2 * !v262;
                    if ( (unsigned __int64)v232 >= v250 )
                      break;
                    v247 += 2 * (unsigned int)v262;
                  }
                  while ( (unsigned __int64)v247 < v260 );
                  goto LABEL_433;
                }
                v205 = (__m128 *)v299;
              }
              else
              {
                v205 = (__m128 *)v299;
                memcpy(v299, &v245[2 * v244], 32 * v249);
                v250 = (unsigned __int64)&v205[2 * v249];
                if ( v286 <= 0 || v249 <= 0 )
                {
                  v245 = v247;
LABEL_471:
                  v232 = v205;
                  v252 = v302;
                  goto LABEL_433;
                }
                v251 = (__m128 *)(v309 + v248);
                v252 = v302;
                do
                {
                  v253 = v247[-1].m128_u64[0];
                  v254 = *(_QWORD *)(v250 - 16) < v253;
                  v255 = *(_QWORD *)(v250 - 16) == v253;
                  if ( *(_QWORD *)(v250 - 16) >= v253 )
                  {
                    v257 = *(_QWORD *)(v250 - 16) <= v253 && *(_QWORD *)(v250 - 32) < v247[-2].m128_u64[0];
                    v258 = 32 * (unsigned int)((v254 || v255) && *(_QWORD *)(v250 - 32) < v247[-2].m128_u64[0]);
                    v247 = (__m128 *)((char *)v247 - v258);
                    v250 = v258 + v250 - 32;
                    v255 = !v257;
                    v256 = (__m128 *)v250;
                    if ( !v255 )
                      v256 = v247;
                  }
                  else
                  {
                    v247 -= 2;
                    v256 = v247;
                  }
                  a4 = (__m128)_mm_loadu_si128((const __m128i *)v256);
                  a5 = (__m128i)v256[1];
                  v251[1] = (__m128)a5;
                  *v251 = a4;
                  if ( v247 <= v245 )
                    break;
                  v251 -= 2;
                }
                while ( v250 > (unsigned __int64)v205 );
                v245 = v247;
              }
              v232 = v205;
LABEL_433:
              v207 = v289;
              v233 = &v289[v316];
              memcpy(v245, v232, v250 - (_QWORD)v232);
              *(_QWORD *)v233 = &v310[v286];
              *((_QWORD *)v233 + 1) = v323;
              memmove(&v289[v252], &v289[v252 + 16], 16 * (~v311 + v300));
              v209 = v324;
              v203 = (char *)dest;
              if ( v324 <= 1 )
              {
                v209 = 1LL;
                goto LABEL_389;
              }
            }
            if ( v209 == 2 )
            {
              v209 = 2LL;
              goto LABEL_389;
            }
            v238 = v209 - 3;
            v239 = *(_QWORD *)&v207[16 * v209 - 48];
            if ( v239 > v237 + v236 )
            {
              if ( v209 <= 3 )
              {
                v209 = 3LL;
LABEL_389:
                v208 = v298;
LABEL_390:
                if ( v208 >= (unsigned __int64)v203 )
                {
                  _rust_dealloc(v207, 16 * v306, 8LL);
                  _rust_dealloc(v205, v315, 8LL);
                  goto LABEL_475;
                }
                continue;
              }
              if ( *(_QWORD *)&v207[16 * v209 - 64] > v239 + v237 )
                goto LABEL_389;
            }
            break;
          }
LABEL_443:
          if ( v239 < v236 )
            goto LABEL_445;
          goto LABEL_444;
        }
        v147 = v148 + 1;
        if ( v151 > v142 )
          v147 = v145;
        if ( v150 <= v142 )
          v145 = v147;
        else
          v146 = v148;
        v143 = v146 - v145;
        if ( v146 > v145 )
          continue;
        break;
      }
      v155 = *v325;
      v156 = 2;
      if ( *(_DWORD *)(*v325 + 96LL) == 47 )
        goto LABEL_333;
LABEL_295:
      if ( !*(_QWORD *)(v155 + 432) )
      {
        <gimli::read::line::LineProgramHeader<R,Offset> as core::clone::Clone>::clone(
          (__int64)&v340,
          (__int64 *)(v155 + 96),
          *(double *)a4.m128_u64,
          (__m128)a5);
        addr2line::Lines::parse(v317.m128i_i64, v155, &v340, (__int64)v6);
        if ( !*(_QWORD *)(v155 + 432) )
        {
          *(_QWORD *)(v155 + 432) = 1LL;
          v175 = v155 + 440;
          a4 = (__m128)_mm_loadu_si128(&v317);
          v178 = v318;
          *(__m128 *)(v155 + 440) = a4;
          *(_OWORD *)(v155 + 456) = v178;
          if ( !*(_QWORD *)(v155 + 440) )
            goto LABEL_303;
          goto LABEL_305;
        }
        v175 = v155 + 440;
        core::ptr::drop_in_place<core::result::Result<addr2line::Lines,gimli::read::Error>>(v317.m128i_i64);
        if ( *(_QWORD *)(v155 + 440) )
          goto LABEL_305;
LABEL_303:
        result = *(unsigned __int8 *)(v155 + 448);
        v175 = *(_QWORD *)(v155 + 456);
        if ( result == 75 )
        {
          if ( v175 )
            goto LABEL_305;
          goto LABEL_333;
        }
        *(_QWORD *)(v5 + 16) = result | ((unsigned __int64)(*(unsigned __int16 *)(v155 + 453) | (*(unsigned __int8 *)(v155 + 455) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(v155 + 449) << 8);
        *(_QWORD *)(v5 + 24) = v175;
        goto LABEL_3;
      }
      v175 = v155 + 440;
      if ( !*(_QWORD *)(v155 + 440) )
        goto LABEL_303;
LABEL_305:
      v179 = *(_QWORD *)(v175 + 16);
      v180 = *(_QWORD *)(v175 + 24);
      if ( v180 )
      {
        v181 = 0LL;
        v182 = *(_QWORD *)(v175 + 24);
        v183 = v182;
        do
        {
          v185 = v181 + (v182 >> 1);
          v186 = *(_QWORD *)(v179 + 32 * v185 + 16);
          v187 = *(_QWORD *)(v179 + 32 * v185 + 24);
          if ( v186 <= v142 && v187 > v142 )
          {
            v188 = v142 + 1;
            if ( v185 >= v180 )
              goto LABEL_331;
            goto LABEL_322;
          }
          v184 = v185 + 1;
          if ( v187 > v142 )
            v184 = v181;
          if ( v186 <= v142 )
            v181 = v184;
          else
            v183 = v185;
          v182 = v183 - v181;
        }
        while ( v183 > v181 );
        if ( v181 )
          v181 = *(_QWORD *)(v175 + 24);
        v185 = v181;
        v188 = v142 + 1;
        if ( v185 >= v180 )
          goto LABEL_331;
LABEL_322:
        v189 = *(_QWORD *)(v179 + 32 * v185 + 8);
        if ( v189 )
        {
          v190 = 0LL;
          v191 = *(_QWORD *)(v179 + 32 * v185 + 8);
          do
          {
            v192 = v190 + (v189 >> 1);
            v193 = *(_QWORD *)(*(_QWORD *)(v179 + 32 * v185) + 24 * v192);
            if ( v193 == v142 )
            {
              v194 = v192;
              goto LABEL_332;
            }
            if ( v193 > v142 )
              v191 = v192;
            if ( v193 < v142 )
              v190 = v192 + 1;
            v189 = v191 - v190;
          }
          while ( v191 > v190 );
          v254 = v190 == 0;
          v194 = v190 - 1;
          if ( !v254 )
            goto LABEL_332;
        }
      }
      else
      {
        v185 = 0LL;
        v188 = v142 + 1;
      }
LABEL_331:
      v194 = 0LL;
LABEL_332:
      v317.m128i_i64[0] = v175;
      v317.m128i_i64[1] = v179;
      *(_QWORD *)&v318 = v180;
      *((_QWORD *)&v318 + 1) = v185;
      v319 = v194;
      v320 = v188;
      <addr2line::LocationRangeUnitIter as core::iter::traits::iterator::Iterator>::next(
        (__int64)&v340,
        (__int64 **)&v317);
      v156 = v341.m128_i32[0];
      result = v341.m128_u32[1];
      v143 = v341.m128_u64[1];
      a4 = (__m128)_mm_loadu_si128(&v342);
LABEL_333:
      *(_QWORD *)v5 = v144;
      *(_DWORD *)(v5 + 8) = v156;
      *(_DWORD *)(v5 + 12) = result;
      *(_QWORD *)(v5 + 16) = v143;
      *(__m128 *)(v5 + 24) = a4;
      return result;
    default:
      goto LABEL_506;
  }
}
// 19BD6: masking with 0x1 was optimized away because bl.1 <= 0x1
// 19513: variable 'v35' is possibly undefined
// 19571: variable 'v39' is possibly undefined
// 19627: variable 'v40' is possibly undefined
// 1A9B3: variable 'v149' is possibly undefined
// 1AC47: variable 'v143' is possibly undefined
// 1AD99: variable 'v199' is possibly undefined
// 1AE59: variable 'v202' is possibly undefined
// 1B875: variable 'v287' is possibly undefined
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);
// 582D0: using guessed type char *off_582D0;
// 583D0: using guessed type char *off_583D0;
// 583E8: using guessed type char *off_583E8;
// 58400: using guessed type char *off_58400;
// 58418: using guessed type char *off_58418;
// 58430: using guessed type char *off_58430;
// 58448: using guessed type char *off_58448;
// 58460: using guessed type char *off_58460;
// 584A0: using guessed type char *off_584A0;
// 584B8: using guessed type char *off_584B8;
// 58898: using guessed type char *off_58898;
// 588C8: using guessed type char *off_588C8;

//----- (000000000001BFC0) ----------------------------------------------------
__int64 __fastcall addr2line::LoopingLookup<T,L,F>::new_lookup(
        __m128i *a1,
        __int64 a2,
        __int64 a3,
        __m128i a4,
        __m128i a5)
{
  unsigned __int64 v5; // r11
  const __m128i *v6; // r9
  __int128 v7; // xmm0
  __int128 v8; // xmm1
  __int128 v9; // xmm0
  __int128 v10; // xmm1
  __int128 v11; // xmm2
  __m128i v12; // xmm1
  __m128i v13; // xmm2
  __int64 result; // rax
  unsigned __int64 *v15; // r13
  unsigned __int64 v16; // r12
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // rsi
  __int64 v19; // rcx
  __int64 v20; // r8
  unsigned __int64 v21; // r14
  unsigned __int64 *v22; // r15
  unsigned __int64 v23; // rdi
  __int64 *v24; // rbp
  bool v25; // zf
  __int64 v26; // rbp
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rcx
  __m128i v30; // xmm0
  int v31; // ebx
  int v32; // r12d
  unsigned __int64 v33; // rcx
  __int64 v34; // r15
  __int64 v35; // rax
  unsigned __int64 v36; // rsi
  unsigned __int64 v37; // r13
  unsigned __int64 v38; // rdx
  bool v39; // cc
  unsigned __int64 v40; // r13
  __int64 v41; // r10
  unsigned __int64 *v42; // r8
  unsigned __int64 v43; // r13
  char v44; // [rsp+8h] [rbp-180h]
  unsigned __int64 v45; // [rsp+8h] [rbp-180h]
  unsigned __int64 v46; // [rsp+10h] [rbp-178h]
  volatile signed __int64 **v47; // [rsp+18h] [rbp-170h]
  __int64 v48; // [rsp+20h] [rbp-168h]
  __int64 v49; // [rsp+20h] [rbp-168h]
  __m128i *v50; // [rsp+28h] [rbp-160h]
  unsigned __int64 v51; // [rsp+30h] [rbp-158h]
  __int64 v52; // [rsp+38h] [rbp-150h]
  unsigned __int64 v53; // [rsp+40h] [rbp-148h]
  unsigned __int64 v54; // [rsp+48h] [rbp-140h]
  unsigned __int64 v55; // [rsp+48h] [rbp-140h]
  __int128 *v56; // [rsp+50h] [rbp-138h]
  __m128i v58; // [rsp+60h] [rbp-128h]
  unsigned __int64 v59; // [rsp+60h] [rbp-128h]
  __int64 v60; // [rsp+70h] [rbp-118h]
  __int64 v61; // [rsp+78h] [rbp-110h]
  __int128 src[9]; // [rsp+80h] [rbp-108h] BYREF
  __m128i v63; // [rsp+110h] [rbp-78h] BYREF
  __int128 v64; // [rsp+120h] [rbp-68h]
  __int128 v65; // [rsp+130h] [rbp-58h]
  __int64 v66[9]; // [rsp+140h] [rbp-48h] BYREF

  v6 = (const __m128i *)a2;
  v56 = (__int128 *)(a2 + 48);
  if ( *(_QWORD *)(a2 + 48) )
  {
LABEL_2:
    v7 = *v56;
    v8 = v56[1];
    src[2] = v56[2];
    src[1] = v8;
    src[0] = v7;
    *(_QWORD *)&src[8] = *(_QWORD *)(a3 + 80);
    src[7] = *(_OWORD *)(a3 + 64);
    v9 = *(_OWORD *)a3;
    v10 = *(_OWORD *)(a3 + 16);
    v11 = *(_OWORD *)(a3 + 32);
    src[6] = *(_OWORD *)(a3 + 48);
    src[5] = v11;
    src[4] = v10;
    src[3] = v9;
    v12 = _mm_loadu_si128(v6 + 1);
    v13 = v6[2];
    *a1 = _mm_loadu_si128(v6);
    a1[1] = v12;
    a1[2] = v13;
    return (__int64)memcpy(&a1[3], src, 0x88uLL);
  }
  v15 = *(unsigned __int64 **)(a3 + 48);
  v16 = *(_QWORD *)(a3 + 72);
  v17 = *(_QWORD *)(a3 + 32);
  v54 = *(_QWORD *)(a3 + 40);
  v60 = *(_QWORD *)(a3 + 24);
  result = *(_QWORD *)a3;
  v18 = *(_QWORD *)(a3 + 16);
  v19 = v6->m128i_u32[2];
  v20 = v6->m128i_u32[3];
  v46 = v6[1].m128i_u64[0];
  v21 = v6[1].m128i_u64[1];
  v44 = *(_BYTE *)(a3 + 80);
  v22 = *(unsigned __int64 **)(a3 + 56);
  v23 = v6[2].m128i_u64[0];
  v51 = v23;
  v52 = a3;
  v50 = (__m128i *)v6;
  while ( 1 )
  {
    v53 = result;
    v47 = (volatile signed __int64 **)v18;
    v24 = (__int64 *)v6->m128i_i64[0];
    if ( (_DWORD)v19 == 3 )
    {
      v32 = v20;
      v19 = v46;
      result = HIDWORD(v46);
      v31 = 5;
      LODWORD(a3) = v46;
      goto LABEL_25;
    }
    if ( v24 )
    {
      v31 = v19;
      v32 = v20;
      *(_QWORD *)&src[0] = 0LL;
      *((_QWORD *)&src[0] + 1) = 8LL;
      *(_QWORD *)&src[1] = 0LL;
      v33 = v24[3];
      if ( !v33 )
      {
        v36 = 0LL;
        goto LABEL_46;
      }
      v34 = v24[2];
      v49 = *v24;
      v45 = v24[1];
      v35 = 8LL;
      v36 = 0LL;
      while ( 1 )
      {
        v37 = v33;
        v38 = 0LL;
        v55 = v33;
        while ( 1 )
        {
          while ( 1 )
          {
            v40 = v38 + (v37 >> 1);
            v41 = 32 * v40;
            v42 = (unsigned __int64 *)(v34 + 32 * v40);
            if ( v42[2] <= v36 )
              break;
LABEL_31:
            v33 = v40;
            v39 = v40 <= v38;
            v37 = v40 - v38;
            if ( v39 )
              goto LABEL_46;
          }
          if ( *(_QWORD *)(v34 + 32 * v40 + 16) >= v36 )
            break;
          v43 = v40 + 1;
LABEL_37:
          v38 = v43;
          v37 = v33 - v43;
          if ( v33 <= v38 )
            goto LABEL_46;
        }
        if ( *v42 > v53 )
          goto LABEL_31;
        v43 = v40 + 1;
        if ( v42[1] <= v53 )
          goto LABEL_37;
        v59 = *(_QWORD *)(v34 + v41 + 24);
        if ( v59 >= v45 )
          core::panicking::panic_bounds_check(v59, v45, (__int64)&off_588B0);
        if ( v36 == *(_QWORD *)&src[0] )
        {
          alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)src, v36);
          v35 = *((_QWORD *)&src[0] + 1);
          v36 = *(_QWORD *)&src[1];
        }
        *(_QWORD *)(v35 + 8 * v36++) = v49 + 48 * v59;
        *(_QWORD *)&src[1] = v36;
        v34 += 32 * v43;
        v33 = v55 - v43;
        if ( v55 == v43 )
        {
LABEL_46:
          v20 = *((_QWORD *)&src[0] + 1);
          v23 = *(_QWORD *)&src[0];
          v19 = *((_QWORD *)&src[0] + 1) + 8 * v36;
          v6 = *(const __m128i **)(v52 + 8);
          v18 = (unsigned __int64)(*v47 + 2);
          LODWORD(a3) = v46;
          result = HIDWORD(v46);
          v5 = v51;
          goto LABEL_25;
        }
      }
    }
    if ( (_DWORD)v19 != 2 )
    {
      v24 = 0LL;
      result = (unsigned int)v20;
      LODWORD(a3) = v19;
      v32 = v20;
      v6 = (const __m128i *)v51;
      v5 = v21;
      v31 = 4;
      v21 = v46;
      goto LABEL_25;
    }
    if ( v44 || v15 == v22 )
      break;
    v22 -= 4;
    v19 = v52;
    while ( 1 )
    {
      if ( v22[3] <= v16 )
      {
        *(_QWORD *)(v52 + 56) = v22;
        *(_BYTE *)(v52 + 80) = 1;
        result = 8LL;
        v44 = 1;
        v19 = 0LL;
        goto LABEL_17;
      }
      if ( v17 < v22[1] && v54 > *v22 )
        break;
      result = (__int64)(v22 - 4);
      v25 = v22 == v15;
      v22 -= 4;
      if ( v25 )
      {
        v31 = 3;
        v32 = v20;
        *(_QWORD *)(v52 + 56) = v15;
        goto LABEL_24;
      }
    }
    *(_QWORD *)(v52 + 56) = v22;
    v23 = v22[2];
    v18 = *(_QWORD *)(v60 + 32);
    if ( v23 >= v18 )
      core::panicking::panic_bounds_check(v23, v18, (__int64)&off_58880);
    *((_QWORD *)&src[0] + 1) = *(_QWORD *)(v60 + 24) + 536 * v23;
    result = 16LL;
    v44 = 0;
    v19 = (__int64)v22;
LABEL_17:
    *(_QWORD *)((char *)src + result) = v19;
    v26 = *((_QWORD *)&src[0] + 1);
    if ( !*((_QWORD *)&src[0] + 1) )
      break;
    v23 = (unsigned __int64)src;
    addr2line::ResUnit<R>::dwarf_and_unit_dwo(src, *((__int64 *)&src[0] + 1), v47);
    v66[0] = v26;
    v66[2] = v53;
    v66[1] = (__int64)v47;
    v48 = *(_QWORD *)&src[3];
    if ( *(_QWORD *)&src[3] )
    {
      v58 = *(__m128i *)((char *)&src[3] + 8);
      v63 = (__m128i)src[0];
      v64 = src[1];
      v65 = src[2];
      v61 = v26;
    }
    else
    {
      v23 = (unsigned __int64)&v63;
      addr2line::ResUnit<R>::find_function_or_location::{{closure}}((__int64)&v63, v66, (__int64)src, (__m128)a4, a5);
    }
    v18 = (unsigned __int64)v47;
    v21 = *((_QWORD *)&v64 + 1);
    v27 = v64;
    v28 = *((_QWORD *)&v65 + 1);
    v29 = v65;
    v30 = _mm_load_si128(&v63);
    v6 = v50;
    *v50 = v30;
    v46 = v27;
    v50[1] = (__m128i)__PAIR128__(v21, v27);
    v51 = v29;
    v50[2] = (__m128i)__PAIR128__(v28, v29);
    v50[3].m128i_i64[0] = v48;
    *(__m128i *)((char *)v50 + 56) = v58;
    v50[4].m128i_i64[1] = v61;
    v50[5].m128i_i64[0] = (__int64)v47;
    result = v53;
    v50[5].m128i_i64[1] = v53;
    a5 = _mm_shuffle_epi32(v30, 238);
    v19 = (unsigned int)_mm_cvtsi128_si32(a5);
    a4 = _mm_shuffle_epi32(v30, 255);
    v20 = (unsigned int)_mm_cvtsi128_si32(a4);
    a3 = v52;
    if ( v48 )
      goto LABEL_2;
  }
  v31 = 3;
  v32 = v20;
LABEL_24:
  v24 = 0LL;
LABEL_25:
  a1->m128i_i32[0] = v31;
  a1->m128i_i32[1] = v32;
  a1->m128i_i32[2] = a3;
  a1->m128i_i32[3] = result;
  a1[1].m128i_i64[0] = v21;
  a1[1].m128i_i64[1] = v5;
  a1[2].m128i_i64[0] = (__int64)v6;
  a1[2].m128i_i64[1] = v18;
  a1[3].m128i_i64[0] = (__int64)v24;
  a1[3].m128i_i64[1] = v20;
  a1[4].m128i_i64[0] = v20;
  a1[4].m128i_i64[1] = v23;
  a1[5].m128i_i64[0] = v19;
  a1[11].m128i_i8[0] = 2;
  return result;
}
// 1C2EB: variable 'v58' is possibly undefined
// 1C2F5: variable 'v61' is possibly undefined
// 1C352: variable 'v5' is possibly undefined
// 58880: using guessed type char *off_58880;
// 588B0: using guessed type char *off_588B0;

//----- (000000000001C5E0) ----------------------------------------------------
__int64 __fastcall addr2line::Lines::parse(__int64 *a1, __int64 a2, __m128i *a3, __int64 a4)
{
  unsigned __int64 v4; // r12
  unsigned __int64 v5; // r13
  __int64 v6; // rbx
  __int64 v7; // r9
  _QWORD *v8; // rdi
  __int64 v9; // rsi
  unsigned __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // rsi
  unsigned __int64 v13; // rbp
  int v14; // r14d
  unsigned __int8 *v15; // rax
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rdx
  __int64 v18; // r8
  __int64 v19; // r15
  __int64 v20; // r8
  unsigned __int64 v21; // r11
  int v22; // ecx
  char v23; // di
  __m128i v24; // xmm0
  __int64 v25; // r10
  unsigned __int64 v26; // rdx
  __int64 v27; // rcx
  char *v28; // rsi
  __int64 v29; // rdi
  unsigned __int8 *v30; // r8
  unsigned __int64 v31; // rdx
  int v32; // ecx
  __int64 v33; // rdi
  unsigned __int8 *v34; // r8
  unsigned __int64 v35; // rdx
  int v36; // ecx
  __int64 v37; // rdi
  int v38; // ecx
  __int64 v39; // rdx
  __int64 v40; // r10
  __int64 v41; // rdi
  unsigned __int8 *v42; // r8
  unsigned __int64 v43; // rdx
  int v44; // ecx
  __int64 v45; // rdi
  unsigned __int8 *v46; // r8
  unsigned __int64 v47; // rdx
  int v48; // ecx
  int v49; // r14d
  __int64 v50; // rax
  unsigned __int8 v51; // r14
  unsigned __int8 v52; // al
  signed __int64 v53; // rcx
  unsigned __int64 v54; // rcx
  __int64 v55; // rsi
  __int64 v56; // rax
  __int64 v57; // rcx
  __int64 v58; // rax
  unsigned __int64 v59; // rax
  unsigned __int64 v60; // rax
  __int64 v61; // rsi
  __int64 v62; // rax
  __int64 v63; // rdx
  int v64; // rdi^4
  unsigned __int64 v65; // r10
  _BYTE *v66; // rcx
  unsigned __int64 v67; // r10
  __int64 v68; // rdi
  unsigned __int64 v69; // rdx
  int v70; // ecx
  char v71; // r10
  unsigned __int8 *v72; // rcx
  unsigned __int64 v73; // r9
  unsigned __int64 v74; // rsi
  unsigned __int64 v75; // rax
  int v76; // ecx
  char v77; // r8
  unsigned __int8 v78; // cl
  unsigned __int64 v79; // r12
  unsigned __int64 v80; // rax
  unsigned __int64 v81; // rax
  unsigned __int64 v82; // rdx
  unsigned __int64 v83; // rtt
  unsigned __int64 v84; // rax
  unsigned __int64 v85; // rtt
  unsigned __int64 v86; // r12
  __int64 v87; // rax
  unsigned __int64 v88; // rsi
  unsigned __int64 v89; // rax
  unsigned __int64 v90; // rax
  unsigned __int64 v91; // rdx
  unsigned __int64 v92; // rtt
  __int64 v93; // rax
  unsigned __int64 v94; // rdx
  __int64 v95; // r15
  __int64 v96; // r11
  unsigned __int64 v97; // rsi
  int v98; // ecx
  char v99; // bp
  __int64 v100; // rbp
  unsigned __int64 v101; // r10
  unsigned __int64 v102; // r12
  unsigned __int64 v103; // rbp
  int v104; // ecx
  char v105; // r11
  char *v106; // r10
  __int64 v107; // r15
  int v108; // ecx
  char v109; // r11
  unsigned __int64 v110; // r12
  int v111; // ecx
  char v112; // r11
  unsigned __int64 v113; // r12
  unsigned __int64 v114; // r15
  __int64 v115; // r14
  unsigned __int64 v116; // rax
  _QWORD *v117; // rbp
  __int64 v118; // rsi
  __int64 v119; // r15
  __int64 v120; // r14
  int v121; // ebp
  __int64 v122; // rax
  __int64 v123; // rax
  __int64 v124; // rcx
  __int64 v125; // rax
  unsigned __int8 *v126; // rax
  __m128i si128; // xmm0
  unsigned __int8 v128; // si
  __int64 *v129; // rax
  __int64 result; // rax
  __int64 v131; // rbx
  unsigned __int64 v132; // r14
  __int64 *v133; // r15
  __int64 v134; // rsi
  __int64 v135; // rdi
  unsigned __int64 v136; // r15
  __int64 v137; // rax
  char *v138; // r14
  __int64 v139; // rax
  char *v140; // rbx
  char *v141; // r10
  unsigned __int64 v142; // r14
  unsigned __int64 v143; // rbp
  unsigned __int64 v144; // rsi
  __int64 v145; // rax
  __int64 v146; // rdi
  unsigned __int64 v147; // rdx
  unsigned __int64 v148; // rsi
  unsigned __int64 v149; // rbx
  unsigned __int64 v150; // rbx
  char *v151; // r12
  char *v152; // rax
  char *v153; // r15
  size_t v154; // r12
  void *v155; // rbp
  void *v156; // rdi
  unsigned __int64 v157; // r8
  unsigned __int64 v158; // rcx
  unsigned __int64 *v159; // rdx
  unsigned __int64 v160; // r9
  unsigned __int64 v161; // rdx
  __m128i *v162; // rax
  __m128i *v163; // rsi
  __m128i v164; // xmm0
  __m128i v165; // xmm0
  __int64 v166; // rax
  __int64 v167; // r12
  char *v168; // rsi
  char *v169; // r14
  _QWORD *v170; // rbp
  __int64 v171; // r9
  __int64 v172; // rcx
  unsigned __int64 v173; // rax
  unsigned __int64 v174; // rsi
  unsigned __int64 v175; // r10
  unsigned __int64 v176; // rcx
  unsigned __int64 v177; // rdi
  __int64 v178; // rcx
  unsigned __int64 v179; // rbp
  __int64 v180; // r12
  unsigned __int64 v181; // rax
  __m128i *v182; // r15
  __int64 v183; // r13
  __m128i *v184; // rbx
  __int64 v185; // rbp
  __int64 v186; // r14
  char *v187; // r13
  __m128i *v188; // rbp
  _QWORD *v189; // r14
  unsigned __int64 v190; // rdx
  unsigned __int64 v191; // rsi
  __m128i *v192; // rax
  __m128i v193; // xmm0
  __int64 v194; // r8
  unsigned __int64 v195; // rbp
  __m128i *v196; // rdx
  unsigned __int64 v197; // rcx
  int v198; // eax
  bool v199; // cf
  _BOOL4 v200; // esi
  __m128i *v201; // rdi
  __m128i v202; // xmm0
  unsigned __int64 *v203; // rax
  unsigned __int64 v204; // rcx
  char *v205; // r14
  __int64 *v206; // rdx
  __int64 v207; // r14
  __int64 v208; // r15
  const char *v209; // r12
  __int64 *v210; // rax
  __int64 v211; // r14
  __int64 v212; // r9
  __int64 v213; // rsi
  unsigned __int64 v214; // rdx
  _QWORD *v215; // rax
  unsigned __int64 v216; // rbx
  __int64 v217; // rbp
  __int64 v218; // rax
  __int64 *v219; // rdx
  __int128 v220; // kr10_16
  const char *v221; // r14
  __int64 v222; // rcx
  __int64 v223; // r15
  unsigned __int64 v224; // r14
  __int64 v225; // rsi
  __int64 *v226; // rax
  __int64 v227; // rbx
  _QWORD *v228; // r15
  __int64 v229; // rsi
  unsigned __int8 v230; // al
  unsigned __int8 v231; // al
  __int64 v232; // rcx
  unsigned __int8 *v233; // rax
  __int64 v234; // rdi
  unsigned __int64 v235; // r12
  __int64 v236; // rsi
  __int64 *v237; // rax
  const char *v238; // rdi
  char **v239; // rdx
  char **v240; // rsi
  __int64 v241; // rdi
  unsigned __int64 v242; // [rsp+8h] [rbp-2D0h]
  char *v243; // [rsp+8h] [rbp-2D0h]
  char *v244; // [rsp+8h] [rbp-2D0h]
  __m128i v245; // [rsp+10h] [rbp-2C8h] BYREF
  __int128 v246; // [rsp+28h] [rbp-2B0h] BYREF
  unsigned __int64 v247; // [rsp+38h] [rbp-2A0h]
  __int64 v248; // [rsp+40h] [rbp-298h]
  _QWORD *v249; // [rsp+48h] [rbp-290h]
  unsigned __int64 v250; // [rsp+50h] [rbp-288h]
  void *src; // [rsp+58h] [rbp-280h]
  __int64 v252; // [rsp+60h] [rbp-278h]
  __int16 v253; // [rsp+6Eh] [rbp-26Ah]
  __m128i v254; // [rsp+70h] [rbp-268h] BYREF
  unsigned __int64 v255; // [rsp+80h] [rbp-258h]
  unsigned __int64 v256; // [rsp+88h] [rbp-250h]
  char **v257; // [rsp+90h] [rbp-248h]
  unsigned __int64 v258; // [rsp+98h] [rbp-240h]
  __int64 v259; // [rsp+A0h] [rbp-238h]
  __int64 v260; // [rsp+A8h] [rbp-230h]
  unsigned __int64 v261; // [rsp+B0h] [rbp-228h] BYREF
  __int64 v262; // [rsp+B8h] [rbp-220h]
  unsigned __int64 v263; // [rsp+C0h] [rbp-218h]
  unsigned __int64 v264; // [rsp+C8h] [rbp-210h] BYREF
  _QWORD *v265; // [rsp+D0h] [rbp-208h]
  __int64 v266; // [rsp+D8h] [rbp-200h]
  unsigned __int64 v267; // [rsp+E0h] [rbp-1F8h]
  __int64 *v268; // [rsp+E8h] [rbp-1F0h]
  unsigned __int64 v269; // [rsp+F0h] [rbp-1E8h]
  __int64 dest[31]; // [rsp+F8h] [rbp-1E0h] BYREF
  unsigned __int128 v271; // [rsp+1F0h] [rbp-E8h]
  __int64 v272; // [rsp+200h] [rbp-D8h]
  unsigned __int64 v273; // [rsp+208h] [rbp-D0h]
  _BYTE v274[25]; // [rsp+210h] [rbp-C8h] BYREF
  char v275; // [rsp+229h] [rbp-AFh]
  int v276; // [rsp+22Ah] [rbp-AEh]
  __m128i v277; // [rsp+230h] [rbp-A8h]
  unsigned __int64 v278; // [rsp+240h] [rbp-98h]
  unsigned __int64 v279; // [rsp+248h] [rbp-90h]
  unsigned __int64 v280; // [rsp+250h] [rbp-88h]
  unsigned __int64 v281; // [rsp+258h] [rbp-80h]
  __int64 v282; // [rsp+260h] [rbp-78h]
  __int64 v283; // [rsp+268h] [rbp-70h]
  __int128 v284; // [rsp+270h] [rbp-68h] BYREF
  const char *v285; // [rsp+280h] [rbp-58h]
  __int128 v286; // [rsp+288h] [rbp-50h]
  __int64 v287; // [rsp+2A0h] [rbp-38h]

  v283 = a4;
  v282 = a2;
  v268 = a1;
  v261 = 0LL;
  v262 = 8LL;
  v263 = 0LL;
  v264 = 0LL;
  v265 = (_QWORD *)&byte_8;
  v266 = 0LL;
  LOBYTE(v6) = a3[14].m128i_i8[12];
  v245 = a3[11];
  memcpy(dest, a3, sizeof(dest));
  v271 = 0LL;
  v272 = 1LL;
  v273 = 1LL;
  memset(v274, 0, sizeof(v274));
  v275 = v6;
  v276 = 0;
  v277 = _mm_load_si128(&v245);
  v8 = (_QWORD *)&byte_8;
  v9 = 0LL;
  v259 = 8LL;
  v260 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  while ( 1 )
  {
    v281 = v10;
    v269 = v9;
    v249 = v8;
    if ( (_BYTE)v11 )
    {
      v11 = BYTE4(dest[29]);
      v271 = 0LL;
      v272 = 1LL;
      v273 = 1LL;
      v274[24] = 0;
      *(_OWORD *)v274 = 0LL;
      v275 = BYTE4(dest[29]);
      BYTE1(v276) = 0;
    }
    *(_QWORD *)&v274[16] = 0LL;
    LOBYTE(v276) = 0;
    HIWORD(v276) = 0;
    v12 = v277.m128i_i64[1];
    if ( !v277.m128i_i64[1] )
      break;
    v245.m128i_i64[0] = v11;
    v248 = v11;
    LODWORD(v13) = 0;
    while ( 2 )
    {
      v14 = v13;
      v15 = (unsigned __int8 *)v277.m128i_i64[0];
      v16 = v12 - 1;
      v17 = ++v277.m128i_i64[0];
      v277.m128i_i64[1] = v12 - 1;
      v18 = *v15;
      if ( !*v15 )
      {
        if ( v12 == 1 )
        {
LABEL_223:
          v230 = 19;
          goto LABEL_225;
        }
        v17 = v12 - 1;
        v20 = 0LL;
        v21 = 0LL;
        v22 = 0;
        while ( 1 )
        {
          v23 = v15[v20 + 1];
          if ( v22 == 63 && (unsigned __int8)v23 >= 2u )
          {
            v277.m128i_i64[0] = (__int64)&v15[v20 + 2];
            v230 = 6;
            goto LABEL_225;
          }
          v21 |= (unsigned __int64)(v23 & 0x7F) << v22;
          if ( v23 >= 0 )
            break;
          v22 += 7;
          if ( v17 == ++v20 )
          {
LABEL_222:
            v126 = &v15[v12];
            v277 = (__m128i)(unsigned __int64)v126;
            v17 = (unsigned __int64)v126;
            goto LABEL_223;
          }
        }
        if ( v12 - v20 - 2 < v21
          || (v16 = v12 - v21 - v20 - 2,
              v25 = v20 + v21,
              v7 = (__int64)&v15[v20 + 2 + v21],
              v277.m128i_i64[0] = v7,
              v277.m128i_i64[1] = v16,
              !v21) )
        {
          v17 = (unsigned __int64)&v15[v20 + 2];
LABEL_373:
          si128 = _mm_load_si128((const __m128i *)&xmmword_482A0);
LABEL_226:
          v4 = 0LL;
LABEL_227:
          v128 = 0;
          LOBYTE(v6) = 0;
          goto LABEL_228;
        }
        v26 = v21 - 1;
        v27 = v15[v20 + 2];
        v28 = (char *)&v15[v20 + 3];
        switch ( v15[v20 + 2] )
        {
          case 1u:
            v19 = 62LL;
LABEL_64:
            v24 = _mm_load_si128(&v254);
            goto LABEL_65;
          case 2u:
            v7 = LOBYTE(dest[29]);
            v78 = 23;
            switch ( LOBYTE(dest[29]) )
            {
              case 1:
                if ( v21 != 1 )
                {
                  v24 = _mm_cvtsi32_si128((unsigned __int8)*v28);
                  v4 = 0LL;
                  v19 = 63LL;
                  v245.m128i_i64[0] = 0LL;
                  LOBYTE(v6) = 0;
                  goto LABEL_65;
                }
                *(_QWORD *)((char *)&v246 + 7) = &v15[v20 + 3];
                v78 = 19;
                v128 = 0;
                LOBYTE(v6) = 0;
                v4 = 0LL;
                LOBYTE(v7) = 0;
                break;
              case 2:
                if ( v26 > 1 )
                {
                  v102 = *(unsigned __int16 *)v28;
                  v78 = 75;
                  goto LABEL_186;
                }
                v102 = (unsigned __int64)&v15[v20 + 3];
                LOWORD(v246) = 0;
                BYTE2(v246) = 0;
                *(_DWORD *)((char *)&v246 + 3) = 0;
                goto LABEL_185;
              case 4:
                if ( v26 <= 3 )
                {
                  v102 = (unsigned __int64)&v15[v20 + 3];
                  LODWORD(v246) = 0;
                  BYTE6(v246) = 0;
                  WORD2(v246) = 0;
LABEL_185:
                  v78 = 19;
                }
                else
                {
                  v102 = *(unsigned int *)v28;
                  v78 = 75;
                }
LABEL_186:
                *(_QWORD *)((char *)&v246 + 7) = v102;
                if ( v78 == 75 )
                {
                  v24 = _mm_cvtsi32_si128(v102);
                  goto LABEL_188;
                }
                LOBYTE(v7) = 0;
LABEL_402:
                v128 = BYTE1(v246);
                LODWORD(v6) = *(_DWORD *)((char *)&v246 + 1) >> 8;
                v4 = (*(unsigned int *)((char *)&v246 + 1) | ((unsigned __int64)*(unsigned __int16 *)((char *)&v246 + 5) << 32)) >> 16;
                break;
              case 8:
                if ( v26 >= 8 )
                {
                  v102 = *(_QWORD *)v28;
                  v24 = (__m128i)*(unsigned __int64 *)v28;
LABEL_188:
                  v245.m128i_i64[0] = WORD1(v102);
                  LODWORD(v6) = BYTE3(v102);
                  v4 = HIDWORD(v102);
                  v19 = 63LL;
                  goto LABEL_65;
                }
                *(_QWORD *)&v284 = 19LL;
                *((_QWORD *)&v284 + 1) = &v15[v20 + 3];
                LOBYTE(v7) = 0;
                DWORD2(v246) = *((_QWORD *)&v284 + 1) >> 8;
                *(_DWORD *)((char *)&v246 + 11) = HIDWORD(v284);
                *(_QWORD *)&v246 = *(_QWORD *)((char *)&v284 + 1);
                v128 = 0;
                LOBYTE(v6) = 0;
                v4 = *(_QWORD *)((char *)&v284 + 1) >> 24;
                v78 = 19;
                break;
              default:
                goto LABEL_402;
            }
            v17 = *(_QWORD *)((char *)&v246 + 7);
            si128 = _mm_cvtsi32_si128(v78 | ((unsigned __int8)v7 << 8));
            goto LABEL_228;
          case 3u:
            if ( WORD1(dest[29]) >= 5u )
            {
              v86 = (unsigned __int64)&v15[v20 + 3];
              v24 = _mm_cvtsi32_si128(v86);
              v245.m128i_i64[0] = (unsigned int)((_DWORD)v15 + v20 + 3) >> 16;
              LODWORD(v6) = (unsigned int)((_DWORD)v15 + v20 + 3) >> 24;
              v4 = HIDWORD(v86);
              v87 = v26 >> 8;
              v242 = v26 >> 8;
              v19 = 66LL;
              LOBYTE(v87) = 3;
              v248 = v87;
              LOBYTE(v5) = v21 - 1;
              goto LABEL_65;
            }
            if ( v21 == 1 )
              goto LABEL_374;
            v72 = &v15[v20];
            v73 = v21 - 3;
            v74 = v21 - 4;
            v5 = 0LL;
            while ( v72[v5 + 3] )
            {
              ++v5;
              --v73;
              --v74;
              if ( v21 - 1 == v5 )
              {
LABEL_374:
                v17 = (unsigned __int64)&v15[v20 + 3];
                si128 = (__m128i)xmmword_482A0;
                goto LABEL_226;
              }
            }
            if ( v21 - 2 == v5 )
            {
              v17 = (unsigned __int64)&v72[v5 + 4];
              goto LABEL_409;
            }
            v17 = (unsigned __int64)&v72[v5 + 4];
            v103 = 0LL;
            v104 = 0;
            while ( 1 )
            {
              v105 = *(_BYTE *)v17;
              if ( v104 == 63 && (unsigned __int8)v105 >= 2u )
              {
LABEL_377:
                v231 = 6;
                goto LABEL_410;
              }
              v103 |= (unsigned __int64)(v105 & 0x7F) << v104;
              if ( v105 >= 0 )
                break;
              ++v17;
              v104 += 7;
              --v74;
              v199 = v73-- != 0;
              if ( !v199 )
              {
                v17 = (unsigned __int64)&v15[v25 + 2];
                goto LABEL_409;
              }
            }
            if ( v73 )
            {
              v106 = (char *)(v17 + 1);
              v107 = 0LL;
              v108 = 0;
              while ( 1 )
              {
                v109 = *v106;
                if ( v108 == 63 && (unsigned __int8)v109 >= 2u )
                  goto LABEL_377;
                v107 |= (unsigned __int64)(v109 & 0x7F) << v108;
                if ( v109 >= 0 )
                  break;
                ++v106;
                v108 += 7;
                v199 = v74-- != 0;
                if ( !v199 )
                {
                  v17 += v73 + 1;
                  goto LABEL_409;
                }
              }
              if ( v74 )
              {
                v17 = (unsigned __int64)(v106 + 1);
                v7 = 0LL;
                v110 = 0LL;
                v111 = 0;
                do
                {
                  v112 = *(_BYTE *)v17;
                  if ( v111 == 63 && (unsigned __int8)v112 >= 2u )
                    goto LABEL_377;
                  v110 |= (unsigned __int64)(v112 & 0x7F) << v111;
                  if ( v112 >= 0 )
                  {
                    src = (void *)v110;
                    v252 = v107;
                    v248 = v103;
                    v256 = v103 >> 8;
                    v113 = (unsigned __int64)&v15[v20 + 3];
                    v24 = _mm_cvtsi32_si128(v113);
                    v245.m128i_i64[0] = (unsigned int)((_DWORD)v15 + v20 + 3) >> 16;
                    LODWORD(v6) = (unsigned int)((_DWORD)v15 + v20 + 3) >> 24;
                    v4 = HIDWORD(v113);
                    v242 = v5 >> 8;
                    v19 = 31LL;
                    goto LABEL_65;
                  }
                  ++v17;
                  v111 += 7;
                  ++v7;
                }
                while ( v74 != v7 );
                v17 = (unsigned __int64)&v106[v74 + 1];
              }
              else
              {
                v17 = (unsigned __int64)(v106 + 1);
              }
            }
            else
            {
              ++v17;
            }
LABEL_409:
            v231 = 19;
LABEL_410:
            si128 = _mm_unpacklo_epi32(
                      _mm_unpacklo_epi16(_mm_unpacklo_epi8(_mm_cvtsi32_si128(v231), (__m128i)0LL), (__m128i)0LL),
                      (__m128i)0LL);
            goto LABEL_226;
          case 4u:
            if ( v21 == 1 )
            {
              v7 = (__int64)&v15[v20 + 3];
            }
            else
            {
              v75 = 0LL;
              v76 = 0;
              do
              {
                v77 = *v28;
                if ( v76 == 63 && (unsigned __int8)v77 >= 2u )
                {
                  v230 = 6;
                  v17 = v279;
                  goto LABEL_225;
                }
                v75 |= (unsigned __int64)(v77 & 0x7F) << v76;
                if ( v77 >= 0 )
                {
                  v245.m128i_i64[0] = WORD1(v75);
                  v24 = _mm_cvtsi32_si128(v75);
                  LODWORD(v6) = BYTE3(v75);
                  v4 = HIDWORD(v75);
                  v19 = 65LL;
                  v279 = v75;
                  goto LABEL_65;
                }
                --v26;
                ++v28;
                v76 += 7;
              }
              while ( v26 );
            }
LABEL_376:
            v230 = 19;
            v17 = v7;
            goto LABEL_225;
          default:
            v79 = (unsigned __int64)&v15[v20 + 3];
            v24 = _mm_cvtsi32_si128(v79);
            v245.m128i_i64[0] = (unsigned int)((_DWORD)v15 + v20 + 3) >> 16;
            LODWORD(v6) = (unsigned int)((_DWORD)v15 + v20 + 3) >> 24;
            v4 = HIDWORD(v79);
            v242 = v26 >> 8;
            v19 = 66LL;
            LOBYTE(v5) = v21 - 1;
            v248 = v27;
            goto LABEL_65;
        }
      }
      if ( (unsigned __int8)v18 >= BYTE1(dest[30]) )
      {
        v24 = _mm_cvtsi32_si128((unsigned __int8)v18 | _mm_cvtsi128_si32(_mm_load_si128(&v254)) & 0xFFFFFF00);
        v19 = 46LL;
        goto LABEL_65;
      }
      switch ( *v15 )
      {
        case 1u:
          v19 = 47LL;
          goto LABEL_64;
        case 2u:
          if ( v12 == 1 )
            goto LABEL_223;
          v45 = 2 - v12;
          v46 = v15 + 2;
          v47 = 0LL;
          v48 = 0;
          while ( 2 )
          {
            LOBYTE(v7) = *(v46 - 1);
            if ( v48 == 63 && (unsigned __int8)v7 >= 2u )
            {
              v277.m128i_i64[0] = (__int64)v46;
              v277.m128i_i64[1] = -v45;
              v230 = 6;
              v17 = v280;
              goto LABEL_225;
            }
            v7 = (unsigned __int8)v7;
            v47 |= (unsigned __int64)(v7 & 0x7F) << v48;
            if ( (v7 & 0x80u) != 0LL )
            {
              v48 += 7;
              ++v45;
              ++v46;
              if ( v45 == 1 )
                goto LABEL_222;
              continue;
            }
            break;
          }
          v277.m128i_i64[0] = (__int64)v46;
          v16 = -v45;
          v277.m128i_i64[1] = v16;
          v245.m128i_i64[0] = WORD1(v47);
          v24 = _mm_cvtsi32_si128(v47);
          LODWORD(v6) = BYTE3(v47);
          v4 = HIDWORD(v47);
          v19 = 48LL;
          v280 = v47;
LABEL_65:
          v254 = v24;
          v13 = (v4 << 32) | ((unsigned __int8)v6 << 24) | (v245.m128i_u8[0] << 16);
          v49 = _mm_cvtsi128_si32(v24) | v14;
          v50 = v19 - 46;
          if ( (unsigned __int64)(v19 - 46) >= 0x15 )
            v50 = 18LL;
          break;
        case 3u:
          v37 = 0LL;
          v7 = -2LL;
          v38 = 0;
          v39 = 0LL;
          while ( v12 - 1 != v37 )
          {
            v277.m128i_i64[0] = (__int64)&v15[v37 + 2];
            v277.m128i_i64[1] = v12 + v7;
            v40 = v15[v37 + 1];
            if ( v38 == 63 && v40 != 127 && v15[v37 + 1] )
            {
              v230 = 7;
              v17 = v278;
              goto LABEL_225;
            }
            v39 |= (unsigned __int64)(v40 & 0x7F) << v38;
            v38 += 7;
            ++v37;
            --v7;
            if ( (v40 & 0x80u) == 0LL )
            {
              v93 = -1LL << v38;
              if ( (unsigned __int8)v40 < 0x40u )
                v93 = 0LL;
              if ( v38 >= 64 )
                v93 = 0LL;
              v94 = v93 | v39;
              v245.m128i_i64[0] = WORD1(v94);
              v24 = _mm_cvtsi32_si128(v94);
              LODWORD(v6) = BYTE3(v94);
              v4 = HIDWORD(v94);
              v16 = v12 + ~v37;
              v19 = 49LL;
              v278 = v94;
              goto LABEL_65;
            }
          }
          v17 = (unsigned __int64)&v15[v37 + 1];
          goto LABEL_223;
        case 4u:
          if ( v12 == 1 )
            goto LABEL_223;
          v41 = 2 - v12;
          v42 = v15 + 2;
          v43 = 0LL;
          v44 = 0;
          while ( 1 )
          {
            LOBYTE(v7) = *(v42 - 1);
            if ( v44 == 63 && (unsigned __int8)v7 >= 2u )
              break;
            v7 = (unsigned __int8)v7;
            v43 |= (unsigned __int64)(v7 & 0x7F) << v44;
            if ( (v7 & 0x80u) == 0LL )
            {
              v277.m128i_i64[0] = (__int64)v42;
              v16 = -v41;
              v277.m128i_i64[1] = v16;
              v245.m128i_i64[0] = WORD1(v43);
              v24 = _mm_cvtsi32_si128(v43);
              LODWORD(v6) = BYTE3(v43);
              v4 = HIDWORD(v43);
              v19 = 50LL;
              v267 = v43;
              goto LABEL_65;
            }
            v44 += 7;
            ++v41;
            ++v42;
            if ( v41 == 1 )
              goto LABEL_222;
          }
          v277.m128i_i64[0] = (__int64)v42;
          v277.m128i_i64[1] = -v41;
          v230 = 6;
          v17 = v267;
          goto LABEL_225;
        case 5u:
          if ( v12 == 1 )
            goto LABEL_223;
          v33 = 2 - v12;
          v34 = v15 + 2;
          v35 = 0LL;
          v36 = 0;
          while ( 1 )
          {
            LOBYTE(v7) = *(v34 - 1);
            if ( v36 == 63 && (unsigned __int8)v7 >= 2u )
              break;
            v7 = (unsigned __int8)v7;
            v35 |= (unsigned __int64)(v7 & 0x7F) << v36;
            if ( (v7 & 0x80u) == 0LL )
            {
              v277.m128i_i64[0] = (__int64)v34;
              v16 = -v33;
              v277.m128i_i64[1] = v16;
              v245.m128i_i64[0] = WORD1(v35);
              v24 = _mm_cvtsi32_si128(v35);
              LODWORD(v6) = BYTE3(v35);
              v4 = HIDWORD(v35);
              v19 = 51LL;
              v255 = v35;
              goto LABEL_65;
            }
            v36 += 7;
            ++v33;
            ++v34;
            if ( v33 == 1 )
              goto LABEL_222;
          }
          v277.m128i_i64[0] = (__int64)v34;
          v277.m128i_i64[1] = -v33;
          v230 = 6;
          v17 = v255;
          goto LABEL_225;
        case 6u:
          v19 = 52LL;
          goto LABEL_64;
        case 7u:
          v19 = 53LL;
          goto LABEL_64;
        case 8u:
          v19 = 54LL;
          goto LABEL_64;
        case 9u:
          if ( v16 <= 1 )
            goto LABEL_373;
          v277.m128i_i64[0] = (__int64)(v15 + 3);
          v277.m128i_i64[1] = v12 - 3;
          v24 = _mm_cvtsi32_si128(*(unsigned __int16 *)(v15 + 1));
          v19 = 55LL;
          v16 = v12 - 3;
          goto LABEL_65;
        case 0xAu:
          v19 = 56LL;
          goto LABEL_64;
        case 0xBu:
          v19 = 57LL;
          goto LABEL_64;
        case 0xCu:
          if ( v12 == 1 )
            goto LABEL_223;
          v29 = 2 - v12;
          v30 = v15 + 2;
          v31 = 0LL;
          v32 = 0;
          while ( 1 )
          {
            LOBYTE(v7) = *(v30 - 1);
            if ( v32 == 63 && (unsigned __int8)v7 >= 2u )
              break;
            v7 = (unsigned __int8)v7;
            v31 |= (unsigned __int64)(v7 & 0x7F) << v32;
            if ( (v7 & 0x80u) == 0LL )
            {
              v277.m128i_i64[0] = (__int64)v30;
              v16 = -v29;
              v277.m128i_i64[1] = v16;
              v245.m128i_i64[0] = WORD1(v31);
              v24 = _mm_cvtsi32_si128(v31);
              LODWORD(v6) = BYTE3(v31);
              v4 = HIDWORD(v31);
              v19 = 58LL;
              v250 = v31;
              goto LABEL_65;
            }
            v32 += 7;
            ++v29;
            ++v30;
            if ( v29 == 1 )
              goto LABEL_222;
          }
          v277.m128i_i64[0] = (__int64)v30;
          v277.m128i_i64[1] = -v29;
          v230 = 6;
          v17 = v250;
          goto LABEL_225;
        default:
          v7 = dest[21];
          v65 = (unsigned __int8)(v18 - 1);
          if ( dest[21] < v65 )
          {
            si128 = _mm_or_si128(
                      _mm_and_si128(
                        _mm_slli_epi16(
                          _mm_cvtsi32_si128((unsigned int)_mm_cvtsi128_si32(_mm_load_si128(&v254)) >> 8),
                          8u),
                        (__m128i)xmmword_482B0),
                      (__m128i)xmmword_482A0);
            v17 = dest[20];
            goto LABEL_398;
          }
          v66 = (_BYTE *)(v65 + dest[20]);
          if ( dest[21] == v65 )
          {
            si128 = (__m128i)xmmword_482A0;
            v4 = 0LL;
            v17 = v65 + dest[20];
            goto LABEL_227;
          }
          v67 = (unsigned __int8)*v66;
          if ( !*v66 )
          {
            v24 = _mm_cvtsi32_si128((unsigned __int8)v18 | _mm_cvtsi128_si32(_mm_load_si128(&v254)) & 0xFFFFFF00);
            v19 = 59LL;
            goto LABEL_65;
          }
          if ( (_DWORD)v67 != 1 )
          {
            v248 = v17;
            v95 = v12 - 1;
            v243 = 0LL;
            while ( 1 )
            {
              v7 = v248;
              if ( !v95 )
                goto LABEL_376;
              v96 = v95;
              v5 = 0LL;
              v97 = 0LL;
              v98 = 0;
              while ( 1 )
              {
                v99 = *(_BYTE *)(v248 + v5);
                if ( v98 == 63 && (unsigned __int8)v99 >= 2u )
                {
                  v277.m128i_i64[0] = v248 + v5 + 1;
                  v277.m128i_i64[1] = v95 + ~v5;
                  v230 = 6;
                  v17 = (unsigned __int64)v257;
                  goto LABEL_225;
                }
                v97 |= (unsigned __int64)(*(_BYTE *)(v248 + v5) & 0x7F) << v98;
                if ( v99 >= 0 )
                  break;
                v98 += 7;
                if ( v95 == ++v5 )
                {
                  v7 = v95 + v248;
                  v277 = (__m128i)(unsigned __int64)(v95 + v248);
                  goto LABEL_376;
                }
              }
              v248 += v5 + 1;
              v277.m128i_i64[0] = v7 + v5 + 1;
              v100 = ~v5;
              v95 += ~v5;
              v277.m128i_i64[1] = ~v5 + v96;
              v258 = v67;
              v257 = (char **)v97;
              if ( ++v243 == (char *)v67 )
              {
                v101 = v5 + v7 - (_QWORD)v15;
                if ( v16 >= v101 )
                {
                  v24 = _mm_cvtsi32_si128(v17);
                  v245.m128i_i64[0] = WORD1(v17);
                  LODWORD(v6) = BYTE3(v17);
                  LOBYTE(v7) = v7 - (_BYTE)v15;
                  LOBYTE(v5) = v7 + v5;
                  v242 = v101 >> 8;
                  v19 = 61LL;
                  v16 = v96 + v100;
                  v4 = HIDWORD(v17);
                  v248 = v18;
                  v257 = (char **)v97;
                  goto LABEL_65;
                }
                si128 = _mm_or_si128(
                          _mm_and_si128(
                            _mm_slli_epi16(
                              _mm_cvtsi32_si128((unsigned int)_mm_cvtsi128_si32(_mm_load_si128(&v254)) >> 8),
                              8u),
                            (__m128i)xmmword_482B0),
                          (__m128i)xmmword_482A0);
LABEL_398:
                v128 = v245.m128i_i8[0];
LABEL_228:
                v277.m128i_i64[0] = (__int64)aRustc9b00956e5;
                v277.m128i_i64[1] = 0LL;
                v129 = v268;
                v268[1] = (unsigned int)_mm_extract_epi16(si128, 0) | (v4 << 32) | ((unsigned __int8)v6 << 24) | (v128 << 16);
                v129[2] = v17;
                *v129 = 0LL;
LABEL_229:
                if ( dest[8] )
                  _rust_dealloc(dest[9], 4 * dest[8], 2LL);
                if ( dest[11] )
                  _rust_dealloc(dest[12], 24 * dest[11], 8LL);
                if ( dest[14] )
                  _rust_dealloc(dest[15], 4 * dest[14], 2LL);
                if ( dest[17] )
                  _rust_dealloc(dest[18], dest[17] << 6, 8LL);
                result = v264;
                if ( v264 )
                  result = _rust_dealloc(v265, 24 * v264, 8LL);
                v131 = v262;
                v132 = v263;
                if ( v263 )
                {
                  v133 = (__int64 *)(v262 + 8);
                  do
                  {
                    result = *v133;
                    if ( *v133 )
                      result = _rust_dealloc(*(v133 - 1), 24 * result, 8LL);
                    v133 += 4;
                    --v132;
                  }
                  while ( v132 );
                }
                if ( v261 )
                {
                  v134 = 32 * v261;
                  v135 = v131;
                  return _rust_dealloc(v135, v134, 8LL);
                }
                return result;
              }
            }
          }
          if ( v12 == 1 )
            goto LABEL_379;
          v68 = 2 - v12;
          v7 = (__int64)(v15 + 2);
          v69 = 0LL;
          v70 = 0;
          do
          {
            v71 = *(_BYTE *)(v7 - 1);
            if ( v70 == 63 && (unsigned __int8)v71 >= 2u )
            {
              v277.m128i_i64[0] = v7;
              v277.m128i_i64[1] = -v68;
              v230 = 6;
              v232 = v287;
              LOWORD(v17) = v253;
              goto LABEL_380;
            }
            v69 |= (unsigned __int64)(v71 & 0x7F) << v70;
            if ( v71 >= 0 )
            {
              v277.m128i_i64[0] = v7;
              v16 = -v68;
              v277.m128i_i64[1] = v16;
              v24 = _mm_cvtsi32_si128(v69);
              LODWORD(v6) = BYTE3(v69);
              v4 = HIDWORD(v69);
              v19 = 60LL;
              v253 = v69;
              LOBYTE(v5) = v18;
              v287 = v69 >> 16;
              v245.m128i_i64[0] = v69 >> 16;
              goto LABEL_65;
            }
            v70 += 7;
            ++v68;
            ++v7;
          }
          while ( v68 != 1 );
          v233 = &v15[v12];
          v277 = (__m128i)(unsigned __int64)v233;
          v17 = (unsigned __int64)v233;
LABEL_379:
          v232 = v17 >> 16;
          v230 = 19;
LABEL_380:
          v17 = (v232 << 16) | (unsigned __int16)v17;
LABEL_225:
          si128 = _mm_cvtsi32_si128(v230);
          goto LABEL_226;
      }
      switch ( v50 )
      {
        case 0LL:
          if ( !LOBYTE(dest[30]) )
          {
            v55 = 57LL;
            v238 = str_1;
            v239 = &off_586B0;
            goto LABEL_415;
          }
          v51 = v49 - BYTE1(dest[30]);
          v52 = v51 / LOBYTE(dest[30]);
          v53 = SHIBYTE(dest[29]) + (unsigned __int64)(unsigned __int8)(v51 % LOBYTE(dest[30]));
          if ( v53 < 0 )
          {
            v88 = v273 + v53;
            v199 = v273 < -v53;
            v54 = 0LL;
            if ( !v199 )
              v54 = v88;
          }
          else
          {
            v54 = v273 + v53;
          }
          v273 = v54;
          if ( BYTE6(dest[29]) == 1 )
          {
            v271 = v52 * (unsigned __int64)BYTE5(dest[29]) + (unsigned __int64)v271;
          }
          else
          {
            if ( !BYTE6(dest[29]) )
            {
LABEL_413:
              v55 = 25LL;
LABEL_414:
              v238 = str_0;
              v239 = &off_586C8;
LABEL_415:
              core::panicking::panic((__int64)v238, v55, (__int64)v239);
            }
            v89 = *((_QWORD *)&v271 + 1) + v52;
            if ( HIDWORD(v89) )
            {
              v92 = v89;
              v90 = v89 / BYTE6(dest[29]);
              v91 = v92 % BYTE6(dest[29]);
            }
            else
            {
              v91 = (unsigned int)v89 % BYTE6(dest[29]);
              v90 = (unsigned int)v89 / BYTE6(dest[29]);
            }
            *(_QWORD *)&v271 = BYTE5(dest[29]) * v90 + v271;
            *((_QWORD *)&v271 + 1) = v91;
          }
LABEL_180:
          if ( v274[24] )
          {
            if ( BYTE1(v276) )
            {
              v271 = 0LL;
              v272 = 1LL;
              v273 = 1LL;
              memset(v274, 0, sizeof(v274));
              v275 = BYTE4(dest[29]);
              v276 = 0;
            }
            else
            {
              *(_QWORD *)&v274[16] = 0LL;
              LOBYTE(v276) = 0;
              HIWORD(v276) = 0;
            }
LABEL_7:
            v12 = v16;
            if ( !v16 )
              goto LABEL_248;
            continue;
          }
          if ( BYTE1(v276) )
          {
            v114 = v281;
            v8 = v249;
            v9 = v269;
            if ( v281 )
            {
              v6 = *v249;
              v115 = v271;
              v116 = v264;
              v264 = 0LL;
              v265 = (_QWORD *)&byte_8;
              v266 = 0LL;
              if ( v116 <= v281 )
              {
                v117 = v249;
                v118 = v260;
              }
              else
              {
                LOBYTE(v5) = 24 * v116;
                v4 = 24 * v281;
                v117 = (_QWORD *)_rust_realloc(v249, 24 * v116, 8LL, 24 * v281);
                v118 = v260;
                if ( !v117 )
                  alloc::alloc::handle_alloc_error(8LL, 24 * v114);
              }
              v124 = v259;
              if ( v118 == v261 )
              {
                alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v261, v118);
                v124 = v262;
                v118 = v263;
              }
              v125 = 32 * v118;
              *(_QWORD *)(v124 + v125) = v117;
              *(_QWORD *)(v124 + v125 + 8) = v114;
              *(_QWORD *)(v124 + v125 + 16) = v6;
              v259 = v124;
              *(_QWORD *)(v124 + v125 + 24) = v115;
              v260 = v118 + 1;
              v263 = v118 + 1;
              v8 = (_QWORD *)&byte_8;
              v9 = 0LL;
              v10 = 0LL;
              v11 = BYTE1(v276);
            }
            else
            {
              v10 = 0LL;
              v11 = BYTE1(v276);
            }
          }
          else
          {
            v119 = v271;
            v120 = v272;
            v121 = v273;
            LODWORD(v6) = *(_DWORD *)v274;
            v9 = v269;
            v8 = v249;
            if ( v269 && v249[3 * v269 - 3] == (_QWORD)v271 )
            {
              v122 = (__int64)&v249[3 * v269 - 3];
              *(_QWORD *)(v122 + 8) = v272;
              *(_DWORD *)(v122 + 16) = v121;
              *(_DWORD *)(v122 + 20) = v6;
            }
            else
            {
              if ( v269 == v264 )
              {
                alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v264, v269);
                v8 = v265;
                v9 = v266;
              }
              v123 = 3 * v9;
              v8[v123] = v119;
              v8[v123 + 1] = v120;
              LODWORD(v8[v123 + 2]) = v121;
              HIDWORD(v8[v123 + 2]) = v6;
              v266 = ++v9;
            }
            v10 = v9;
            v11 = BYTE1(v276);
          }
          break;
        case 1LL:
          goto LABEL_180;
        case 2LL:
          v60 = v13 | (unsigned __int16)v49;
          v57 = BYTE5(dest[29]);
          if ( BYTE6(dest[29]) == 1 )
          {
            v59 = BYTE5(dest[29]) * v60;
LABEL_86:
            v271 = v59 + (unsigned __int64)v271;
            goto LABEL_7;
          }
          if ( !BYTE6(dest[29]) )
            goto LABEL_413;
          v80 = *((_QWORD *)&v271 + 1) + v60;
          if ( HIDWORD(v80) )
          {
            v83 = v80;
            v81 = v80 / BYTE6(dest[29]);
            v82 = v83 % BYTE6(dest[29]);
          }
          else
          {
            v82 = (unsigned int)v80 % BYTE6(dest[29]);
            v81 = (unsigned int)v80 / BYTE6(dest[29]);
          }
          goto LABEL_177;
        case 3LL:
          v58 = v13 | (unsigned __int16)v49;
          if ( v58 < 0 )
          {
            if ( v273 >= -v58 )
              v273 += v58;
            else
              v273 = 0LL;
          }
          else
          {
            v273 += v58;
          }
          goto LABEL_7;
        case 4LL:
          v272 = v13 | (unsigned __int16)v49;
          goto LABEL_7;
        case 5LL:
          *(_QWORD *)v274 = v13 | (unsigned __int16)v49;
          goto LABEL_7;
        case 6LL:
          v275 ^= 1u;
          goto LABEL_7;
        case 7LL:
          LOBYTE(v276) = 1;
          goto LABEL_7;
        case 8LL:
          v55 = 25LL;
          if ( !LOBYTE(dest[30]) )
          {
            v238 = str_0;
            v239 = &off_586E0;
            goto LABEL_415;
          }
          v56 = (unsigned __int8)((unsigned __int8)~BYTE1(dest[30]) / LOBYTE(dest[30]));
          v57 = BYTE5(dest[29]);
          if ( BYTE6(dest[29]) == 1 )
          {
            v271 = v56 * BYTE5(dest[29]) + (unsigned __int64)v271;
          }
          else
          {
            if ( !BYTE6(dest[29]) )
              goto LABEL_414;
            v84 = *((_QWORD *)&v271 + 1) + v56;
            if ( HIDWORD(v84) )
            {
              v85 = v84;
              v81 = v84 / BYTE6(dest[29]);
              v82 = v85 % BYTE6(dest[29]);
            }
            else
            {
              v82 = (unsigned int)v84 % BYTE6(dest[29]);
              v81 = (unsigned int)v84 / BYTE6(dest[29]);
            }
LABEL_177:
            *(_QWORD *)&v271 = v57 * v81 + v271;
            *((_QWORD *)&v271 + 1) = v82;
          }
          goto LABEL_7;
        case 9LL:
          v59 = (unsigned __int16)v49;
          goto LABEL_86;
        case 10LL:
          BYTE2(v276) = 1;
          goto LABEL_7;
        case 11LL:
          HIBYTE(v276) = 1;
          goto LABEL_7;
        case 12LL:
          *(_QWORD *)&v274[8] = v13 | (unsigned __int16)v49;
          goto LABEL_7;
        case 13LL:
        case 14LL:
        case 15LL:
        case 20LL:
          goto LABEL_7;
        case 16LL:
          BYTE1(v276) = 1;
          goto LABEL_180;
        case 17LL:
          v274[24] = (v13 | (unsigned __int16)v49) == 0xFFFFFFFFFFFFFFFFLL >> (-8 * LOBYTE(dest[29]));
          v271 = v13 | (unsigned __int128)(unsigned __int16)v49;
          goto LABEL_7;
        case 18LL:
          v61 = dest[19];
          if ( dest[19] == dest[17] )
          {
            alloc::raw_vec::RawVec<T,A>::reserve_for_push(&dest[17], dest[19]);
            v61 = dest[19];
          }
          v62 = dest[18];
          v63 = v61 << 6;
          *(_QWORD *)(dest[18] + v63) = v19;
          *(_QWORD *)(v62 + v63 + 8) = v13 | (unsigned __int16)v49;
          *(_QWORD *)(v62 + v63 + 16) = (v242 << 8) | (unsigned __int8)v5;
          *(_BYTE *)(v62 + v63 + 24) = v248;
          v64 = HIDWORD(v256);
          *(_DWORD *)(v62 + v63 + 25) = v256;
          *(_BYTE *)(v62 + v63 + 31) = BYTE2(v64);
          *(_WORD *)(v62 + v63 + 29) = v64;
          *(_QWORD *)(v62 + v63 + 32) = v252;
          *(_QWORD *)(v62 + v63 + 40) = src;
          *(_OWORD *)(v62 + v63 + 48) = 0LL;
          dest[19] = v61 + 1;
          v16 = v277.m128i_u64[1];
          goto LABEL_7;
        case 19LL:
          *(_QWORD *)&v274[16] = v13 | (unsigned __int16)v49;
          goto LABEL_7;
      }
      break;
    }
  }
LABEL_248:
  v252 = v262;
  v136 = v263;
  if ( v263 < 0x15 )
  {
    if ( v263 > 1 )
      core::slice::sort::insertion_sort_shift_left(v252, v263, 1uLL);
    goto LABEL_334;
  }
  v258 = (16 * v263) & 0x7FFFFFFFFFFFFFE0LL;
  v137 = _rust_alloc(v258, 8LL);
  if ( !v137 )
    core::option::unwrap_failed((__int64)&off_58430);
  v138 = (char *)v137;
  v139 = _rust_alloc(256LL, 8LL);
  v244 = v138;
  if ( !v139 )
    core::option::unwrap_failed((__int64)&off_58448);
  v140 = (char *)v139;
  v141 = v138;
  v267 = v252 + 80;
  v279 = v252 + 16;
  v278 = v252 - 16;
  v280 = v252 - 32;
  v255 = 16LL;
  v142 = 0LL;
  v257 = &off_583D0;
  v143 = 0LL;
  v256 = v136;
  while ( 1 )
  {
LABEL_255:
    v144 = v136 - v142;
    v145 = 32 * v142;
    v146 = v252 + 32 * v142;
    src = v140;
    if ( v136 - v142 < 2 )
    {
LABEL_256:
      v147 = v136 - v142;
LABEL_257:
      v148 = v147 + v142;
      goto LABEL_258;
    }
    v157 = *(_QWORD *)(v146 + 48);
    if ( v157 >= *(_QWORD *)(v146 + 16) )
    {
      v147 = 2LL;
      if ( v144 != 2 )
      {
        v203 = (unsigned __int64 *)(v267 + v145);
        while ( 1 )
        {
          v204 = v157;
          v157 = *v203;
          if ( *v203 < v204 )
            break;
          ++v147;
          v203 += 4;
          if ( v144 == v147 )
            goto LABEL_256;
        }
      }
      goto LABEL_257;
    }
    v158 = 2LL;
    if ( v144 != 2 )
    {
      v159 = (unsigned __int64 *)(v267 + v145);
      v158 = 2LL;
      while ( 1 )
      {
        v160 = v157;
        v157 = *v159;
        if ( *v159 >= v160 )
          break;
        ++v158;
        v159 += 4;
        if ( v144 == v158 )
        {
          v158 = v136 - v142;
          break;
        }
      }
    }
    v148 = v142 + v158;
    if ( __CFADD__(v142, v158) )
    {
      v241 = v142;
LABEL_427:
      core::slice::index::slice_index_order_fail(v241, v148, (__int64)v257);
    }
    if ( v148 > v136 )
      core::slice::index::slice_end_index_len_fail(v142 + v158, v136, (__int64)&off_583D0);
    v147 = 1LL;
    if ( v158 >= 2 )
    {
      v161 = v158 >> 1;
      v162 = (__m128i *)(v279 + v145);
      v163 = (__m128i *)(v278 + 32 * v148);
      do
      {
        v164 = v162[-1];
        v162[-1] = v163[-1];
        v163[-1] = v164;
        v165 = _mm_loadu_si128(v162);
        *v162 = *v163;
        *v163 = v165;
        v162 += 2;
        v163 -= 2;
        --v161;
      }
      while ( v161 );
      v147 = v158;
      v148 = v142 + v158;
    }
LABEL_258:
    v149 = v148 - v142;
    if ( v148 < v142 || v148 > v136 )
      core::panicking::panic((__int64)aAssertionFaile, 44LL, (__int64)&off_584A0);
    if ( v148 >= v136 || v147 >= 0xA )
    {
      v250 = v148;
      if ( v143 != v255 )
        goto LABEL_281;
    }
    else
    {
      v150 = v142 + 10;
      if ( v142 + 10 >= v136 )
        v150 = v136;
      if ( v142 > 0xFFFFFFFFFFFFFFF5LL )
      {
        v241 = v142;
        v148 = v150;
        v257 = &off_584B8;
        goto LABEL_427;
      }
      v151 = v141;
      v250 = v150;
      v149 = v150 - v142;
      core::slice::sort::insertion_sort_shift_left(v146, v149, (v147 == 0) + v147);
      v141 = v151;
      if ( v143 != v255 )
      {
LABEL_281:
        v153 = (char *)src;
        goto LABEL_282;
      }
    }
    v255 = 2 * v143;
    v152 = (char *)_rust_alloc(32 * v143, 8LL);
    if ( !v152 )
      core::option::unwrap_failed((__int64)&off_58460);
    v153 = v152;
    v154 = 16 * v143;
    v245.m128i_i64[0] = v143;
    v155 = src;
    memcpy(v152, src, v154);
    v156 = v155;
    v143 = v245.m128i_i64[0];
    _rust_dealloc(v156, v154, 8LL);
    v141 = v244;
LABEL_282:
    v166 = 16 * v143;
    *(_QWORD *)&v153[v166] = v149;
    *(_QWORD *)&v153[v166 + 8] = v142;
    ++v143;
    v140 = v153;
    if ( v143 >= 2 )
      break;
    v136 = v256;
    v142 = v250;
    if ( v250 >= v256 )
      goto LABEL_333;
  }
  v136 = v256;
  src = v140;
  while ( 1 )
  {
    v171 = v143;
    v172 = 16 * (v143 - 1);
    v173 = *(_QWORD *)&v140[v172];
    if ( v173 + *(_QWORD *)&v140[v172 + 8] != v136 )
    {
      v174 = *(_QWORD *)&v140[16 * v143 - 32];
      if ( v174 > v173 )
        break;
    }
    if ( v143 != 2 )
    {
      v175 = v143 - 3;
      v176 = *(_QWORD *)&v140[16 * v143 - 48];
      goto LABEL_295;
    }
LABEL_296:
    v175 = v143 - 2;
LABEL_297:
    if ( v143 <= v175 )
    {
      *(_QWORD *)&v284 = &off_582D0;
      v240 = &off_583E8;
LABEL_418:
      *((_QWORD *)&v284 + 1) = 1LL;
      v285 = aRustc9b00956e5;
      v286 = 0LL;
      core::panicking::panic_fmt((__int64)&v284, (__int64)v240);
    }
    v245.m128i_i64[0] = v143 - 1;
    if ( v143 <= v175 + 1 )
    {
      *(_QWORD *)&v284 = &off_582D0;
      v240 = &off_58400;
      goto LABEL_418;
    }
    v177 = *(_QWORD *)&v140[16 * v175 + 8];
    v178 = 16 * (v175 + 1);
    v179 = *(_QWORD *)&v140[v178] + *(_QWORD *)&v140[v178 + 8];
    v180 = v179 - v177;
    if ( v179 < v177 )
      core::slice::index::slice_index_order_fail(v177, v179, (__int64)&off_58418);
    if ( v179 > v136 )
      core::slice::index::slice_end_index_len_fail(v179, v256, (__int64)&off_58418);
    v260 = *(_QWORD *)&v140[v178];
    v269 = 16 * (v175 + 1);
    v248 = v175;
    v254.m128i_i64[0] = v171;
    v249 = (_QWORD *)(16 * v175);
    v181 = *(_QWORD *)&v140[16 * v175];
    v281 = v177;
    v182 = (__m128i *)(v252 + 32 * v177);
    v183 = 32 * v181;
    v184 = &v182[2 * v181];
    v185 = 32 * v179;
    v186 = v180 - v181;
    v259 = v181;
    if ( v180 - v181 >= v181 )
    {
      memcpy(v244, v182, 32 * v181);
      v187 = &v244[v183];
      v194 = v259;
      if ( v259 > 0 )
      {
        v189 = v249;
        if ( v180 <= v259 )
        {
          v167 = v259;
          v168 = v244;
        }
        else
        {
          v195 = v252 + v185;
          v168 = v244;
          do
          {
            v196 = (__m128i *)v168;
            v197 = v184[1].m128i_u64[0];
            v198 = 0;
            v199 = v197 < *((_QWORD *)v168 + 2);
            v200 = v197 >= *((_QWORD *)v168 + 2);
            v201 = v196;
            if ( v199 )
              v201 = v184;
            v202 = _mm_loadu_si128(v201);
            v182[1] = v201[1];
            *v182 = v202;
            v182 += 2;
            v168 = &v196->m128i_i8[32 * v200];
            if ( v168 >= v187 )
              break;
            LOBYTE(v198) = v199;
            v184 = (__m128i *)((char *)v184 + (unsigned int)(32 * v198));
          }
          while ( (unsigned __int64)v184 < v195 );
          v167 = v194;
        }
        goto LABEL_285;
      }
      v167 = v259;
      v168 = v244;
    }
    else
    {
      memcpy(v244, &v182[2 * v181], 32 * v186);
      v187 = &v244[32 * v186];
      v167 = v259;
      if ( v259 > 0 && v186 > 0 )
      {
        v188 = (__m128i *)(v280 + v185);
        v189 = v249;
        do
        {
          v190 = *((_QWORD *)v187 - 2);
          v191 = v184[-1].m128i_u64[0];
          v184 -= 2 * (v190 < v191);
          v187 += 32 * (v190 < v191) - 32;
          v192 = (__m128i *)v187;
          if ( v190 < v191 )
            v192 = v184;
          v193 = _mm_loadu_si128(v192);
          v188[1] = v192[1];
          *v188 = v193;
          if ( v184 <= v182 )
            break;
          v188 -= 2;
        }
        while ( v187 > v244 );
        v182 = v184;
        v168 = v244;
        goto LABEL_285;
      }
      v182 = v184;
      v168 = v244;
    }
    v189 = v249;
LABEL_285:
    v140 = (char *)src;
    v169 = (char *)v189 + (_QWORD)src;
    v170 = (char *)src + v269;
    memcpy(v182, v168, v187 - v168);
    *v170 = v167 + v260;
    v170[1] = v281;
    memmove(v169, v169 + 16, 16 * (~v248 + v254.m128i_i64[0]));
    v143 = v245.m128i_i64[0];
    v136 = v256;
    if ( v245.m128i_i64[0] <= 1uLL )
    {
      v143 = 1LL;
      v142 = v250;
      v141 = v244;
      if ( v250 < v256 )
        goto LABEL_255;
      goto LABEL_333;
    }
  }
  if ( v143 == 2 )
  {
    v143 = 2LL;
    v142 = v250;
    v141 = v244;
    if ( v250 < v136 )
      goto LABEL_255;
    goto LABEL_333;
  }
  v175 = v143 - 3;
  v176 = *(_QWORD *)&v140[16 * v143 - 48];
  if ( v176 <= v174 + v173 )
  {
LABEL_295:
    if ( v176 < v173 )
      goto LABEL_297;
    goto LABEL_296;
  }
  if ( v143 > 3 )
  {
    if ( *(_QWORD *)&v140[16 * v143 - 64] > v176 + v174 )
    {
      v142 = v250;
      v141 = v244;
      if ( v250 >= v136 )
        goto LABEL_333;
      goto LABEL_255;
    }
    goto LABEL_295;
  }
  v143 = 3LL;
  v142 = v250;
  v141 = v244;
  if ( v250 < v136 )
    goto LABEL_255;
LABEL_333:
  v205 = v141;
  _rust_dealloc(v140, 16 * v255, 8LL);
  _rust_dealloc(v205, v258, 8LL);
LABEL_334:
  *(_QWORD *)&v246 = 0LL;
  *((_QWORD *)&v246 + 1) = 8LL;
  v247 = 0LL;
  if ( WORD1(dest[29]) >= 5u )
  {
    if ( !dest[19] )
      goto LABEL_341;
    v206 = (__int64 *)dest[18];
LABEL_339:
    addr2line::render_file(&v284, v282, (__int64)v206, (__int64)dest, v283, v7);
    v207 = *((_QWORD *)&v284 + 1);
    v208 = v284;
    v209 = v285;
    if ( (_QWORD)v284 != 0x8000000000000000LL )
    {
      alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v246, 0LL);
      v213 = *((_QWORD *)&v246 + 1);
      v214 = v247;
      v215 = (_QWORD *)(*((_QWORD *)&v246 + 1) + 24 * v247);
      *v215 = v208;
      goto LABEL_344;
    }
    v210 = v268;
    v268[1] = *((_QWORD *)&v284 + 1);
    v210[2] = (__int64)v209;
    *v210 = 0LL;
    v211 = 8LL;
LABEL_365:
    if ( (_QWORD)v246 )
      _rust_dealloc(v211, 24 * v246, 8LL);
    goto LABEL_229;
  }
  if ( LODWORD(dest[0]) != 46 )
  {
    v206 = dest;
    goto LABEL_339;
  }
LABEL_341:
  alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v246, 0LL);
  v213 = *((_QWORD *)&v246 + 1);
  v214 = v247;
  v215 = (_QWORD *)(*((_QWORD *)&v246 + 1) + 24 * v247);
  *v215 = 0LL;
  v207 = 1LL;
  v209 = 0LL;
LABEL_344:
  v215[1] = v207;
  v215[2] = v209;
  v245.m128i_i64[0] = v214 + 1;
  v247 = v214 + 1;
  v216 = 1LL;
  v217 = 0LL;
  while ( 2 )
  {
    if ( WORD1(dest[29]) >= 5u )
    {
      if ( dest[19] <= v216 )
        break;
      v219 = (__int64 *)(dest[18] + (v216 << 6));
      goto LABEL_353;
    }
    if ( v216 )
    {
      if ( v216 - 1 >= dest[19] )
        break;
      v219 = (__int64 *)(v217 + dest[18]);
      goto LABEL_353;
    }
    v219 = dest;
    if ( LODWORD(dest[0]) != 46 )
    {
LABEL_353:
      addr2line::render_file(&v284, v282, (__int64)v219, (__int64)dest, v283, v212);
      v220 = v284;
      v221 = v285;
      if ( (_QWORD)v284 == 0x8000000000000000LL )
      {
        v226 = v268;
        v268[1] = *((_QWORD *)&v284 + 1);
        v226[2] = (__int64)v221;
        v211 = *((_QWORD *)&v246 + 1);
        *v226 = 0LL;
        v227 = v245.m128i_i64[0];
        if ( v245.m128i_i64[0] )
        {
          v228 = (_QWORD *)(v211 + 8);
          do
          {
            v229 = *(v228 - 1);
            if ( v229 )
              _rust_dealloc(*v228, v229, 1LL);
            v228 += 3;
            --v227;
          }
          while ( v227 );
        }
        goto LABEL_365;
      }
      v222 = v245.m128i_i64[0];
      if ( v245.m128i_i64[0] == (_QWORD)v246 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v246, v245.m128i_i64[0]);
        v213 = *((_QWORD *)&v246 + 1);
        v222 = v247;
      }
      v218 = 3 * v222;
      *(_OWORD *)(v213 + 8 * v218) = v220;
      *(_QWORD *)(v213 + 8 * v218 + 16) = v221;
      v245.m128i_i64[0] = v222 + 1;
      v247 = v222 + 1;
      ++v216;
      v217 += 64LL;
      continue;
    }
    break;
  }
  v223 = *((_QWORD *)&v246 + 1);
  v224 = v247;
  if ( (unsigned __int64)v246 > v247 )
  {
    v225 = 24 * v246;
    if ( v247 )
    {
      v223 = _rust_realloc(*((_QWORD *)&v246 + 1), v225, 8LL, 24 * v247);
      if ( !v223 )
        alloc::alloc::handle_alloc_error(8LL, 24 * v224);
    }
    else
    {
      _rust_dealloc(*((_QWORD *)&v246 + 1), v225, 8LL);
      v223 = 8LL;
    }
  }
  v234 = v262;
  v235 = v263;
  if ( v261 > v263 )
  {
    v236 = 32 * v261;
    if ( v263 )
    {
      v234 = _rust_realloc(v262, v236, 8LL, 32 * v263);
      if ( !v234 )
        alloc::alloc::handle_alloc_error(8LL, 32 * v235);
    }
    else
    {
      _rust_dealloc(v262, v236, 8LL);
      v234 = 8LL;
    }
  }
  v237 = v268;
  *v268 = v223;
  v237[1] = v224;
  v237[2] = v234;
  v237[3] = v235;
  if ( dest[8] )
    _rust_dealloc(dest[9], 4 * dest[8], 2LL);
  if ( dest[11] )
    _rust_dealloc(dest[12], 24 * dest[11], 8LL);
  if ( dest[14] )
    _rust_dealloc(dest[15], 4 * dest[14], 2LL);
  if ( dest[17] )
    _rust_dealloc(dest[18], dest[17] << 6, 8LL);
  result = v264;
  if ( v264 )
  {
    v135 = (__int64)v265;
    v134 = 24 * v264;
    return _rust_dealloc(v135, v134, 8LL);
  }
  return result;
}
// 1CBAB: variable 'v4' is possibly undefined
// 1CDE0: variable 'v242' is possibly undefined
// 1CDE4: variable 'v5' is possibly undefined
// 1E2DD: variable 'v7' is possibly undefined
// 1E463: variable 'v212' is possibly undefined
// 8: using guessed type char byte_8;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);
// 482A0: using guessed type __int128 xmmword_482A0;
// 482B0: using guessed type __int128 xmmword_482B0;
// 582D0: using guessed type char *off_582D0;
// 583D0: using guessed type char *off_583D0;
// 583E8: using guessed type char *off_583E8;
// 58400: using guessed type char *off_58400;
// 58418: using guessed type char *off_58418;
// 58430: using guessed type char *off_58430;
// 58448: using guessed type char *off_58448;
// 58460: using guessed type char *off_58460;
// 584A0: using guessed type char *off_584A0;
// 584B8: using guessed type char *off_584B8;
// 586B0: using guessed type char *off_586B0;
// 586C8: using guessed type char *off_586C8;
// 586E0: using guessed type char *off_586E0;
// 1C5E0: using guessed type __m128i var_2C8;

//----- (000000000001ECB0) ----------------------------------------------------
void __fastcall addr2line::function::name_entry(
        unsigned __int64 a1,
        char a2,
        __int64 a3,
        unsigned __int64 a4,
        _QWORD *a5,
        _QWORD *a6,
        __int64 a7)
{
  unsigned __int64 v10; // r9
  __int64 v11; // rcx
  unsigned __int8 v12; // bl
  _BOOL8 v13; // rdx
  unsigned __int64 v14; // r11
  _QWORD *v15; // r10
  __int64 v16; // r11
  __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rax
  unsigned __int64 v20; // r9
  int v21; // ecx
  char v22; // r11
  char v23; // cl
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // r10
  __int64 v27; // r15
  __int64 v28; // r12
  char v29; // r13
  _QWORD *v31; // rax
  __int64 v32; // rdx
  _QWORD *v33; // r13
  __int64 v34; // rbp
  unsigned __int64 v35; // r12
  __int64 v36; // rbx
  __int64 v37; // rdx
  _QWORD *v38; // [rsp+10h] [rbp-E8h]
  _QWORD *v39; // [rsp+10h] [rbp-E8h]
  unsigned __int8 v40; // [rsp+1Ch] [rbp-DCh]
  unsigned __int64 v41; // [rsp+20h] [rbp-D8h]
  __int64 v42; // [rsp+30h] [rbp-C8h]
  __int64 v43; // [rsp+38h] [rbp-C0h] BYREF
  __int128 v44; // [rsp+40h] [rbp-B8h]
  __int64 v45; // [rsp+50h] [rbp-A8h]
  _QWORD *v46; // [rsp+58h] [rbp-A0h]
  unsigned __int64 v47; // [rsp+60h] [rbp-98h]
  int v48; // [rsp+68h] [rbp-90h] BYREF
  __int128 v49; // [rsp+70h] [rbp-88h]
  unsigned __int16 v50; // [rsp+80h] [rbp-78h]
  unsigned __int64 v51[2]; // [rsp+88h] [rbp-70h] BYREF
  __int64 v52; // [rsp+98h] [rbp-60h]
  _QWORD *v53; // [rsp+A0h] [rbp-58h]
  __int64 v54; // [rsp+A8h] [rbp-50h]
  __int128 v55[4]; // [rsp+B0h] [rbp-48h] BYREF

  v10 = *(_QWORD *)(a3 + 48);
  v11 = *(_QWORD *)(a3 + 56);
  v12 = *(_BYTE *)(a3 + 73);
  v13 = v12 == 8;
  v14 = v11 - v10 + 8 * v13 + 4;
  if ( a4 < v14 || a4 - v14 >= v10 )
  {
    *(_QWORD *)(a1 + 8) = 56LL;
    *(_QWORD *)(a1 + 16) = a3;
LABEL_12:
    *(_QWORD *)a1 = 1LL;
    return;
  }
  v15 = *(_QWORD **)(a3 + 344);
  v16 = 8 * v13 + 4;
  v17 = *(_QWORD *)(a3 + 40);
  v52 = a3;
  v53 = v15 + 2;
  v54 = 0LL;
  v18 = v10 + v17;
  v19 = a4 - v16 - v11;
  v20 = 0LL;
  v21 = 0;
  while ( 1 )
  {
    v22 = *(_BYTE *)(v18 + v19);
    if ( v21 == 63 && (unsigned __int8)v22 > 1u )
    {
      v23 = 6;
LABEL_11:
      *(_BYTE *)(a1 + 8) = v23;
      *(_BYTE *)(a1 + 9) = 0;
      *(_WORD *)(a1 + 14) = 0;
      *(_DWORD *)(a1 + 10) = 0;
      *(_QWORD *)(a1 + 16) = v18;
      goto LABEL_12;
    }
    v20 |= (unsigned __int64)(v22 & 0x7F) << v21;
    if ( v22 >= 0 )
      break;
    v21 += 7;
    if ( !++v19 )
    {
      v23 = 19;
      goto LABEL_11;
    }
  }
  v51[0] = v19 + v18 + 1;
  v51[1] = ~v19;
  if ( !v20 )
  {
    *(_BYTE *)(a1 + 8) = 55;
    goto LABEL_12;
  }
  if ( v20 - 1 < v15[4] )
  {
    v24 = v15[3] + 112 * (v20 - 1);
    goto LABEL_29;
  }
  v25 = v15[5];
  v23 = 18;
  if ( !v25 )
    goto LABEL_11;
  v38 = a6;
  v26 = v15[6];
LABEL_19:
  v27 = -1LL;
  v28 = 0LL;
  do
  {
    if ( !(v28 + 112LL * *(unsigned __int16 *)(v25 + 1330)) )
    {
      v27 = *(unsigned __int16 *)(v25 + 1330);
LABEL_27:
      if ( v26-- == 0 )
        goto LABEL_11;
      v25 = *(_QWORD *)(v25 + 8 * v27 + 1336);
      goto LABEL_19;
    }
    v29 = *(_QWORD *)(v25 + 8 * v27 + 1248) != v20;
    if ( *(_QWORD *)(v25 + 8 * v27 + 1248) > v20 )
      v29 = -1;
    ++v27;
    v28 -= 112LL;
  }
  while ( v29 == 1 );
  if ( v29 )
    goto LABEL_27;
  v24 = v25 - v28 - 112;
  a6 = v38;
LABEL_29:
  v46 = a5;
  if ( *(_BYTE *)(v24 + 106) == 1 )
    v54 = 1LL;
  v31 = <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v24);
  if ( !v32 )
    goto LABEL_50;
  v33 = v31;
  v39 = a6;
  v41 = *(_QWORD *)(a3 + 392);
  v34 = 16 * v32;
  v42 = 46LL;
  v35 = 0LL;
  v40 = v12;
  v36 = 0LL;
  while ( 2 )
  {
    v55[0] = *(_OWORD *)&v33[v35 / 8];
    gimli::read::unit::parse_attribute((__int64)&v48, v51, *(_DWORD *)(v52 + 72), (__int64)v55);
    if ( v48 == 46 )
    {
      *(_OWORD *)(a1 + 8) = v49;
      *(_QWORD *)a1 = 1LL;
      return;
    }
    if ( v50 <= 0x46u )
    {
      if ( v50 == 3 )
      {
        gimli::read::unit::Attribute<R>::value(v55, (__int64)&v48, v37);
        gimli::read::dwarf::Dwarf<R>::attr_string((__int64)&v43, v39, v40, v41, v55);
        if ( !v43 )
        {
          v45 = *((_QWORD *)&v44 + 1);
          v36 = v44;
        }
        goto LABEL_36;
      }
      if ( v50 != 49 )
        goto LABEL_36;
LABEL_35:
      gimli::read::unit::Attribute<R>::value(v55, (__int64)&v48, v37);
      v47 = *((_QWORD *)&v55[0] + 1);
      v42 = *(_QWORD *)&v55[0];
      goto LABEL_36;
    }
    if ( v50 == 71 )
      goto LABEL_35;
    if ( v50 == 110 || v50 == 8199 )
    {
      gimli::read::unit::Attribute<R>::value(v55, (__int64)&v48, v37);
      gimli::read::dwarf::Dwarf<R>::attr_string((__int64)&v43, v39, v40, v41, v55);
      if ( !v43 )
      {
        *(_OWORD *)(a1 + 8) = v44;
        *(_QWORD *)a1 = 0LL;
        return;
      }
    }
LABEL_36:
    v35 += 16LL;
    if ( v34 != v35 )
      continue;
    break;
  }
  if ( v36 )
  {
    *(_QWORD *)(a1 + 8) = v36;
    *(_QWORD *)(a1 + 16) = v45;
    *(_QWORD *)a1 = 0LL;
    return;
  }
  if ( v42 == 46 )
LABEL_50:
    *(_OWORD *)a1 = 0LL;
  else
    addr2line::function::name_attr((_QWORD *)a1, v42, v47, a2, a3, v46, v39, a7 - 1);
}
// 1EEB3: variable 'v32' is possibly undefined
// 1EF16: variable 'v37' is possibly undefined

//----- (000000000001F0D0) ----------------------------------------------------
void __fastcall addr2line::function::Function<R>::parse_children(
        __int64 a1,
        unsigned __int64 *a2,
        __int64 a3,
        int a4,
        __int64 a5,
        _QWORD *a6,
        __int64 a7,
        __int64 *a8,
        __int64 *a9,
        __int64 a10)
{
  __int64 v11; // rcx
  __int64 v12; // r15
  int v13; // r13d
  int v14; // r11d
  __int64 v15; // rsi
  bool v16; // r9
  unsigned __int64 v17; // r12
  __int64 v18; // r11
  __int64 v19; // rax
  unsigned __int64 v20; // r14
  __int64 v21; // rsi
  unsigned __int64 v22; // r10
  char v23; // si
  unsigned __int64 v24; // r9
  unsigned __int64 v25; // r11
  unsigned __int64 v26; // r8
  int v27; // ecx
  char v28; // r12
  unsigned __int64 v29; // r12
  _QWORD *v30; // rcx
  __int64 v31; // rsi
  int v32; // eax
  __int64 v33; // rbp
  _QWORD *v34; // rax
  __int64 v35; // rdx
  char v36; // cl
  __int64 v37; // rsi
  unsigned __int64 v38; // r9
  unsigned __int64 v39; // r11
  unsigned __int64 v40; // r10
  unsigned __int64 v41; // r14
  unsigned __int64 v42; // r8
  int v43; // ecx
  char v44; // r12
  _QWORD *v45; // rdx
  __int64 v46; // r13
  __int64 v47; // r13
  __int64 v48; // rdx
  __int64 v49; // r9
  __int64 v50; // r10
  char v51; // r12
  bool v52; // cf
  _QWORD *v53; // rax
  __int64 v54; // rdx
  __int64 v55; // rax
  __int64 v56; // rcx
  __int64 v57; // r9
  __int64 v58; // r10
  char v59; // r13
  __int64 v60; // rdx
  __int64 v61; // r15
  unsigned __int64 v62; // r14
  __int64 v63; // rdx
  __int64 v64; // rax
  unsigned __int64 v65; // rsi
  __int64 v66; // r10
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // rax
  __int64 v69; // rax
  unsigned __int64 v70; // rsi
  unsigned __int64 v71; // rcx
  unsigned __int64 v72; // rax
  __int64 v73; // rax
  __int64 v74; // rax
  __int64 v75; // rcx
  __int64 v76; // rax
  unsigned __int64 v77; // rcx
  __m128i si128; // xmm0
  __int64 v79; // rsi
  unsigned __int64 v80; // rcx
  __int64 v81; // rax
  __int64 v82; // rcx
  __int64 v83; // rax
  __int64 v84; // rax
  char v85; // al
  _QWORD *v86; // rax
  __int64 v87; // rdx
  __int64 v88; // rbp
  __int64 v89; // rax
  __int64 v90; // rcx
  __int64 v91; // rdx
  __int64 v92; // r10
  unsigned __int64 v93; // rcx
  unsigned __int64 v94; // rax
  __int64 v95; // rcx
  char v96; // cl
  unsigned __int64 v97; // rsi
  unsigned __int32 v98; // r8d
  __int64 v99; // r15
  __int64 v100; // rsi
  __int64 v101; // rax
  __int64 v102; // rcx
  __int64 v103; // rax
  __int64 v104; // rax
  __int64 v105; // rcx
  __int64 v106; // r14
  unsigned __int64 v107; // r12
  __int64 v108; // rsi
  __int64 v109; // r14
  __int64 v110; // rax
  __int64 v111; // rcx
  unsigned __int64 v112; // rdx
  char v113; // si
  _BYTE v114[15]; // [rsp+8h] [rbp-280h]
  unsigned __int8 v115; // [rsp+17h] [rbp-271h]
  __int64 v116; // [rsp+18h] [rbp-270h]
  char v117; // [rsp+27h] [rbp-261h]
  __int64 v118; // [rsp+28h] [rbp-260h]
  __m128i v119; // [rsp+30h] [rbp-258h] BYREF
  unsigned __int64 v120; // [rsp+40h] [rbp-248h]
  __int64 v121; // [rsp+48h] [rbp-240h]
  __m128i v122; // [rsp+50h] [rbp-238h] BYREF
  __int64 v123; // [rsp+60h] [rbp-228h]
  unsigned __int16 v124; // [rsp+6Eh] [rbp-21Ah]
  __int128 v125; // [rsp+70h] [rbp-218h] BYREF
  __int64 v126; // [rsp+80h] [rbp-208h]
  unsigned __int64 v127; // [rsp+88h] [rbp-200h]
  __int64 v128; // [rsp+90h] [rbp-1F8h]
  __int128 v129; // [rsp+98h] [rbp-1F0h] BYREF
  __int64 v130; // [rsp+A8h] [rbp-1E0h]
  unsigned __int64 v131; // [rsp+B0h] [rbp-1D8h]
  unsigned __int64 v132; // [rsp+B8h] [rbp-1D0h]
  __int64 v133; // [rsp+C0h] [rbp-1C8h]
  __int16 v134; // [rsp+C8h] [rbp-1C0h]
  __int16 v135; // [rsp+CAh] [rbp-1BEh]
  char v136; // [rsp+CCh] [rbp-1BCh]
  __int64 v137; // [rsp+D0h] [rbp-1B8h]
  __int64 v138; // [rsp+D8h] [rbp-1B0h]
  __int64 v139; // [rsp+E0h] [rbp-1A8h]
  __int64 v140; // [rsp+E8h] [rbp-1A0h]
  int v141; // [rsp+F4h] [rbp-194h]
  unsigned __int64 v142; // [rsp+F8h] [rbp-190h]
  __int64 v143; // [rsp+100h] [rbp-188h]
  __int64 v144; // [rsp+108h] [rbp-180h]
  unsigned __int64 v145; // [rsp+110h] [rbp-178h]
  __int64 v146; // [rsp+118h] [rbp-170h]
  __int64 v147; // [rsp+120h] [rbp-168h]
  __int64 v148; // [rsp+128h] [rbp-160h]
  __int64 v149; // [rsp+130h] [rbp-158h]
  __int64 v150; // [rsp+138h] [rbp-150h]
  __int64 v151; // [rsp+140h] [rbp-148h]
  __int128 v152; // [rsp+148h] [rbp-140h]
  unsigned __int64 v153; // [rsp+158h] [rbp-130h]
  int v154; // [rsp+160h] [rbp-128h]
  int v155; // [rsp+164h] [rbp-124h]
  unsigned __int64 v156; // [rsp+168h] [rbp-120h]
  __int64 v157; // [rsp+170h] [rbp-118h]
  __int64 v158; // [rsp+178h] [rbp-110h]
  __int64 v159; // [rsp+180h] [rbp-108h]
  __int64 v160; // [rsp+188h] [rbp-100h]
  unsigned __int64 v161; // [rsp+190h] [rbp-F8h]
  __int64 v162; // [rsp+198h] [rbp-F0h]
  _QWORD *v163; // [rsp+1A0h] [rbp-E8h]
  __int64 v164; // [rsp+1A8h] [rbp-E0h]
  __int64 v165; // [rsp+1B0h] [rbp-D8h]
  unsigned __int64 v166; // [rsp+1B8h] [rbp-D0h]
  _QWORD *v167; // [rsp+1C0h] [rbp-C8h]
  __int64 v168; // [rsp+1C8h] [rbp-C0h]
  __int64 v169; // [rsp+1D0h] [rbp-B8h]
  __int64 v170; // [rsp+1D8h] [rbp-B0h]
  unsigned __int64 v171; // [rsp+1E0h] [rbp-A8h]
  unsigned __int64 v172; // [rsp+1E8h] [rbp-A0h]
  __int64 v173; // [rsp+1F0h] [rbp-98h]
  __int64 v174; // [rsp+1F8h] [rbp-90h]
  __int64 v175; // [rsp+200h] [rbp-88h]
  __int64 v176; // [rsp+208h] [rbp-80h]
  __m128i v177; // [rsp+210h] [rbp-78h] BYREF
  __m128i v178; // [rsp+220h] [rbp-68h]
  __m128i v179; // [rsp+230h] [rbp-58h]

  v163 = a6;
  v141 = a4;
  v11 = *(unsigned int *)(a5 + 72);
  v12 = *(_QWORD *)(a5 + 416);
  v13 = HIWORD(*(_DWORD *)(a5 + 72));
  v14 = 0;
  v15 = 0LL;
  if ( HIWORD(*(_DWORD *)(a5 + 72)) < 5u )
    v15 = *(_QWORD *)(a5 + 416);
  v16 = HIWORD(*(_DWORD *)(a5 + 72)) >= 5u;
  if ( !*(_BYTE *)(a7 + 240) )
    v15 = 0LL;
  v176 = v15;
  v128 = a2[4];
  if ( v128 <= a3 )
  {
LABEL_225:
    *(_BYTE *)a1 = 75;
    return;
  }
  v124 = *(_WORD *)(a5 + 74);
  v172 = *(_QWORD *)(a7 + 200);
  v171 = v172 - v12;
  v154 = v11 & 0xFF00;
  v17 = *(_QWORD *)(a5 + 400);
  *((_QWORD *)&v152 + 1) = *(_QWORD *)(a7 + 24);
  v145 = *((_QWORD *)&v152 + 1) - v17;
  LOBYTE(v14) = v16;
  v18 = (unsigned int)(16 * v14);
  v19 = *a2;
  v20 = a2[2];
  v146 = v11;
  v115 = *(_BYTE *)(a5 + 73);
  v162 = v19
       + *(_QWORD *)(v20 + 56)
       + 8LL * (*(_BYTE *)(v20 + 73) == 8)
       - (*(_QWORD *)(v20 + 40)
        + *(_QWORD *)(v20 + 48))
       + 4;
  v161 = *(_QWORD *)(a5 + 392);
  v168 = *(_QWORD *)(a7 + 192);
  v158 = v12 + v168;
  v170 = BYTE1(v11);
  v21 = *(_QWORD *)(a7 + 16);
  v153 = v17;
  *(_QWORD *)&v152 = v21;
  v144 = v21 + v17;
  v159 = (unsigned __int8)v11;
  v174 = v18 + 8;
  v169 = *(_QWORD *)(a5 + 384);
  v173 = a10 + 1;
  v140 = v12;
  v155 = v13;
  v175 = v18;
  v117 = v16;
  v160 = a5;
LABEL_7:
  v22 = a2[1];
  v23 = 19;
  if ( !v22 )
  {
LABEL_227:
    *(_BYTE *)a1 = v23;
    *(_BYTE *)(a1 + 1) = 0;
    *(_WORD *)(a1 + 6) = 0;
    *(_DWORD *)(a1 + 2) = 0;
    goto LABEL_228;
  }
  v24 = 1 - v22;
  v25 = v19 + 1;
  v26 = 0LL;
  v27 = 0;
  while ( 1 )
  {
    v28 = *(_BYTE *)(v25 - 1);
    if ( v27 == 63 && (unsigned __int8)v28 >= 2u )
    {
      *a2 = v25;
      a2[1] = -(__int64)v24;
      v23 = 6;
      goto LABEL_227;
    }
    v26 |= (unsigned __int64)(v28 & 0x7F) << v27;
    if ( v28 >= 0 )
      break;
    v27 += 7;
    ++v24;
    ++v25;
    if ( v24 == 1 )
    {
      v19 += v22;
      *a2 = v19;
      a2[1] = 0LL;
      goto LABEL_227;
    }
  }
  *a2 = v25;
  a2[1] = -(__int64)v24;
  v29 = v140;
  if ( !v26 )
  {
    a2[4] = v128 - 1;
    v151 = 0LL;
    goto LABEL_206;
  }
  v30 = (_QWORD *)a2[3];
  if ( v26 - 1 < v30[2] )
  {
    v31 = v30[1] + 112 * (v26 - 1);
    if ( *(_BYTE *)(v31 + 106) != 1 )
      goto LABEL_18;
    goto LABEL_17;
  }
  v55 = v30[3];
  v23 = 18;
  if ( !v55 )
  {
LABEL_233:
    v19 = v151;
    goto LABEL_227;
  }
  v56 = v30[4];
LABEL_55:
  v57 = -1LL;
  v58 = 0LL;
  do
  {
    if ( !(v58 + 112LL * *(unsigned __int16 *)(v55 + 1330)) )
    {
      v57 = *(unsigned __int16 *)(v55 + 1330);
LABEL_63:
      v52 = v56-- == 0;
      if ( v52 )
        goto LABEL_233;
      v55 = *(_QWORD *)(v55 + 8 * v57 + 1336);
      goto LABEL_55;
    }
    v59 = *(_QWORD *)(v55 + 8 * v57 + 1248) != v26;
    if ( *(_QWORD *)(v55 + 8 * v57 + 1248) > v26 )
      v59 = -1;
    ++v57;
    v58 -= 112LL;
  }
  while ( v59 == 1 );
  v29 = v140;
  if ( v59 )
    goto LABEL_63;
  v31 = v55 - v58 - 112;
  if ( *(_BYTE *)(v31 + 106) == 1 )
LABEL_17:
    a2[4] = v128 + 1;
LABEL_18:
  v32 = *(unsigned __int16 *)(v31 + 104);
  v116 = a1;
  v151 = v31;
  if ( v32 == 29 )
  {
    v118 = a3;
    v167 = <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v31);
    if ( v60 )
    {
      v61 = 16 * v60;
      v62 = 0LL;
      v121 = 0LL;
      v143 = 0LL;
      v149 = 0LL;
      v150 = 0LL;
      v139 = 0LL;
      v147 = 0LL;
      v137 = 0LL;
      v138 = 0LL;
      while ( 1 )
      {
        v119 = _mm_loadu_si128((const __m128i *)&v167[v62 / 8]);
        gimli::read::unit::parse_attribute((__int64)&v129, a2, *(_DWORD *)(a2[2] + 72), (__int64)&v119);
        if ( (_QWORD)v129 == 46LL )
        {
          v122 = _mm_loadu_si128((const __m128i *)((char *)&v129 + 8));
          goto LABEL_202;
        }
        v63 = (unsigned int)(unsigned __int16)v131 - 3;
        switch ( (__int16)v131 )
        {
          case 3:
            if ( !v121 )
            {
              gimli::read::unit::Attribute<R>::value(&v119, (__int64)&v129, v63);
              gimli::read::dwarf::Dwarf<R>::attr_string((__int64)&v125, (_QWORD *)a7, v115, v161, &v119);
              if ( (_QWORD)v125 )
              {
                v121 = 0LL;
                v29 = v140;
                v76 = v165;
              }
              else
              {
                v121 = *((_QWORD *)&v125 + 1);
                v76 = v126;
                v29 = v140;
              }
              v165 = v76;
              v148 = v76;
            }
            goto LABEL_70;
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 86:
            goto LABEL_70;
          case 17:
            gimli::read::unit::Attribute<R>::value(&v119, (__int64)&v129, v63);
            if ( v119.m128i_i64[0] )
            {
              if ( v119.m128i_i32[0] == 12 )
              {
                a1 = v116;
                v66 = v118;
                if ( *((_QWORD *)&v152 + 1) < v153 )
                {
                  v110 = v152;
                  goto LABEL_212;
                }
                v69 = v159 * v119.m128i_i64[1];
                v70 = v145 - v159 * v119.m128i_i64[1];
                if ( v145 < v159 * v119.m128i_i64[1] )
                {
LABEL_209:
                  v110 = v144;
LABEL_212:
                  *(_QWORD *)&v114[7] = v110;
                  goto LABEL_213;
                }
                v71 = v69 + v144;
                switch ( (int)v159 )
                {
                  case 1:
                    if ( v145 == v69 )
                    {
                      v114[0] = 0;
                      *(_WORD *)&v114[5] = 0;
                      *(_DWORD *)&v114[1] = 0;
                      *(_QWORD *)&v114[7] = v69 + v144;
LABEL_213:
                      v85 = 19;
LABEL_222:
                      v122.m128i_i32[1] = *(_DWORD *)&v114[3];
                      *(__int32 *)((char *)v122.m128i_i32 + 1) = *(_DWORD *)v114;
                      v122.m128i_i8[0] = v85;
                      v122.m128i_i64[1] = *(_QWORD *)&v114[7];
                      v79 = v123;
                      a3 = v66;
                      goto LABEL_204;
                    }
                    v72 = *(unsigned __int8 *)v71;
LABEL_160:
                    v127 = v72;
                    v138 = 1LL;
                    break;
                  case 2:
                    if ( v70 > 1 )
                    {
                      v71 = *(unsigned __int16 *)v71;
                      goto LABEL_145;
                    }
                    *(_WORD *)v114 = 0;
                    v114[2] = 0;
                    *(_DWORD *)&v114[3] = 0;
                    goto LABEL_156;
                  case 4:
                    if ( v70 <= 3 )
                    {
                      *(_DWORD *)v114 = 0;
                      v114[6] = 0;
                      *(_WORD *)&v114[4] = 0;
LABEL_156:
                      v85 = 19;
                    }
                    else
                    {
                      v71 = *(unsigned int *)v71;
LABEL_145:
                      v85 = 75;
                    }
                    *(_QWORD *)&v114[7] = v71;
LABEL_158:
                    if ( v85 != 75 )
                      goto LABEL_222;
                    v72 = *(_QWORD *)&v114[7];
                    goto LABEL_160;
                  case 8:
                    if ( v70 < 8 )
                    {
                      *(_QWORD *)&v125 = 19LL;
                      *((_QWORD *)&v125 + 1) = v69 + v144;
                      *(_DWORD *)&v114[11] = (unsigned __int64)(v69 + v144) >> 32;
                      *(_DWORD *)&v114[8] = v71 >> 8;
                      *(_QWORD *)v114 = *(_QWORD *)((char *)&v125 + 1);
                      v85 = 19;
                    }
                    else
                    {
                      *(_QWORD *)&v114[7] = *(_QWORD *)v71;
                      v85 = 75;
                    }
                    goto LABEL_158;
                  default:
                    goto LABEL_221;
                }
              }
            }
            else
            {
              v138 = 1LL;
              v127 = v119.m128i_u64[1];
            }
            goto LABEL_70;
          case 18:
            gimli::read::unit::Attribute<R>::value(&v119, (__int64)&v129, v63);
            if ( v119.m128i_i64[0] )
            {
              if ( v119.m128i_i32[0] == 7 )
              {
                v147 = 1LL;
                v164 = v119.m128i_i64[1];
              }
              else if ( v119.m128i_i32[0] == 12 )
              {
                if ( *((_QWORD *)&v152 + 1) < v153 )
                {
                  *(_QWORD *)&v114[7] = v152;
LABEL_218:
                  v85 = 19;
                  a1 = v116;
                  v66 = v118;
                  goto LABEL_222;
                }
                v64 = v159 * v119.m128i_i64[1];
                v65 = v145 - v159 * v119.m128i_i64[1];
                a1 = v116;
                v66 = v118;
                if ( v145 < v159 * v119.m128i_i64[1] )
                  goto LABEL_209;
                v67 = v64 + v144;
                switch ( (int)v159 )
                {
                  case 1:
                    if ( v145 == v64 )
                    {
                      v114[0] = 0;
                      *(_WORD *)&v114[5] = 0;
                      *(_DWORD *)&v114[1] = 0;
                      *(_QWORD *)&v114[7] = v64 + v144;
                      goto LABEL_218;
                    }
                    v68 = *(unsigned __int8 *)v67;
LABEL_168:
                    v142 = v68;
                    v137 = 1LL;
                    break;
                  case 2:
                    if ( v65 > 1 )
                    {
                      v67 = *(unsigned __int16 *)v67;
                      goto LABEL_152;
                    }
                    *(_WORD *)v114 = 0;
                    v114[2] = 0;
                    *(_DWORD *)&v114[3] = 0;
                    goto LABEL_164;
                  case 4:
                    if ( v65 <= 3 )
                    {
                      *(_DWORD *)v114 = 0;
                      v114[6] = 0;
                      *(_WORD *)&v114[4] = 0;
LABEL_164:
                      v85 = 19;
                    }
                    else
                    {
                      v67 = *(unsigned int *)v67;
LABEL_152:
                      v85 = 75;
                    }
                    *(_QWORD *)&v114[7] = v67;
LABEL_166:
                    if ( v85 != 75 )
                      goto LABEL_222;
                    v68 = *(_QWORD *)&v114[7];
                    goto LABEL_168;
                  case 8:
                    if ( v65 < 8 )
                    {
                      *(_QWORD *)&v125 = 19LL;
                      *((_QWORD *)&v125 + 1) = v64 + v144;
                      *(_DWORD *)&v114[11] = (unsigned __int64)(v64 + v144) >> 32;
                      *(_DWORD *)&v114[8] = v67 >> 8;
                      *(_QWORD *)v114 = *(_QWORD *)((char *)&v125 + 1);
                      v85 = 19;
                    }
                    else
                    {
                      *(_QWORD *)&v114[7] = *(_QWORD *)v67;
                      v85 = 75;
                    }
                    goto LABEL_166;
                  default:
LABEL_221:
                    v114[0] = v146;
                    v85 = 23;
                    goto LABEL_222;
                }
              }
            }
            else
            {
              v137 = 1LL;
              v142 = v119.m128i_u64[1];
            }
            goto LABEL_70;
          case 49:
          case 71:
            if ( v121 )
              goto LABEL_70;
            gimli::read::unit::Attribute<R>::value(&v119, (__int64)&v129, v63);
            addr2line::function::name_attr(
              &v125,
              v119.m128i_i64[0],
              v119.m128i_u64[1],
              v141,
              v160,
              v163,
              (_QWORD *)a7,
              16LL);
            v121 = *((_QWORD *)&v125 + 1);
            if ( (_QWORD)v125 )
            {
              v122.m128i_i64[0] = v121;
              v122.m128i_i64[1] = v126;
LABEL_202:
              a1 = v116;
              a3 = v118;
LABEL_203:
              v79 = v123;
LABEL_204:
              if ( v122.m128i_i8[0] == 75 )
              {
                v123 = v79;
                goto LABEL_206;
              }
              v179 = v122;
              *(__m128i *)a1 = v122;
              return;
            }
            v148 = v126;
            goto LABEL_70;
          case 85:
            gimli::read::unit::Attribute<R>::value(&v119, (__int64)&v129, v63);
            if ( v119.m128i_i64[0] == 24 )
            {
              a1 = v116;
              a3 = v118;
              si128 = _mm_load_si128((const __m128i *)&xmmword_482C0);
              v79 = v123;
              if ( v172 < v29 )
              {
                v111 = v168;
LABEL_215:
                v81 = v111;
LABEL_216:
                v122.m128i_i64[0] = (v79 << 8) | 0x13;
                v156 = v81 & 0xFFFFFFFFFFFFFF00LL | (unsigned __int8)v111;
                v122.m128i_i64[1] = v156;
                goto LABEL_204;
              }
              v80 = v171 - v170 * v119.m128i_i64[1];
              if ( v171 < v170 * v119.m128i_i64[1] )
              {
                v111 = v158;
                goto LABEL_215;
              }
              v81 = v158 + v170 * v119.m128i_i64[1];
              if ( v154 == 2048 )
              {
                if ( v80 <= 7 )
                {
                  *(_QWORD *)&v125 = 19LL;
                  *((_QWORD *)&v125 + 1) = v158 + v170 * v119.m128i_i64[1];
                  v178 = _mm_loadl_epi64((const __m128i *)((char *)&v125 + 1));
                  LOBYTE(v111) = v178.m128i_i8[7];
                  v177 = v178;
                  v79 = v178.m128i_i64[0];
                  goto LABEL_216;
                }
                v82 = *(_QWORD *)v81;
              }
              else
              {
                if ( v80 <= 3 )
                {
                  v177 = _mm_and_si128(_mm_load_si128(&v177), si128);
                  v79 = v177.m128i_i64[0];
                  LOBYTE(v111) = v158 + v170 * v119.m128i_i8[8];
                  goto LABEL_216;
                }
                v82 = *(unsigned int *)v81;
              }
              v77 = v29 + v82;
              v83 = 1LL;
              goto LABEL_125;
            }
            v77 = v156;
            if ( v119.m128i_i32[0] != 22 )
            {
              v83 = 0LL;
LABEL_125:
              v139 = v83;
              goto LABEL_126;
            }
            v139 = 1LL;
            v77 = v176 + v119.m128i_i64[1];
LABEL_126:
            v156 = v77;
            v166 = v77;
LABEL_70:
            v62 += 16LL;
            if ( v61 == v62 )
              goto LABEL_172;
            break;
          case 87:
            switch ( (__int64)v129 )
            {
              case 2LL:
                v73 = BYTE8(v129);
                break;
              case 3LL:
                v73 = WORD4(v129);
                break;
              case 4LL:
                v73 = DWORD2(v129);
                break;
              case 5LL:
              case 7LL:
                v73 = *((_QWORD *)&v129 + 1);
                break;
              case 6LL:
                v73 = *((_QWORD *)&v129 + 1);
                if ( v129 < 0 )
                  goto LABEL_135;
                break;
              default:
LABEL_135:
                v73 = 0LL;
                break;
            }
            v150 = v73;
            goto LABEL_70;
          case 88:
            gimli::read::unit::Attribute<R>::value(&v119, (__int64)&v129, v63);
            if ( v119.m128i_i32[0] == 44 )
            {
              v74 = v157;
              if ( v124 >= 5u || v119.m128i_i64[1] != 0 )
                v74 = v119.m128i_i64[1];
              v157 = v74;
              v75 = v143;
              if ( v124 >= 5u || v119.m128i_i64[1] != 0 )
                v75 = 1LL;
              v143 = v75;
            }
            goto LABEL_70;
          case 89:
            switch ( (__int64)v129 )
            {
              case 2LL:
                v149 = BYTE8(v129);
                break;
              case 3LL:
                v149 = WORD4(v129);
                break;
              case 4LL:
                v149 = DWORD2(v129);
                break;
              case 5LL:
              case 7LL:
                v149 = *((_QWORD *)&v129 + 1);
                break;
              case 6LL:
                v84 = *((_QWORD *)&v129 + 1);
                if ( v129 >= 0 )
                  goto LABEL_130;
                goto LABEL_129;
              default:
LABEL_129:
                v84 = 0LL;
LABEL_130:
                v149 = v84;
                break;
            }
            goto LABEL_70;
          default:
            if ( (unsigned __int16)v131 == 110 || (unsigned __int16)v131 == 8199 )
            {
              gimli::read::unit::Attribute<R>::value(&v119, (__int64)&v129, v63);
              gimli::read::dwarf::Dwarf<R>::attr_string((__int64)&v125, (_QWORD *)a7, v115, v161, &v119);
              if ( !(_QWORD)v125 )
              {
                v148 = v126;
                v121 = *((_QWORD *)&v125 + 1);
              }
              v29 = v140;
            }
            goto LABEL_70;
        }
      }
    }
    v138 = 0LL;
    v137 = 0LL;
    v147 = 0LL;
    v139 = 0LL;
    v150 = 0LL;
    v149 = 0LL;
    v143 = 0LL;
    v121 = 0LL;
LABEL_172:
    v88 = a8[2];
    v89 = v88;
    if ( v88 == *a8 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve_for_push(a8, a8[2]);
      v89 = a8[2];
    }
    v90 = a8[1];
    v91 = 48 * v89;
    *(_QWORD *)(v90 + v91) = v143;
    *(_QWORD *)(v90 + v91 + 8) = v157;
    *(_QWORD *)(v90 + v91 + 16) = v162;
    *(_QWORD *)(v90 + v91 + 24) = v121;
    *(_QWORD *)(v90 + v91 + 32) = v148;
    *(_DWORD *)(v90 + v91 + 40) = v149;
    *(_DWORD *)(v90 + v91 + 44) = v150;
    a8[2] = v89 + 1;
    v92 = a7;
    if ( v139 )
    {
      v93 = *(_QWORD *)(a7 + v174 + 176);
      v94 = *(_QWORD *)(a7 + v175 + 176);
      v52 = v93 < v166;
      v95 = v93 - v166;
      if ( v52 )
      {
        v96 = 19;
        v97 = 0LL;
        LOBYTE(v98) = 0;
LABEL_187:
        a1 = v116;
        a3 = v118;
        v122.m128i_i8[0] = v96;
        v122.m128i_i8[1] = v98;
        *(__int32 *)((char *)v122.m128i_i32 + 2) = v97;
        v122.m128i_i16[3] = WORD2(v97);
        v122.m128i_i64[1] = v94;
        goto LABEL_203;
      }
      v129 = v152;
      v130 = v169;
      v131 = v153;
      v132 = v166 + v94;
      v133 = v95;
      v134 = v146;
      v135 = v155;
      v136 = v117;
      gimli::read::rnglists::RngListIter<R>::next(&v119, (__int64)&v129);
      v103 = v119.m128i_i64[0];
      v99 = (__int64)a9;
      if ( v119.m128i_i64[0] == 2 )
      {
LABEL_185:
        v96 = v119.m128i_i8[8];
        v92 = a7;
        if ( v119.m128i_i8[8] != 75 )
        {
          v94 = v120;
          v98 = (unsigned __int32)v119.m128i_i32[2] >> 8;
          v97 = (unsigned __int64)v119.m128i_i64[1] >> 16;
          goto LABEL_187;
        }
      }
      else
      {
        while ( v103 == 1 )
        {
          v106 = v119.m128i_i64[1];
          v107 = v120;
          if ( v119.m128i_i64[1] < v120 )
          {
            v108 = a9[2];
            if ( v108 == *a9 )
            {
              alloc::raw_vec::RawVec<T,A>::reserve_for_push(a9, v108);
              v108 = a9[2];
            }
            v104 = a9[1];
            v105 = 32 * v108;
            *(_QWORD *)(v104 + v105) = v106;
            *(_QWORD *)(v104 + v105 + 8) = v107;
            *(_QWORD *)(v104 + v105 + 16) = a10;
            *(_QWORD *)(v104 + v105 + 24) = v88;
            a9[2] = v108 + 1;
          }
          gimli::read::rnglists::RngListIter<R>::next(&v119, (__int64)&v129);
          v103 = v119.m128i_i64[0];
          if ( v119.m128i_i64[0] == 2 )
            goto LABEL_185;
        }
        v92 = a7;
      }
    }
    else
    {
      v99 = (__int64)a9;
      if ( v138 )
      {
        if ( v137 )
        {
          if ( v127 >= v142 )
            goto LABEL_201;
          v100 = a9[2];
          if ( v100 == *a9 )
          {
            alloc::raw_vec::RawVec<T,A>::reserve_for_push(a9, v100);
            v92 = a7;
            v100 = a9[2];
          }
          v101 = a9[1];
          v102 = 32 * v100;
          *(_QWORD *)(v101 + v102) = v127;
          *(_QWORD *)(v101 + v102 + 8) = v142;
        }
        else
        {
          if ( !v147 )
            goto LABEL_201;
          v109 = v164 + v127;
          if ( v127 >= v164 + v127 )
            goto LABEL_201;
          v100 = a9[2];
          if ( v100 == *a9 )
          {
            alloc::raw_vec::RawVec<T,A>::reserve_for_push(a9, v100);
            v92 = a7;
            v100 = a9[2];
          }
          v101 = a9[1];
          v102 = 32 * v100;
          *(_QWORD *)(v101 + v102) = v127;
          *(_QWORD *)(v101 + v102 + 8) = v109;
        }
        *(_QWORD *)(v101 + v102 + 16) = a10;
        *(_QWORD *)(v101 + v102 + 24) = v88;
        a9[2] = v100 + 1;
      }
    }
LABEL_201:
    addr2line::function::Function<R>::parse_children(
      (unsigned int)&v122,
      (_DWORD)a2,
      v128,
      (unsigned __int8)v141,
      v160,
      (_DWORD)v163,
      v92,
      (__int64)a8,
      v99,
      v173);
    goto LABEL_202;
  }
  v33 = a3;
  if ( v32 != 46 )
  {
    v86 = <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v31);
    gimli::read::unit::skip_attributes((__int64)&v129, (__int64)a2, *(_DWORD *)(a2[2] + 72), (__int64)v86, v87);
    if ( (_BYTE)v129 != 75 )
    {
      *(_OWORD *)a1 = v129;
      return;
    }
    goto LABEL_170;
  }
  v34 = <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v31);
  gimli::read::unit::skip_attributes((__int64)&v129, (__int64)a2, *(_DWORD *)(v20 + 72), (__int64)v34, v35);
  v36 = v129;
  if ( (_BYTE)v129 != 75 )
  {
LABEL_234:
    v113 = BYTE1(v129);
    v112 = *(unsigned int *)((char *)&v129 + 2) | ((unsigned __int64)WORD3(v129) << 32);
    v19 = *((_QWORD *)&v129 + 1);
    a1 = v116;
    goto LABEL_232;
  }
  v37 = a2[4];
  if ( v37 <= v128 )
  {
LABEL_170:
    a3 = v33;
    goto LABEL_206;
  }
  a3 = v33;
LABEL_23:
  v38 = *a2;
  v39 = a2[1];
  if ( !v39 )
    goto LABEL_230;
  v40 = 1 - v39;
  v41 = v38 + 1;
  v42 = 0LL;
  v43 = 0;
  do
  {
    v44 = *(_BYTE *)(v41 - 1);
    if ( v43 == 63 && (unsigned __int8)v44 >= 2u )
    {
      *a2 = v41;
      a2[1] = -(__int64)v40;
      v36 = 6;
      goto LABEL_231;
    }
    v42 |= (unsigned __int64)(v44 & 0x7F) << v43;
    if ( v44 >= 0 )
    {
      *a2 = v41;
      a2[1] = -(__int64)v40;
      if ( !v42 )
      {
        a2[4] = --v37;
        v19 = 0LL;
        goto LABEL_50;
      }
      v45 = (_QWORD *)a2[3];
      if ( v42 - 1 < v45[2] )
      {
        v46 = v45[1] + 112 * (v42 - 1);
        goto LABEL_46;
      }
      v47 = v45[3];
      v36 = 18;
      if ( !v47 )
        goto LABEL_231;
      v48 = v45[4];
LABEL_36:
      v49 = -1LL;
      v50 = 0LL;
      do
      {
        if ( !(v50 + 112LL * *(unsigned __int16 *)(v47 + 1330)) )
        {
          v49 = *(unsigned __int16 *)(v47 + 1330);
LABEL_44:
          v52 = v48-- == 0;
          if ( v52 )
            goto LABEL_231;
          v47 = *(_QWORD *)(v47 + 8 * v49 + 1336);
          goto LABEL_36;
        }
        v51 = *(_QWORD *)(v47 + 8 * v49 + 1248) != v42;
        if ( *(_QWORD *)(v47 + 8 * v49 + 1248) > v42 )
          v51 = -1;
        ++v49;
        v50 -= 112LL;
      }
      while ( v51 == 1 );
      if ( v51 )
        goto LABEL_44;
      v46 = v47 - v50 - 112;
LABEL_46:
      if ( *(_BYTE *)(v46 + 106) == 1 )
        a2[4] = v37 + 1;
      v53 = <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v46);
      gimli::read::unit::skip_attributes((__int64)&v129, (__int64)a2, *(_DWORD *)(a2[2] + 72), (__int64)v53, v54);
      v36 = v129;
      if ( (_BYTE)v129 != 75 )
        goto LABEL_234;
      v37 = a2[4];
      v19 = v46;
      a1 = v116;
      a3 = v33;
LABEL_50:
      if ( v37 <= v128 )
      {
LABEL_206:
        v20 = a2[2];
        v19 = *a2;
        v162 = *a2
             + *(_QWORD *)(v20 + 56)
             + 8LL * (*(_BYTE *)(v20 + 73) == 8)
             - (*(_QWORD *)(v20 + 40)
              + *(_QWORD *)(v20 + 48))
             + 4;
        v128 = a2[4];
        if ( v128 <= a3 )
          goto LABEL_225;
        goto LABEL_7;
      }
      goto LABEL_23;
    }
    v43 += 7;
    ++v40;
    ++v41;
  }
  while ( v40 != 1 );
  v38 += v39;
  *a2 = v38;
  a2[1] = 0LL;
LABEL_230:
  v36 = 19;
  v19 = v38;
LABEL_231:
  v112 = 0LL;
  v113 = 0;
LABEL_232:
  *(_BYTE *)a1 = v36;
  *(_BYTE *)(a1 + 1) = v113;
  *(_DWORD *)(a1 + 2) = v112;
  *(_WORD *)(a1 + 6) = WORD2(v112);
LABEL_228:
  *(_QWORD *)(a1 + 8) = v19;
}
// 1F39E: variable 'v35' is possibly undefined
// 1F515: variable 'v54' is possibly undefined
// 1F62A: variable 'v60' is possibly undefined
// 1FE38: variable 'v87' is possibly undefined
// 203C1: variable 'v114' is possibly undefined
// 20455: variable 'v19' is possibly undefined
// 482C0: using guessed type __int128 xmmword_482C0;

//----- (0000000000020510) ----------------------------------------------------
void __fastcall addr2line::function::name_attr(
        _QWORD *a1,
        __int64 a2,
        unsigned __int64 a3,
        char a4,
        __int64 a5,
        _QWORD *a6,
        _QWORD *a7,
        __int64 a8)
{
  __int64 v9; // rax
  unsigned __int64 v10; // rsi
  __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // r11
  __int64 v16; // rdx
  __int64 v17; // rdx
  bool v18; // cf
  unsigned __int64 v19; // r10
  __int64 v22; // rdx
  unsigned __int64 v23; // rcx
  char v24; // si
  _QWORD *v25; // r8
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // r8
  __int64 v28; // [rsp+0h] [rbp-48h]
  __int64 v29; // [rsp+8h] [rbp-40h] BYREF
  __int64 v30; // [rsp+10h] [rbp-38h]
  unsigned __int64 v31; // [rsp+18h] [rbp-30h]

  if ( !a8 )
    goto LABEL_18;
  if ( a2 == 13 )
  {
    v28 = a8;
    v24 = a4;
    v22 = a5;
    v23 = a3;
    v25 = a6;
LABEL_23:
    addr2line::function::name_entry((unsigned __int64)a1, v24, v22, v23, v25, a7, v28);
    return;
  }
  if ( a2 == 14 )
  {
    addr2line::Context<R>::find_unit(&v29, a6, a3, a4);
    v22 = v30;
    v23 = v31;
    if ( v29 )
    {
      a1[1] = v30;
      a1[2] = v23;
      *a1 = 1LL;
      return;
    }
    v28 = a8;
    v24 = a4;
    v25 = a6;
    goto LABEL_23;
  }
  if ( a2 != 15 || (v9 = a7[26]) == 0 )
  {
LABEL_18:
    *(_OWORD *)a1 = 0LL;
    return;
  }
  v10 = a6[6];
  if ( v10 )
  {
    v11 = a6[5];
    v12 = 0LL;
    v13 = a6[6];
    while ( 1 )
    {
      v14 = v12 + (v10 >> 1);
      v15 = *(_QWORD *)(v11 + 432 * v14 + 424);
      if ( v15 == a3 )
        break;
      if ( v15 > a3 )
        v13 = v14;
      if ( v15 < a3 )
        v12 = v14 + 1;
      v10 = v13 - v12;
      if ( v13 <= v12 )
      {
        if ( v12 )
        {
          v16 = 432 * v12;
          if ( !*(_QWORD *)(v16 + v11 - 432) )
          {
            v17 = v11 + v16 - 432;
            v18 = a3 < *(_QWORD *)(v17 + 8);
            v19 = a3 - *(_QWORD *)(v17 + 8);
            if ( !v18 )
            {
              v26 = *(_QWORD *)(v17 + 48);
              v27 = *(_QWORD *)(v17 + 56) - v26 + 8LL * (*(_BYTE *)(v17 + 73) == 8) + 4;
              if ( v19 >= v27 && v19 - v27 < v26 )
              {
                addr2line::function::name_entry((unsigned __int64)a1, 1, v17, v19, a6, (_QWORD *)(v9 + 16), a8);
                return;
              }
            }
          }
        }
        break;
      }
    }
  }
  a1[1] = 55LL;
  *a1 = 1LL;
}

//----- (00000000000206C0) ----------------------------------------------------
__int64 std::rt::cleanup()
{
  __int64 result; // rax
  char v1; // [rsp+1h] [rbp-9h] BYREF
  char *v2; // [rsp+2h] [rbp-8h] BYREF

  result = (unsigned int)std::rt::cleanup::CLEANUP;
  if ( std::rt::cleanup::CLEANUP != 4 )
  {
    v1 = 1;
    v2 = &v1;
    return std::sys::sync::once::futex::Once::call(&v2);
  }
  return result;
}
// 5B064: using guessed type int std::rt::cleanup::CLEANUP;

//----- (00000000000206F0) ----------------------------------------------------
__int64 __fastcall std::rt::lang_start_internal(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  unsigned int v7; // eax
  int v8; // ecx
  void (*v9)(int); // rsi
  __int64 v10; // rax
  unsigned __int64 v11; // rbp
  __int64 v12; // r15
  pthread_t v13; // rax
  size_t v14; // rax
  size_t *v15; // r13
  unsigned __int64 v16; // r12
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rbp
  size_t v19; // r12
  volatile signed __int64 *v20; // rsi
  __int64 v21; // r14
  char **v23; // rdx
  __int64 v24; // rsi
  const char *v25; // rdi
  char **v26; // r8
  char **v27; // [rsp+0h] [rbp-138h] BYREF
  size_t stacksize[3]; // [rsp+8h] [rbp-130h] BYREF
  void *stackaddr[2]; // [rsp+20h] [rbp-118h] BYREF
  __int128 v30; // [rsp+30h] [rbp-108h] BYREF
  __int64 v31; // [rsp+40h] [rbp-F8h]
  struct sigaction fds; // [rsp+60h] [rbp-D8h] BYREF
  __int128 *v33; // [rsp+100h] [rbp-38h] BYREF

  fds.sa_handler = 0LL;
  *(_OWORD *)fds.sa_mask.__val = xmmword_482D0;
  do
  {
    if ( poll((struct pollfd *)&fds, 3uLL, 0) != -1 )
    {
      if ( (BYTE6(fds.sa_sigaction) & 0x20) != 0 && open64(aD, 2, 0LL) == -1
        || (fds.sa_mask.__val[0] & 0x20000000000000LL) != 0 && open64(aD, 2, 0LL) == -1 )
      {
        goto LABEL_45;
      }
      if ( (fds.sa_mask.__val[1] & 0x20000000000000LL) == 0 )
        goto LABEL_21;
LABEL_20:
      if ( open64(aD, 2, 0LL) != -1 )
        goto LABEL_21;
LABEL_45:
      abort();
    }
    v7 = *_errno_location();
  }
  while ( v7 == 4 );
  if ( v7 > 0x16 )
    goto LABEL_45;
  v8 = 4200448;
  if ( !_bittest(&v8, v7) || fcntl(0, 1) == -1 && *_errno_location() == 9 && open64(aD, 2, 0LL) == -1 )
    goto LABEL_45;
  if ( fcntl(1, 1) == -1 && *_errno_location() == 9 && open64(aD, 2, 0LL) == -1 )
    goto LABEL_45;
  if ( fcntl(2, 1) == -1 && *_errno_location() == 9 )
    goto LABEL_20;
LABEL_21:
  v9 = (void (*)(int))(&dword_0 + 1);
  switch ( a5 )
  {
    case 0:
      goto LABEL_25;
    case 1:
      std::sys::pal::unix::UNIX_SIGPIPE_ATTR_SPECIFIED = 1;
      goto LABEL_26;
    case 2:
      goto LABEL_24;
    case 3:
      v9 = 0LL;
LABEL_24:
      std::sys::pal::unix::UNIX_SIGPIPE_ATTR_SPECIFIED = 1;
LABEL_25:
      if ( signal(13, v9) == (__sighandler_t)-1LL )
      {
        fds.sa_handler = (__sighandler_t)&off_592F8;
        fds.sa_mask.__val[0] = 1LL;
        fds.sa_mask.__val[1] = (unsigned __int64)stacksize;
        *(_OWORD *)&fds.sa_mask.__val[2] = 0LL;
        *(_QWORD *)&v30 = std::io::Write::write_fmt((__int64)stacksize, &fds);
        core::ptr::drop_in_place<core::result::Result<(),std::io::error::Error>>((__int64 *)&v30);
        goto LABEL_50;
      }
LABEL_26:
      memset(&fds, 0, sizeof(fds));
      sigaction(11, 0LL, &fds);
      if ( !fds.sa_handler )
      {
        fds.sa_flags = 134217732;
        fds.sa_handler = (__sighandler_t)std::sys::pal::unix::stack_overflow::imp::signal_handler;
        sigaction(11, &fds, 0LL);
        std::sys::pal::unix::stack_overflow::imp::NEED_ALTSTACK = 1;
      }
      sigaction(7, 0LL, &fds);
      if ( !fds.sa_handler )
      {
        fds.sa_flags = 134217732;
        fds.sa_handler = (__sighandler_t)std::sys::pal::unix::stack_overflow::imp::signal_handler;
        sigaction(7, &fds, 0LL);
        std::sys::pal::unix::stack_overflow::imp::NEED_ALTSTACK = 1;
      }
      std::sys::pal::unix::stack_overflow::imp::MAIN_ALTSTACK = (__int64)std::sys::pal::unix::stack_overflow::imp::make_handler();
      v10 = sysconf(30);
      std::sys::pal::unix::thread::guard::PAGE_SIZE = v10;
      v11 = v10;
      if ( !v10 )
      {
        v23 = &off_592E0;
        v24 = 32LL;
        v25 = aAssertionFaile_2;
LABEL_55:
        core::panicking::panic((__int64)v25, v24, (__int64)v23);
      }
      v12 = v10;
      memset(&fds, 0, 56);
      v13 = pthread_self();
      if ( pthread_getattr_np(v13, (pthread_attr_t *)&fds) )
      {
        v14 = 0LL;
        goto LABEL_41;
      }
      stackaddr[0] = 0LL;
      stacksize[0] = 0LL;
      v15 = stacksize;
      LODWORD(v27) = pthread_attr_getstack((const pthread_attr_t *)&fds, stackaddr, stacksize);
      if ( (_DWORD)v27 )
      {
        *(_QWORD *)&v30 = 0LL;
        v26 = &off_592C8;
        v15 = (size_t *)&v27;
        goto LABEL_53;
      }
      v16 = (unsigned __int64)stackaddr[0];
      LODWORD(stacksize[0]) = pthread_attr_destroy((pthread_attr_t *)&fds);
      if ( LODWORD(stacksize[0]) )
      {
        *(_QWORD *)&v30 = 0LL;
        v26 = &off_592B0;
LABEL_53:
        core::panicking::assert_failed(0, (__int64)v15, (__int64)&unk_4949C, &v30, (__int64)v26);
      }
      if ( (v11 | v16) >> 32 )
        v17 = v16 % v11;
      else
        v17 = (unsigned int)v16 % (unsigned int)v11;
      v18 = v11 - v17;
      if ( !v17 )
        v18 = 0LL;
      v19 = v18 + v16;
      stacksize[1] = v19 - v12;
      stacksize[2] = v19;
      v14 = 1LL;
LABEL_41:
      stacksize[0] = v14;
      <&[u8] as alloc::ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl((__int64 *)&v30, &unk_49440, 4uLL);
      if ( (_QWORD)v30 != 0x8000000000000000LL )
      {
        v33 = &v30;
        stackaddr[0] = &v33;
        stackaddr[1] = <core::result::Result<T,E> as core::fmt::Debug>::fmt;
        fds.sa_handler = (__sighandler_t)&off_588E0;
        fds.sa_mask.__val[0] = 2LL;
        fds.sa_mask.__val[3] = 0LL;
        fds.sa_mask.__val[1] = (unsigned __int64)stackaddr;
        fds.sa_mask.__val[2] = 1LL;
        v27 = std::io::Write::write_fmt((__int64)stacksize, &fds);
        if ( v27 )
          core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v27);
LABEL_50:
        std::sys::pal::unix::abort_internal();
      }
      v20 = (volatile signed __int64 *)std::thread::Thread::new(*((__int64 *)&v30 + 1), v31);
      std::sys_common::thread_info::set((__int64)stacksize, v20);
      v21 = (*(int (__fastcall **)(__int64))(a2 + 40))(a1);
      if ( std::rt::cleanup::CLEANUP != 4 )
      {
        LOBYTE(v30) = 1;
        fds.sa_handler = (__sighandler_t)&v30;
        std::sys::sync::once::futex::Once::call(&fds);
      }
      return v21;
    default:
      v23 = &off_59308;
      v24 = 40LL;
      v25 = aInternalErrorE;
      goto LABEL_55;
  }
}
// 0: using guessed type int dword_0;
// 482D0: using guessed type __int128 xmmword_482D0;
// 588E0: using guessed type char *off_588E0;
// 592B0: using guessed type char *off_592B0;
// 592C8: using guessed type char *off_592C8;
// 592E0: using guessed type char *off_592E0;
// 592F8: using guessed type char *off_592F8;
// 59308: using guessed type char *off_59308;
// 5B064: using guessed type int std::rt::cleanup::CLEANUP;
// 5B150: using guessed type __int64 std::sys::pal::unix::stack_overflow::imp::MAIN_ALTSTACK;
// 5B158: using guessed type char std::sys::pal::unix::stack_overflow::imp::NEED_ALTSTACK;
// 5B160: using guessed type __int64 std::sys::pal::unix::thread::guard::PAGE_SIZE;
// 5B168: using guessed type char std::sys::pal::unix::UNIX_SIGPIPE_ATTR_SPECIFIED;

//----- (0000000000020DA0) ----------------------------------------------------
void __noreturn std::rt::lang_start_internal::{{closure}}()
{
  char v0[8]; // [rsp+8h] [rbp-40h] BYREF
  char **v1; // [rsp+10h] [rbp-38h] BYREF
  __int64 v2[3]; // [rsp+18h] [rbp-30h] BYREF
  __int128 v3; // [rsp+30h] [rbp-18h]

  v2[0] = (__int64)&off_58918;
  v2[1] = 1LL;
  v2[2] = (__int64)v0;
  v3 = 0LL;
  v1 = std::io::Write::write_fmt((__int64)v0, v2);
  core::ptr::drop_in_place<core::result::Result<(),std::io::error::Error>>((__int64 *)&v1);
  std::sys::pal::unix::abort_internal();
}
// 58918: using guessed type char *off_58918;
// 20DA0: using guessed type char var_40[8];

//----- (0000000000020DF0) ----------------------------------------------------
void __noreturn std::rt::lang_start_internal::{{closure}}()
{
  char v0[8]; // [rsp+8h] [rbp-40h] BYREF
  char **v1; // [rsp+10h] [rbp-38h] BYREF
  __int64 v2[3]; // [rsp+18h] [rbp-30h] BYREF
  __int128 v3; // [rsp+30h] [rbp-18h]

  v2[0] = (__int64)&off_58928;
  v2[1] = 1LL;
  v2[2] = (__int64)v0;
  v3 = 0LL;
  v1 = std::io::Write::write_fmt((__int64)v0, v2);
  core::ptr::drop_in_place<core::result::Result<(),std::io::error::Error>>((__int64 *)&v1);
  std::sys::pal::unix::abort_internal();
}
// 20DF0: using guessed type void __noreturn std::rt::lang_start_internal::{{closure}}();
// 58928: using guessed type void *off_58928;
// 20DF0: using guessed type char var_40[8];

//----- (0000000000020E40) ----------------------------------------------------
char __fastcall <std::thread::local::AccessError as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  _BYTE v3[24]; // [rsp+0h] [rbp-18h] BYREF

  core::fmt::Formatter::debug_struct((__int64)v3, a2, (__int64)aAccesserror, 11LL);
  return core::fmt::builders::DebugStruct::finish(v3);
}

//----- (0000000000020E70) ----------------------------------------------------
volatile signed __int64 *__fastcall std::thread::current(
        __int64 a1,
        volatile signed __int64 *(__fastcall *a2)(__int64 a1))
{
  volatile signed __int64 *result; // rax

  result = std::sys_common::thread_info::current_thread(a1, a2);
  if ( !result )
    core::option::expect_failed((__int64)aUseOfStdThread, 94LL, (__int64)&off_58938);
  return result;
}
// 58938: using guessed type char *off_58938;

//----- (0000000000020EA0) ----------------------------------------------------
__int64 __fastcall std::thread::Thread::new(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // r13
  __int64 v5; // r12
  __int64 v6; // r15
  signed __int64 v7; // rax
  signed __int64 v8; // rcx
  signed __int64 v9; // rtt

  v2 = alloc::sync::arcinner_layout_for_value_layout(8uLL, 32LL);
  v4 = v2;
  v5 = v3;
  if ( !v3 )
  {
    v6 = v2;
    if ( v2 )
      goto LABEL_3;
LABEL_8:
    alloc::alloc::handle_alloc_error(v4, v5);
  }
  v6 = _rust_alloc(v3, v2);
  if ( !v6 )
    goto LABEL_8;
LABEL_3:
  *(_QWORD *)v6 = 1LL;
  *(_QWORD *)(v6 + 8) = 1LL;
  *(_QWORD *)(v6 + 24) = a1;
  *(_QWORD *)(v6 + 32) = a2;
  v7 = std::thread::ThreadId::new::COUNTER;
  do
  {
    v8 = v7 + 1;
    if ( v7 == -1 )
      std::thread::ThreadId::new::exhausted();
    v9 = v7;
    v7 = _InterlockedCompareExchange64(&std::thread::ThreadId::new::COUNTER, v8, v7);
  }
  while ( v9 != v7 );
  *(_QWORD *)(v6 + 16) = v8;
  *(_DWORD *)(v6 + 40) = 0;
  return v6;
}
// 20EC6: variable 'v3' is possibly undefined
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 5B128: using guessed type __int64 std::thread::ThreadId::new::COUNTER;

//----- (0000000000020FB0) ----------------------------------------------------
size_t *__fastcall std::env::current_dir(size_t *a1)
{
  unsigned __int64 v1; // r14
  char *v2; // rax
  char *v3; // r15
  size_t v4; // rax
  size_t v5; // r12
  char *v6; // r13
  unsigned int v7; // ecx
  unsigned __int64 v8; // rax
  size_t size; // [rsp+8h] [rbp-50h] BYREF
  char *buf; // [rsp+10h] [rbp-48h]
  size_t v12; // [rsp+18h] [rbp-40h]
  unsigned __int64 v13[7]; // [rsp+20h] [rbp-38h] BYREF

  v1 = 512LL;
  v2 = (char *)_rust_alloc(512LL, 1LL);
  if ( !v2 )
    alloc::alloc::handle_alloc_error(1LL, 512LL);
  v3 = v2;
  size = 512LL;
  buf = v2;
  if ( getcwd(v2, 0x200uLL) )
  {
LABEL_3:
    v4 = strlen(v3);
    v12 = v4;
    if ( v1 > v4 )
    {
      v5 = v4;
      if ( v4 )
      {
        v6 = (char *)_rust_realloc(v3, v1, 1LL, v4);
        if ( !v6 )
          alloc::alloc::handle_alloc_error(1LL, v5);
      }
      else
      {
        v6 = (_BYTE *)(&dword_0 + 1);
        _rust_dealloc(v3, v1, 1LL);
      }
      buf = v6;
      size = v5;
    }
    a1[2] = v12;
    *a1 = size;
    a1[1] = (size_t)buf;
    return a1;
  }
  v7 = *_errno_location();
  v13[0] = ((unsigned __int64)v7 << 32) | 2;
  if ( v7 == 34 )
  {
    v1 = 512LL;
    while ( 1 )
    {
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)v13);
      v12 = v1;
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&size, v1, 1LL);
      v1 = size;
      v3 = buf;
      if ( getcwd(buf, size) )
        goto LABEL_3;
      v8 = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
      v13[0] = v8;
      if ( (v8 & 0xFFFFFFFF00000000LL) != 0x2200000000LL )
      {
        a1[1] = v8;
        *a1 = 0x8000000000000000LL;
        if ( v1 )
          goto LABEL_14;
        return a1;
      }
    }
  }
  a1[1] = ((unsigned __int64)v7 << 32) | 2;
  *a1 = 0x8000000000000000LL;
  v1 = 512LL;
LABEL_14:
  _rust_dealloc(v3, v1, 1LL);
  return a1;
}
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);
// 20FB0: using guessed type unsigned __int64 var_38[7];

//----- (00000000000211E0) ----------------------------------------------------
_QWORD *__fastcall std::env::current_exe(_QWORD *a1)
{
  char *v2; // rdi
  char v3; // al
  __int128 v5; // [rsp+0h] [rbp-1C8h] BYREF
  __int64 v6; // [rsp+10h] [rbp-1B8h]
  __int64 v7[3]; // [rsp+18h] [rbp-1B0h] BYREF
  char v8[408]; // [rsp+30h] [rbp-198h] BYREF

  strcpy(v8, "/proc/self/exe");
  core::ffi::c_str::CStr::from_bytes_with_nul(v7, (__int64)v8, 0xFuLL);
  if ( v7[0] )
  {
    v2 = ptr;
    *((_QWORD *)&v5 + 1) = ptr;
    *(_QWORD *)&v5 = 0x8000000000000000LL;
    switch ( (unsigned __int64)ptr & 3 )
    {
      case 0uLL:
        goto LABEL_5;
      case 1uLL:
        goto LABEL_9;
      case 2uLL:
        goto LABEL_6;
      case 3uLL:
        goto LABEL_7;
    }
  }
  std::sys::pal::unix::fs::readlink::{{closure}}((size_t *)&v5, (__int64)v8, (const char *)v7[1]);
  if ( (_QWORD)v5 != 0x8000000000000000LL )
    goto LABEL_11;
  v2 = (char *)*((_QWORD *)&v5 + 1);
  switch ( BYTE8(v5) & 3 )
  {
    case 0:
LABEL_5:
      v3 = v2[16];
      break;
    case 1:
LABEL_9:
      v3 = v2[15];
      break;
    case 2:
LABEL_6:
      v3 = std::sys::pal::unix::decode_error_kind(SHIDWORD(v2));
      break;
    case 3:
LABEL_7:
      switch ( HIDWORD(v2) )
      {
        case 0:
          v3 = 0;
          break;
        case 1:
          v3 = 1;
          break;
        case 2:
          v3 = 2;
          break;
        case 3:
          v3 = 3;
          break;
        case 4:
          v3 = 4;
          break;
        case 5:
          v3 = 5;
          break;
        case 6:
          v3 = 6;
          break;
        case 7:
          v3 = 7;
          break;
        case 8:
          v3 = 8;
          break;
        case 9:
          v3 = 9;
          break;
        case 0xA:
          v3 = 10;
          break;
        case 0xB:
          v3 = 11;
          break;
        case 0xC:
          v3 = 12;
          break;
        case 0xD:
          v3 = 13;
          break;
        case 0xE:
          v3 = 14;
          break;
        case 0xF:
          v3 = 15;
          break;
        case 0x10:
          v3 = 16;
          break;
        case 0x11:
          v3 = 17;
          break;
        case 0x12:
          v3 = 18;
          break;
        case 0x13:
          v3 = 19;
          break;
        case 0x14:
          v3 = 20;
          break;
        case 0x15:
          v3 = 21;
          break;
        case 0x16:
          v3 = 22;
          break;
        case 0x17:
          v3 = 23;
          break;
        case 0x18:
          v3 = 24;
          break;
        case 0x19:
          v3 = 25;
          break;
        case 0x1A:
          v3 = 26;
          break;
        case 0x1B:
          v3 = 27;
          break;
        case 0x1C:
          v3 = 28;
          break;
        case 0x1D:
          v3 = 29;
          break;
        case 0x1E:
          v3 = 30;
          break;
        case 0x1F:
          v3 = 31;
          break;
        case 0x20:
          v3 = 32;
          break;
        case 0x21:
          v3 = 33;
          break;
        case 0x22:
          v3 = 34;
          break;
        case 0x23:
          v3 = 35;
          break;
        case 0x24:
          v3 = 36;
          break;
        case 0x25:
          v3 = 37;
          break;
        case 0x26:
          v3 = 38;
          break;
        case 0x27:
          v3 = 39;
          break;
        case 0x28:
          v3 = 40;
          break;
        default:
          v3 = 41;
          break;
      }
      break;
  }
  if ( !v3 )
  {
    a1[1] = &off_59218;
    *a1 = 0x8000000000000000LL;
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v5 + 1);
  }
  else
  {
LABEL_11:
    a1[2] = v6;
    *(_OWORD *)a1 = v5;
  }
  return a1;
}
// 59218: using guessed type char *off_59218;

//----- (0000000000021400) ----------------------------------------------------
void *__fastcall <std::ffi::os_str::OsString as core::convert::From<&T>>::from(__int64 *a1, const void *a2, __int64 a3)
{
  __int64 v4; // rax
  void *v5; // r15
  void *result; // rax

  if ( a3 )
  {
    if ( a3 < 0 )
      alloc::raw_vec::capacity_overflow();
    v4 = _rust_alloc(a3, 1LL);
    if ( !v4 )
      alloc::alloc::handle_alloc_error(1LL, a3);
    v5 = (void *)v4;
  }
  else
  {
    v5 = &dword_0 + 1;
  }
  result = memcpy(v5, a2, a3);
  *a1 = a3;
  a1[1] = (__int64)v5;
  a1[2] = a3;
  return result;
}
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);

//----- (0000000000021480) ----------------------------------------------------
__int64 __fastcall std::fs::buffer_capacity_required(int *a1)
{
  int v1; // ebx
  unsigned __int64 v2; // rax
  unsigned __int64 v4; // rax
  __int64 *v5; // rdi
  unsigned __int64 v6; // [rsp+8h] [rbp-160h] BYREF
  struct stat64 buf; // [rsp+10h] [rbp-158h] BYREF
  __int64 v8; // [rsp+A8h] [rbp-C0h] BYREF
  unsigned __int64 v9; // [rsp+B0h] [rbp-B8h] BYREF

  v1 = *a1;
  std::sys::pal::unix::fs::try_statx((__int64)&v8, (unsigned int)*a1, (__int64)&unk_48F69, 4096LL);
  if ( v8 == 3 )
  {
    memset(&buf, 0, sizeof(buf));
    if ( fstat64(v1, &buf) != -1 )
      goto LABEL_6;
    v2 = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
LABEL_10:
    v5 = (__int64 *)&v6;
    v6 = v2;
    goto LABEL_11;
  }
  if ( (_DWORD)v8 == 2 )
  {
    v2 = v9;
    goto LABEL_10;
  }
LABEL_6:
  if ( lseek64(v1, 0LL, 1) != -1 )
    return 1LL;
  v4 = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
  v8 = 1LL;
  v5 = (__int64 *)&v9;
  v9 = v4;
LABEL_11:
  core::ptr::drop_in_place<std::io::error::Error>(v5);
  return 0LL;
}

//----- (00000000000215B0) ----------------------------------------------------
__int64 __fastcall <&std::fs::File as std::io::Read>::read_to_string(int **a1, __int64 *a2)
{
  int *v3; // r15
  __int64 v4; // r12
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r13
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r14
  __int64 v9; // r15
  unsigned __int64 v10; // rbp
  __int64 result; // rax
  __int64 v12[9]; // [rsp+10h] [rbp-48h] BYREF

  v3 = *a1;
  v4 = std::fs::buffer_capacity_required(*a1);
  v6 = v5;
  v7 = v5;
  if ( !v4 )
    v7 = 0LL;
  if ( alloc::string::String::try_reserve(a2, v7) != 0x8000000000000001LL )
    return 1LL;
  v8 = a2[2];
  v9 = std::io::default_read_to_end(v3, a2, v4, v6);
  v10 = a2[2];
  if ( v10 < v8 )
    core::slice::index::slice_start_index_len_fail(v8, a2[2], (__int64)&off_58B38);
  core::str::converts::from_utf8((__int64)v12, v8 + a2[1], v10 - v8);
  if ( !v12[0] )
    v8 = v10;
  result = 1LL;
  if ( !v12[0] )
    result = v9;
  a2[2] = v8;
  return result;
}
// 215CF: variable 'v5' is possibly undefined
// 58B38: using guessed type char *off_58B38;
// 215B0: using guessed type __int64 var_48[9];

//----- (00000000000216D0) ----------------------------------------------------
__int64 __fastcall <std::fs::File as std::io::Read>::read_to_string(int *a1, __int64 *a2)
{
  int *v3; // [rsp+0h] [rbp-8h] BYREF

  v3 = a1;
  return <&std::fs::File as std::io::Read>::read_to_string(&v3, a2);
}

//----- (00000000000216E0) ----------------------------------------------------
__int64 __fastcall std::fs::OpenOptions::_open(__int64 a1, __int64 a2, const void *a3, size_t a4)
{
  int v5; // eax
  int v7[2]; // [rsp+8h] [rbp-1D0h] BYREF
  char *v8; // [rsp+10h] [rbp-1C8h]
  __int64 v9; // [rsp+18h] [rbp-1C0h] BYREF
  __int64 v10[3]; // [rsp+20h] [rbp-1B8h] BYREF
  char dest[416]; // [rsp+38h] [rbp-1A0h] BYREF

  v9 = a2;
  if ( a4 > 0x17F )
  {
    std::sys::pal::common::small_c_string::run_with_cstr_allocating((__int64)v7, a3, a4, &v9);
    if ( v7[0] )
      goto LABEL_5;
    goto LABEL_7;
  }
  memcpy(dest, a3, a4);
  dest[a4] = 0;
  core::ffi::c_str::CStr::from_bytes_with_nul(v10, (__int64)dest, a4 + 1);
  if ( !v10[0] )
  {
    std::sys::pal::unix::fs::File::open_c((__int64)v7, (const char *)v10[1], a2);
    if ( v7[0] )
      goto LABEL_5;
LABEL_7:
    *(_DWORD *)(a1 + 4) = v7[1];
    v5 = 0;
    goto LABEL_8;
  }
  v8 = ptr;
  v7[0] = 1;
LABEL_5:
  *(_QWORD *)(a1 + 8) = v8;
  v5 = 1;
LABEL_8:
  *(_DWORD *)a1 = v5;
  return a1;
}
// 216E0: using guessed type char dest[416];

//----- (00000000000217C0) ----------------------------------------------------
unsigned __int64 __fastcall std::io::buffered::bufwriter::BufWriter<W>::flush_buf(__int64 a1)
{
  unsigned __int64 v1; // rbp
  char *v2; // r12
  unsigned __int64 v3; // r15
  unsigned __int64 v4; // r14
  char *v5; // r13
  size_t v6; // rdx
  ssize_t v7; // rax
  unsigned __int64 v8; // r12
  char *dest; // [rsp+0h] [rbp-58h]
  __int64 v11[2]; // [rsp+10h] [rbp-48h] BYREF
  unsigned __int64 v12[7]; // [rsp+20h] [rbp-38h] BYREF

  v1 = *(_QWORD *)(a1 + 16);
  if ( !v1 )
    return 0LL;
  v2 = *(char **)(a1 + 8);
  v3 = 0LL;
  dest = v2;
  while ( 1 )
  {
    *(_BYTE *)(a1 + 24) = 1;
    v4 = v1 - v3;
    v5 = &v2[v3];
    v6 = 0x7FFFFFFFFFFFFFFFLL;
    if ( v1 - v3 < 0x7FFFFFFFFFFFFFFFLL )
      v6 = v1 - v3;
    v7 = write(1, &v2[v3], v6);
    if ( v7 == -1 )
    {
      v8 = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
      v11[1] = 1LL;
      v12[0] = v8;
      if ( (v8 & 0xFFFFFFFF00000000LL) != 0x900000000LL )
      {
        v11[0] = v8;
        *(_BYTE *)(a1 + 24) = 0;
        if ( (v8 & 0xFFFFFFFF00000000LL) != 0x400000000LL )
          goto LABEL_17;
        core::ptr::drop_in_place<std::io::error::Error>(v11);
        v2 = dest;
        goto LABEL_3;
      }
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)v12);
      v7 = v1 - v3;
      v2 = dest;
    }
    *(_BYTE *)(a1 + 24) = 0;
    if ( !v7 )
      break;
    v3 += v7;
LABEL_3:
    if ( v3 >= v1 )
    {
      v4 = 0LL;
      v8 = 0LL;
      if ( v1 >= v3 )
        goto LABEL_21;
      goto LABEL_23;
    }
  }
  v8 = (unsigned __int64)&off_58990;
LABEL_17:
  if ( !v3 )
    return v8;
  if ( v1 < v3 )
LABEL_23:
    core::slice::index::slice_end_index_len_fail(v3, v1, (__int64)&off_58668);
  *(_QWORD *)(a1 + 16) = 0LL;
  if ( v1 != v3 )
  {
    memmove(dest, v5, v1 - v3);
LABEL_21:
    *(_QWORD *)(a1 + 16) = v4;
  }
  return v8;
}
// 58668: using guessed type char *off_58668;
// 58990: using guessed type char *off_58990;
// 217C0: using guessed type unsigned __int64 var_38[7];

//----- (0000000000021960) ----------------------------------------------------
char __fastcall std::io::error::<impl core::fmt::Debug for std::io::error::repr_bitpacked::Repr>::fmt(
        __int64 *a1,
        __int64 a2,
        double a3,
        double a4)
{
  __int64 v4; // rbx
  _BYTE *v5; // rax
  _BYTE *v6; // rax
  char result; // al
  _BYTE *v8; // rbx
  _BYTE *v9; // rbx
  __int64 v10; // rax
  _BYTE *v11; // rax
  char v12; // bl
  char v13; // al
  __int64 *v14; // rax
  char v15; // [rsp+3h] [rbp-F5h] BYREF
  unsigned int v16; // [rsp+4h] [rbp-F4h] BYREF
  __int64 v17[3]; // [rsp+8h] [rbp-F0h] BYREF
  __int64 v18[3]; // [rsp+20h] [rbp-D8h] BYREF
  __int128 v19; // [rsp+38h] [rbp-C0h]
  char s[16]; // [rsp+50h] [rbp-A8h] BYREF
  __int128 v21; // [rsp+60h] [rbp-98h]
  __int128 v22; // [rsp+70h] [rbp-88h]
  __int128 v23; // [rsp+80h] [rbp-78h]
  __int128 v24; // [rsp+90h] [rbp-68h]
  __int128 v25; // [rsp+A0h] [rbp-58h]
  __int128 v26; // [rsp+B0h] [rbp-48h]
  __int128 v27; // [rsp+C0h] [rbp-38h]
  char v28[40]; // [rsp+D0h] [rbp-28h] BYREF

  v4 = *a1;
  switch ( *a1 & 3 )
  {
    case 0LL:
      core::fmt::Formatter::debug_struct((__int64)s, a2, (__int64)aError, 5LL);
      v5 = core::fmt::builders::DebugStruct::field(s, (__int64)aKind, 4uLL, v4 + 16, (__int64)&off_589F0, a3, a4);
      v6 = core::fmt::builders::DebugStruct::field(v5, (__int64)aMessage, 7uLL, v4, (__int64)&off_58A30, a3, a4);
      result = core::fmt::builders::DebugStruct::finish(v6);
      break;
    case 1LL:
      *(_QWORD *)s = v4 - 1;
      result = core::fmt::Formatter::debug_struct_field2_finish(
                 a2,
                 a3,
                 a4,
                 (__int64)&unk_499D2,
                 6LL,
                 (__int64)aKind,
                 4uLL,
                 v4 + 15,
                 (__int64)&off_589F0,
                 (__int64)&unk_499D8,
                 5uLL,
                 (__int64)s,
                 (__int64)&off_58A50);
      break;
    case 2LL:
      v16 = HIDWORD(*a1);
      core::fmt::Formatter::debug_struct((__int64)v28, a2, (__int64)aOs, 2LL);
      v8 = core::fmt::builders::DebugStruct::field(
             v28,
             (__int64)aCode,
             4uLL,
             (__int64)&v16,
             (__int64)&off_589D0,
             a3,
             a4);
      v15 = std::sys::pal::unix::decode_error_kind(v16);
      v9 = core::fmt::builders::DebugStruct::field(v8, (__int64)aKind, 4uLL, (__int64)&v15, (__int64)&off_589F0, a3, a4);
      v27 = 0LL;
      v26 = 0LL;
      v25 = 0LL;
      v24 = 0LL;
      v23 = 0LL;
      v22 = 0LL;
      v21 = 0LL;
      *(_OWORD *)s = 0LL;
      if ( (int)_xpg_strerror_r(v16, s, 128LL) < 0 )
      {
        v18[0] = (__int64)&off_591F0;
        v18[1] = 1LL;
        v18[2] = (__int64)aRustc9b00956e5;
        v19 = 0LL;
        core::panicking::panic_fmt((__int64)v18, (__int64)&off_59200);
      }
      v10 = strlen(s);
      alloc::string::String::from_utf8_lossy(v18, (__int64)s, v10);
      <alloc::string::String as core::convert::From<alloc::borrow::Cow<str>>>::from(v17, (__int64)v18);
      v11 = core::fmt::builders::DebugStruct::field(
              v9,
              (__int64)aMessage,
              7uLL,
              (__int64)v17,
              (__int64)off_58A10,
              0.0,
              a4);
      result = core::fmt::builders::DebugStruct::finish(v11);
      if ( v17[0] )
      {
        v12 = result;
        _rust_dealloc(v17[1], v17[0], 1LL);
        result = v12;
      }
      break;
    case 3LL:
      switch ( HIDWORD(v4) )
      {
        case 0:
          v13 = 0;
          break;
        case 1:
          v13 = 1;
          break;
        case 2:
          v13 = 2;
          break;
        case 3:
          v13 = 3;
          break;
        case 4:
          v13 = 4;
          break;
        case 5:
          v13 = 5;
          break;
        case 6:
          v13 = 6;
          break;
        case 7:
          v13 = 7;
          break;
        case 8:
          v13 = 8;
          break;
        case 9:
          v13 = 9;
          break;
        case 0xA:
          v13 = 10;
          break;
        case 0xB:
          v13 = 11;
          break;
        case 0xC:
          v13 = 12;
          break;
        case 0xD:
          v13 = 13;
          break;
        case 0xE:
          v13 = 14;
          break;
        case 0xF:
          v13 = 15;
          break;
        case 0x10:
          v13 = 16;
          break;
        case 0x11:
          v13 = 17;
          break;
        case 0x12:
          v13 = 18;
          break;
        case 0x13:
          v13 = 19;
          break;
        case 0x14:
          v13 = 20;
          break;
        case 0x15:
          v13 = 21;
          break;
        case 0x16:
          v13 = 22;
          break;
        case 0x17:
          v13 = 23;
          break;
        case 0x18:
          v13 = 24;
          break;
        case 0x19:
          v13 = 25;
          break;
        case 0x1A:
          v13 = 26;
          break;
        case 0x1B:
          v13 = 27;
          break;
        case 0x1C:
          v13 = 28;
          break;
        case 0x1D:
          v13 = 29;
          break;
        case 0x1E:
          v13 = 30;
          break;
        case 0x1F:
          v13 = 31;
          break;
        case 0x20:
          v13 = 32;
          break;
        case 0x21:
          v13 = 33;
          break;
        case 0x22:
          v13 = 34;
          break;
        case 0x23:
          v13 = 35;
          break;
        case 0x24:
          v13 = 36;
          break;
        case 0x25:
          v13 = 37;
          break;
        case 0x26:
          v13 = 38;
          break;
        case 0x27:
          v13 = 39;
          break;
        case 0x28:
          v13 = 40;
          break;
        default:
          v13 = 41;
          break;
      }
      LOBYTE(v18[0]) = v13;
      core::fmt::Formatter::debug_tuple((__int64)s, a2, (__int64)&unk_49458, 4LL);
      v14 = core::fmt::builders::DebugTuple::field((__int64 *)s, (__int64)v18, (__int64)&off_589F0);
      result = core::fmt::builders::DebugTuple::finish((__int64)v14);
      break;
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 589D0: using guessed type __int64 (__fastcall *off_589D0)();
// 589F0: using guessed type __int64 (__fastcall *off_589F0)();
// 58A10: using guessed type __int64 (__fastcall *off_58A10[2])();
// 58A30: using guessed type __int64 (__fastcall *off_58A30)();
// 58A50: using guessed type __int64 (__fastcall *off_58A50)();
// 591F0: using guessed type char *off_591F0;
// 59200: using guessed type char *off_59200;
// 5B230: using guessed type __int64 __fastcall _xpg_strerror_r(_QWORD, _QWORD, _QWORD);

//----- (0000000000021D30) ----------------------------------------------------
char __fastcall <std::io::error::Error as core::fmt::Display>::fmt(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  char result; // al
  unsigned __int64 v4; // rdi
  __int64 v5; // rax
  char v6; // bl
  __int64 v7; // rdi
  char (__fastcall *v8)(__int64, __int64); // rax
  int v9; // [rsp+4h] [rbp-E4h] BYREF
  __int64 **v10; // [rsp+8h] [rbp-E0h] BYREF
  char (__fastcall *v11)(__int64, __int64); // [rsp+10h] [rbp-D8h]
  __int64 *v12; // [rsp+20h] [rbp-C8h] BYREF
  char (__fastcall *v13)(__int64, __int64); // [rsp+28h] [rbp-C0h]
  int *v14; // [rsp+30h] [rbp-B8h]
  __int128 v15; // [rsp+38h] [rbp-B0h]
  char s[16]; // [rsp+50h] [rbp-98h] BYREF
  __int128 v17; // [rsp+60h] [rbp-88h]
  __int128 v18; // [rsp+70h] [rbp-78h]
  __int128 v19; // [rsp+80h] [rbp-68h]
  __int128 v20; // [rsp+90h] [rbp-58h]
  __int128 v21; // [rsp+A0h] [rbp-48h]
  __int128 v22; // [rsp+B0h] [rbp-38h]
  __int128 v23; // [rsp+C0h] [rbp-28h]

  v2 = *a1;
  switch ( v2 & 3 )
  {
    case 0LL:
      result = <str as core::fmt::Display>::fmt(*(_QWORD *)v2, *(_QWORD *)(v2 + 8), a2);
      break;
    case 1LL:
      result = (*(__int64 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v2 + 7) + 32LL))(*(_QWORD *)(v2 - 1), a2);
      break;
    case 2LL:
      v4 = HIDWORD(v2);
      v9 = v4;
      v23 = 0LL;
      v22 = 0LL;
      v21 = 0LL;
      v20 = 0LL;
      v19 = 0LL;
      v18 = 0LL;
      v17 = 0LL;
      *(_OWORD *)s = 0LL;
      if ( (int)_xpg_strerror_r(v4, s, 128LL) < 0 )
      {
        v12 = (__int64 *)&off_591F0;
        v13 = (char (__fastcall *)(__int64, __int64))(&dword_0 + 1);
        v14 = (int *)aRustc9b00956e5;
        v15 = 0LL;
        core::panicking::panic_fmt((__int64)&v12, (__int64)&off_59200);
      }
      v5 = strlen(s);
      alloc::string::String::from_utf8_lossy(&v12, (__int64)s, v5);
      <alloc::string::String as core::convert::From<alloc::borrow::Cow<str>>>::from((__int64 *)&v10, (__int64)&v12);
      v12 = (__int64 *)&v10;
      v13 = <alloc::string::String as core::fmt::Display>::fmt;
      v14 = &v9;
      *(_QWORD *)&v15 = core::fmt::num::imp::<impl core::fmt::Display for i32>::fmt;
      *(_QWORD *)s = &off_58A70;
      *(_QWORD *)&s[8] = 3LL;
      *(_QWORD *)&v18 = 0LL;
      *(_QWORD *)&v17 = &v12;
      *((_QWORD *)&v17 + 1) = 2LL;
      result = core::fmt::write(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40), s);
      if ( v10 )
      {
        v6 = result;
        _rust_dealloc(v11, v10, 1LL);
        result = v6;
      }
      break;
    case 3LL:
      v7 = v2 >> 32;
      v8 = (char (__fastcall *)(__int64, __int64))qword_4A660[v7];
      v12 = (__int64 *)*(&off_59498 + v7);
      v13 = v8;
      v10 = &v12;
      v11 = <&T as core::fmt::Display>::fmt;
      *(_QWORD *)s = &off_589A8;
      *(_QWORD *)&s[8] = 1LL;
      *(_QWORD *)&v18 = 0LL;
      *(_QWORD *)&v17 = &v10;
      *((_QWORD *)&v17 + 1) = 1LL;
      result = core::fmt::write(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40), s);
      break;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 4A660: using guessed type _QWORD qword_4A660[41];
// 589A8: using guessed type char *off_589A8;
// 58A70: using guessed type char *off_58A70;
// 591F0: using guessed type char *off_591F0;
// 59200: using guessed type char *off_59200;
// 59498: using guessed type void *off_59498;
// 5B230: using guessed type __int64 __fastcall _xpg_strerror_r(_QWORD, _QWORD, _QWORD);

//----- (0000000000021FA0) ----------------------------------------------------
__int64 __fastcall std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::write(
        __int64 *a1,
        const void *a2,
        size_t a3)
{
  __int64 v3; // r14
  size_t v4; // r15
  size_t v6; // r14

  v3 = a1[2];
  if ( *a1 - v3 < a3 )
  {
    v6 = a3;
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, a1[2], a3);
    a3 = v6;
    v3 = a1[2];
  }
  v4 = a3;
  memcpy((void *)(v3 + a1[1]), a2, a3);
  a1[2] = v4 + v3;
  return 0LL;
}

//----- (0000000000022000) ----------------------------------------------------
__int64 __fastcall std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::write_vectored(
        __int64 *a1,
        __int64 a2,
        unsigned __int64 a3)
{
  __int64 v4; // r14
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r12
  __int64 v7; // rcx
  unsigned __int64 v9; // rdx
  _QWORD *v10; // rsi
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // r15
  __int64 v15; // rsi
  __int64 v16; // r15
  __int64 v17; // r13
  const void *v18; // rbx
  size_t v19; // rbp
  __int64 *v20; // [rsp+0h] [rbp-38h]

  if ( a3 )
  {
    v4 = a2;
    v5 = a3 & 3;
    if ( a3 >= 4 )
    {
      v9 = a3 & 0xFFFFFFFFFFFFFFFCLL;
      v10 = (_QWORD *)(a2 + 56);
      v6 = 0LL;
      v7 = 0LL;
      do
      {
        v6 += *v10 + *(v10 - 2) + *(v10 - 4) + *(v10 - 6);
        v7 += 4LL;
        v10 += 8;
      }
      while ( v9 != v7 );
    }
    else
    {
      v6 = 0LL;
      v7 = 0LL;
    }
    if ( v5 )
    {
      v11 = v4 + 16 * v7 + 8;
      v12 = (unsigned int)(16 * v5);
      v13 = 0LL;
      do
      {
        v6 += *(_QWORD *)(v11 + v13);
        v13 += 16LL;
      }
      while ( v12 != v13 );
    }
    v14 = 16 * a3;
    v15 = a1[2];
    v20 = a1;
    if ( *a1 - v15 < v6 )
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, v15, v6);
    v16 = v4 + v14;
    v17 = a1[2];
    do
    {
      v18 = *(const void **)v4;
      v19 = *(_QWORD *)(v4 + 8);
      if ( *a1 - v17 < v19 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(v20, v17, *(_QWORD *)(v4 + 8));
        v17 = v20[2];
      }
      memcpy((void *)(v17 + v20[1]), v18, v19);
      a1 = v20;
      v17 += v19;
      v20[2] = v17;
      v4 += 16LL;
    }
    while ( v4 != v16 );
  }
  return 0LL;
}

//----- (0000000000022130) ----------------------------------------------------
char std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::is_write_vectored()
{
  return 1;
}

//----- (0000000000022140) ----------------------------------------------------
__int64 __fastcall std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::write_all(
        __int64 *a1,
        const void *a2,
        size_t a3)
{
  __int64 v4; // r15

  v4 = a1[2];
  if ( *a1 - v4 < a3 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, a1[2], a3);
    v4 = a1[2];
  }
  memcpy((void *)(v4 + a1[1]), a2, a3);
  a1[2] = a3 + v4;
  return 0LL;
}

//----- (00000000000221A0) ----------------------------------------------------
__int64 std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::flush()
{
  return 0LL;
}
// 221A0: using guessed type __int64 std::io::impls::<impl std::io::Write for alloc::vec::Vec<u8,A>>::flush();

//----- (00000000000221B0) ----------------------------------------------------
unsigned __int64 __fastcall <std::io::stdio::StdoutRaw as std::io::Write>::write_all(
        __int64 a1,
        char *a2,
        unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  size_t v5; // rdx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // [rsp+8h] [rbp-40h] BYREF
  unsigned __int64 v11[7]; // [rsp+10h] [rbp-38h] BYREF

  if ( !a3 )
    return 0LL;
  v3 = a3;
  while ( 1 )
  {
    v5 = 0x7FFFFFFFFFFFFFFFLL;
    if ( v3 < 0x7FFFFFFFFFFFFFFFLL )
      v5 = v3;
    v6 = write(1, a2, v5);
    if ( v6 != -1LL )
      break;
    result = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
    v10 = 1LL;
    v11[0] = result;
    if ( (result & 0xFFFFFFFF00000000LL) != 0x400000000LL )
      goto LABEL_13;
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)v11);
    v7 = v3;
LABEL_3:
    if ( !v7 )
      return 0LL;
  }
  if ( v6 )
  {
    v7 = v3 - v6;
    if ( v3 < v6 )
      core::slice::index::slice_start_index_len_fail(v6, v3, (__int64)&off_58C00);
    a2 += v6;
    v3 -= v6;
    goto LABEL_3;
  }
  result = (unsigned __int64)&off_58BE8;
LABEL_13:
  v10 = result;
  v9 = result & 3;
  if ( v9 >= 2 && (_DWORD)v9 == 2 && (result & 0xFFFFFFFF00000000LL) == 0x900000000LL )
  {
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v10);
    return 0LL;
  }
  return result;
}
// 58BE8: using guessed type char *off_58BE8;
// 58C00: using guessed type char *off_58C00;
// 221B0: using guessed type unsigned __int64 var_38[7];

//----- (00000000000222E0) ----------------------------------------------------
void *__fastcall std::io::stdio::stdin(__int64 a1)
{
  if ( dword_5B0A0 != 4 )
    std::sync::once_lock::OnceLock<T>::initialize();
  return &std::io::stdio::stdin::INSTANCE;
}
// 5B0A0: using guessed type int dword_5B0A0;

//----- (0000000000022310) ----------------------------------------------------
__int64 __fastcall std::io::stdio::Stdin::read_line(volatile signed __int32 **a1, __int64 *a2)
{
  volatile signed __int32 *v2; // rbx
  bool v3; // bp
  __int64 result; // rax
  __int64 v5; // r14
  __int64 v6; // r14
  bool is_zero_slow_path; // cl
  volatile signed __int32 *v8; // [rsp+8h] [rbp-30h] BYREF
  bool v9; // [rsp+10h] [rbp-28h]

  v2 = *a1;
  if ( _InterlockedCompareExchange(*a1, 1, 0) )
    std::sys::sync::mutex::futex::Mutex::lock_contended(v2);
  if ( 2 * std::panicking::panic_count::GLOBAL_PANIC_COUNT )
    v3 = !std::panicking::panic_count::is_zero_slow_path();
  else
    v3 = 0;
  v8 = v2;
  v9 = v3;
  result = <std::io::stdio::StdinLock as std::io::BufRead>::read_line((__int64)&v8, a2);
  if ( !v3 && (std::panicking::panic_count::GLOBAL_PANIC_COUNT & 0x7FFFFFFFFFFFFFFFLL) != 0 )
  {
    v6 = result;
    is_zero_slow_path = std::panicking::panic_count::is_zero_slow_path();
    result = v6;
    if ( !is_zero_slow_path )
      *((_BYTE *)v2 + 4) = 1;
  }
  if ( _InterlockedExchange(v2, 0) == 2 )
  {
    v5 = result;
    syscall(202LL, v2, 129LL, 1LL);
    return v5;
  }
  return result;
}
// 5B120: using guessed type signed __int64 std::panicking::panic_count::GLOBAL_PANIC_COUNT;

//----- (0000000000022420) ----------------------------------------------------
__int64 __fastcall <std::io::stdio::StdinLock as std::io::BufRead>::read_line(__int64 a1, __int64 *a2)
{
  unsigned __int64 v2; // r14
  __int64 until; // r15
  unsigned __int64 v4; // rbp
  __int64 result; // rax
  __int64 v6[9]; // [rsp+10h] [rbp-48h] BYREF

  v2 = a2[2];
  until = std::io::read_until((char **)(*(_QWORD *)a1 + 8LL), 0xAu, a2);
  v4 = a2[2];
  if ( v4 < v2 )
    core::slice::index::slice_start_index_len_fail(v2, a2[2], (__int64)&off_58B38);
  core::str::converts::from_utf8((__int64)v6, v2 + a2[1], v4 - v2);
  if ( !v6[0] )
    v2 = v4;
  result = 1LL;
  if ( !v6[0] )
    result = until;
  a2[2] = v2;
  return result;
}
// 58B38: using guessed type char *off_58B38;
// 22420: using guessed type __int64 var_48[9];

//----- (0000000000022500) ----------------------------------------------------
__int64 *__fastcall std::io::stdio::stdout(__int64 a1)
{
  if ( dword_5B0E0 != 4 )
    std::sync::once_lock::OnceLock<T>::initialize();
  return &std::io::stdio::STDOUT;
}
// 5B0A8: using guessed type __int64 std::io::stdio::STDOUT;
// 5B0E0: using guessed type int dword_5B0E0;

//----- (0000000000022530) ----------------------------------------------------
unsigned __int64 __fastcall <std::io::stdio::Stdout as std::io::Write>::flush(__int64 *a1)
{
  __int64 *v2; // [rsp+0h] [rbp-8h] BYREF

  v2 = a1;
  return <&std::io::stdio::Stdout as std::io::Write>::flush(&v2);
}

//----- (0000000000022540) ----------------------------------------------------
unsigned __int64 __fastcall <&std::io::stdio::Stdout as std::io::Write>::flush(__int64 **a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // r14
  unsigned __int64 result; // rax
  __int64 v5; // rsi
  unsigned __int64 v6; // rbx

  v1 = **a1;
  v2 = __readfsqword(0);
  if ( *(_QWORD *)v1 == v2 - 31 )
  {
    if ( *(_DWORD *)(v1 + 12) == -1 )
      core::option::expect_failed((__int64)aLockCountOverf, 38LL, (__int64)&off_58DE0);
    ++*(_DWORD *)(v1 + 12);
  }
  else
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(v1 + 8), 1, 0) )
      std::sys::sync::mutex::futex::Mutex::lock_contended((volatile __int32 *)(v1 + 8));
    *(_QWORD *)v1 = v2 - 31;
    *(_DWORD *)(v1 + 12) = 1;
  }
  if ( *(_QWORD *)(v1 + 16) )
    core::cell::panic_already_borrowed((__int64)&off_58AB8);
  *(_QWORD *)(v1 + 16) = -1LL;
  result = std::io::buffered::bufwriter::BufWriter<W>::flush_buf(v1 + 24);
  ++*(_QWORD *)(v1 + 16);
  if ( (*(_DWORD *)(v1 + 12))-- == 1 )
  {
    *(_QWORD *)v1 = 0LL;
    if ( _InterlockedExchange((volatile __int32 *)(v1 + 8), 0) == 2 )
    {
      v5 = v1 + 8;
      v6 = result;
      syscall(202LL, v5, 129LL, 1LL);
      return v6;
    }
  }
  return result;
}
// 58AB8: using guessed type char *off_58AB8;
// 58DE0: using guessed type char *off_58DE0;

//----- (0000000000022660) ----------------------------------------------------
char **__fastcall <&std::io::stdio::Stdout as std::io::Write>::write_fmt(__int64 **a1, _QWORD *a2)
{
  __int64 v2; // r15
  unsigned __int64 v3; // r14
  char **result; // rax
  __int64 v5; // rsi
  bool v6; // zf
  char **v7; // rbx
  __int64 v8; // [rsp+0h] [rbp-38h] BYREF
  __int64 *v9; // [rsp+8h] [rbp-30h] BYREF
  char **v10; // [rsp+10h] [rbp-28h] BYREF

  v2 = **a1;
  v3 = __readfsqword(0);
  if ( *(_QWORD *)v2 == v3 - 31 )
  {
    if ( *(_DWORD *)(v2 + 12) == -1 )
      core::option::expect_failed((__int64)aLockCountOverf, 38LL, (__int64)&off_58DE0);
    ++*(_DWORD *)(v2 + 12);
  }
  else
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 8), 1, 0) )
      std::sys::sync::mutex::futex::Mutex::lock_contended((volatile __int32 *)(v2 + 8));
    *(_QWORD *)v2 = v3 - 31;
    *(_DWORD *)(v2 + 12) = 1;
  }
  v8 = v2;
  v9 = &v8;
  v10 = 0LL;
  if ( core::fmt::write((__int64)&v9, (__int64)&off_587D8, a2) )
  {
    result = &off_58C18;
    if ( v10 )
      result = v10;
    v5 = v8;
    v6 = (*(_DWORD *)(v8 + 12))-- == 1;
    if ( v6 )
    {
LABEL_15:
      *(_QWORD *)v5 = 0LL;
      if ( _InterlockedExchange((volatile __int32 *)(v5 + 8), 0) == 2 )
      {
        v7 = result;
        syscall(202LL, v5 + 8, 129LL, 1LL);
        return v7;
      }
    }
  }
  else
  {
    if ( v10 )
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v10);
    result = 0LL;
    v5 = v8;
    v6 = (*(_DWORD *)(v8 + 12))-- == 1;
    if ( v6 )
      goto LABEL_15;
  }
  return result;
}
// 587D8: using guessed type __int64 (__fastcall *off_587D8)();
// 58C18: using guessed type char *off_58C18;
// 58DE0: using guessed type char *off_58DE0;

//----- (00000000000227E0) ----------------------------------------------------
unsigned __int64 __fastcall <std::io::stdio::StdoutLock as std::io::Write>::write_all(
        __int64 a1,
        char *a2,
        unsigned __int64 a3)
{
  _QWORD *v3; // r13
  unsigned __int64 v4; // rbx
  char *v5; // r14
  __int64 v6; // rdx
  _QWORD *v7; // r15
  unsigned __int64 v8; // r12
  bool v9; // cf
  __int64 v10; // rbp
  __int64 v11; // r12
  unsigned __int64 result; // rax
  __int64 v13[3]; // [rsp+8h] [rbp-60h] BYREF
  __int128 v14; // [rsp+20h] [rbp-48h]

  v3 = *(_QWORD **)a1;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 16LL) )
    core::cell::panic_already_borrowed((__int64)&off_58AD0);
  v4 = a3;
  v5 = a2;
  v3[2] = -1LL;
  v7 = v3 + 3;
  if ( !core::slice::memchr::memrchr(0xAu, (__int64)a2, a3) )
  {
    v11 = v3[5];
    if ( v11 )
    {
      if ( *(_BYTE *)(v11 + v3[4] - 1) == 10 )
      {
        result = std::io::buffered::bufwriter::BufWriter<W>::flush_buf((__int64)(v3 + 3));
        if ( result )
          goto LABEL_20;
        v11 = v3[5];
      }
    }
    else
    {
      v11 = 0LL;
    }
    if ( *v7 - v11 <= v4 )
      goto LABEL_16;
    goto LABEL_19;
  }
  v8 = v6 + 1;
  v9 = v4 < v6 + 1;
  v4 -= v6 + 1;
  if ( v9 )
  {
    v13[0] = (__int64)&off_58490;
    v13[1] = 1LL;
    v13[2] = (__int64)aRustc9b00956e5;
    v14 = 0LL;
    core::panicking::panic_fmt((__int64)v13, (__int64)&off_589B8);
  }
  v10 = v3[5];
  if ( v10 )
  {
    if ( *v7 - v10 <= v8 )
    {
      result = std::io::buffered::bufwriter::BufWriter<W>::write_all_cold((__int64)(v3 + 3), a2, v6 + 1);
      if ( result )
        goto LABEL_20;
    }
    else
    {
      memcpy((void *)(v10 + v3[4]), a2, v6 + 1);
      v3[5] = v8 + v10;
    }
    result = std::io::buffered::bufwriter::BufWriter<W>::flush_buf((__int64)(v3 + 3));
  }
  else
  {
    result = <std::io::stdio::StdoutRaw as std::io::Write>::write_all(10LL, a2, v6 + 1);
  }
  if ( !result )
  {
    v5 = &a2[v8];
    v11 = v3[5];
    if ( v3[3] - v11 <= v4 )
    {
LABEL_16:
      result = std::io::buffered::bufwriter::BufWriter<W>::write_all_cold((__int64)(v3 + 3), v5, v4);
      goto LABEL_20;
    }
LABEL_19:
    memcpy((void *)(v11 + v3[4]), v5, v4);
    v3[5] = v4 + v11;
    result = 0LL;
  }
LABEL_20:
  ++v3[2];
  return result;
}
// 22821: variable 'v6' is possibly undefined
// 58490: using guessed type char *off_58490;
// 589B8: using guessed type char *off_589B8;
// 58AD0: using guessed type char *off_58AD0;

//----- (0000000000022970) ----------------------------------------------------
__int64 __fastcall std::io::stdio::print_to_buffer_if_capture_used(_QWORD *a1)
{
  unsigned __int64 v1; // rax
  __int64 *v2; // r14
  volatile __int32 *v3; // rbx
  __int64 v4; // r13
  bool v5; // bp
  char **v6; // rax
  volatile signed __int64 *v7; // rax
  char **v9; // [rsp+0h] [rbp-48h] BYREF
  char **v10; // [rsp+8h] [rbp-40h] BYREF
  __int64 v11; // [rsp+10h] [rbp-38h]

  if ( !std::io::stdio::OUTPUT_CAPTURE_USED )
    goto LABEL_15;
  v1 = __readfsqword(0);
  if ( *(_QWORD *)(v1 - 24) )
  {
    v2 = (__int64 *)(v1 - 16);
  }
  else
  {
    LODWORD(v3) = 0;
    v2 = (__int64 *)std::sys::thread_local::fast_local::Key<T>::try_initialize(0LL);
    if ( !v2 )
      return (unsigned int)v3;
  }
  v4 = *v2;
  *v2 = 0LL;
  if ( !v4 )
  {
LABEL_15:
    LODWORD(v3) = 0;
    return (unsigned int)v3;
  }
  v11 = v4;
  v3 = (volatile __int32 *)(v4 + 16);
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 16), 1, 0) )
    std::sys::sync::mutex::futex::Mutex::lock_contended((volatile __int32 *)(v4 + 16));
  if ( 2 * std::panicking::panic_count::GLOBAL_PANIC_COUNT )
    v5 = !std::panicking::panic_count::is_zero_slow_path();
  else
    v5 = 0;
  v9 = (char **)(v4 + 24);
  v10 = 0LL;
  if ( core::fmt::write((__int64)&v9, (__int64)&off_587A8, a1) )
  {
    v6 = &off_58C18;
    if ( v10 )
      v6 = v10;
    v9 = v6;
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v9);
    if ( v5 )
      goto LABEL_20;
  }
  else
  {
    if ( v10 )
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v10);
    v9 = 0LL;
    if ( v5 )
      goto LABEL_20;
  }
  if ( (std::panicking::panic_count::GLOBAL_PANIC_COUNT & 0x7FFFFFFFFFFFFFFFLL) != 0
    && !std::panicking::panic_count::is_zero_slow_path() )
  {
    *(_BYTE *)(v4 + 20) = 1;
  }
LABEL_20:
  if ( _InterlockedExchange(v3, 0) == 2 )
    syscall(202LL, v4 + 16, 129LL, 1LL);
  v9 = (char **)*v2;
  v7 = (volatile signed __int64 *)v9;
  *v2 = v11;
  if ( v7 && !_InterlockedDecrement64(v7) )
    alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v9);
  LOBYTE(v3) = 1;
  return (unsigned int)v3;
}
// 587A8: using guessed type __int64 (__fastcall *off_587A8)();
// 58C18: using guessed type char *off_58C18;
// 5B068: using guessed type char std::io::stdio::OUTPUT_CAPTURE_USED;
// 5B120: using guessed type signed __int64 std::panicking::panic_count::GLOBAL_PANIC_COUNT;

//----- (0000000000022B70) ----------------------------------------------------
__int64 __fastcall std::io::stdio::_print(_QWORD *a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+0h] [rbp-78h] BYREF
  __int64 *v3; // [rsp+8h] [rbp-70h] BYREF
  __int64 v4[2]; // [rsp+10h] [rbp-68h] BYREF
  __int64 *v5[6]; // [rsp+20h] [rbp-58h] BYREF
  __int64 v6[5]; // [rsp+50h] [rbp-28h] BYREF

  v4[0] = (__int64)aStdout;
  v4[1] = 6LL;
  result = std::io::stdio::print_to_buffer_if_capture_used(a1);
  if ( !(_BYTE)result )
  {
    if ( dword_5B0E0 != 4 )
      std::sync::once_lock::OnceLock<T>::initialize();
    v3 = &std::io::stdio::STDOUT;
    v5[0] = (__int64 *)&v3;
    result = (__int64)<&std::io::stdio::Stdout as std::io::Write>::write_fmt(v5, a1);
    if ( result )
    {
      v2 = result;
      v6[0] = (__int64)v4;
      v6[1] = (__int64)<&T as core::fmt::Display>::fmt;
      v6[2] = (__int64)&v2;
      v6[3] = (__int64)<std::io::error::Error as core::fmt::Display>::fmt;
      v5[0] = (__int64 *)&off_58B00;
      v5[1] = (_QWORD *)(&dword_0 + 2);
      v5[4] = 0LL;
      v5[2] = v6;
      v5[3] = (_QWORD *)(&dword_0 + 2);
      core::panicking::panic_fmt((__int64)v5, (__int64)&off_58B20);
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 58B00: using guessed type char *off_58B00;
// 58B20: using guessed type char *off_58B20;
// 5B0A8: using guessed type __int64 std::io::stdio::STDOUT;
// 5B0E0: using guessed type int dword_5B0E0;

//----- (0000000000022C70) ----------------------------------------------------
__int64 __fastcall std::io::default_read_to_end(int *a1, __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 *v4; // rbp
  __int64 v6; // r14
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rdx
  size_t v10; // rdi
  __int64 v11; // r13
  __int64 v12; // rdx
  __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // r14
  unsigned __int64 v17; // r12
  void *v18; // r14
  size_t v19; // rbp
  unsigned __int64 v20; // rax
  __int64 v21; // rax
  unsigned __int64 v22; // rdi
  __int64 v23; // rdx
  __int64 v24; // rcx
  size_t nbytes; // [rsp+8h] [rbp-90h]
  unsigned __int64 v26; // [rsp+18h] [rbp-80h]
  __int64 v27; // [rsp+20h] [rbp-78h]
  __int64 v29[3]; // [rsp+38h] [rbp-60h] BYREF
  __int64 v30; // [rsp+50h] [rbp-48h] BYREF
  __int64 v31; // [rsp+58h] [rbp-40h]

  v4 = a2;
  v6 = *a2;
  v7 = a2[2];
  if ( a3 )
  {
    v8 = a4 + 1024;
    if ( a4 >= 0xFFFFFFFFFFFFFC00LL )
      goto LABEL_6;
    v9 = v8 & 0x1FFF;
    v10 = v8 + 0x2000 - v9;
    if ( (v8 & 0x1FFF) == 0 )
      v10 = a4 + 1024;
    nbytes = v10;
    if ( __CFADD__(v8, 0x2000 - v9) && v9 != 0 )
LABEL_6:
      nbytes = 0x2000LL;
    v11 = *a2;
    if ( a4 )
      goto LABEL_14;
  }
  else
  {
    nbytes = 0x2000LL;
  }
  v7 = a2[2];
  if ( v6 - v7 > 0x1F )
  {
    v11 = *a2;
LABEL_14:
    v26 = 0LL;
    v27 = v6;
    while ( 1 )
    {
      if ( v7 == v11 && v11 == v6 )
      {
        if ( std::io::default_read_to_end::small_probe_read(a1, v4) )
          return 1LL;
        if ( !v14 )
          return 0LL;
        v11 = *v4;
        v7 = v4[2];
      }
      if ( v7 == v11 )
      {
        v11 = v7 + 32;
        if ( v7 >= 0xFFFFFFFFFFFFFFE0LL )
          return 1LL;
        if ( 2 * v7 > v11 )
          v11 = 2 * v7;
        if ( v7 )
        {
          v29[0] = v4[1];
          v29[2] = v7;
          v15 = 1LL;
        }
        else
        {
          v15 = 0LL;
        }
        v29[1] = v15;
        alloc::raw_vec::finish_grow(&v30, v11 >= 0, v11, v29);
        if ( v30 )
          return 1LL;
        v16 = v31;
        v4[1] = v31;
        *v4 = v11;
      }
      else
      {
        v11 = *v4;
        v16 = v4[1];
      }
      v17 = v11 - v7;
      v18 = (void *)(v7 + v16);
      if ( v11 - v7 >= nbytes )
        v17 = nbytes;
      v19 = 0x7FFFFFFFFFFFFFFFLL;
      if ( v17 < 0x7FFFFFFFFFFFFFFFLL )
        v19 = v17;
      while ( 1 )
      {
        v20 = read(*a1, v18, v19);
        if ( v20 != -1LL )
          break;
        v21 = (unsigned int)*_errno_location();
        if ( (_DWORD)v21 != 4 )
          return 1LL;
        v29[0] = (v21 << 32) | 2;
        core::ptr::drop_in_place<std::io::error::Error>(v29);
      }
      v22 = v26;
      if ( v26 <= v20 )
        v22 = v20;
      if ( v22 > v17 )
        core::slice::index::slice_end_index_len_fail(v22, v17, (__int64)&off_58B50);
      v4 = a2;
      v6 = v27;
      if ( !v20 )
        return 0LL;
      v26 = v22 - v20;
      v7 += v20;
      a2[2] = v7;
      if ( !a3 )
      {
        v23 = nbytes;
        if ( v22 != v17 )
          v23 = -1LL;
        v24 = 2 * v23;
        if ( v23 < 0 )
          v24 = -1LL;
        if ( v17 < v23 )
          v24 = v23;
        if ( v20 == v17 )
          v23 = v24;
        nbytes = v23;
      }
    }
  }
  if ( std::io::default_read_to_end::small_probe_read(a1, a2) )
    return 1LL;
  if ( v12 )
  {
    v11 = *a2;
    v7 = a2[2];
    goto LABEL_14;
  }
  return 0LL;
}
// 22D5B: variable 'v14' is possibly undefined
// 22EDB: variable 'v12' is possibly undefined
// 58B50: using guessed type char *off_58B50;

//----- (0000000000022F50) ----------------------------------------------------
__int64 __fastcall std::io::default_read_to_end::small_probe_read(int *a1, __int64 *a2)
{
  unsigned __int64 v2; // rax
  unsigned int v3; // ecx
  __int64 v4; // r15
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // r12
  unsigned __int64 v8; // [rsp+8h] [rbp-60h] BYREF
  __int128 buf[5]; // [rsp+10h] [rbp-58h] BYREF

  memset(buf, 0, 32);
  v2 = read(*a1, buf, 0x20uLL);
  if ( v2 == -1LL )
  {
    while ( 1 )
    {
      v3 = *_errno_location();
      v8 = ((unsigned __int64)v3 << 32) | 2;
      if ( v3 != 4 )
        return 1LL;
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v8);
      v2 = read(*a1, buf, 0x20uLL);
      if ( v2 != -1LL )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    if ( v2 >= 0x21 )
      core::slice::index::slice_end_index_len_fail(v2, 32LL, (__int64)&off_58B68);
    v4 = a2[2];
    v5 = v2;
    if ( *a2 - v4 < v2 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a2, a2[2], v2);
      v2 = v5;
      v4 = a2[2];
    }
    v6 = v2;
    memcpy((void *)(v4 + a2[1]), buf, v2);
    a2[2] = v6 + v4;
    return 0LL;
  }
}
// 58B68: using guessed type char *off_58B68;

//----- (0000000000023070) ----------------------------------------------------
char **__fastcall std::io::Write::write_all(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  size_t v5; // rdx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rcx
  unsigned int v8; // ecx
  char **result; // rax
  char **v10; // [rsp+10h] [rbp-38h] BYREF

  if ( a3 )
  {
    v3 = a3;
    do
    {
      v5 = 0x7FFFFFFFFFFFFFFFLL;
      if ( v3 < 0x7FFFFFFFFFFFFFFFLL )
        v5 = v3;
      v6 = write(2, a2, v5);
      if ( v6 == -1LL )
      {
        v8 = *_errno_location();
        result = (char **)(((unsigned __int64)v8 << 32) | 2);
        v10 = result;
        if ( v8 != 4 )
          return result;
        core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v10);
        v7 = v3;
      }
      else
      {
        if ( !v6 )
          return &off_58BE8;
        v7 = v3 - v6;
        if ( v3 < v6 )
          core::slice::index::slice_start_index_len_fail(v6, v3, (__int64)&off_58C00);
        a2 += v6;
        v3 -= v6;
      }
    }
    while ( v7 );
  }
  return 0LL;
}
// 58BE8: using guessed type char *off_58BE8;
// 58C00: using guessed type char *off_58C00;

//----- (0000000000023150) ----------------------------------------------------
char **__fastcall std::io::Write::write_all_vectored(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v5; // rcx
  __int64 v6; // rdx
  unsigned __int64 v7; // rdi
  size_t v8; // rsi
  size_t v9; // rax
  bool v10; // cf
  const struct iovec *v11; // r14
  size_t iov_len; // rcx
  size_t v13; // rcx
  int v14; // edx
  ssize_t v15; // rax
  __int64 v16; // rsi
  size_t v17; // rcx
  unsigned int v18; // ecx
  char **result; // rax
  size_t v20; // rax
  size_t v21; // rax
  char **v22; // [rsp+8h] [rbp-70h] BYREF
  __int64 v23; // [rsp+10h] [rbp-68h]
  const char *v24; // [rsp+18h] [rbp-60h]
  __int128 v25; // [rsp+20h] [rbp-58h]
  __int64 v26; // [rsp+38h] [rbp-40h]
  ssize_t v27[7]; // [rsp+40h] [rbp-38h] BYREF

  if ( !a3 )
    return 0LL;
  v3 = a3;
  v5 = 16 * a3;
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  while ( 1 )
  {
    v10 = v9 < *(_QWORD *)(a2 + v6 + 8);
    v9 -= *(_QWORD *)(a2 + v6 + 8);
    if ( v10 )
      break;
    ++v7;
    v6 += 16LL;
    v8 = v9;
    if ( v5 == v6 )
      goto LABEL_7;
  }
  v9 = v8;
LABEL_7:
  if ( v3 < v7 )
LABEL_33:
    core::slice::index::slice_start_index_len_fail(v7, v3, (__int64)&off_58B80);
  v11 = (const struct iovec *)(16 * v7 + a2);
  v3 -= v7;
  if ( !v3 )
  {
    if ( v9 )
    {
LABEL_35:
      v22 = &off_58B98;
      v23 = 1LL;
      v24 = aRustc9b00956e5;
      v25 = 0LL;
      core::panicking::panic_fmt((__int64)&v22, (__int64)&off_58BA8);
    }
    return 0LL;
  }
  iov_len = v11->iov_len;
  v10 = iov_len < v9;
  v13 = iov_len - v9;
  if ( v10 )
  {
LABEL_34:
    v22 = &off_58BC0;
    v23 = 1LL;
    v24 = aRustc9b00956e5;
    v25 = 0LL;
    core::panicking::panic_fmt((__int64)&v22, (__int64)&off_58BD0);
  }
  v11->iov_len = v13;
  v11->iov_base = (char *)v11->iov_base + v9;
  while ( 1 )
  {
    v14 = 1024;
    if ( v3 < 0x400 )
      v14 = v3;
    v15 = writev(2, v11, v14);
    if ( v15 == -1 )
    {
      v18 = *_errno_location();
      result = (char **)(((unsigned __int64)v18 << 32) | 2);
      v26 = 1LL;
      v27[0] = (ssize_t)result;
      if ( v18 != 4 )
        return result;
LABEL_30:
      core::ptr::drop_in_place<std::io::error::Error>(v27);
      goto LABEL_14;
    }
    v26 = 0LL;
    v27[0] = v15;
    if ( !v15 )
      return &off_58BE8;
    v16 = 0LL;
    v7 = 0LL;
    v17 = v15;
    while ( 1 )
    {
      v10 = v17 < v11[v16].iov_len;
      v17 -= v11[v16].iov_len;
      if ( v10 )
        break;
      ++v7;
      ++v16;
      v15 = v17;
      if ( v3 == v16 )
        goto LABEL_26;
    }
    v17 = v15;
LABEL_26:
    if ( v3 < v7 )
      goto LABEL_33;
    v11 += v7;
    v3 -= v7;
    if ( !v3 )
    {
      if ( v17 )
        goto LABEL_35;
      goto LABEL_14;
    }
    v20 = v11->iov_len;
    v10 = v20 < v17;
    v21 = v20 - v17;
    if ( v10 )
      goto LABEL_34;
    v11->iov_len = v21;
    v11->iov_base = (char *)v11->iov_base + v17;
    if ( v26 )
      goto LABEL_30;
LABEL_14:
    if ( !v3 )
      return 0LL;
  }
}
// 231BF: conditional instruction was optimized away because rbx.8==0
// 231DD: conditional instruction was optimized away because rbx.8!=0
// 58B80: using guessed type char *off_58B80;
// 58B98: using guessed type char *off_58B98;
// 58BA8: using guessed type char *off_58BA8;
// 58BC0: using guessed type char *off_58BC0;
// 58BD0: using guessed type char *off_58BD0;
// 58BE8: using guessed type char *off_58BE8;
// 23150: using guessed type ssize_t var_38[7];

//----- (0000000000023390) ----------------------------------------------------
char **__fastcall std::io::Write::write_all_vectored(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v6; // rcx
  __int64 v7; // rdx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rax
  bool v11; // cf
  _QWORD *v12; // r15
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // r13
  __int64 v17; // rax
  _QWORD *v18; // rdx
  __int64 v19; // rax
  __int64 v20; // rdx
  __int64 v21; // rbp
  _QWORD *v22; // r14
  const void *v23; // rbx
  size_t v24; // r12
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rcx
  unsigned __int64 v28; // rcx
  __int64 *v30; // [rsp+8h] [rbp-80h]
  char **v31; // [rsp+10h] [rbp-78h] BYREF
  __int64 v32; // [rsp+18h] [rbp-70h]
  const char *v33; // [rsp+20h] [rbp-68h]
  __int128 v34; // [rsp+28h] [rbp-60h]
  unsigned __int64 v35; // [rsp+40h] [rbp-48h]
  _QWORD *v36; // [rsp+48h] [rbp-40h]
  unsigned __int64 v37; // [rsp+50h] [rbp-38h]

  if ( !a3 )
    return 0LL;
  v3 = a3;
  v6 = 16 * a3;
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  while ( 1 )
  {
    v11 = v10 < *(_QWORD *)(a2 + v7 + 8);
    v10 -= *(_QWORD *)(a2 + v7 + 8);
    if ( v11 )
      break;
    ++v8;
    v7 += 16LL;
    v9 = v10;
    if ( v6 == v7 )
      goto LABEL_7;
  }
  v10 = v9;
LABEL_7:
  if ( v3 < v8 )
LABEL_40:
    core::slice::index::slice_start_index_len_fail(v8, v3, (__int64)&off_58B80);
  v12 = (_QWORD *)(16 * v8 + a2);
  v13 = v3 - v8;
  if ( !v13 )
  {
    if ( !v10 )
      return 0LL;
    goto LABEL_41;
  }
  v14 = v12[1];
  v11 = v14 < v10;
  v15 = v14 - v10;
  if ( v11 )
  {
LABEL_42:
    v31 = &off_58BC0;
    v32 = 1LL;
    v33 = aRustc9b00956e5;
    v34 = 0LL;
    core::panicking::panic_fmt((__int64)&v31, (__int64)&off_58BD0);
  }
  v12[1] = v15;
  *v12 += v10;
  v30 = a1;
  while ( 1 )
  {
    if ( v13 >= 4 )
    {
      v18 = v12 + 7;
      v16 = 0LL;
      v17 = 0LL;
      do
      {
        v16 += *v18 + *(v18 - 2) + *(v18 - 4) + *(v18 - 6);
        v17 += 4LL;
        v18 += 8;
      }
      while ( (v13 & 0xFFFFFFFFFFFFFFFCLL) != v17 );
    }
    else
    {
      v16 = 0LL;
      v17 = 0LL;
    }
    if ( (v13 & 3) != 0 )
    {
      v19 = (__int64)&v12[2 * v17 + 1];
      v20 = 0LL;
      do
      {
        v16 += *(_QWORD *)(v19 + v20);
        v20 += 16LL;
      }
      while ( 16 * (v13 & 3) != v20 );
    }
    v21 = a1[2];
    if ( *a1 - v21 < v16 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, a1[2], v16);
      a1 = v30;
      v21 = v30[2];
    }
    v37 = v13;
    v35 = 16 * v13;
    v22 = &v12[2 * v13];
    v36 = v12;
    do
    {
      v23 = (const void *)*v12;
      v24 = v12[1];
      if ( *a1 - v21 < v24 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, v21, v12[1]);
        a1 = v30;
        v21 = v30[2];
      }
      memcpy((void *)(v21 + a1[1]), v23, v24);
      a1 = v30;
      v21 += v24;
      v30[2] = v21;
      v12 += 2;
    }
    while ( v12 != v22 );
    if ( !v16 )
      return &off_58BE8;
    v25 = 0LL;
    v8 = 0LL;
    v26 = v16;
    v3 = v37;
    while ( 1 )
    {
      v11 = v26 < v36[v25 / 8 + 1];
      v26 -= v36[v25 / 8 + 1];
      if ( v11 )
        break;
      ++v8;
      v25 += 16LL;
      v16 = v26;
      if ( v35 == v25 )
        goto LABEL_34;
    }
    v26 = v16;
LABEL_34:
    if ( v37 < v8 )
      goto LABEL_40;
    v12 = &v36[2 * v8];
    v13 = v37 - v8;
    if ( v37 == v8 )
    {
      if ( !v26 )
        return 0LL;
LABEL_41:
      v31 = &off_58B98;
      v32 = 1LL;
      v33 = aRustc9b00956e5;
      v34 = 0LL;
      core::panicking::panic_fmt((__int64)&v31, (__int64)&off_58BA8);
    }
    v27 = v12[1];
    v11 = v27 < v26;
    v28 = v27 - v26;
    if ( v11 )
      goto LABEL_42;
    v12[1] = v28;
    *v12 += v26;
    if ( !v13 )
      return 0LL;
  }
}
// 233FF: conditional instruction was optimized away because rbx.8==0
// 2341D: conditional instruction was optimized away because rbx.8!=0
// 2343C: conditional instruction was optimized away because rbx.8==0
// 58B80: using guessed type char *off_58B80;
// 58B98: using guessed type char *off_58B98;
// 58BA8: using guessed type char *off_58BA8;
// 58BC0: using guessed type char *off_58BC0;
// 58BD0: using guessed type char *off_58BD0;
// 58BE8: using guessed type char *off_58BE8;

//----- (0000000000023680) ----------------------------------------------------
char **__fastcall std::io::Write::write_fmt(__int64 a1, _QWORD *a2)
{
  char **result; // rax
  __int64 v3; // [rsp+8h] [rbp-20h] BYREF
  __int64 v4[3]; // [rsp+10h] [rbp-18h] BYREF

  v3 = a1;
  v4[0] = 0LL;
  if ( core::fmt::write((__int64)&v3, (__int64)&off_58808, a2) )
  {
    result = &off_58C18;
    if ( v4[0] )
      return (char **)v4[0];
  }
  else
  {
    if ( v4[0] )
      core::ptr::drop_in_place<std::io::error::Error>(v4);
    return 0LL;
  }
  return result;
}
// 58808: using guessed type __int64 (__fastcall *off_58808)();
// 58C18: using guessed type char *off_58C18;
// 23680: using guessed type __int64 var_18[3];

//----- (0000000000023710) ----------------------------------------------------
char **__fastcall std::io::Write::write_fmt(__int64 a1, _QWORD *a2)
{
  char **result; // rax
  __int64 v3; // [rsp+8h] [rbp-20h] BYREF
  __int64 v4[3]; // [rsp+10h] [rbp-18h] BYREF

  v3 = a1;
  v4[0] = 0LL;
  if ( core::fmt::write((__int64)&v3, (__int64)&off_587A8, a2) )
  {
    result = &off_58C18;
    if ( v4[0] )
      return (char **)v4[0];
  }
  else
  {
    if ( v4[0] )
      core::ptr::drop_in_place<std::io::error::Error>(v4);
    return 0LL;
  }
  return result;
}
// 587A8: using guessed type __int64 (__fastcall *off_587A8)();
// 58C18: using guessed type char *off_58C18;
// 23710: using guessed type __int64 var_18[3];

//----- (00000000000237A0) ----------------------------------------------------
char __fastcall <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(
        __int64 a1,
        char *a2,
        unsigned __int64 a3)
{
  unsigned __int64 v3; // r14
  size_t v5; // rdx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rcx
  __int64 v8; // rax
  char **v9; // r12
  char **v11; // [rsp+10h] [rbp-38h] BYREF

  if ( !a3 )
    return 0;
  v3 = a3;
  while ( 1 )
  {
    v5 = 0x7FFFFFFFFFFFFFFFLL;
    if ( v3 < 0x7FFFFFFFFFFFFFFFLL )
      v5 = v3;
    v6 = write(2, a2, v5);
    if ( v6 != -1LL )
      break;
    v8 = (unsigned int)*_errno_location();
    v9 = (char **)((v8 << 32) | 2);
    v11 = v9;
    if ( (_DWORD)v8 != 4 )
      goto LABEL_14;
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v11);
    v7 = v3;
LABEL_3:
    if ( !v7 )
      return 0;
  }
  if ( v6 )
  {
    v7 = v3 - v6;
    if ( v3 < v6 )
      core::slice::index::slice_start_index_len_fail(v6, v3, (__int64)&off_58C00);
    a2 += v6;
    v3 -= v6;
    goto LABEL_3;
  }
  v9 = &off_58BE8;
LABEL_14:
  if ( *(_QWORD *)(a1 + 8) )
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)(a1 + 8));
  *(_QWORD *)(a1 + 8) = v9;
  return 1;
}
// 58BE8: using guessed type char *off_58BE8;
// 58C00: using guessed type char *off_58C00;

//----- (00000000000238B0) ----------------------------------------------------
bool __fastcall <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(
        __int64 *a1,
        char *a2,
        unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx

  v3 = <std::io::stdio::StdoutLock as std::io::Write>::write_all(*a1, a2, a3);
  if ( v3 )
  {
    if ( a1[1] )
      core::ptr::drop_in_place<std::io::error::Error>(a1 + 1);
    a1[1] = v3;
  }
  return v3 != 0;
}

//----- (0000000000023900) ----------------------------------------------------
__int64 __fastcall <std::io::Write::write_fmt::Adapter<T> as core::fmt::Write>::write_str(
        __int64 **a1,
        const void *a2,
        size_t a3)
{
  __int64 *v4; // r14
  __int64 v5; // r15

  v4 = *a1;
  v5 = (*a1)[2];
  if ( **a1 - v5 < a3 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(*a1, v5, a3);
    v5 = v4[2];
  }
  memcpy((void *)(v5 + v4[1]), a2, a3);
  v4[2] = a3 + v5;
  return 0LL;
}

//----- (0000000000023960) ----------------------------------------------------
__int64 __fastcall std::io::read_until(char **a1, unsigned __int8 a2, __int64 *a3)
{
  char *v3; // r15
  size_t v4; // rcx
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // r12
  unsigned __int64 v7; // r13
  __int64 v8; // rcx
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // r14
  char *v11; // rbp
  unsigned __int64 v12; // rdx
  __int64 v13; // rsi
  unsigned __int64 v14; // rax
  size_t v16; // r15
  __int64 v17; // r14
  unsigned __int64 v18; // rcx
  __int64 v21; // [rsp+10h] [rbp-68h]
  unsigned __int64 v22; // [rsp+20h] [rbp-58h]
  unsigned __int64 v23; // [rsp+30h] [rbp-48h] BYREF
  size_t nbytes; // [rsp+38h] [rbp-40h]
  unsigned __int64 v25[7]; // [rsp+40h] [rbp-38h] BYREF

  v3 = *a1;
  v4 = 0x7FFFFFFFFFFFFFFFLL;
  if ( (unsigned __int64)a1[1] < 0x7FFFFFFFFFFFFFFFLL )
    v4 = (size_t)a1[1];
  nbytes = v4;
  v5 = (unsigned __int64)a1[2];
  v6 = (unsigned __int64)a1[3];
  v7 = (unsigned __int64)a1[4];
  v8 = 0LL;
  while ( 1 )
  {
    v21 = v8;
    v22 = v5;
    while ( 1 )
    {
      if ( v5 < v6 )
        goto LABEL_15;
      v9 = read(0, v3, nbytes);
      if ( v9 != -1LL )
        break;
      v10 = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
      v25[0] = v10;
      if ( (v10 & 0xFFFFFFFF00000000LL) == 0x900000000LL )
      {
        core::ptr::drop_in_place<std::io::error::Error>((__int64 *)v25);
        v6 = 0LL;
        goto LABEL_14;
      }
      v23 = v10;
      switch ( v10 & 3 )
      {
        case 0uLL:
LABEL_17:
          if ( *(_BYTE *)(v10 + 16) == 35 )
            goto LABEL_6;
          return 1LL;
        case 1uLL:
LABEL_20:
          if ( *(_BYTE *)(v10 + 15) != 35 )
            return 1LL;
          goto LABEL_6;
        case 2uLL:
LABEL_5:
          if ( (v10 & 0xFFFFFFFF00000000LL) == 0x400000000LL )
            goto LABEL_6;
          return 1LL;
        case 3uLL:
LABEL_22:
          if ( HIDWORD(v10) != 35 )
            return 1LL;
LABEL_6:
          core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v23);
          break;
      }
    }
    if ( v7 <= v9 )
      v7 = v9;
    v6 = v9;
LABEL_14:
    a1[2] = 0LL;
    a1[3] = (char *)v6;
    a1[4] = (char *)v7;
    v22 = 0LL;
    v5 = 0LL;
LABEL_15:
    v10 = v6 - v5;
    v11 = &v3[v5];
    v23 = v6 - v5;
    if ( !v3 )
    {
      switch ( v10 & 3 )
      {
        case 0uLL:
          goto LABEL_17;
        case 1uLL:
          goto LABEL_20;
        case 2uLL:
          goto LABEL_5;
        case 3uLL:
          goto LABEL_22;
      }
    }
    if ( v10 < 0x10 )
      break;
    if ( core::slice::memchr::memchr_aligned(a2, (__int64)&v3[v5], v6 - v5) )
      goto LABEL_41;
LABEL_34:
    v13 = a3[2];
    if ( *a3 - v13 < v10 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a3, v13, v10);
      v13 = a3[2];
    }
    memcpy((void *)(v13 + a3[1]), v11, v10);
    v14 = v10 + v22;
    if ( v10 + v22 >= v6 )
      v14 = v6;
    a3[2] = v10 + v13;
    v5 = v14;
    a1[2] = (char *)v14;
    v8 = v10 + v21;
    if ( !v10 )
      return 0LL;
  }
  if ( !v10 )
    goto LABEL_34;
  v12 = 0LL;
  while ( v11[v12] != a2 )
  {
    if ( v6 - v5 == ++v12 )
      goto LABEL_34;
  }
LABEL_41:
  if ( v12 == -1LL )
    core::slice::index::slice_end_index_overflow_fail((__int64)&off_58C30);
  v16 = v12 + 1;
  if ( v12 >= v10 )
    core::slice::index::slice_end_index_len_fail(v16, v6 - v5, (__int64)&off_58C30);
  v17 = a3[2];
  if ( *a3 - v17 <= v12 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a3, a3[2], v12 + 1);
    v17 = a3[2];
  }
  memcpy((void *)(v17 + a3[1]), v11, v16);
  a3[2] = v16 + v17;
  v18 = v16 + v22;
  if ( v16 + v22 >= v6 )
    v18 = v6;
  a1[2] = (char *)v18;
  return 0LL;
}
// 23C39: variable 'v12' is possibly undefined
// 58C30: using guessed type char *off_58C30;
// 23960: using guessed type unsigned __int64 var_38[7];

//----- (0000000000023CE0) ----------------------------------------------------
__int64 __fastcall std::panic::get_backtrace_style()
{
  unsigned int v0; // ebx
  char v2; // al
  size_t v3; // [rsp+0h] [rbp-1B8h] BYREF
  char *v4; // [rsp+8h] [rbp-1B0h] BYREF
  __int64 v5; // [rsp+10h] [rbp-1A8h]
  __int64 v6[3]; // [rsp+18h] [rbp-1A0h] BYREF
  char v7[392]; // [rsp+30h] [rbp-188h] BYREF

  switch ( std::panic::SHOULD_CAPTURE )
  {
    case 0:
      strcpy(v7, "RUST_BACKTRACE");
      core::ffi::c_str::CStr::from_bytes_with_nul(v6, (__int64)v7, 0xFuLL);
      if ( v6[0] )
      {
        v4 = ptr;
        v3 = 0x8000000000000001LL;
        core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v4);
LABEL_10:
        v2 = 3;
        LOBYTE(v0) = 2;
        goto LABEL_11;
      }
      v0 = 1;
      std::sys::pal::unix::os::getenv::{{closure}}(&v3, (__int64)v7, (const char *)v6[1]);
      if ( v3 == 0x8000000000000001LL )
      {
        core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v4);
        goto LABEL_10;
      }
      v0 = 0;
      if ( v3 == 0x8000000000000000LL )
        goto LABEL_10;
      if ( v5 == 4 )
      {
        LOBYTE(v0) = *(_DWORD *)v4 == 1819047270;
      }
      else if ( v5 == 1 )
      {
        LOBYTE(v0) = 2 * (*v4 == 48);
      }
      else
      {
        v0 = 0;
      }
      if ( v3 )
        _rust_dealloc(v4, v3, 1LL);
      v2 = v0 + 1;
LABEL_11:
      std::panic::SHOULD_CAPTURE = v2;
      return v0;
    case 1:
      return 0LL;
    case 2:
      LOBYTE(v0) = 1;
      return v0;
    case 3:
      LOBYTE(v0) = 2;
      return v0;
    default:
      core::panicking::panic((__int64)aInternalErrorE, 40LL, (__int64)off_58C48);
  }
}
// 23D72: variable 'v0' is possibly undefined
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 58C48: using guessed type char *off_58C48[2];
// 5B0E8: using guessed type char std::panic::SHOULD_CAPTURE;

//----- (0000000000023E40) ----------------------------------------------------
__int64 __fastcall std::path::Components::len_before_body(__int64 *a1)
{
  unsigned __int8 v1; // dl
  unsigned __int8 v2; // al
  char v3; // r9
  __int64 v4; // rcx
  unsigned __int64 v5; // rsi
  __int64 v6; // r8
  __int64 v7; // rcx
  __int64 result; // rax
  _BYTE *v9; // r9
  bool v10; // si
  char v11; // cl

  v1 = *((_BYTE *)a1 + 56);
  if ( v1 > 1u )
  {
    v2 = 0;
    v7 = 0LL;
    return v7 + v2;
  }
  v2 = *((_BYTE *)a1 + 58);
  if ( v2 )
    goto LABEL_8;
  v3 = *((_BYTE *)a1 + 16);
  if ( (unsigned __int8)(v3 - 5) > 1u )
    goto LABEL_8;
  v4 = *a1;
  v5 = a1[1];
  v6 = 0LL;
  if ( !v1 && v3 != 6 )
  {
    v6 = 2LL;
    if ( v5 <= 1 )
      core::slice::index::slice_start_index_len_fail(2LL, v5, (__int64)&off_58C60);
  }
  if ( v6 == v5 )
  {
LABEL_8:
    v7 = 0LL;
    if ( !v1 )
      goto LABEL_9;
    return v7 + v2;
  }
  v9 = (_BYTE *)(v4 + v6 + 1);
  v10 = v9 == (_BYTE *)(v4 + v5);
  v11 = *(_BYTE *)(v4 + v6);
  if ( v10 || v11 != 46 )
  {
    if ( v11 != 46 || !v10 )
      goto LABEL_8;
  }
  else if ( *v9 != 47 )
  {
    goto LABEL_8;
  }
  v7 = 1LL;
  if ( v1 )
    return v7 + v2;
LABEL_9:
  v1 = *((_BYTE *)a1 + 16);
  switch ( (char)v7 )
  {
    case 0:
      result = v7 + 2 + v2;
      break;
    case 1:
      return v7 + v2;
    default:
      goto LABEL_8;
  }
  return result;
}
// 58C60: using guessed type char *off_58C60;

//----- (0000000000023F90) ----------------------------------------------------
_BYTE *__fastcall std::path::Components::as_path(__int64 a1)
{
  _BYTE *v1; // rbx
  unsigned __int64 v2; // r14
  __int64 v3; // rax
  __int128 v4; // xmm0
  unsigned __int8 v5; // cl
  char v6; // bp
  char v7; // dl
  __int64 v8; // rsi
  __int64 v9; // rdi
  unsigned __int64 v10; // rdi
  __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rdx
  __int64 v14; // rdx
  unsigned __int8 v15; // di
  __int64 v16; // rsi
  _BYTE *v17; // rdi
  char v18; // dl
  __int64 v19; // rsi
  unsigned __int64 v20; // r15
  bool v21; // r12
  __int64 v22; // rcx
  unsigned __int64 v23; // r13
  __int64 v24; // rcx
  _BYTE *v25; // rdx
  char v26; // cl
  bool v27; // zf
  unsigned __int64 v28; // rdi
  char v30; // cl
  __int64 v31; // rax
  _BYTE *v32; // [rsp+10h] [rbp-C8h] BYREF
  unsigned __int64 v33; // [rsp+18h] [rbp-C0h]
  char v34; // [rsp+20h] [rbp-B8h]
  _BYTE v35[39]; // [rsp+21h] [rbp-B7h]
  char v36; // [rsp+48h] [rbp-90h]
  char v37; // [rsp+49h] [rbp-8Fh]
  unsigned __int8 v38; // [rsp+4Ah] [rbp-8Eh]
  __int64 v39; // [rsp+50h] [rbp-88h]
  __int64 v40; // [rsp+58h] [rbp-80h]
  __int128 v41; // [rsp+60h] [rbp-78h] BYREF
  _BYTE v42[23]; // [rsp+70h] [rbp-68h]
  __int64 v43; // [rsp+A0h] [rbp-38h]

  v1 = *(_BYTE **)a1;
  v2 = *(_QWORD *)(a1 + 8);
  LODWORD(v3) = *(unsigned __int8 *)(a1 + 16);
  if ( (_DWORD)v3 != 6 )
  {
    *(_QWORD *)&v42[15] = *(_QWORD *)(a1 + 48);
    v4 = *(_OWORD *)(a1 + 17);
    *(_OWORD *)v42 = *(_OWORD *)(a1 + 33);
    v41 = v4;
  }
  v5 = *(_BYTE *)(a1 + 58);
  v6 = *(_BYTE *)(a1 + 56);
  v7 = *(_BYTE *)(a1 + 57);
  v32 = v1;
  v33 = v2;
  v34 = v3;
  *(_OWORD *)v35 = v41;
  *(_OWORD *)&v35[16] = *(_OWORD *)v42;
  *(_QWORD *)&v35[31] = *(_QWORD *)&v42[15];
  v38 = v5;
  v36 = v6;
  v37 = v7;
  if ( v6 == 2 )
  {
    if ( !v2 )
      return v1;
    if ( (unsigned __int8)v3 >= 3u )
    {
      while ( 1 )
      {
        v10 = 0LL;
        while ( v1[v10] != 47 )
        {
          if ( v2 == ++v10 )
          {
            v11 = 0LL;
            v10 = v2;
            goto LABEL_19;
          }
        }
        v11 = 1LL;
        if ( v10 )
          break;
LABEL_21:
        v12 = v11 + v10;
        if ( v2 < v12 )
          core::slice::index::slice_start_index_len_fail(v12, v2, (__int64)&off_58CA8);
        v1 += v12;
        v2 -= v12;
        if ( !v2 )
        {
          v2 = 0LL;
          goto LABEL_24;
        }
      }
LABEL_19:
      if ( v10 == 1 && *v1 == 46 )
        goto LABEL_21;
    }
    else
    {
      v8 = (__int64)&v1[v2];
      while ( 1 )
      {
        v9 = 0LL;
        while ( v1[v9] != 47 )
        {
          if ( v2 == ++v9 )
            goto LABEL_24;
        }
        if ( v9 )
          break;
        ++v1;
        if ( !--v2 )
        {
          v2 = 0LL;
          v1 = (_BYTE *)v8;
          v32 = (_BYTE *)v8;
          goto LABEL_25;
        }
      }
    }
LABEL_24:
    v32 = v1;
LABEL_25:
    v33 = v2;
  }
  if ( v7 != 2 )
    return v1;
  if ( (unsigned __int8)v6 > 1u )
  {
    v15 = 0;
    v13 = 0LL;
    v16 = 0LL;
    goto LABEL_46;
  }
  v13 = 0LL;
  if ( v5 || (unsigned __int8)(v3 - 5) > 1u )
    goto LABEL_43;
  v14 = 0LL;
  if ( (_BYTE)v3 != 6 && !v6 )
  {
    v14 = 2LL;
    if ( v2 <= 1 )
LABEL_93:
      core::slice::index::slice_start_index_len_fail(2LL, v2, (__int64)&off_58C60);
  }
  if ( v14 != v2 )
  {
    v17 = &v1[v14 + 1];
    v18 = v1[v14];
    if ( v17 == &v1[v2] || v18 != 46 )
    {
      if ( v18 != 46 || v17 != &v1[v2] )
        goto LABEL_34;
    }
    else if ( *v17 != 47 )
    {
      goto LABEL_34;
    }
    v13 = 1LL;
LABEL_43:
    if ( !v6 )
      goto LABEL_74;
    goto LABEL_44;
  }
LABEL_34:
  v13 = 0LL;
  if ( !v6 )
  {
LABEL_74:
    switch ( (char)v3 )
    {
      case 0:
        v16 = 2LL;
        break;
      case 1:
        goto LABEL_44;
      default:
        goto LABEL_43;
    }
    goto LABEL_45;
  }
LABEL_44:
  v16 = 0LL;
LABEL_45:
  v15 = v5;
LABEL_46:
  if ( v2 > v16 + v13 + (unsigned __int64)v15 )
  {
    v19 = *(_QWORD *)&v35[31] + 1LL;
    if ( !*(_QWORD *)&v35[31] )
      v19 = 0LL;
    if ( (unsigned __int8)v6 >= 2u )
    {
      do
      {
        std::path::Components::parse_next_component_back((__int64)&v41, (__int64)&v32);
        if ( BYTE8(v41) != 10 )
          break;
        v28 = v2 - v41;
        v27 = v2 == (_QWORD)v41;
        if ( v2 < (unsigned __int64)v41 )
LABEL_91:
          core::slice::index::slice_end_index_len_fail(v28, v2, (__int64)&off_58CC0);
        v33 = v2 - v41;
        v2 -= v41;
      }
      while ( !v27 );
    }
    else
    {
      v20 = v5;
      v40 = *(_QWORD *)&v35[15] + v19 + 2;
      v39 = *(_QWORD *)&v35[15] + v19 + 8;
      if ( !v5 && (unsigned __int8)(v3 - 5) <= 1u )
      {
        v21 = v6 != 0 || (_BYTE)v3 == 6;
        v43 = (unsigned int)v3;
        while ( 1 )
        {
          v23 = v2;
          std::path::Components::parse_next_component_back((__int64)&v41, (__int64)&v32);
          if ( BYTE8(v41) != 10 )
            return v1;
          v2 -= v41;
          if ( v23 < (unsigned __int64)v41 )
            goto LABEL_92;
          v33 = v23 - v41;
          if ( v21 )
          {
            v24 = 0LL;
          }
          else
          {
            v24 = 2LL;
            if ( v2 < 2 )
              goto LABEL_93;
          }
          if ( v24 != v2 )
          {
            v25 = &v1[v24 + 1];
            v26 = v1[v24];
            if ( v25 == &v1[v2] || v26 != 46 )
            {
              if ( v26 == 46 && v25 == &v1[v2] )
              {
LABEL_67:
                v3 = 1LL;
                if ( !v6 )
                {
LABEL_68:
                  switch ( (char)v43 )
                  {
                    case 0:
                      v22 = 2LL;
                      goto LABEL_55;
                    case 1:
                      goto LABEL_54;
                    default:
                      goto LABEL_75;
                  }
                }
                goto LABEL_54;
              }
            }
            else if ( *v25 == 47 )
            {
              goto LABEL_67;
            }
          }
          v3 = 0LL;
          if ( !v6 )
            goto LABEL_68;
LABEL_54:
          v22 = 0LL;
LABEL_55:
          if ( v2 <= v22 + v20 + v3 )
            return v1;
        }
      }
LABEL_75:
      if ( v6 )
      {
        do
        {
          std::path::Components::parse_next_component_back((__int64)&v41, (__int64)&v32);
          if ( BYTE8(v41) != 10 )
            break;
          v28 = v2 - v41;
          if ( v2 < (unsigned __int64)v41 )
            goto LABEL_91;
          v33 = v2 - v41;
          v2 -= v41;
        }
        while ( v28 > v20 );
      }
      else
      {
        v6 = v3;
        while ( 2 )
        {
          v23 = v2;
          LOBYTE(v3) = std::path::Components::parse_next_component_back((__int64)&v41, (__int64)&v32);
          if ( BYTE8(v41) == 10 )
          {
            v2 -= v41;
            if ( v23 >= (unsigned __int64)v41 )
            {
              v33 = v23 - v41;
              switch ( v30 )
              {
                case 0:
                  v31 = 2LL;
                  goto LABEL_81;
                case 1:
                  v31 = 0LL;
LABEL_81:
                  if ( v2 > v20 + v31 )
                    continue;
                  return v1;
                default:
                  goto LABEL_75;
              }
            }
LABEL_92:
            core::slice::index::slice_end_index_len_fail(v2, v23, (__int64)&off_58CC0);
          }
          break;
        }
      }
    }
  }
  return v1;
}
// 24086: conditional instruction was optimized away because r14.8!=0
// 2441F: variable 'v30' is possibly undefined
// 58C60: using guessed type char *off_58C60;
// 58CA8: using guessed type char *off_58CA8;
// 58CC0: using guessed type char *off_58CC0;

//----- (0000000000024500) ----------------------------------------------------
char __fastcall std::path::Components::parse_next_component_back(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rsi
  __int64 v6; // r8
  _BYTE *v7; // rcx
  __int64 v8; // rdi
  __int64 v9; // rdx
  unsigned __int64 v10; // r9
  __int64 v11; // r10
  bool v12; // zf
  unsigned __int64 v13; // rsi
  char result; // al

  v4 = std::path::Components::len_before_body((__int64 *)a2);
  v5 = *(_QWORD *)(a2 + 8);
  if ( v4 > v5 )
    core::slice::index::slice_start_index_len_fail(v4, v5, (__int64)&off_58C78);
  v6 = *(_QWORD *)a2;
  v7 = (_BYTE *)(*(_QWORD *)a2 + v4);
  v8 = -1LL;
  v9 = 0LL;
  v10 = v4;
  while ( v5 != v10 )
  {
    v11 = v6 - 1;
    ++v10;
    ++v8;
    v12 = *(_BYTE *)(v6 + v5 - 1) == 47;
    --v6;
    if ( v12 )
    {
      v4 = v5 - v8;
      if ( v5 - v8 > v5 )
        core::slice::index::slice_start_index_len_fail(v5 - v8, v5, (__int64)&off_58C90);
      v7 = (_BYTE *)(v11 + v5 + 1);
      v9 = 1LL;
      break;
    }
  }
  v13 = v5 - v4;
  if ( v13 )
  {
    result = 9;
    if ( v13 == 2 )
    {
      if ( *v7 == 46 )
        result = (v7[1] == 46) ^ 9;
    }
    else if ( v13 == 1 && *v7 == 46 )
    {
      result = 3 * (*(_BYTE *)(a2 + 16) >= 3u) + 7;
    }
  }
  else
  {
    result = 10;
  }
  *(_QWORD *)a1 = v13 + v9;
  *(_BYTE *)(a1 + 8) = result;
  *(_QWORD *)(a1 + 16) = v7;
  *(_QWORD *)(a1 + 24) = v13;
  return result;
}
// 58C78: using guessed type char *off_58C78;
// 58C90: using guessed type char *off_58C90;

//----- (00000000000245F0) ----------------------------------------------------
__int64 __fastcall <std::path::Components as core::iter::traits::iterator::Iterator>::next(__int64 a1, __int64 a2)
{
  unsigned __int8 v2; // r11
  unsigned __int8 v4; // bp
  _BYTE *v5; // rdx
  unsigned __int64 v6; // rcx
  unsigned int v7; // r10d
  char v8; // r12
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rax
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // r8
  _BYTE *v15; // r8
  char v16; // r8
  unsigned __int64 v17; // r9
  __int64 v18; // r8
  char v19; // r15
  unsigned __int64 v20; // r8
  unsigned __int64 v21; // r8
  __int128 v23; // xmm1
  __int64 v24; // [rsp+0h] [rbp-48h]

  v2 = *(_BYTE *)(a2 + 56);
  if ( v2 == 3 || (v4 = *(_BYTE *)(a2 + 57), v4 == 3) || v2 > v4 )
  {
LABEL_51:
    *(_BYTE *)a1 = 10;
    return a1;
  }
  v5 = *(_BYTE **)a2;
  v6 = *(_QWORD *)(a2 + 8);
  v7 = *(unsigned __int8 *)(a2 + 16);
  v8 = *(_BYTE *)(a2 + 58);
  v9 = *(_QWORD *)(a2 + 48);
  v10 = v9 + 1;
  if ( !v9 )
    v10 = 0LL;
  v11 = *(_QWORD *)(a2 + 32);
  v24 = v11 + v10 + 8;
  v12 = v11 + 4;
  v13 = v6;
  while ( 1 )
  {
    if ( !v2 )
    {
      v14 = v12;
      switch ( v7 )
      {
        case 0u:
          goto LABEL_8;
        case 1u:
          v14 = v24;
LABEL_8:
          if ( v14 )
            goto LABEL_46;
          *(_BYTE *)(a2 + 56) = 1;
          v2 = 1;
          goto LABEL_10;
        case 2u:
LABEL_46:
          *(_BYTE *)(a2 + 56) = 1;
          switch ( v7 )
          {
            case 0u:
              v21 = v12;
              goto LABEL_55;
            case 1u:
              v21 = v24;
              goto LABEL_55;
            case 2u:
              v21 = 6LL;
LABEL_55:
              if ( v21 <= v6 )
              {
                switch ( v7 )
                {
                  case 0u:
                    goto LABEL_59;
                  case 1u:
                    v12 = v24;
                    goto LABEL_59;
                  case 2u:
                    v12 = 6LL;
LABEL_59:
                    if ( v6 < v12 )
                      core::slice::index::slice_start_index_len_fail(v12, v6, (__int64)&off_58CF0);
                    *(_QWORD *)a2 = &v5[v12];
                    *(_QWORD *)(a2 + 8) = v6 - v12;
                    *(_BYTE *)a1 = v7;
                    v23 = *(_OWORD *)(a2 + 33);
                    *(_OWORD *)(a1 + 1) = *(_OWORD *)(a2 + 17);
                    *(_OWORD *)(a1 + 17) = v23;
                    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 48);
                    *(_QWORD *)(a1 + 40) = v5;
                    *(_QWORD *)(a1 + 48) = v21;
                    return a1;
                  default:
                    goto LABEL_16;
                }
              }
              core::slice::index::slice_end_index_len_fail(v21, v6, (__int64)&off_58CD8);
            default:
              goto LABEL_16;
          }
          goto LABEL_16;
        default:
          goto LABEL_16;
      }
    }
    if ( v2 != 1 )
    {
      if ( !v13 )
      {
        *(_BYTE *)(a2 + 56) = 3;
        goto LABEL_51;
      }
      v17 = 0LL;
      while ( v5[v17] != 47 )
      {
        if ( v13 == ++v17 )
        {
          v18 = 0LL;
          v17 = v13;
          goto LABEL_31;
        }
      }
      v18 = 1LL;
      if ( !v17 )
      {
        v19 = 10;
        goto LABEL_38;
      }
LABEL_31:
      v19 = 9;
      if ( v17 == 2 )
      {
        if ( *v5 == 46 )
          v19 = (v5[1] == 46) ^ 9;
      }
      else if ( v17 == 1 )
      {
        v19 = 3 * (v7 >= 3) + 7;
        if ( *v5 != 46 )
          v19 = 9;
      }
LABEL_38:
      v20 = v17 + v18;
      v6 = v13 - v20;
      if ( v13 < v20 )
        core::slice::index::slice_start_index_len_fail(v20, v13, (__int64)&off_58D38);
      v15 = &v5[v20];
      *(_QWORD *)a2 = v15;
      *(_QWORD *)(a2 + 8) = v6;
      v2 = 2;
      v13 = v6;
      if ( v19 != 10 )
      {
        *(_BYTE *)a1 = v19;
        *(_QWORD *)(a1 + 8) = v5;
        *(_QWORD *)(a1 + 16) = v17;
        return a1;
      }
      goto LABEL_11;
    }
    *(_BYTE *)(a2 + 56) = 2;
    if ( v8 )
      break;
    v2 = 2;
    if ( v7 >= 3 )
    {
LABEL_16:
      if ( v7 != 5 )
      {
        if ( v7 != 6 )
        {
          *(_BYTE *)a1 = 6;
          return a1;
        }
        if ( v13 )
        {
          v16 = *v5;
          if ( v13 == 1 || v16 != 46 )
          {
            if ( v13 == 1 && v16 == 46 )
            {
LABEL_44:
              if ( !v6 )
                core::slice::index::slice_start_index_len_fail(1LL, 0LL, (__int64)&off_58D08);
              *(_QWORD *)a2 = v5 + 1;
              *(_QWORD *)(a2 + 8) = v6 - 1;
              *(_BYTE *)a1 = 7;
              return a1;
            }
          }
          else if ( v5[1] == 47 )
          {
            goto LABEL_44;
          }
        }
        else
        {
          v13 = 0LL;
        }
      }
    }
LABEL_10:
    v15 = v5;
LABEL_11:
    v5 = v15;
    if ( v2 > v4 )
      goto LABEL_51;
  }
  if ( !v6 )
    core::slice::index::slice_start_index_len_fail(1LL, 0LL, (__int64)&off_58D20);
  *(_QWORD *)a2 = v5 + 1;
  *(_QWORD *)(a2 + 8) = v6 - 1;
  *(_BYTE *)a1 = 6;
  return a1;
}
// 24758: conditional instruction was optimized away because rsi.8!=0
// 58CD8: using guessed type char *off_58CD8;
// 58CF0: using guessed type char *off_58CF0;
// 58D08: using guessed type char *off_58D08;
// 58D20: using guessed type char *off_58D20;
// 58D38: using guessed type char *off_58D38;

//----- (0000000000024950) ----------------------------------------------------
_BYTE *__fastcall <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(
        __int64 a1,
        __int64 a2)
{
  unsigned __int8 v2; // r13
  _BYTE *result; // rax
  unsigned __int64 v5; // r15
  unsigned __int64 *v6; // rbx
  char v7; // dl
  __int64 v8; // rdi
  char v9; // cl
  bool v10; // cf
  __int64 v11; // r15
  __int64 v12; // rcx
  __int64 v13; // r15
  __int64 v14; // rsi
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int128 v17; // xmm1
  unsigned __int8 v18; // [rsp+Fh] [rbp-B9h]
  char *v20; // [rsp+18h] [rbp-B0h]
  __int128 v21; // [rsp+20h] [rbp-A8h]
  __int128 v22; // [rsp+30h] [rbp-98h]
  _BYTE v23[23]; // [rsp+40h] [rbp-88h]
  unsigned __int64 v24; // [rsp+58h] [rbp-70h] BYREF
  char v25; // [rsp+60h] [rbp-68h]
  __int128 v26; // [rsp+61h] [rbp-67h]
  __int128 v27; // [rsp+71h] [rbp-57h]
  _OWORD v28[4]; // [rsp+81h] [rbp-47h]

  v2 = *(_BYTE *)(a2 + 56);
  if ( v2 == 3 || (LOBYTE(result) = *(_BYTE *)(a2 + 57), (_BYTE)result == 3) || v2 > (unsigned __int8)result )
  {
LABEL_12:
    result = (_BYTE *)a1;
LABEL_13:
    *result = 10;
  }
  else
  {
    v18 = *(_BYTE *)(a2 + 16);
    v20 = *(char **)a2;
    v5 = *(_QWORD *)(a2 + 8);
    if ( !*(_BYTE *)(a2 + 58) )
    {
      v6 = *(unsigned __int64 **)(a2 + 8);
      while ( 1 )
      {
        if ( (_BYTE)result == 1 )
        {
          *(_BYTE *)(a2 + 57) = 0;
          LOBYTE(result) = 0;
          if ( v18 >= 3u )
          {
LABEL_24:
            if ( v18 != 5 )
            {
              if ( v18 != 6 )
                goto LABEL_41;
              if ( v6 )
              {
                v9 = *v20;
                if ( v6 == (unsigned __int64 *)((char *)&dword_0 + 1) || v9 != 46 )
                {
                  LOBYTE(result) = 0;
                  if ( v6 == (unsigned __int64 *)((char *)&dword_0 + 1) && v9 == 46 )
                  {
LABEL_34:
                    v10 = v5 == 0;
                    v11 = v5 - 1;
                    if ( v10 )
                      core::slice::index::slice_end_index_len_fail(v11, 0LL, (__int64)&off_58D50);
                    *(_QWORD *)(a2 + 8) = v11;
                    result = (_BYTE *)a1;
                    *(_BYTE *)a1 = 7;
                    return result;
                  }
                }
                else
                {
                  if ( v20[1] == 47 )
                    goto LABEL_34;
                  LOBYTE(result) = 0;
                }
              }
              else
              {
                v6 = 0LL;
                LOBYTE(result) = 0;
              }
            }
          }
        }
        else
        {
          if ( (unsigned __int8)result != 2 )
            goto LABEL_37;
          if ( (unsigned __int64)v6 <= std::path::Components::len_before_body((__int64 *)a2) )
          {
            *(_BYTE *)(a2 + 57) = 1;
            LOBYTE(result) = 1;
          }
          else
          {
            std::path::Components::parse_next_component_back((__int64)&v24, a2);
            v7 = v25;
            v21 = v26;
            v22 = v27;
            *(_OWORD *)v23 = v28[0];
            *(_QWORD *)&v23[15] = *(_QWORD *)((char *)v28 + 15);
            v5 = (unsigned __int64)v6 - v24;
            if ( (unsigned __int64)v6 < v24 )
            {
              v8 = (__int64)v6 - v24;
              v5 = (unsigned __int64)v6;
LABEL_50:
              core::slice::index::slice_end_index_len_fail(v8, v5, (__int64)&off_58D80);
            }
            *(_QWORD *)(a2 + 8) = v5;
            if ( v7 != 10 )
            {
LABEL_42:
              result = (_BYTE *)a1;
              *(_BYTE *)a1 = v7;
              *(_OWORD *)(a1 + 1) = v21;
              *(_OWORD *)(a1 + 17) = v22;
              *(_OWORD *)(a1 + 33) = *(_OWORD *)v23;
              *(_QWORD *)(a1 + 48) = *(_QWORD *)&v23[15];
              return result;
            }
            LOBYTE(result) = 2;
            v6 = (unsigned __int64 *)v5;
          }
        }
        if ( v2 > (unsigned __int8)result )
          goto LABEL_12;
      }
    }
    v6 = &v24;
    while ( (_BYTE)result == 2 )
    {
      if ( v5 <= std::path::Components::len_before_body((__int64 *)a2) )
      {
        *(_BYTE *)(a2 + 57) = 1;
        LOBYTE(result) = 1;
        if ( v2 > 1u )
          goto LABEL_12;
      }
      else
      {
        std::path::Components::parse_next_component_back((__int64)&v24, a2);
        v7 = v25;
        v21 = v26;
        v22 = v27;
        *(_OWORD *)v23 = v28[0];
        *(_QWORD *)&v23[15] = *(_QWORD *)((char *)v28 + 15);
        v8 = v5 - v24;
        if ( v5 < v24 )
          goto LABEL_50;
        *(_QWORD *)(a2 + 8) = v8;
        if ( v7 != 10 )
          goto LABEL_42;
        LOBYTE(result) = 2;
        v5 = v8;
        if ( v2 > 2u )
          goto LABEL_12;
      }
    }
    if ( !(_BYTE)result )
    {
LABEL_37:
      result = (_BYTE *)a1;
      switch ( v18 )
      {
        case 0u:
          v12 = *(_QWORD *)(a2 + 32) + 4LL;
          goto LABEL_46;
        case 1u:
          v14 = *(_QWORD *)(a2 + 32);
          v15 = *(_QWORD *)(a2 + 48);
          v16 = v15 + 1;
          if ( !v15 )
            v16 = 0LL;
          v12 = v14 + v16 + 8;
LABEL_46:
          if ( v12 )
            goto LABEL_47;
          *(_BYTE *)(a2 + 57) = 3;
          goto LABEL_13;
        case 2u:
LABEL_47:
          *(_BYTE *)(a2 + 57) = 3;
          *(_BYTE *)a1 = v18;
          v17 = *(_OWORD *)(a2 + 33);
          *(_OWORD *)(a1 + 1) = *(_OWORD *)(a2 + 17);
          *(_OWORD *)(a1 + 17) = v17;
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 48);
          *(_QWORD *)(a1 + 40) = v20;
          *(_QWORD *)(a1 + 48) = v5;
          return result;
        default:
          goto LABEL_24;
      }
    }
    *(_BYTE *)(a2 + 57) = 0;
    v10 = v5 == 0;
    v13 = v5 - 1;
    if ( v10 )
      core::slice::index::slice_end_index_len_fail(v13, 0LL, (__int64)&off_58D68);
    *(_QWORD *)(a2 + 8) = v13;
LABEL_41:
    result = (_BYTE *)a1;
    *(_BYTE *)a1 = 6;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 58D50: using guessed type char *off_58D50;
// 58D68: using guessed type char *off_58D68;
// 58D80: using guessed type char *off_58D80;
// 24950: using guessed type _OWORD anonymous_1[4];

//----- (0000000000024CB0) ----------------------------------------------------
bool __fastcall <std::path::Components as core::cmp::PartialEq>::eq(__int64 a1, __int64 a2)
{
  const void *v2; // r14
  size_t v3; // r15
  const void *v4; // rbx
  __int64 v5; // r12
  char v6; // al
  __int128 v7; // xmm0
  char v8; // cl
  char v9; // r8
  char v10; // di
  char v11; // dl
  __int128 v12; // xmm0
  char v13; // r9
  __int16 v14; // si
  __int64 v16[2]; // [rsp+0h] [rbp-1F8h] BYREF
  char v17; // [rsp+10h] [rbp-1E8h]
  __int128 v18; // [rsp+11h] [rbp-1E7h]
  char v19[23]; // [rsp+21h] [rbp-1D7h]
  char v20; // [rsp+38h] [rbp-1C0h]
  char v21; // [rsp+39h] [rbp-1BFh]
  char v22; // [rsp+3Ah] [rbp-1BEh]
  __int64 v23[2]; // [rsp+40h] [rbp-1B8h] BYREF
  char v24; // [rsp+50h] [rbp-1A8h]
  __int128 v25; // [rsp+51h] [rbp-1A7h]
  char v26[23]; // [rsp+61h] [rbp-197h]
  __int16 v27; // [rsp+78h] [rbp-180h]
  char v28; // [rsp+7Ah] [rbp-17Eh]
  __int128 v29; // [rsp+80h] [rbp-178h]
  _BYTE v30[23]; // [rsp+90h] [rbp-168h]
  __int128 v31; // [rsp+B0h] [rbp-148h]
  _BYTE v32[23]; // [rsp+C0h] [rbp-138h]
  __int128 v33[3]; // [rsp+E0h] [rbp-118h] BYREF
  __int64 v34; // [rsp+110h] [rbp-E8h]
  __int128 v35[3]; // [rsp+118h] [rbp-E0h] BYREF
  __int64 v36; // [rsp+148h] [rbp-B0h]
  __int128 v37[3]; // [rsp+150h] [rbp-A8h] BYREF
  __int64 v38; // [rsp+180h] [rbp-78h]
  _OWORD v39[3]; // [rsp+188h] [rbp-70h] BYREF
  __int64 v40; // [rsp+1B8h] [rbp-40h]

  v2 = *(const void **)a1;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(const void **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  if ( v3 == v5
    && *(_BYTE *)(a1 + 56) == *(_BYTE *)(a2 + 56)
    && *(_BYTE *)(a1 + 57) == 2
    && *(_BYTE *)(a2 + 57) == 2
    && *(_BYTE *)(a1 + 16) < 3u == *(_BYTE *)(a2 + 16) < 3u
    && !bcmp(*(const void **)a1, *(const void **)a2, v3) )
  {
    return 1;
  }
  v6 = *(_BYTE *)(a1 + 16);
  if ( v6 != 6 )
  {
    *(_QWORD *)&v30[15] = *(_QWORD *)(a1 + 48);
    v7 = *(_OWORD *)(a1 + 17);
    *(_OWORD *)v30 = *(_OWORD *)(a1 + 33);
    v29 = v7;
  }
  v8 = *(_BYTE *)(a1 + 58);
  v9 = *(_BYTE *)(a1 + 56);
  v10 = *(_BYTE *)(a1 + 57);
  v11 = *(_BYTE *)(a2 + 16);
  if ( v11 != 6 )
  {
    *(_QWORD *)&v32[15] = *(_QWORD *)(a2 + 48);
    v12 = *(_OWORD *)(a2 + 17);
    *(_OWORD *)v32 = *(_OWORD *)(a2 + 33);
    v31 = v12;
  }
  v13 = *(_BYTE *)(a2 + 58);
  v14 = *(_WORD *)(a2 + 56);
  v16[0] = (__int64)v2;
  v16[1] = v3;
  v17 = v6;
  v18 = v29;
  *(_OWORD *)v19 = *(_OWORD *)v30;
  *(_QWORD *)&v19[15] = *(_QWORD *)&v30[15];
  v20 = v9;
  v21 = v10;
  v22 = v8;
  v23[0] = (__int64)v4;
  v23[1] = v5;
  v24 = v11;
  v25 = v31;
  *(_OWORD *)v26 = *(_OWORD *)v32;
  *(_QWORD *)&v26[15] = *(_QWORD *)&v32[15];
  v27 = v14;
  v28 = v13;
  <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(
    (__int64)v33,
    (__int64)v16);
  if ( LOBYTE(v33[0]) == 10 )
  {
LABEL_15:
    <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(
      (__int64)v37,
      (__int64)v23);
    return LOBYTE(v37[0]) == 10;
  }
  else
  {
    while ( 1 )
    {
      <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(
        (__int64)v35,
        (__int64)v23);
      if ( LOBYTE(v35[0]) == 10 )
        return 0;
      v38 = v34;
      v37[2] = v33[2];
      v37[1] = v33[1];
      v37[0] = v33[0];
      v40 = v36;
      v39[2] = v35[2];
      v39[1] = v35[1];
      v39[0] = v35[0];
      if ( !<std::path::Component as core::cmp::PartialEq>::eq((__int64)v37, (__int64)v39) )
        return 0;
      <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(
        (__int64)v33,
        (__int64)v16);
      if ( LOBYTE(v33[0]) == 10 )
        goto LABEL_15;
    }
  }
}
// 24CB0: using guessed type _OWORD var_70[3];

//----- (0000000000024F50) ----------------------------------------------------
void *__fastcall std::path::PathBuf::push(__int64 *a1, __int64 *a2)
{
  size_t v3; // r12
  __int64 v4; // r13
  bool v5; // cl
  _BYTE *v6; // rbx
  __int64 v7; // rax
  void *result; // rax
  __int64 v9; // rsi

  v3 = a2[2];
  v4 = a1[2];
  if ( v4 )
  {
    v5 = *(_BYTE *)(v4 + a1[1] - 1) == 47;
    v6 = (_BYTE *)a2[1];
    if ( !v3 )
      goto LABEL_7;
  }
  else
  {
    v5 = 1;
    v6 = (_BYTE *)a2[1];
    if ( !v3 )
      goto LABEL_7;
  }
  if ( *v6 == 47 )
  {
    v4 = 0LL;
    goto LABEL_11;
  }
LABEL_7:
  v7 = *a1;
  if ( v5 )
    goto LABEL_12;
  if ( v7 == v4 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, a1[2], 1LL);
    v4 = a1[2];
  }
  *(_BYTE *)(a1[1] + v4++) = 47;
LABEL_11:
  a1[2] = v4;
  v7 = *a1;
LABEL_12:
  if ( v7 - v4 < v3 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, v4, v3);
    v4 = a1[2];
  }
  result = memcpy((void *)(v4 + a1[1]), v6, v3);
  a1[2] = v3 + v4;
  v9 = *a2;
  if ( *a2 )
    return (void *)_rust_dealloc(v6, v9, 1LL);
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (0000000000025050) ----------------------------------------------------
__int64 __fastcall std::path::PathBuf::_set_extension(__int64 *a1, void *a2, size_t a3)
{
  _BYTE *v6; // r15
  unsigned __int64 v7; // r12
  bool v8; // al
  unsigned int v9; // r13d
  _WORD *v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rdi
  _WORD *v13; // rsi
  __int64 v14; // rsi
  unsigned __int64 v16; // rsi
  size_t v17; // rbp
  __int64 v18; // rax
  bool v19; // cf
  __int64 v20; // rbp
  __int64 v21; // rax
  __int64 v22; // r12
  void *src; // [rsp+8h] [rbp-B0h]
  __int64 v25; // [rsp+10h] [rbp-A8h] BYREF
  _WORD *v26; // [rsp+18h] [rbp-A0h]
  __int64 v27; // [rsp+20h] [rbp-98h]
  _BYTE *v28; // [rsp+48h] [rbp-70h] BYREF
  unsigned __int64 v29; // [rsp+50h] [rbp-68h]
  __int64 v30; // [rsp+58h] [rbp-60h]
  __int16 v31; // [rsp+80h] [rbp-38h]
  bool v32; // [rsp+82h] [rbp-36h]

  v6 = (_BYTE *)a1[1];
  v7 = a1[2];
  if ( v7 )
    v8 = *v6 == 47;
  else
    v8 = 0;
  v28 = (_BYTE *)a1[1];
  v29 = v7;
  LOBYTE(v30) = 6;
  v32 = v8;
  v31 = 512;
  <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(
    (__int64)&v25,
    (__int64)&v28);
  v9 = 0;
  v10 = v26;
  if ( (_BYTE)v25 == 9 )
  {
    v11 = v27;
    if ( v27 == 2 && *v26 == 11822 )
    {
      v12 = 2LL;
      v13 = 0LL;
      if ( v26 )
        v13 = v26;
      if ( !v13 )
        return 0;
    }
    else
    {
      v14 = v27;
      do
      {
        v12 = (__int64)v26 + v14;
        if ( (_WORD *)((char *)v26 + v14) == v26 )
        {
          v13 = v26;
          v10 = 0LL;
          if ( !v26 )
            return 0;
          goto LABEL_17;
        }
        v12 = v14 - 1;
      }
      while ( *((_BYTE *)v26 + --v14) != 46 );
      if ( v12 )
      {
        v11 = ~v12 + v27;
        v13 = (_WORD *)((char *)v26 + v12 + 1);
      }
      else
      {
        v13 = 0LL;
        v12 = v27;
      }
      v10 = v26;
      if ( v26 )
        v13 = v26;
      if ( !v13 )
        return 0;
    }
LABEL_17:
    if ( !v10 )
      v12 = v11;
    v16 = (char *)v13 + v12 - v6;
    if ( v7 >= v16 )
    {
      a1[2] = v16;
      v7 = v16;
    }
    LOBYTE(v9) = 1;
    if ( a3 )
    {
      src = a2;
      v17 = a3 + 1;
      v18 = *a1;
      if ( *a1 - v7 < a3 + 1 )
      {
        v19 = __CFADD__(v7, v17);
        v20 = v7 + v17;
        if ( !v19 )
        {
          if ( v18 )
          {
            v28 = v6;
            v30 = v18;
            v21 = 1LL;
          }
          else
          {
            v21 = 0LL;
          }
          v29 = v21;
          alloc::raw_vec::finish_grow(&v25, v20 >= 0, v20, &v28);
          if ( !v25 )
          {
            v6 = v26;
            a1[1] = (__int64)v26;
            *a1 = v20;
            if ( v7 != v20 )
              goto LABEL_28;
            goto LABEL_27;
          }
          if ( v26 )
            alloc::alloc::handle_alloc_error((__int64)v26, v27);
        }
        alloc::raw_vec::capacity_overflow();
      }
      if ( v7 != v18 )
      {
LABEL_28:
        v6[v7] = 46;
        v22 = v7 + 1;
        a1[2] = v22;
        if ( *a1 - v22 < a3 )
        {
          alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, v22, a3);
          v22 = a1[2];
        }
        memcpy((void *)(v22 + a1[1]), src, a3);
        a1[2] = a3 + v22;
        return v9;
      }
LABEL_27:
      alloc::raw_vec::RawVec<T,A>::reserve_for_push(a1, v7);
      v6 = (_BYTE *)a1[1];
      v7 = a1[2];
      goto LABEL_28;
    }
  }
  return v9;
}

//----- (00000000000252B0) ----------------------------------------------------
_BYTE *__fastcall std::path::Path::_strip_prefix(__int128 a1, _BYTE *a2, __int64 a3)
{
  char v3; // r8
  bool v4; // al
  char *v5; // r10
  char v6; // r9
  char v7; // cl
  char v8; // dl
  __int128 v9; // xmm0
  char *v10; // rbp
  char v11; // r15
  char v12; // r12
  char v14; // [rsp+Bh] [rbp-19Dh]
  int v15; // [rsp+14h] [rbp-194h]
  char v16; // [rsp+18h] [rbp-190h]
  char v17; // [rsp+1Ch] [rbp-18Ch]
  __int128 v18; // [rsp+20h] [rbp-188h]
  _BYTE v19[23]; // [rsp+30h] [rbp-178h]
  __int64 v20; // [rsp+6Fh] [rbp-139h]
  __int128 v21; // [rsp+80h] [rbp-128h] BYREF
  char v22; // [rsp+90h] [rbp-118h]
  char v23; // [rsp+91h] [rbp-117h] BYREF
  char v24; // [rsp+B8h] [rbp-F0h]
  char v25; // [rsp+B9h] [rbp-EFh]
  char v26; // [rsp+BAh] [rbp-EEh]
  __int128 v27; // [rsp+C0h] [rbp-E8h] BYREF
  _BYTE v28[40]; // [rsp+D0h] [rbp-D8h]
  char v29[3]; // [rsp+F8h] [rbp-B0h] BYREF
  int v30; // [rsp+FBh] [rbp-ADh]
  char v31; // [rsp+FFh] [rbp-A9h]
  __int64 v32[2]; // [rsp+138h] [rbp-70h] BYREF
  char v33; // [rsp+148h] [rbp-60h]
  __int16 v34; // [rsp+170h] [rbp-38h]
  bool v35; // [rsp+172h] [rbp-36h]

  if ( !*((_QWORD *)&a1 + 1) )
  {
    v3 = 0;
    if ( a3 )
      goto LABEL_3;
LABEL_5:
    v4 = 0;
    goto LABEL_6;
  }
  v3 = *(_BYTE *)a1 == 47;
  if ( !a3 )
    goto LABEL_5;
LABEL_3:
  v4 = *a2 == 47;
LABEL_6:
  v32[0] = (__int64)a2;
  v32[1] = a3;
  v33 = 6;
  v35 = v4;
  v34 = 512;
  v5 = &v23;
  v6 = 6;
  v7 = 2;
  v8 = 0;
  while ( 1 )
  {
    v21 = a1;
    v14 = v6;
    v22 = v6;
    *(_QWORD *)(v5 + 31) = *(_QWORD *)&v28[15];
    v9 = v27;
    *((_OWORD *)v5 + 1) = *(_OWORD *)v28;
    v10 = v5;
    *(_OWORD *)v5 = v9;
    v11 = v3;
    v26 = v3;
    v17 = v8;
    v24 = v8;
    v12 = v7;
    v25 = v7;
    <std::path::Components as core::iter::traits::iterator::Iterator>::next((__int64)&v27, (__int64)&v21);
    <std::path::Components as core::iter::traits::iterator::Iterator>::next((__int64)v29, (__int64)v32);
    if ( (_BYTE)v27 == 10 )
      break;
    if ( v29[0] == 10 )
      goto LABEL_14;
    if ( !<std::path::Component as core::cmp::PartialEq>::eq((__int64)&v27, (__int64)v29) )
      return 0LL;
    a1 = v21;
    v6 = v22;
    v5 = v10;
    v18 = *(_OWORD *)v10;
    *(_OWORD *)v19 = *((_OWORD *)v10 + 1);
    *(_QWORD *)&v19[15] = *(_QWORD *)(v10 + 31);
    v8 = v24;
    v7 = v25;
    v3 = v26;
    v16 = v10[46];
    v15 = *(_DWORD *)(v10 + 42);
    if ( v22 != 6 )
    {
      *(_QWORD *)&v28[15] = *(_QWORD *)(v10 + 31);
      *(_OWORD *)v28 = *(_OWORD *)v19;
      v27 = v18;
    }
  }
  if ( v29[0] != 10 )
    return 0LL;
LABEL_14:
  v20 = *(_QWORD *)&v19[15];
  LOBYTE(v20) = v19[15];
  if ( v11 == 2 )
    return 0LL;
  *(_QWORD *)&v28[32] = v20;
  *(_OWORD *)&v28[17] = *(_OWORD *)v19;
  *(_OWORD *)&v28[1] = v18;
  v30 = v15;
  v31 = v16;
  v27 = a1;
  v28[0] = v14;
  v29[0] = v17;
  v29[1] = v12;
  v29[2] = v11;
  return std::path::Components::as_path((__int64)&v27);
}
// 2549D: variable 'v19' is possibly undefined
// 254F8: variable 'v18' is possibly undefined
// 25504: variable 'v15' is possibly undefined
// 25510: variable 'v16' is possibly undefined

//----- (0000000000025570) ----------------------------------------------------
void __fastcall __noreturn std::process::exit(int a1)
{
  std::rt::cleanup();
  std::sys::pal::unix::os::exit(a1);
}

//----- (0000000000025580) ----------------------------------------------------
__int64 __fastcall std::sys_common::backtrace::print(__int64 a1, __int64 a2, char a3)
{
  bool v3; // bl
  __int64 (__fastcall *v4)(__int64, __int64 *); // rax
  __int64 result; // rax
  __int64 v6; // rbx
  char v7; // bp
  char v8; // bp
  bool is_zero_slow_path; // al
  __int64 v10; // rbx
  bool v11; // cl
  char v12; // [rsp+7h] [rbp-61h] BYREF
  __int64 v13[2]; // [rsp+8h] [rbp-60h] BYREF
  __int64 v14[10]; // [rsp+18h] [rbp-50h] BYREF

  if ( _InterlockedCompareExchange(&std::sys_common::backtrace::lock::LOCK, 1, 0) )
  {
    v7 = a3;
    std::sys::sync::mutex::futex::Mutex::lock_contended(&std::sys_common::backtrace::lock::LOCK);
    a3 = v7;
  }
  if ( 2 * std::panicking::panic_count::GLOBAL_PANIC_COUNT )
  {
    v8 = a3;
    is_zero_slow_path = std::panicking::panic_count::is_zero_slow_path();
    a3 = v8;
    v3 = !is_zero_slow_path;
  }
  else
  {
    v3 = 0;
  }
  v4 = *(__int64 (__fastcall **)(__int64, __int64 *))(a2 + 72);
  v12 = a3;
  v13[0] = (__int64)&v12;
  v13[1] = (__int64)<std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt;
  v14[0] = (__int64)&off_589A8;
  v14[1] = 1LL;
  v14[4] = 0LL;
  v14[2] = (__int64)v13;
  v14[3] = 1LL;
  result = v4(a1, v14);
  if ( !v3 && (std::panicking::panic_count::GLOBAL_PANIC_COUNT & 0x7FFFFFFFFFFFFFFFLL) != 0 )
  {
    v10 = result;
    v11 = std::panicking::panic_count::is_zero_slow_path();
    result = v10;
    if ( !v11 )
      byte_5B0F0 = 1;
  }
  if ( _InterlockedExchange(&std::sys_common::backtrace::lock::LOCK, 0) == 2 )
  {
    v6 = result;
    syscall(202LL, &std::sys_common::backtrace::lock::LOCK, 129LL, 1LL);
    return v6;
  }
  return result;
}
// 589A8: using guessed type char *off_589A8;
// 5B0EC: using guessed type int std::sys_common::backtrace::lock::LOCK;
// 5B0F0: using guessed type char byte_5B0F0;
// 5B120: using guessed type signed __int64 std::panicking::panic_count::GLOBAL_PANIC_COUNT;

//----- (00000000000256F0) ----------------------------------------------------
char __fastcall <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt(char *a1, __int64 a2)
{
  char v2; // bp
  size_t v3; // r15
  char v5; // [rsp+Ch] [rbp-DCh] BYREF
  char v6; // [rsp+Dh] [rbp-DBh] BYREF
  char v7; // [rsp+Eh] [rbp-DAh] BYREF
  bool v8; // [rsp+Fh] [rbp-D9h] BYREF
  size_t v9; // [rsp+10h] [rbp-D8h] BYREF
  __int128 v10; // [rsp+18h] [rbp-D0h]
  char v11; // [rsp+28h] [rbp-C0h]
  __int64 v12; // [rsp+30h] [rbp-B8h] BYREF
  __int64 v13; // [rsp+38h] [rbp-B0h] BYREF
  __int64 v14[2]; // [rsp+40h] [rbp-A8h] BYREF
  char *v15; // [rsp+50h] [rbp-98h] BYREF
  __int128 v16; // [rsp+58h] [rbp-90h] BYREF
  __int64 *v17; // [rsp+68h] [rbp-80h]
  char *v18; // [rsp+70h] [rbp-78h]
  __int64 *v19; // [rsp+78h] [rbp-70h]
  char *v20; // [rsp+80h] [rbp-68h]
  __int64 v21[4]; // [rsp+88h] [rbp-60h] BYREF
  char v22; // [rsp+A8h] [rbp-40h]
  __int128 v23; // [rsp+B0h] [rbp-38h]

  v2 = *a1;
  v5 = *a1;
  std::env::current_dir((size_t *)&v15);
  v3 = (size_t)v15;
  if ( v15 == (char *)0x8000000000000000LL )
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v16);
  else
    v23 = v16;
  v11 = v2;
  v9 = v3;
  v10 = v23;
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 40) + 24LL))(
         *(_QWORD *)(a2 + 32),
         aStackBacktrace,
         17LL) )
  {
LABEL_7:
    if ( 2 * v3 )
      _rust_dealloc(v10, v3, 1LL);
    return 1;
  }
  v21[0] = a2;
  v21[3] = 0LL;
  v22 = v2;
  v21[1] = (__int64)&v9;
  v21[2] = (__int64)&off_58E10;
  v12 = 0LL;
  v6 = 0;
  v13 = 0LL;
  v7 = 1;
  v8 = v2 != 0;
  v15 = &v5;
  *(_QWORD *)&v16 = &v12;
  *((_QWORD *)&v16 + 1) = &v8;
  v17 = &v13;
  v18 = &v7;
  v19 = v21;
  v20 = &v6;
  v14[0] = (__int64)&v15;
  v14[1] = (__int64)&off_58E38;
  Unwind_Backtrace((_Unwind_Trace_Fn)std::backtrace_rs::backtrace::libunwind::trace::trace_fn, v14);
  if ( v6
    || !v5
    && (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 40) + 24LL))(
         *(_QWORD *)(a2 + 32),
         aNoteSomeDetail,
         88LL) )
  {
    v3 = v9;
    goto LABEL_7;
  }
  if ( 2 * v9 )
    _rust_dealloc(v10, v9, 1LL);
  return 0;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 58E10: using guessed type __int64 (__fastcall *off_58E10)();
// 58E38: using guessed type __int64 (__fastcall *off_58E38)();

//----- (0000000000025900) ----------------------------------------------------
char __fastcall std::sys_common::backtrace::_print_fmt::{{closure}}(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx

  v3 = 0LL;
  if ( *(_QWORD *)a1 != 0x8000000000000000LL )
    v3 = a1;
  return std::sys_common::backtrace::output_filename(a2, a3, *(_DWORD *)(a1 + 24), v3);
}

//----- (0000000000025930) ----------------------------------------------------
bool __fastcall std::sys_common::backtrace::_print_fmt::{{closure}}(__int64 a1, __int64 a2, double a3, __m128i a4)
{
  _BYTE *v5; // rax
  _BYTE *v7; // r13
  __int64 v8; // r12
  char *v9; // r15
  int v10; // r9d
  __int64 v11; // rsi
  __int64 v12; // rax
  int v13; // [rsp+8h] [rbp-B0h]
  char v14; // [rsp+17h] [rbp-A1h] BYREF
  __int64 v15[2]; // [rsp+18h] [rbp-A0h] BYREF
  __int128 v16; // [rsp+28h] [rbp-90h] BYREF
  _BYTE *v17; // [rsp+38h] [rbp-80h]
  __m128 v18; // [rsp+40h] [rbp-78h]
  __int64 v19; // [rsp+50h] [rbp-68h]
  char *v20; // [rsp+58h] [rbp-60h]
  __int64 v21; // [rsp+60h] [rbp-58h]
  __int64 v22[8]; // [rsp+78h] [rbp-40h] BYREF

  v5 = *(_BYTE **)a1;
  if ( !**(_BYTE **)a1 && **(_QWORD **)(a1 + 8) > 0x64uLL )
    return 0;
  v14 = 0;
  v7 = *(_BYTE **)(a1 + 16);
  v8 = *(_QWORD *)(a1 + 40);
  v9 = *(char **)(a1 + 48);
  *(_QWORD *)&v16 = &v14;
  *((_QWORD *)&v16 + 1) = v5;
  v17 = v7;
  v18 = *(__m128 *)(a1 + 24);
  v19 = v8;
  v20 = v9;
  v21 = a2;
  std::backtrace_rs::symbolize::gimli::resolve(1LL, a2, (__int64)&v16, (__int64)&off_59160, v18, a4);
  if ( !v14 && *v7 )
  {
    v15[0] = v8;
    v15[1] = 0LL;
    v11 = *(_QWORD *)(a2 + 8);
    if ( !*(_QWORD *)a2 )
    {
      LODWORD(v12) = Unwind_GetIP(*(struct _Unwind_Context **)(a2 + 8));
      v11 = v12;
    }
    *(_QWORD *)&v16 = 3LL;
    v22[0] = 2LL;
    *v9 = std::backtrace_rs::print::BacktraceFrameFmt::print_raw_with_column(
            (__int64)v15,
            v11,
            &v16,
            v22,
            0,
            v10,
            0,
            v13);
    ++*(_QWORD *)(v15[0] + 24);
  }
  ++**(_QWORD **)(a1 + 8);
  return *v9 == 0;
}
// 259E5: variable 'v12' is possibly undefined
// 25A13: variable 'v10' is possibly undefined
// 25A13: variable 'v13' is possibly undefined
// 59160: using guessed type __int64 (__fastcall *off_59160)();
// 25930: using guessed type __int64 var_40[8];

//----- (0000000000025A60) ----------------------------------------------------
_BYTE *__fastcall std::sys_common::backtrace::_print_fmt::{{closure}}::{{closure}}(__int64 a1, __int64 a2)
{
  _BYTE *result; // rax
  _QWORD *v4; // r15
  __int64 v5; // rax
  _BYTE *v6; // r12
  __int64 v7; // rcx
  const char *v8; // rsi
  _QWORD *v9; // rax
  __int64 v10; // r15
  __int64 v11; // rax
  unsigned int v12; // r8d
  __int64 (__fastcall *v13)(unsigned __int64 *, __int64); // rax
  __int64 v14; // rcx
  int v15; // eax
  char *v16; // r15
  unsigned __int64 v17; // r12
  _BYTE *v18; // r13
  const char *v19; // [rsp+0h] [rbp-A8h] BYREF
  _BOOL8 v20; // [rsp+8h] [rbp-A0h]
  _QWORD *v21; // [rsp+10h] [rbp-98h] BYREF
  __int64 (__fastcall *v22)(unsigned __int64 *, __int64); // [rsp+18h] [rbp-90h]
  __int64 *v23; // [rsp+20h] [rbp-88h]
  char (__fastcall *v24)(__int64, __int64); // [rsp+28h] [rbp-80h]
  __int128 v25; // [rsp+30h] [rbp-78h] BYREF
  __int64 *v26; // [rsp+40h] [rbp-68h]
  __int64 v27; // [rsp+48h] [rbp-60h]
  void *s1; // [rsp+50h] [rbp-58h]
  unsigned __int64 v29; // [rsp+58h] [rbp-50h]
  __int64 v30; // [rsp+70h] [rbp-38h]
  unsigned __int64 v31; // [rsp+78h] [rbp-30h]

  **(_BYTE **)a1 = 1;
  if ( **(_BYTE **)(a1 + 8) )
    goto LABEL_2;
  std::backtrace_rs::symbolize::Symbol::name((__int64)&v25, a2);
  if ( (_QWORD)v25 == 2LL )
  {
    core::str::converts::from_utf8((__int64)&v21, v30, v31);
    if ( v21 )
      goto LABEL_2;
    v16 = (char *)v22;
    v17 = (unsigned __int64)v23;
    v18 = *(_BYTE **)(a1 + 16);
    if ( !*v18 )
      goto LABEL_30;
  }
  else
  {
    if ( (_DWORD)v25 == 3 )
      goto LABEL_2;
    v16 = (char *)s1;
    if ( !s1 )
      goto LABEL_2;
    v17 = v29;
    v18 = *(_BYTE **)(a1 + 16);
    if ( !*v18 )
      goto LABEL_30;
  }
  result = (_BYTE *)<&str as core::str::pattern::Pattern>::is_contained_in(aRustBeginShort, 0x1CuLL, v16, v17);
  if ( (_BYTE)result )
  {
    *v18 = 0;
    return result;
  }
LABEL_30:
  result = (_BYTE *)<&str as core::str::pattern::Pattern>::is_contained_in(aRustEndShortBa, 0x1AuLL, v16, v17);
  if ( (_BYTE)result )
  {
    *v18 = 1;
    return result;
  }
  if ( !*v18 )
    ++**(_QWORD **)(a1 + 24);
LABEL_2:
  result = *(_BYTE **)(a1 + 16);
  if ( *result )
  {
    v4 = *(_QWORD **)(a1 + 24);
    v5 = *v4;
    if ( *v4 )
    {
      v6 = *(_BYTE **)(a1 + 32);
      if ( !*v6 )
      {
        v7 = **(_QWORD **)(a1 + 40);
        v8 = aRustc9b00956e5;
        if ( v5 != 1 )
          v8 = (const char *)&unk_49CB4;
        v19 = v8;
        v20 = v5 != 1;
        v21 = v4;
        v22 = core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
        v23 = (__int64 *)&v19;
        v24 = <&T as core::fmt::Display>::fmt;
        *(_QWORD *)&v25 = &off_58E60;
        *((_QWORD *)&v25 + 1) = 3LL;
        s1 = 0LL;
        v26 = (__int64 *)&v21;
        v27 = 2LL;
        core::fmt::write(*(_QWORD *)(v7 + 32), *(_QWORD *)(v7 + 40), &v25);
      }
      *v6 = 0;
      *v4 = 0LL;
    }
    v19 = *(const char **)(a1 + 40);
    v20 = 0LL;
    v9 = *(_QWORD **)(a1 + 56);
    v10 = v9[1];
    if ( !*v9 )
    {
      LODWORD(v11) = Unwind_GetIP((struct _Unwind_Context *)v9[1]);
      v10 = v11;
    }
    std::backtrace_rs::symbolize::Symbol::name((__int64)&v25, a2);
    v12 = *(_DWORD *)a2;
    if ( *(_DWORD *)a2 == 2
      || v12 == 3
      || (v13 = *(__int64 (__fastcall **)(unsigned __int64 *, __int64))(a2 + 16)) == 0LL )
    {
      v21 = (_QWORD *)(&dword_0 + 2);
    }
    else
    {
      v14 = *(_QWORD *)(a2 + 24);
      v21 = 0LL;
      v22 = v13;
      v23 = (__int64 *)v14;
    }
    v15 = 0;
    if ( v12 < 2 )
      v15 = *(_DWORD *)(a2 + 8);
    else
      v12 = 0;
    **(_BYTE **)(a1 + 48) = std::backtrace_rs::print::BacktraceFrameFmt::print_raw_with_column(
                              (__int64)&v19,
                              v10,
                              &v25,
                              &v21,
                              v12,
                              *(_DWORD *)(a2 + 4),
                              v15,
                              *(_DWORD *)(a2 + 12));
    result = v19;
    ++*((_QWORD *)v19 + 3);
  }
  return result;
}
// 25B7D: variable 'v11' is possibly undefined
// 0: using guessed type int dword_0;
// 58E60: using guessed type char *off_58E60;

//----- (0000000000025D10) ----------------------------------------------------
void __fastcall __noreturn std::sys_common::backtrace::__rust_end_short_backtrace(const char ****a1)
{
  std::panicking::begin_panic_handler::{{closure}}(a1);
}

//----- (0000000000025D20) ----------------------------------------------------
char __fastcall std::sys_common::backtrace::output_filename(__int64 a1, __int64 a2, char a3, __int64 a4)
{
  __int128 v5; // rdi
  _BYTE *v6; // rax
  unsigned __int64 v7; // rdx
  void *v9; // [rsp+0h] [rbp-78h] BYREF
  __int128 v10; // [rsp+8h] [rbp-70h]
  __int64 v11; // [rsp+18h] [rbp-60h]
  __int64 v12; // [rsp+20h] [rbp-58h]
  __int64 v13[4]; // [rsp+30h] [rbp-48h] BYREF
  __int128 v14; // [rsp+50h] [rbp-28h] BYREF

  if ( *(_QWORD *)a2 )
  {
    *((_QWORD *)&v5 + 1) = 9LL;
    *(_QWORD *)&v5 = aUnknown;
    if ( !a3 )
      goto LABEL_6;
    return <std::sys::os_str::bytes::Slice as core::fmt::Display>::fmt(v5, *((__int64 *)&v5 + 1), a1);
  }
  v5 = *(_OWORD *)(a2 + 8);
  if ( a3 )
    return <std::sys::os_str::bytes::Slice as core::fmt::Display>::fmt(v5, *((__int64 *)&v5 + 1), a1);
  if ( !*((_QWORD *)&v5 + 1) )
  {
    *((_QWORD *)&v5 + 1) = 0LL;
    return <std::sys::os_str::bytes::Slice as core::fmt::Display>::fmt(v5, *((__int64 *)&v5 + 1), a1);
  }
LABEL_6:
  if ( !a4 )
    return <std::sys::os_str::bytes::Slice as core::fmt::Display>::fmt(v5, *((__int64 *)&v5 + 1), a1);
  if ( *(_BYTE *)v5 != 47 )
    return <std::sys::os_str::bytes::Slice as core::fmt::Display>::fmt(v5, *((__int64 *)&v5 + 1), a1);
  v6 = std::path::Path::_strip_prefix(v5, *(_BYTE **)(a4 + 8), *(_QWORD *)(a4 + 16));
  if ( !v6 )
    return <std::sys::os_str::bytes::Slice as core::fmt::Display>::fmt(v5, *((__int64 *)&v5 + 1), a1);
  core::str::converts::from_utf8((__int64)&v9, (__int64)v6, v7);
  if ( v9 )
    return <std::sys::os_str::bytes::Slice as core::fmt::Display>::fmt(v5, *((__int64 *)&v5 + 1), a1);
  v14 = v10;
  v13[0] = (__int64)&unk_49470;
  v13[1] = (__int64)<char as core::fmt::Display>::fmt;
  v13[2] = (__int64)&v14;
  v13[3] = (__int64)<&T as core::fmt::Display>::fmt;
  v9 = &off_58E90;
  *(_QWORD *)&v10 = 2LL;
  v12 = 0LL;
  *((_QWORD *)&v10 + 1) = v13;
  v11 = 2LL;
  return core::fmt::write(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), &v9);
}
// 25D7E: variable 'v7' is possibly undefined

//----- (0000000000025E30) ----------------------------------------------------
volatile signed __int64 *__fastcall std::sys_common::thread_info::current_thread(
        __int64 a1,
        volatile signed __int64 *(__fastcall *a2)(__int64 a1))
{
  unsigned __int64 v2; // rbx
  volatile signed __int64 *result; // rax
  __int64 v4; // r14
  __int64 v5[3]; // [rsp+10h] [rbp-48h] BYREF
  __int128 v6; // [rsp+28h] [rbp-30h]

  v2 = __readfsqword(0);
  if ( *(_BYTE *)(v2 - 32) != 1 )
  {
    if ( *(_BYTE *)(v2 - 32) )
      return 0LL;
    a2 = std::sys_common::thread_info::THREAD_INFO::__getit::destroy;
    std::sys::pal::unix::thread_local_dtor::register_dtor(
      v2 - 64,
      (__int64)std::sys_common::thread_info::THREAD_INFO::__getit::destroy);
    *(_BYTE *)(v2 - 32) = 1;
  }
  result = *(volatile signed __int64 **)(v2 - 40);
  if ( !result )
  {
    v4 = std::thread::Thread::new(0LL, (__int64)a2);
    if ( *(_QWORD *)(v2 - 40) )
    {
      v5[0] = (__int64)&off_583A8;
      v5[1] = 1LL;
      v5[2] = (__int64)aRustc9b00956e5;
      v6 = 0LL;
      core::panicking::panic_fmt((__int64)v5, (__int64)&off_583B8);
    }
    result = (volatile signed __int64 *)v4;
    *(_QWORD *)(v2 - 40) = v4;
  }
  if ( _InterlockedIncrement64(result) <= 0 )
    BUG();
  return result;
}
// 583A8: using guessed type char *off_583A8;
// 583B8: using guessed type char *off_583B8;

//----- (0000000000025F30) ----------------------------------------------------
unsigned __int64 __fastcall std::sys_common::thread_info::set(__int64 a1, volatile signed __int64 *a2)
{
  unsigned __int64 v2; // r15
  unsigned __int64 result; // rax
  __int64 v4; // [rsp+0h] [rbp-78h] BYREF
  char **v5; // [rsp+8h] [rbp-70h] BYREF
  _BYTE v6[24]; // [rsp+10h] [rbp-68h]
  volatile signed __int64 *v7; // [rsp+28h] [rbp-50h] BYREF
  __int64 v8[3]; // [rsp+30h] [rbp-48h] BYREF
  __int128 v9; // [rsp+48h] [rbp-30h]

  *(_QWORD *)&v6[16] = *(_QWORD *)(a1 + 16);
  *(_OWORD *)v6 = *(_OWORD *)a1;
  v7 = a2;
  v2 = __readfsqword(0);
  if ( *(_BYTE *)(v2 - 32) != 1 )
  {
    if ( *(_BYTE *)(v2 - 32) )
    {
      if ( !_InterlockedDecrement64(a2) )
        alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v7);
      core::result::unwrap_failed(
        (__int64)aCannotAccessAT,
        70LL,
        (__int64)&v4,
        (__int64)&off_585D8,
        (__int64)&off_58AE8);
    }
    std::sys::pal::unix::thread_local_dtor::register_dtor(
      v2 - 64,
      (__int64)std::sys_common::thread_info::THREAD_INFO::__getit::destroy);
    *(_BYTE *)(v2 - 32) = 1;
  }
  result = v2;
  if ( *(_QWORD *)(v2 - 64) || *(_QWORD *)(v2 - 40) )
  {
    v8[0] = (__int64)&off_58EB0;
    v8[1] = 1LL;
    v8[2] = (__int64)&v4;
    v9 = 0LL;
    v5 = std::io::Write::write_fmt((__int64)&v4, v8);
    if ( v5 )
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v5);
    std::sys::pal::unix::abort_internal();
  }
  if ( *(_QWORD *)v6 )
  {
    result = v2;
    *(_QWORD *)(v2 - 64) = 1LL;
    *(_OWORD *)(v2 - 56) = *(_OWORD *)&v6[8];
  }
  *(_QWORD *)(v2 - 40) = a2;
  return result;
}
// 585D8: using guessed type __int64 (__fastcall *off_585D8)();
// 58AE8: using guessed type char *off_58AE8;
// 58EB0: using guessed type char *off_58EB0;

//----- (0000000000026080) ----------------------------------------------------
int __fastcall std::sys_common::thread_local_dtor::register_dtor_fallback::run_dtors(_QWORD *a1)
{
  int result; // eax
  _QWORD *v2; // rbx
  __int64 v3; // r14
  __int64 v4; // r15
  __int64 v5; // r13
  __int64 v6; // r13
  __int64 v7; // rbx
  pthread_key_t v8; // eax
  pthread_key_t v9; // eax

  if ( a1 )
  {
    v2 = a1;
    do
    {
      v3 = v2[1];
      v4 = v2[2];
      v5 = v2[3];
      _rust_dealloc(v2, 32LL, 8LL);
      if ( v5 )
      {
        v6 = v4 + 16 * v5;
        v7 = v4;
        do
        {
          (*(void (__fastcall **)(_QWORD))(v7 + 8))(*(_QWORD *)v7);
          v7 += 16LL;
        }
        while ( v7 != v6 );
      }
      if ( v3 )
        _rust_dealloc(v4, 16 * v3, 8LL);
      v8 = std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS;
      if ( !*(_QWORD *)&std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS )
        v8 = std::sys_common::thread_local_key::StaticKey::lazy_init();
      v2 = pthread_getspecific(v8);
      v9 = std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS;
      if ( !*(_QWORD *)&std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS )
        v9 = std::sys_common::thread_local_key::StaticKey::lazy_init();
      result = pthread_setspecific(v9, 0LL);
    }
    while ( v2 );
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (0000000000026170) ----------------------------------------------------
char __fastcall std::alloc::default_alloc_error_hook(__int64 a1, __int64 a2)
{
  char result; // al
  char **v3; // rax
  __int64 *v4; // rdi
  char v5; // [rsp+Fh] [rbp-69h] BYREF
  __int64 *v6; // [rsp+10h] [rbp-68h] BYREF
  __int64 (__fastcall *v7)(unsigned __int64 *, __int64); // [rsp+18h] [rbp-60h] BYREF
  __int64 v8[2]; // [rsp+20h] [rbp-58h] BYREF
  char **v9; // [rsp+30h] [rbp-48h] BYREF
  __int64 v10; // [rsp+38h] [rbp-40h]
  __int64 *v11; // [rsp+40h] [rbp-38h]
  __int64 v12; // [rsp+48h] [rbp-30h]
  __int64 v13; // [rsp+50h] [rbp-28h]
  __int64 v14; // [rsp+60h] [rbp-18h] BYREF

  if ( _rust_alloc_error_handler_should_panic )
  {
    v8[0] = a2;
    v6 = v8;
    v7 = core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
    v9 = &off_58EF0;
    v10 = 2LL;
    v13 = 0LL;
    v11 = (__int64 *)&v6;
    v12 = 1LL;
    core::panicking::panic_fmt((__int64)&v9, (__int64)off_58F10);
  }
  v14 = a2;
  v8[0] = (__int64)&v14;
  v8[1] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v9 = &off_58ED0;
  v10 = 2LL;
  v13 = 0LL;
  v11 = v8;
  v12 = 1LL;
  v6 = (__int64 *)&v5;
  v7 = 0LL;
  result = core::fmt::write((__int64)&v6, (__int64)&off_58808, &v9);
  if ( result )
  {
    v3 = &off_58C18;
    if ( v7 )
      v3 = (char **)v7;
    v6 = (__int64 *)v3;
    v4 = (__int64 *)&v6;
  }
  else
  {
    if ( !v7 )
      return result;
    v4 = (__int64 *)&v7;
  }
  return core::ptr::drop_in_place<std::io::error::Error>(v4);
}
// 58808: using guessed type __int64 (__fastcall *off_58808)();
// 58C18: using guessed type char *off_58C18;
// 58ED0: using guessed type char *off_58ED0;
// 58EF0: using guessed type char *off_58EF0;
// 58F10: using guessed type char *off_58F10[2];

//----- (00000000000262C0) ----------------------------------------------------
void *__fastcall _rdl_alloc(size_t size, size_t alignment)
{
  size_t v3; // rax
  void *v4; // [rsp+0h] [rbp-8h] BYREF

  if ( alignment <= 0x10 && alignment <= size )
    return malloc(size);
  v4 = 0LL;
  v3 = 8LL;
  if ( alignment >= 9 )
    v3 = alignment;
  if ( posix_memalign(&v4, v3, size) )
    return 0LL;
  else
    return v4;
}

//----- (0000000000026320) ----------------------------------------------------
void *__fastcall _rdl_realloc(void *ptr, size_t n, size_t alignment, size_t size)
{
  void *v4; // rax
  size_t v5; // rbx
  void *result; // rax
  size_t v8; // rsi
  int v9; // ecx
  void *v10; // r15
  void *dest; // [rsp+0h] [rbp-28h] BYREF

  dest = v4;
  v5 = size;
  if ( alignment <= 0x10 && alignment <= size )
    return realloc(ptr, size);
  dest = 0LL;
  v8 = 8LL;
  if ( alignment >= 9 )
    v8 = alignment;
  v9 = posix_memalign(&dest, v8, size);
  result = 0LL;
  if ( !v9 )
  {
    v10 = dest;
    if ( dest )
    {
      if ( n < v5 )
        v5 = n;
      memcpy(dest, ptr, v5);
      free(ptr);
      return v10;
    }
  }
  return result;
}
// 26327: variable 'v4' is possibly undefined

//----- (00000000000263C0) ----------------------------------------------------
void *__fastcall _rdl_alloc_zeroed(size_t n, size_t alignment)
{
  void *v2; // rax
  void *result; // rax
  size_t v4; // rax
  int v5; // ecx
  void *v6; // r14
  void *s; // [rsp+0h] [rbp-18h] BYREF

  s = v2;
  if ( alignment <= 0x10 && alignment <= n )
    return calloc(n, 1uLL);
  s = 0LL;
  v4 = 8LL;
  if ( alignment >= 9 )
    v4 = alignment;
  v5 = posix_memalign(&s, v4, n);
  result = 0LL;
  if ( !v5 )
  {
    v6 = s;
    if ( s )
    {
      memset(s, 0, n);
      return v6;
    }
  }
  return result;
}
// 263C3: variable 'v2' is possibly undefined

//----- (0000000000026440) ----------------------------------------------------
void __noreturn _rust_drop_panic()
{
  char **v0; // rax
  char v1; // [rsp+8h] [rbp-50h] BYREF
  char *v2; // [rsp+10h] [rbp-48h] BYREF
  char **v3; // [rsp+18h] [rbp-40h] BYREF
  __int64 v4[3]; // [rsp+20h] [rbp-38h] BYREF
  __int128 v5; // [rsp+38h] [rbp-20h]

  v4[0] = (__int64)&off_58F28;
  v4[1] = 1LL;
  v4[2] = (__int64)&v1;
  v5 = 0LL;
  v2 = &v1;
  v3 = 0LL;
  if ( core::fmt::write((__int64)&v2, (__int64)&off_58808, v4) )
  {
    v0 = &off_58C18;
    if ( v3 )
      v0 = v3;
    v2 = (char *)v0;
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v2);
  }
  else if ( v3 )
  {
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v3);
  }
  std::sys::pal::unix::abort_internal();
}
// 58808: using guessed type __int64 (__fastcall *off_58808)();
// 58C18: using guessed type char *off_58C18;
// 58F28: using guessed type char *off_58F28;

//----- (0000000000026500) ----------------------------------------------------
void __noreturn _rust_foreign_exception()
{
  char **v0; // rax
  char v1; // [rsp+8h] [rbp-50h] BYREF
  char *v2; // [rsp+10h] [rbp-48h] BYREF
  char **v3; // [rsp+18h] [rbp-40h] BYREF
  __int64 v4[3]; // [rsp+20h] [rbp-38h] BYREF
  __int128 v5; // [rsp+38h] [rbp-20h]

  v4[0] = (__int64)&off_58F38;
  v4[1] = 1LL;
  v4[2] = (__int64)&v1;
  v5 = 0LL;
  v2 = &v1;
  v3 = 0LL;
  if ( core::fmt::write((__int64)&v2, (__int64)&off_58808, v4) )
  {
    v0 = &off_58C18;
    if ( v3 )
      v0 = v3;
    v2 = (char *)v0;
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v2);
  }
  else if ( v3 )
  {
    core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v3);
  }
  std::sys::pal::unix::abort_internal();
}
// 58808: using guessed type __int64 (__fastcall *off_58808)();
// 58C18: using guessed type char *off_58C18;
// 58F38: using guessed type char *off_58F38;

//----- (00000000000265C0) ----------------------------------------------------
volatile signed __int64 *__fastcall std::panicking::default_hook(__int64 a1)
{
  volatile signed __int64 *(__fastcall **v1)(__int64); // rbx
  __int64 v2; // r14
  __int64 v3; // rdi
  __int64 v4; // rdx
  __int64 v5; // rax
  volatile signed __int64 *(__fastcall **v6)(__int64); // rcx
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  volatile signed __int64 *(__fastcall *v10)(__int64); // rsi
  volatile signed __int64 *v11; // rbx
  __int64 v12; // rax
  char *v13; // rcx
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // r14
  __int64 *v16; // rax
  __int64 v17; // r15
  bool v18; // bp
  volatile signed __int64 *v19; // rbx
  volatile signed __int64 **v20; // rax
  char v21; // bp
  volatile signed __int64 *v22; // rcx
  volatile signed __int64 *result; // rax
  char backtrace_style; // [rsp+7h] [rbp-91h] BYREF
  volatile signed __int64 *v25; // [rsp+8h] [rbp-90h] BYREF
  volatile signed __int64 *v26; // [rsp+10h] [rbp-88h] BYREF
  volatile signed __int64 *v27; // [rsp+18h] [rbp-80h] BYREF
  volatile signed __int64 *v28; // [rsp+20h] [rbp-78h]
  __int64 v29; // [rsp+28h] [rbp-70h] BYREF
  __int64 v30[2]; // [rsp+30h] [rbp-68h] BYREF
  __int64 v31[2]; // [rsp+40h] [rbp-58h] BYREF
  __int64 v32[9]; // [rsp+50h] [rbp-48h] BYREF

  if ( *(_BYTE *)(a1 + 33) )
  {
    backtrace_style = 3;
  }
  else if ( *(_QWORD *)(__readfsqword(0) - 80) <= 1uLL )
  {
    backtrace_style = std::panic::get_backtrace_style();
  }
  else
  {
    backtrace_style = 1;
  }
  v29 = *(_QWORD *)(a1 + 24);
  v1 = *(volatile signed __int64 *(__fastcall ***)(__int64))a1;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)a1;
  if ( (*(__int64 (__fastcall **)(__int64))(v2 + 24))(v3) == 0xFDBC168100B1EF64LL )
  {
    v5 = 1LL;
    v6 = v1;
    if ( v4 == 0xC1A2C89CCD1E7BC1LL )
      goto LABEL_11;
  }
  v7 = (*(__int64 (__fastcall **)(_QWORD))(v2 + 24))(v1);
  v3 = 0xDAF1A5398DFFA0D6LL;
  v9 = 12LL;
  v10 = (volatile signed __int64 *(__fastcall *)(__int64))aBoxDynAnyUnnam;
  if ( v7 == 0xDAF1A5398DFFA0D6LL && v8 == 0x99A631E767988929LL )
  {
    v6 = v1 + 1;
    v5 = 2LL;
LABEL_11:
    v10 = *v6;
    v9 = (__int64)v1[v5];
  }
  v30[0] = (__int64)v10;
  v30[1] = v9;
  v11 = std::sys_common::thread_info::current_thread(v3, v10);
  v26 = v11;
  v12 = 9LL;
  v13 = &aBoxDynAnyUnnam[12];
  if ( v11 && *((_QWORD *)v11 + 3) )
  {
    v12 = *((_QWORD *)v11 + 4) - 1LL;
    v13 = (char *)*((_QWORD *)v11 + 3);
  }
  v31[0] = (__int64)v13;
  v31[1] = v12;
  v32[0] = (__int64)v31;
  v32[1] = (__int64)&v29;
  v32[2] = (__int64)v30;
  v32[3] = (__int64)&backtrace_style;
  if ( !std::io::stdio::OUTPUT_CAPTURE_USED )
  {
    v27 = 0LL;
    goto LABEL_31;
  }
  std::io::stdio::OUTPUT_CAPTURE_USED = 1;
  v14 = __readfsqword(0);
  v15 = v14;
  if ( *(_QWORD *)(v14 - 24) )
  {
    v16 = (__int64 *)(v14 - 16);
  }
  else
  {
    v16 = (__int64 *)std::sys::thread_local::fast_local::Key<T>::try_initialize(0LL);
    if ( !v16 )
      core::result::unwrap_failed(
        (__int64)aCannotAccessAT,
        70LL,
        (__int64)&v25,
        (__int64)&off_585D8,
        (__int64)&off_58AE8);
  }
  v17 = *v16;
  *v16 = 0LL;
  v27 = (volatile signed __int64 *)v17;
  if ( !v17 )
  {
LABEL_31:
    std::panicking::default_hook::{{closure}}((__int64)v32, (__int64)&v25, (__int64)&off_58F98);
    v21 = 0;
    if ( !v11 )
      goto LABEL_40;
    goto LABEL_38;
  }
  v28 = (volatile signed __int64 *)v17;
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(v17 + 16), 1, 0) )
    std::sys::sync::mutex::futex::Mutex::lock_contended((volatile __int32 *)(v17 + 16));
  if ( 2 * std::panicking::panic_count::GLOBAL_PANIC_COUNT )
    v18 = !std::panicking::panic_count::is_zero_slow_path();
  else
    v18 = 0;
  std::panicking::default_hook::{{closure}}((__int64)v32, v17 + 24, (__int64)off_58F48);
  if ( !v18
    && (std::panicking::panic_count::GLOBAL_PANIC_COUNT & 0x7FFFFFFFFFFFFFFFLL) != 0
    && !std::panicking::panic_count::is_zero_slow_path() )
  {
    *(_BYTE *)(v17 + 20) = 1;
  }
  if ( _InterlockedExchange((volatile __int32 *)(v17 + 16), 0) == 2 )
    syscall(202LL, v17 + 16, 129LL, 1LL);
  v19 = v28;
  std::io::stdio::OUTPUT_CAPTURE_USED = 1;
  v25 = v28;
  if ( *(_QWORD *)(v15 - 24) )
  {
    v20 = (volatile signed __int64 **)(v15 - 16);
  }
  else
  {
    v20 = (volatile signed __int64 **)std::sys::thread_local::fast_local::Key<T>::try_initialize(0LL);
    if ( !v20 )
    {
      if ( !_InterlockedDecrement64(v19) )
        alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v25);
      core::result::unwrap_failed(
        (__int64)aCannotAccessAT,
        70LL,
        (__int64)&v25,
        (__int64)&off_585D8,
        (__int64)&off_58AE8);
    }
  }
  v22 = *v20;
  *v20 = v19;
  v25 = v22;
  if ( v22 && !_InterlockedDecrement64(v22) )
    alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v25);
  v21 = 1;
  v11 = v26;
  if ( v26 )
  {
LABEL_38:
    if ( !_InterlockedDecrement64(v11) )
      alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v26);
  }
LABEL_40:
  result = v27;
  if ( ((v27 != 0LL) & (unsigned __int8)~v21) != 0 && !_InterlockedDecrement64(v27) )
    return (volatile signed __int64 *)alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v27);
  return result;
}
// 2663E: variable 'v4' is possibly undefined
// 2666F: variable 'v8' is possibly undefined
// 585D8: using guessed type __int64 (__fastcall *off_585D8)();
// 58AE8: using guessed type char *off_58AE8;
// 58F48: using guessed type __int64 (__fastcall *off_58F48[2])();
// 58F98: using guessed type __int64 (__fastcall *off_58F98)();
// 5B068: using guessed type char std::io::stdio::OUTPUT_CAPTURE_USED;
// 5B120: using guessed type signed __int64 std::panicking::panic_count::GLOBAL_PANIC_COUNT;

//----- (00000000000269F0) ----------------------------------------------------
__int64 __fastcall std::panicking::default_hook::{{closure}}(__int64 a1, __int64 a2, __int64 a3)
{
  const char *v4; // rcx
  __int64 v5; // rdx
  __int64 (__fastcall *v6)(__int64, __int64 *); // r12
  __int64 result; // rax
  __int64 *v8; // rdi
  char **v9; // [rsp+0h] [rbp-88h] BYREF
  char (__fastcall *v10)(__int64, __int64); // [rsp+8h] [rbp-80h]
  const char *v11; // [rsp+10h] [rbp-78h]
  __int128 v12; // [rsp+18h] [rbp-70h]
  char (__fastcall *v13)(__int64, __int64); // [rsp+28h] [rbp-60h]
  __int64 v14; // [rsp+30h] [rbp-58h] BYREF
  __int64 v15[10]; // [rsp+38h] [rbp-50h] BYREF

  v4 = *(const char **)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v9 = *(char ***)a1;
  v10 = <&T as core::fmt::Display>::fmt;
  v11 = v4;
  *(_QWORD *)&v12 = <&T as core::fmt::Display>::fmt;
  *((_QWORD *)&v12 + 1) = v5;
  v13 = <&T as core::fmt::Display>::fmt;
  v15[0] = (__int64)&off_58FE8;
  v15[1] = 4LL;
  v15[4] = 0LL;
  v15[2] = (__int64)&v9;
  v15[3] = 3LL;
  v6 = *(__int64 (__fastcall **)(__int64, __int64 *))(a3 + 72);
  v14 = v6(a2, v15);
  if ( v14 )
    core::ptr::drop_in_place<std::io::error::Error>(&v14);
  result = **(unsigned __int8 **)(a1 + 24);
  switch ( **(_BYTE **)(a1 + 24) )
  {
    case 0:
      result = std::sys_common::backtrace::print(a2, a3, 0);
      v9 = (char **)result;
      if ( result )
        goto LABEL_7;
      break;
    case 1:
      result = std::sys_common::backtrace::print(a2, a3, 1);
      v9 = (char **)result;
      if ( result )
      {
LABEL_7:
        v8 = (__int64 *)&v9;
        goto LABEL_11;
      }
      break;
    case 2:
      result = (unsigned __int8)std::panicking::default_hook::{{closure}}::FIRST_PANIC;
      std::panicking::default_hook::{{closure}}::FIRST_PANIC = 0;
      if ( (_BYTE)result )
      {
        v9 = &off_59028;
        v10 = (char (__fastcall *)(__int64, __int64))(&dword_0 + 1);
        v11 = aRustc9b00956e5;
        v12 = 0LL;
        result = v6(a2, (__int64 *)&v9);
        v15[0] = result;
        if ( result )
        {
          v8 = v15;
LABEL_11:
          result = core::ptr::drop_in_place<std::io::error::Error>(v8);
        }
      }
      break;
    case 3:
      return result;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 58FE8: using guessed type char *off_58FE8;
// 59028: using guessed type char *off_59028;
// 5B020: using guessed type char std::panicking::default_hook::{{closure}}::FIRST_PANIC;

//----- (0000000000026B40) ----------------------------------------------------
void __fastcall __noreturn rust_begin_unwind(__int64 a1)
{
  const char ***v1; // rcx
  const char ***v2[3]; // [rsp+0h] [rbp-18h] BYREF

  if ( !*(_QWORD *)(a1 + 16) )
    core::option::unwrap_failed((__int64)&off_59038);
  v1 = *(const char ****)(a1 + 24);
  v2[0] = *(const char ****)(a1 + 16);
  v2[1] = (const char ***)a1;
  v2[2] = v1;
  std::sys_common::backtrace::__rust_end_short_backtrace(v2);
}
// 59038: using guessed type char *off_59038;

//----- (0000000000026B80) ----------------------------------------------------
_QWORD *__fastcall <std::panicking::begin_panic_handler::FormatStringPayload as core::panic::PanicPayload>::take_box(
        __int64 *a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rdx
  __int128 v3; // xmm0
  __int64 v4; // r15
  __int64 v5; // r12
  _QWORD *result; // rax
  __int128 v7; // [rsp+8h] [rbp-50h] BYREF
  __int64 v8; // [rsp+18h] [rbp-40h]
  __int128 v9; // [rsp+20h] [rbp-38h]
  __int64 v10; // [rsp+30h] [rbp-28h]

  v1 = *a1;
  if ( *a1 == 0x8000000000000000LL )
  {
    v2 = (_QWORD *)a1[3];
    *(_QWORD *)&v7 = 0LL;
    *((_QWORD *)&v7 + 1) = 1LL;
    v8 = 0LL;
    core::fmt::write((__int64)&v7, (__int64)off_582E0, v2);
    v10 = v8;
    v3 = v7;
    v9 = v7;
    a1[2] = v8;
    *(_OWORD *)a1 = v3;
    v1 = *a1;
  }
  v4 = a1[1];
  v5 = a1[2];
  *a1 = 0LL;
  a1[1] = 1LL;
  a1[2] = 0LL;
  result = (_QWORD *)_rust_alloc(24LL, 8LL);
  if ( !result )
    alloc::alloc::handle_alloc_error(8LL, 24LL);
  *result = v1;
  result[1] = v4;
  result[2] = v5;
  return result;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 582E0: using guessed type __int64 (__fastcall *off_582E0[2])();

//----- (0000000000026CA0) ----------------------------------------------------
__int64 __fastcall <std::panicking::begin_panic_handler::FormatStringPayload as core::panic::PanicPayload>::get(
        __int64 a1)
{
  _QWORD *v1; // rdx
  __int128 v2; // xmm0
  __int128 v4; // [rsp+8h] [rbp-40h] BYREF
  __int64 v5; // [rsp+18h] [rbp-30h]
  __int128 v6; // [rsp+20h] [rbp-28h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  if ( *(_QWORD *)a1 == 0x8000000000000000LL )
  {
    v1 = *(_QWORD **)(a1 + 24);
    *(_QWORD *)&v4 = 0LL;
    *((_QWORD *)&v4 + 1) = 1LL;
    v5 = 0LL;
    core::fmt::write((__int64)&v4, (__int64)off_582E0, v1);
    v7 = v5;
    v2 = v4;
    v6 = v4;
    *(_QWORD *)(a1 + 16) = v5;
    *(_OWORD *)a1 = v2;
  }
  return a1;
}
// 582E0: using guessed type __int64 (__fastcall *off_582E0[2])();

//----- (0000000000026D40) ----------------------------------------------------
_QWORD *__fastcall <std::panicking::begin_panic_handler::StaticStrPayload as core::panic::PanicPayload>::take_box(
        __int64 *a1)
{
  __int64 v1; // rbx
  __int64 v2; // r14
  _QWORD *result; // rax

  v1 = *a1;
  v2 = a1[1];
  result = (_QWORD *)_rust_alloc(16LL, 8LL);
  if ( !result )
    alloc::alloc::handle_alloc_error(8LL, 16LL);
  *result = v1;
  result[1] = v2;
  return result;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);

//----- (0000000000026D90) ----------------------------------------------------
__int64 __fastcall <std::panicking::begin_panic_handler::StaticStrPayload as core::panic::PanicPayload>::get(
        __int64 a1)
{
  return a1;
}

//----- (0000000000026DA0) ----------------------------------------------------
void __fastcall __noreturn std::panicking::begin_panic_handler::{{closure}}(const char ****a1)
{
  const char ***v1; // rax
  const char **v2; // rdx
  const char **v3; // rcx
  const char *v4; // rax
  __int64 v5; // rcx
  const char **v6; // rcx
  __int64 v7[5]; // [rsp+0h] [rbp-28h] BYREF

  v1 = *a1;
  v2 = (*a1)[1];
  v3 = (*a1)[3];
  if ( v2 == (const char **)((char *)&dword_0 + 1) )
  {
    if ( !v3 )
    {
      v6 = *v1;
      v4 = **v1;
      v5 = (__int64)v6[1];
LABEL_7:
      v7[0] = (__int64)v4;
      v7[1] = v5;
      std::panicking::rust_panic_with_hook(
        (__int64)v7,
        (__int64)&off_59090,
        (__int64)a1[1][2],
        (__int64)a1[2],
        *((_BYTE *)a1[1] + 32),
        *((_BYTE *)a1[1] + 33));
    }
  }
  else if ( !v2 && !v3 )
  {
    v4 = aRustc9b00956e5;
    v5 = 0LL;
    goto LABEL_7;
  }
  v7[3] = (__int64)*a1;
  v7[0] = 0x8000000000000000LL;
  std::panicking::rust_panic_with_hook(
    (__int64)v7,
    (__int64)&off_590B8,
    (__int64)a1[1][2],
    (__int64)a1[2],
    *((_BYTE *)a1[1] + 32),
    *((_BYTE *)a1[1] + 33));
}
// 0: using guessed type int dword_0;
// 59090: using guessed type __int64 (__fastcall *off_59090)();
// 590B8: using guessed type __int64 (__fastcall *off_590B8)();

//----- (0000000000026E80) ----------------------------------------------------
void __fastcall __noreturn std::panicking::rust_panic_with_hook(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        char a5,
        char a6)
{
  unsigned __int64 v8; // rax
  int v9; // eax
  __int64 (__fastcall *v10)(__int64); // rax
  __int64 v11; // r13
  __int64 (__fastcall **v12)(); // rdx
  __int64 *v13; // r14
  char v14; // al
  __int64 (__fastcall **v15)(); // rcx
  char **v16; // rax
  __int64 *v17; // rdi
  char v18; // al
  char **v19; // rax
  __int64 (__fastcall **v20)(); // rdx
  signed __int32 v21; // esi
  char v22; // [rsp+Fh] [rbp-B9h] BYREF
  const char *v23; // [rsp+10h] [rbp-B8h] BYREF
  __int64 (__fastcall **v24)(); // [rsp+18h] [rbp-B0h] BYREF
  __int64 v25; // [rsp+20h] [rbp-A8h]
  __int64 v26; // [rsp+28h] [rbp-A0h]
  char v27; // [rsp+30h] [rbp-98h]
  char v28; // [rsp+31h] [rbp-97h]
  char **v29; // [rsp+38h] [rbp-90h] BYREF
  __int64 (__fastcall **v30)(); // [rsp+40h] [rbp-88h] BYREF
  __int64 v31; // [rsp+48h] [rbp-80h]
  char **v32; // [rsp+50h] [rbp-78h] BYREF
  __int64 v33; // [rsp+58h] [rbp-70h]
  __int64 *v34; // [rsp+60h] [rbp-68h]
  __int128 v35; // [rsp+68h] [rbp-60h]
  char **v36; // [rsp+80h] [rbp-48h] BYREF
  __int64 v37[8]; // [rsp+88h] [rbp-40h] BYREF

  if ( _InterlockedIncrement64(&std::panicking::panic_count::GLOBAL_PANIC_COUNT) <= 0 )
  {
    v23 = aRustc9b00956e5;
    v24 = &off_590E0;
    v25 = a3;
    v26 = a4;
    v27 = a5;
    v28 = a6;
    v37[0] = (__int64)&v23;
    v37[1] = (__int64)<core::panic::panic_info::PanicInfo as core::fmt::Display>::fmt;
    v32 = &off_59100;
    v33 = 2LL;
    v34 = v37;
    v35 = 1uLL;
    v29 = (char **)&v22;
    v13 = (__int64 *)&v30;
    v30 = 0LL;
    v14 = core::fmt::write((__int64)&v29, (__int64)&off_58808, &v32);
    v15 = v30;
    if ( v14 )
    {
      v16 = &off_58C18;
      if ( v30 )
        v16 = (char **)v30;
      v36 = v16;
      v17 = (__int64 *)&v36;
      goto LABEL_18;
    }
  }
  else
  {
    v8 = __readfsqword(0);
    if ( !*(_BYTE *)(v8 - 72) )
    {
      ++*(_QWORD *)(v8 - 80);
      v31 = v8;
      *(_BYTE *)(v8 - 72) = 1;
      v23 = aRustc9b00956e5;
      v24 = &off_590E0;
      v25 = a3;
      v26 = a4;
      v27 = a5;
      v28 = a6;
      v9 = std::panicking::HOOK;
      if ( std::panicking::HOOK > 0x3FFFFFFDu
        || v9 != _InterlockedCompareExchange(
                   (volatile signed __int32 *)&std::panicking::HOOK,
                   std::panicking::HOOK + 1,
                   std::panicking::HOOK) )
      {
        std::sys::sync::rwlock::futex::RwLock::read_contended((volatile signed __int32 *)&std::panicking::HOOK);
      }
      v10 = *(__int64 (__fastcall **)(__int64))(a2 + 32);
      v11 = v31;
      if ( *((_QWORD *)&std::panicking::HOOK + 2) )
      {
        v23 = (const char *)v10(a1);
        v24 = v20;
        (*(void (__fastcall **)(_QWORD, const char **))(*((_QWORD *)&std::panicking::HOOK + 3) + 40LL))(
          *((_QWORD *)&std::panicking::HOOK + 2),
          &v23);
      }
      else
      {
        v23 = (const char *)v10(a1);
        v24 = v12;
        std::panicking::default_hook((__int64)&v23);
      }
      v21 = _InterlockedDecrement((volatile signed __int32 *)&std::panicking::HOOK);
      if ( (v21 & 0xBFFFFFFF) == 0x80000000 )
        std::sys::sync::rwlock::futex::RwLock::wake_writer_or_readers(
          (volatile signed __int32 *)&std::panicking::HOOK,
          v21);
      *(_BYTE *)(v11 - 72) = 0;
      if ( a5 )
        rust_panic(a1, a2);
      v32 = &off_59130;
      v33 = 1LL;
      v34 = (__int64 *)aRustc9b00956e5;
      v35 = 0LL;
      v29 = std::io::Write::write_fmt((__int64)&v22, &v32);
      if ( !v29 )
LABEL_19:
        std::sys::pal::unix::abort_internal();
      v17 = (__int64 *)&v29;
LABEL_18:
      core::ptr::drop_in_place<std::io::error::Error>(v17);
      goto LABEL_19;
    }
    v32 = &off_59120;
    v33 = 1LL;
    v34 = (__int64 *)aRustc9b00956e5;
    v35 = 0LL;
    v23 = &v22;
    v13 = (__int64 *)&v24;
    v24 = 0LL;
    v18 = core::fmt::write((__int64)&v23, (__int64)&off_58808, &v32);
    v15 = v24;
    if ( v18 )
    {
      v19 = &off_58C18;
      if ( v24 )
        v19 = (char **)v24;
      v23 = (const char *)v19;
      v17 = (__int64 *)&v23;
      goto LABEL_18;
    }
  }
  if ( !v15 )
    goto LABEL_19;
  v17 = v13;
  goto LABEL_18;
}
// 26F5D: variable 'v12' is possibly undefined
// 270E9: variable 'v20' is possibly undefined
// 58808: using guessed type __int64 (__fastcall *off_58808)();
// 58C18: using guessed type char *off_58C18;
// 590E0: using guessed type __int64 (__fastcall *off_590E0)();
// 59100: using guessed type char *off_59100;
// 59120: using guessed type char *off_59120;
// 59130: using guessed type char *off_59130;
// 5B120: using guessed type signed __int64 std::panicking::panic_count::GLOBAL_PANIC_COUNT;

//----- (0000000000027210) ----------------------------------------------------
void __fastcall __noreturn rust_panic(__int64 a1, __int64 a2)
{
  char v2; // [rsp+Bh] [rbp-4Dh] BYREF
  _Unwind_Reason_Code started; // [rsp+Ch] [rbp-4Ch] BYREF
  char **v4; // [rsp+10h] [rbp-48h] BYREF
  __int64 v5[2]; // [rsp+18h] [rbp-40h] BYREF
  __int64 v6[6]; // [rsp+28h] [rbp-30h] BYREF

  started = _rust_start_panic(a1, a2);
  v5[0] = (__int64)&started;
  v5[1] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt;
  v6[0] = (__int64)&off_59140;
  v6[1] = 2LL;
  v6[4] = 0LL;
  v6[2] = (__int64)v5;
  v6[3] = 1LL;
  v4 = std::io::Write::write_fmt((__int64)&v2, v6);
  core::ptr::drop_in_place<core::result::Result<(),std::io::error::Error>>((__int64 *)&v4);
  std::sys::pal::unix::abort_internal();
}
// 59140: using guessed type char *off_59140;

//----- (0000000000027290) ----------------------------------------------------
__int64 __fastcall std::backtrace_rs::symbolize::Symbol::name(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  unsigned __int64 v3; // r15
  __int64 v4; // rax
  __int128 v5; // xmm1
  __int128 v6; // xmm2
  __int64 v8; // [rsp+0h] [rbp-98h] BYREF
  __int128 v9; // [rsp+8h] [rbp-90h]
  __int128 v10; // [rsp+18h] [rbp-80h]
  __int128 v11; // [rsp+28h] [rbp-70h]
  __int64 v12; // [rsp+38h] [rbp-60h]
  __int128 v13; // [rsp+40h] [rbp-58h]
  __int128 v14; // [rsp+50h] [rbp-48h]
  __int128 v15; // [rsp+60h] [rbp-38h]
  __int64 v16; // [rsp+70h] [rbp-28h]

  if ( *(_DWORD *)a2 == 3 )
  {
    v2 = *(_QWORD *)(a2 + 8);
    v3 = *(_QWORD *)(a2 + 16);
  }
  else
  {
    v2 = *(_QWORD *)(a2 + 40);
    if ( !v2 )
    {
      *(_QWORD *)a1 = 3LL;
      return a1;
    }
    v3 = *(_QWORD *)(a2 + 48);
  }
  core::str::converts::from_utf8((__int64)&v8, v2, v3);
  v4 = 2LL;
  if ( !v8 )
  {
    rustc_demangle::try_demangle((__int128 *)&v8, v9, *((__int64 *)&v9 + 1));
    v4 = v8;
    if ( v8 != 2 )
    {
      v16 = v12;
      v15 = v11;
      v14 = v10;
      v13 = v9;
    }
  }
  *(_QWORD *)a1 = v4;
  v5 = v14;
  v6 = v15;
  *(_OWORD *)(a1 + 8) = v13;
  *(_OWORD *)(a1 + 24) = v5;
  *(_OWORD *)(a1 + 40) = v6;
  *(_QWORD *)(a1 + 56) = v16;
  *(_QWORD *)(a1 + 64) = v2;
  *(_QWORD *)(a1 + 72) = v3;
  return a1;
}

//----- (0000000000027370) ----------------------------------------------------
char __fastcall std::backtrace_rs::print::BacktraceFrameFmt::print_raw_with_column(
        __int64 a1,
        __int64 a2,
        __int128 *a3,
        _QWORD *a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  unsigned __int8 *v8; // r15
  __int64 v9; // rbx
  char result; // al
  __int64 v13; // rax
  __int64 v14; // rax
  int v15; // eax
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  __int128 v18; // xmm2
  __int64 v19; // rax
  __int64 v20; // rdi
  __int64 v21; // rsi
  __m256i **v22; // rdx
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rdi
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  char v29; // cl
  char **v30; // [rsp+8h] [rbp-120h] BYREF
  __int64 (__fastcall *v31)(unsigned int *, __int64); // [rsp+10h] [rbp-118h]
  __m256i **v32; // [rsp+18h] [rbp-110h]
  __int64 v33; // [rsp+20h] [rbp-108h]
  __m256i *v34; // [rsp+28h] [rbp-100h]
  __int64 v35; // [rsp+30h] [rbp-F8h]
  char v36; // [rsp+38h] [rbp-F0h]
  __m256i v37; // [rsp+40h] [rbp-E8h] BYREF
  __int128 v38; // [rsp+60h] [rbp-C8h]
  __int128 v39; // [rsp+70h] [rbp-B8h]
  __int128 v40; // [rsp+80h] [rbp-A8h]
  __m256i *v41; // [rsp+98h] [rbp-90h] BYREF
  void *v42; // [rsp+A0h] [rbp-88h]
  __int64 *v43; // [rsp+A8h] [rbp-80h]
  void (__noreturn *v44)(); // [rsp+B0h] [rbp-78h]
  __int64 *v45; // [rsp+B8h] [rbp-70h]
  __int64 v46; // [rsp+C0h] [rbp-68h]
  int v47; // [rsp+CCh] [rbp-5Ch]
  __int64 v48; // [rsp+D0h] [rbp-58h]
  _QWORD *v49; // [rsp+D8h] [rbp-50h]
  __int64 v50[2]; // [rsp+E0h] [rbp-48h] BYREF
  __int64 v51; // [rsp+F0h] [rbp-38h] BYREF

  v8 = *(unsigned __int8 **)a1;
  v9 = *(_QWORD *)(a1 + 8);
  v51 = a2;
  if ( !a2 && !v8[32] )
    goto LABEL_3;
  v47 = a6;
  v49 = a4;
  v48 = a1;
  v13 = *(_QWORD *)v8;
  if ( v9 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v13 + 40) + 24LL))(
           *(_QWORD *)(v13 + 32),
           asc_49FAB,
           6LL) )
    {
      return 1;
    }
    if ( v8[32] != 1 )
      goto LABEL_12;
    v14 = *(_QWORD *)v8;
    v41 = (__m256i *)&off_589A8;
    v42 = <&T as core::fmt::Display>::fmt;
    v43 = (__int64 *)&unk_493C0;
    v44 = core::ops::function::FnOnce::call_once;
    v37.m256i_i64[0] = 2LL;
    v37.m256i_i64[2] = 1LL;
    v37.m256i_i64[3] = 1LL;
    *(_QWORD *)&v38 = 0LL;
    *((_QWORD *)&v38 + 1) = 32LL;
    LOBYTE(v39) = 3;
    v30 = &off_589A8;
    v31 = (__int64 (__fastcall *)(unsigned int *, __int64))(&dword_0 + 1);
    v34 = &v37;
    v35 = 1LL;
    v32 = &v41;
    goto LABEL_11;
  }
  v41 = (__m256i *)(v8 + 24);
  v42 = core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v37.m256i_i64[0] = 2LL;
  v37.m256i_i64[2] = 0LL;
  v37.m256i_i64[3] = 4LL;
  *(_QWORD *)&v38 = 0LL;
  *((_QWORD *)&v38 + 1) = 32LL;
  LOBYTE(v39) = 3;
  v30 = &off_591A0;
  v31 = (__int64 (__fastcall *)(unsigned int *, __int64))(&dword_0 + 2);
  v34 = &v37;
  v35 = 1LL;
  v32 = &v41;
  v33 = 1LL;
  if ( core::fmt::write(*(_QWORD *)(v13 + 32), *(_QWORD *)(v13 + 40), &v30) )
    return 1;
  if ( v8[32] == 1 )
  {
    v14 = *(_QWORD *)v8;
    v41 = (__m256i *)&v51;
    v42 = <*mut T as core::fmt::Debug>::fmt;
    v43 = (__int64 *)&unk_493B8;
    v44 = core::ops::function::FnOnce::call_once;
    v37.m256i_i64[0] = 2LL;
    v37.m256i_i64[2] = 1LL;
    v37.m256i_i64[3] = 1LL;
    *(_QWORD *)&v38 = 0LL;
    *((_QWORD *)&v38 + 1) = 32LL;
    LOBYTE(v39) = 3;
    v30 = &off_591C0;
    v31 = (__int64 (__fastcall *)(unsigned int *, __int64))(&dword_0 + 2);
    v34 = &v37;
    v35 = 1LL;
    v32 = &v41;
LABEL_11:
    v33 = 2LL;
    if ( core::fmt::write(*(_QWORD *)(v14 + 32), *(_QWORD *)(v14 + 40), &v30) )
      return 1;
  }
LABEL_12:
  if ( *(_DWORD *)a3 == 3 || (v15 = v8[32], v15 == 2) )
  {
    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(*(_QWORD *)v8 + 40LL) + 24LL))(
           *(_QWORD *)(*(_QWORD *)v8 + 32LL),
           aUnknown,
           9LL) )
    {
      return 1;
    }
  }
  else
  {
    v40 = a3[4];
    v16 = *a3;
    v17 = a3[1];
    v18 = a3[2];
    v39 = a3[3];
    v38 = v18;
    *(_OWORD *)&v37.m256i_u64[2] = v17;
    *(_OWORD *)v37.m256i_i8 = v16;
    if ( v15 == 1 )
    {
      v19 = *(_QWORD *)v8;
      v41 = &v37;
      v42 = <std::backtrace_rs::symbolize::SymbolName as core::fmt::Display>::fmt;
      v30 = &off_589A8;
      v31 = (__int64 (__fastcall *)(unsigned int *, __int64))(&dword_0 + 1);
      v34 = 0LL;
      v32 = &v41;
      v33 = 1LL;
      v20 = *(_QWORD *)(v19 + 32);
      v21 = *(_QWORD *)(v19 + 40);
      v22 = (__m256i **)&v30;
    }
    else
    {
      v23 = *(_QWORD *)v8;
      v50[0] = (__int64)&v37;
      v50[1] = (__int64)<std::backtrace_rs::symbolize::SymbolName as core::fmt::Display>::fmt;
      v30 = (char **)(&dword_0 + 2);
      v32 = (__m256i **)(&dword_0 + 2);
      v34 = 0LL;
      v35 = 0x400000020LL;
      v36 = 3;
      v41 = (__m256i *)&off_589A8;
      v42 = &dword_0 + 1;
      v45 = (__int64 *)&v30;
      v46 = 1LL;
      v43 = v50;
      v44 = (void (__noreturn *)())(&dword_0 + 1);
      v20 = *(_QWORD *)(v23 + 32);
      v21 = *(_QWORD *)(v23 + 40);
      v22 = &v41;
    }
    if ( core::fmt::write(v20, v21, v22) )
      return 1;
  }
  if ( (unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str(*(_QWORD *)v8) )
    return 1;
  a1 = v48;
  if ( a5 != 1 || (unsigned int)*v49 == 2 )
    goto LABEL_3;
  LODWORD(v50[0]) = v47;
  if ( v8[32] == 1 )
  {
    v24 = *(_QWORD *)v8;
    v41 = (__m256i *)&off_589A8;
    v42 = <&T as core::fmt::Display>::fmt;
    v43 = (__int64 *)&unk_493B8;
    v44 = core::ops::function::FnOnce::call_once;
    v37.m256i_i64[0] = 2LL;
    v37.m256i_i64[2] = 1LL;
    v37.m256i_i64[3] = 1LL;
    *(_QWORD *)&v38 = 0LL;
    *((_QWORD *)&v38 + 1) = 32LL;
    LOBYTE(v39) = 3;
    v30 = &off_589A8;
    v31 = (__int64 (__fastcall *)(unsigned int *, __int64))(&dword_0 + 1);
    v34 = &v37;
    v35 = 1LL;
    v32 = &v41;
    v33 = 2LL;
    if ( core::fmt::write(*(_QWORD *)(v24 + 32), *(_QWORD *)(v24 + 40), &v30) )
      return 1;
  }
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, void *, __int64))(*(_QWORD *)(*(_QWORD *)v8 + 40LL) + 24LL))(
         *(_QWORD *)(*(_QWORD *)v8 + 32LL),
         &unk_48420,
         16LL) )
  {
    return 1;
  }
  v25 = *((_QWORD *)v8 + 1);
  v26 = *((_QWORD *)v8 + 2);
  v37.m256i_i64[0] = *(_QWORD *)v8;
  *(_OWORD *)&v37.m256i_u64[1] = *(_OWORD *)v49;
  v37.m256i_i64[3] = v49[2];
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int64 *))(v26 + 32))(
         v25,
         v37.m256i_i64[0],
         &v37.m256i_u64[1]) )
  {
    return 1;
  }
  v27 = *(_QWORD *)v8;
  v30 = (char **)v50;
  v31 = core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt;
  v37.m256i_i64[0] = (__int64)&off_591E0;
  v37.m256i_i64[1] = 1LL;
  *(_QWORD *)&v38 = 0LL;
  v37.m256i_i64[2] = (__int64)&v30;
  v37.m256i_i64[3] = 1LL;
  if ( core::fmt::write(*(_QWORD *)(v27 + 32), *(_QWORD *)(v27 + 40), &v37) )
    return 1;
  if ( a7 == 1 )
  {
    LODWORD(v41) = a8;
    v28 = *(_QWORD *)v8;
    v30 = (char **)&v41;
    v31 = core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt;
    v37.m256i_i64[0] = (__int64)&off_591E0;
    v37.m256i_i64[1] = 1LL;
    *(_QWORD *)&v38 = 0LL;
    v37.m256i_i64[2] = (__int64)&v30;
    v37.m256i_i64[3] = 1LL;
    if ( core::fmt::write(*(_QWORD *)(v28 + 32), *(_QWORD *)(v28 + 40), &v37) )
      return 1;
  }
  v29 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(*(_QWORD *)v8 + 40LL) + 24LL))(
          *(_QWORD *)(*(_QWORD *)v8 + 32LL),
          asc_49545,
          1LL);
  result = 1;
  a1 = v48;
  if ( !v29 )
  {
LABEL_3:
    *(_QWORD *)(a1 + 8) = v9 + 1;
    return 0;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 41EB0: using guessed type void __noreturn core::ops::function::FnOnce::call_once();
// 49545: using guessed type char asc_49545;
// 589A8: using guessed type char *off_589A8;
// 591A0: using guessed type char *off_591A0;
// 591C0: using guessed type char *off_591C0;
// 591E0: using guessed type void *off_591E0;

//----- (0000000000027A80) ----------------------------------------------------
__int64 __fastcall <std::io::error::ErrorKind as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
}

//----- (0000000000027AB0) ----------------------------------------------------
char __fastcall <std::path::Component as core::cmp::PartialEq>::eq(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // rdx
  char result; // al
  __int64 v5; // r10
  __int64 v6; // r11
  size_t v7; // rdx
  const void *v8; // rsi
  const void *v9; // rdi
  size_t v11; // rdx

  v2 = (unsigned __int8)(*(_BYTE *)a1 - 6);
  v3 = v2 + 1;
  result = 0;
  if ( (unsigned __int8)v2 >= 4u )
    v3 = 0LL;
  v5 = (unsigned __int8)(*(_BYTE *)a2 - 6);
  v6 = v5 + 1;
  if ( (unsigned __int8)v5 >= 4u )
    v6 = 0LL;
  if ( v3 == v6 )
  {
    result = 1;
    if ( (_BYTE)v3 )
    {
      if ( (unsigned __int8)v3 != 4 || (_DWORD)v3 != 4 )
        return result;
LABEL_9:
      v7 = *(_QWORD *)(a1 + 16);
      if ( v7 == *(_QWORD *)(a2 + 16) )
      {
        v8 = *(const void **)(a2 + 8);
        v9 = *(const void **)(a1 + 8);
        return bcmp(v9, v8, v7) == 0;
      }
    }
    else
    {
      if ( (unsigned __int8)(*(_BYTE *)a2 - 6) <= 3u )
        return result;
      if ( *(_BYTE *)a1 == *(_BYTE *)a2 )
      {
        switch ( *(_BYTE *)a1 )
        {
          case 0:
          case 3:
            goto LABEL_9;
          case 1:
          case 4:
            v11 = *(_QWORD *)(a1 + 16);
            if ( v11 != *(_QWORD *)(a2 + 16) )
              return 0;
            if ( bcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v11) )
              return 0;
            v7 = *(_QWORD *)(a1 + 32);
            if ( v7 != *(_QWORD *)(a2 + 32) )
              return 0;
            v8 = *(const void **)(a2 + 24);
            v9 = *(const void **)(a1 + 24);
            break;
          case 2:
          case 5:
            return *(_BYTE *)(a1 + 1) == *(_BYTE *)(a2 + 1);
        }
        return bcmp(v9, v8, v7) == 0;
      }
    }
    return 0;
  }
  return result;
}

//----- (0000000000027B90) ----------------------------------------------------
bool __fastcall <std::path::StripPrefixError as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+0h] [rbp-8h] BYREF

  v3 = a1;
  return core::fmt::Formatter::debug_tuple_field1_finish(
           a2,
           (__int64)&unk_48450,
           16LL,
           (__int64)&v3,
           (__int64)&off_58768);
}
// 58768: using guessed type __int64 (__fastcall *off_58768)();

//----- (0000000000027BC0) ----------------------------------------------------
__int64 __fastcall std::sys::pal::unix::args::imp::ARGV_INIT_ARRAY::init_wrapper(int a1, __int64 a2)
{
  __int64 result; // rax

  result = a1;
  std::sys::pal::unix::args::imp::ARGC = a1;
  std::sys::pal::unix::args::imp::ARGV = a2;
  return result;
}
// 5B130: using guessed type __int64 std::sys::pal::unix::args::imp::ARGC;
// 5B138: using guessed type __int64 std::sys::pal::unix::args::imp::ARGV;

//----- (0000000000027BE0) ----------------------------------------------------
int __fastcall std::sys::pal::unix::fs::File::open_c(__int64 a1, const char *a2, __int64 a3)
{
  __int64 v4; // rbx
  char v5; // cl
  char v6; // al
  int v7; // ebp
  char v8; // cl
  char v9; // al
  unsigned __int64 v10; // rax
  int v11; // esi
  bool v12; // cl
  int v13; // esi
  int v14; // esi
  bool v15; // cl
  int v16; // ebp
  unsigned int v17; // r15d
  int v18; // r12d
  unsigned int v19; // ecx
  unsigned __int64 v21[7]; // [rsp+10h] [rbp-38h] BYREF

  v4 = a1;
  v5 = *(_BYTE *)(a3 + 9);
  v6 = *(_BYTE *)(a3 + 10);
  if ( *(_BYTE *)(a3 + 8) )
  {
    v7 = 1026;
    if ( v5 )
    {
      if ( !v6 )
      {
        v7 = 2;
LABEL_8:
        v8 = *(_BYTE *)(a3 + 11);
        v9 = *(_BYTE *)(a3 + 13);
        goto LABEL_18;
      }
    }
    else if ( !v6 )
    {
      if ( *(_BYTE *)(a3 + 11) )
        goto LABEL_17;
      if ( *(_BYTE *)(a3 + 12) )
        goto LABEL_17;
      v7 = 0;
      v9 = 0;
      v8 = 0;
      if ( *(_BYTE *)(a3 + 13) )
        goto LABEL_17;
      goto LABEL_18;
    }
  }
  else
  {
    v7 = 1025;
    if ( v5 )
    {
      if ( !v6 )
      {
        v7 = 1;
        goto LABEL_8;
      }
    }
    else if ( !v6 )
    {
LABEL_17:
      v10 = 0x1600000002LL;
LABEL_29:
      *(_QWORD *)(v4 + 8) = v10;
      v18 = 1;
      goto LABEL_30;
    }
  }
  v8 = *(_BYTE *)(a3 + 11);
  v9 = *(_BYTE *)(a3 + 13);
  if ( v8 && !v9 )
    goto LABEL_17;
LABEL_18:
  if ( *(_BYTE *)(a3 + 12) )
  {
    v11 = 0;
    v12 = v8 != 0;
    if ( !v9 )
    {
      LOBYTE(v11) = v12;
      v13 = (v11 << 9) | 0x40;
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  v14 = 0;
  v15 = v8 != 0;
  if ( v9 )
  {
LABEL_22:
    v13 = 192;
    goto LABEL_23;
  }
  LOBYTE(v14) = v15;
  v13 = v14 << 9;
LABEL_23:
  v16 = v13 | *(_DWORD *)a3 & 0xFFF7FFFC | v7 | 0x80000;
  v17 = *(_DWORD *)(a3 + 4);
  v18 = 0;
  LODWORD(v10) = open64(a2, v16, v17);
  if ( (_DWORD)v10 == -1 )
  {
    while ( 1 )
    {
      v19 = *_errno_location();
      v10 = ((unsigned __int64)v19 << 32) | 2;
      v21[0] = v10;
      if ( v19 != 4 )
        break;
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)v21);
      LODWORD(v10) = open64(a2, v16, v17);
      if ( (_DWORD)v10 != -1 )
      {
        v4 = a1;
        v18 = 0;
        goto LABEL_27;
      }
    }
    v4 = a1;
    goto LABEL_29;
  }
LABEL_27:
  *(_DWORD *)(v4 + 4) = v10;
LABEL_30:
  *(_DWORD *)v4 = v18;
  return v10;
}
// 27BE0: using guessed type unsigned __int64 var_38[7];

//----- (0000000000027D70) ----------------------------------------------------
size_t *__fastcall std::sys::pal::unix::fs::readlink::{{closure}}(size_t *a1, __int64 a2, const char *a3)
{
  size_t v4; // r14
  char *v5; // rax
  char *v6; // r15
  unsigned __int64 v7; // rax
  size_t v8; // r12
  char *v9; // r13
  size_t len; // [rsp+0h] [rbp-48h] BYREF
  char *buf; // [rsp+8h] [rbp-40h]
  unsigned __int64 v13; // [rsp+10h] [rbp-38h]

  v4 = 256LL;
  v5 = (char *)_rust_alloc(256LL, 1LL);
  if ( !v5 )
    alloc::alloc::handle_alloc_error(1LL, 256LL);
  v6 = v5;
  len = 256LL;
  buf = v5;
  v7 = readlink(a3, v5, 0x100uLL);
  if ( v7 != -1LL )
  {
    v13 = v7;
    v4 = 256LL;
    if ( v7 != 256 )
    {
LABEL_6:
      if ( v4 > v7 )
      {
        if ( v7 )
        {
          v8 = v7;
          v9 = (char *)_rust_realloc(v6, v4, 1LL, v7);
          if ( !v9 )
            alloc::alloc::handle_alloc_error(1LL, v8);
        }
        else
        {
          v8 = 0LL;
          v9 = (_BYTE *)(&dword_0 + 1);
          _rust_dealloc(v6, v4, 1LL);
        }
        buf = v9;
        len = v8;
      }
      a1[2] = v13;
      *a1 = len;
      a1[1] = (size_t)buf;
      return a1;
    }
    while ( 1 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&len, v7, 1LL);
      v4 = len;
      v6 = buf;
      v7 = readlink(a3, buf, len);
      if ( v7 == -1LL )
        break;
      v13 = v7;
      if ( v4 != v7 )
        goto LABEL_6;
    }
  }
  a1[1] = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
  *a1 = 0x8000000000000000LL;
  if ( v4 )
    _rust_dealloc(v6, v4, 1LL);
  return a1;
}
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000027F40) ----------------------------------------------------
_QWORD *__fastcall std::sys::pal::unix::fs::stat(_QWORD *dest, const void *a2, size_t a3)
{
  char *v4; // rax
  char *v5; // r14
  __int64 v7; // [rsp+8h] [rbp-2F0h] BYREF
  char *file; // [rsp+10h] [rbp-2E8h]
  struct stat64 buf; // [rsp+20h] [rbp-2D8h] BYREF
  int src[44]; // [rsp+B0h] [rbp-248h] BYREF
  char desta[408]; // [rsp+160h] [rbp-198h] BYREF

  if ( a3 > 0x17F )
  {
    std::sys::pal::common::small_c_string::run_with_cstr_allocating(
      dest,
      a2,
      a3,
      (__int64 (__fastcall *)(_QWORD *, const char *, _BYTE *, __int64))std::sys::pal::unix::fs::stat::{{closure}});
    return dest;
  }
  memcpy(desta, a2, a3);
  desta[a3] = 0;
  core::ffi::c_str::CStr::from_bytes_with_nul(&v7, (__int64)desta, a3 + 1);
  if ( v7 )
  {
    v4 = ptr;
  }
  else
  {
    v5 = file;
    std::sys::pal::unix::fs::try_statx((__int64)src, 4294967196LL, (__int64)file, 0LL);
    if ( src[0] != 3 )
    {
      memcpy(dest, src, 0xB0uLL);
      return dest;
    }
    memset(&buf, 0, sizeof(buf));
    if ( stat64(v5, &buf) != -1 )
    {
      *dest = 0LL;
      memcpy(dest + 4, &buf, 0x90uLL);
      return dest;
    }
    v4 = (char *)(((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2);
  }
  dest[1] = v4;
  *dest = 2LL;
  return dest;
}
// 27F40: using guessed type char dest[408];

//----- (0000000000028090) ----------------------------------------------------
_QWORD *__fastcall std::sys::pal::unix::fs::stat::{{closure}}(_QWORD *dest, __int64 a2, const char *a3)
{
  _QWORD *v4; // rbx
  int *v5; // rsi
  size_t v6; // rdx
  struct stat64 v8; // [rsp+0h] [rbp-158h] BYREF
  int src[48]; // [rsp+98h] [rbp-C0h] BYREF

  v4 = dest;
  std::sys::pal::unix::fs::try_statx((__int64)src, 4294967196LL, (__int64)a3, 0LL);
  if ( src[0] == 3 )
  {
    memset(&v8, 0, sizeof(v8));
    if ( stat64(a3, &v8) == -1 )
    {
      dest[1] = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
      *dest = 2LL;
      return v4;
    }
    *dest = 0LL;
    dest += 4;
    v5 = (int *)&v8;
    v6 = 144LL;
  }
  else
  {
    v5 = src;
    v6 = 176LL;
  }
  memcpy(dest, v5, v6);
  return v4;
}

//----- (0000000000028160) ----------------------------------------------------
size_t *__fastcall std::sys::pal::unix::fs::canonicalize(size_t *a1, const void *a2, size_t a3)
{
  char *v4; // r14
  __int64 v5; // rax
  char *v6; // rdx
  signed __int64 v7; // rax
  size_t v8; // r15
  __int64 v9; // rax
  void *v10; // r12
  __int64 v12[3]; // [rsp+0h] [rbp-1B8h] BYREF
  char dest[416]; // [rsp+18h] [rbp-1A0h] BYREF

  if ( a3 > 0x17F )
  {
    v5 = std::sys::pal::common::small_c_string::run_with_cstr_allocating(a2, a3);
    v4 = v6;
    if ( v5 )
      goto LABEL_5;
  }
  else
  {
    memcpy(dest, a2, a3);
    dest[a3] = 0;
    core::ffi::c_str::CStr::from_bytes_with_nul(v12, (__int64)dest, a3 + 1);
    if ( v12[0] )
    {
      v4 = ptr;
LABEL_5:
      a1[1] = (size_t)v4;
LABEL_6:
      *a1 = 0x8000000000000000LL;
      return a1;
    }
    v4 = realpath((const char *)v12[1], 0LL);
  }
  if ( !v4 )
  {
    a1[1] = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
    goto LABEL_6;
  }
  v7 = strlen(v4);
  v8 = v7;
  if ( v7 )
  {
    if ( v7 < 0 )
      alloc::raw_vec::capacity_overflow();
    v9 = _rust_alloc(v7, 1LL);
    if ( !v9 )
      alloc::alloc::handle_alloc_error(1LL, v8);
    v10 = (void *)v9;
  }
  else
  {
    v10 = &dword_0 + 1;
  }
  memcpy(v10, v4, v8);
  free(v4);
  *a1 = v8;
  a1[1] = (size_t)v10;
  a1[2] = v8;
  return a1;
}
// 281FA: variable 'v6' is possibly undefined
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 28160: using guessed type char dest[416];

//----- (00000000000282B0) ----------------------------------------------------
size_t *__fastcall std::sys::pal::unix::os::getenv::{{closure}}(size_t *a1, __int64 a2, const char *a3)
{
  int v4; // eax
  char *v5; // rax
  char *v6; // r15
  signed __int64 v7; // rax
  size_t v8; // r14
  __int64 v9; // rax
  void *v10; // r12
  signed __int32 v11; // esi

  v4 = std::sys::pal::unix::os::ENV_LOCK;
  if ( (unsigned int)std::sys::pal::unix::os::ENV_LOCK > 0x3FFFFFFD
    || v4 != _InterlockedCompareExchange(
               &std::sys::pal::unix::os::ENV_LOCK,
               std::sys::pal::unix::os::ENV_LOCK + 1,
               std::sys::pal::unix::os::ENV_LOCK) )
  {
    std::sys::sync::rwlock::futex::RwLock::read_contended(&std::sys::pal::unix::os::ENV_LOCK);
  }
  v5 = getenv(a3);
  if ( v5 )
  {
    v6 = v5;
    v7 = strlen(v5);
    v8 = v7;
    if ( v7 )
    {
      if ( v7 < 0 )
        alloc::raw_vec::capacity_overflow();
      v9 = _rust_alloc(v7, 1LL);
      if ( !v9 )
        alloc::alloc::handle_alloc_error(1LL, v8);
      v10 = (void *)v9;
    }
    else
    {
      v10 = &dword_0 + 1;
    }
    memcpy(v10, v6, v8);
    *a1 = v8;
    a1[1] = (size_t)v10;
    a1[2] = v8;
  }
  else
  {
    *a1 = 0x8000000000000000LL;
  }
  v11 = _InterlockedDecrement(&std::sys::pal::unix::os::ENV_LOCK);
  if ( (v11 & 0xBFFFFFFF) == 0x80000000 )
    std::sys::sync::rwlock::futex::RwLock::wake_writer_or_readers(&std::sys::pal::unix::os::ENV_LOCK, v11);
  return a1;
}
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 5B140: using guessed type int std::sys::pal::unix::os::ENV_LOCK;

//----- (0000000000028410) ----------------------------------------------------
void __fastcall __noreturn std::sys::pal::unix::os::exit(int a1)
{
  exit(a1);
}

//----- (0000000000028420) ----------------------------------------------------
int __fastcall std::sys::pal::unix::stack_overflow::imp::signal_handler(
        __int64 sig,
        volatile signed __int64 *(__fastcall *a2)(__int64 a1),
        unsigned __int64 a3)
{
  volatile signed __int64 *(__fastcall *v3)(__int64); // r14
  int v4; // ebx
  unsigned __int64 v5; // r15
  unsigned __int64 v6; // rax
  __int64 v7; // r12
  bool v8; // cl
  volatile signed __int64 *(__fastcall *v9)(__int64); // rsi
  volatile signed __int64 *v11; // rbx
  const char *v12; // rax
  __int64 v13; // rcx
  char v14[8]; // [rsp+8h] [rbp-F0h] BYREF
  char **v15; // [rsp+10h] [rbp-E8h] BYREF
  __int64 v16; // [rsp+18h] [rbp-E0h]
  char **v17; // [rsp+20h] [rbp-D8h] BYREF
  volatile signed __int64 *v18; // [rsp+28h] [rbp-D0h] BYREF
  __int64 v19[2]; // [rsp+30h] [rbp-C8h] BYREF
  struct sigaction act; // [rsp+40h] [rbp-B8h] BYREF

  v3 = a2;
  v4 = sig;
  v5 = __readfsqword(0);
  v6 = *(unsigned __int8 *)(v5 - 32);
  if ( (_DWORD)v6 != 1 )
  {
    if ( *(_BYTE *)(v5 - 32) )
    {
      v8 = 1;
      goto LABEL_9;
    }
    sig = v5 - 64;
    a2 = std::sys_common::thread_info::THREAD_INFO::__getit::destroy;
    std::sys::pal::unix::thread_local_dtor::register_dtor(
      v5 - 64,
      (__int64)std::sys_common::thread_info::THREAD_INFO::__getit::destroy);
    *(_BYTE *)(v5 - 32) = 1;
  }
  if ( !*(_QWORD *)(v5 - 40) )
  {
    sig = 0LL;
    v7 = std::thread::Thread::new(0LL, (__int64)a2);
    if ( *(_QWORD *)(v5 - 40) )
    {
      v16 = v7;
      v15 = (char **)(v5 - 40);
      act.sa_handler = (__sighandler_t)&off_583A8;
      act.sa_mask.__val[0] = 1LL;
      act.sa_mask.__val[1] = (unsigned __int64)aRustc9b00956e5;
      *(_OWORD *)&act.sa_mask.__val[2] = 0LL;
      core::panicking::panic_fmt((__int64)&act, (__int64)&off_583B8);
    }
    *(_QWORD *)(v5 - 40) = v7;
  }
  v8 = *(_QWORD *)(v5 - 64) == 0LL;
  a3 = *(_QWORD *)(v5 - 56);
  v6 = *(_QWORD *)(v5 - 48);
LABEL_9:
  v9 = (volatile signed __int64 *(__fastcall *)(__int64))*((_QWORD *)v3 + 2);
  if ( (v8 || a3 <= (unsigned __int64)v9) && !v8 && v6 > (unsigned __int64)v9 )
  {
    v11 = std::thread::current(sig, v9);
    v18 = v11;
    v12 = (const char *)*((_QWORD *)v11 + 3);
    if ( v12 )
    {
      v13 = *((_QWORD *)v11 + 4) - 1LL;
    }
    else
    {
      v13 = 9LL;
      v12 = aUnknown;
    }
    v15 = (char **)v12;
    v16 = v13;
    v19[0] = (__int64)&v15;
    v19[1] = (__int64)<&T as core::fmt::Display>::fmt;
    act.sa_handler = (__sighandler_t)&off_59230;
    act.sa_mask.__val[0] = 2LL;
    act.sa_mask.__val[3] = 0LL;
    act.sa_mask.__val[1] = (unsigned __int64)v19;
    act.sa_mask.__val[2] = 1LL;
    v17 = std::io::Write::write_fmt((__int64)v14, &act);
    if ( v17 )
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v17);
    if ( !_InterlockedDecrement64(v11) )
      alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v18);
    act.sa_handler = (__sighandler_t)&off_59250;
    act.sa_mask.__val[0] = 1LL;
    act.sa_mask.__val[1] = (unsigned __int64)v14;
    *(_OWORD *)&act.sa_mask.__val[2] = 0LL;
    v15 = std::io::Write::write_fmt((__int64)v14, &act);
    if ( v15 )
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v15);
    std::sys::pal::unix::abort_internal();
  }
  memset(&act, 0, sizeof(act));
  return sigaction(v4, &act, 0LL);
}
// 583A8: using guessed type char *off_583A8;
// 583B8: using guessed type char *off_583B8;
// 59230: using guessed type char *off_59230;
// 59250: using guessed type char *off_59250;
// 28420: using guessed type char var_F0[8];

//----- (00000000000286B0) ----------------------------------------------------
void *std::sys::pal::unix::stack_overflow::imp::make_handler()
{
  __int64 v0; // rbx
  unsigned __int64 v1; // rax
  size_t v2; // r15
  __int64 v3; // rbx
  char *v4; // rax
  char *v5; // r14
  unsigned __int64 v7; // [rsp+8h] [rbp-80h] BYREF
  struct sigaltstack oss; // [rsp+10h] [rbp-78h] BYREF
  unsigned __int64 *v9; // [rsp+30h] [rbp-58h] BYREF
  char (__fastcall *v10)(__int64 *, __int64); // [rsp+38h] [rbp-50h]
  char **v11; // [rsp+40h] [rbp-48h] BYREF
  __int64 v12; // [rsp+48h] [rbp-40h]
  __int64 *v13; // [rsp+50h] [rbp-38h]
  __int64 v14; // [rsp+58h] [rbp-30h]
  __int64 v15; // [rsp+60h] [rbp-28h]

  if ( !std::sys::pal::unix::stack_overflow::imp::NEED_ALTSTACK )
    return 0LL;
  memset(&oss, 0, sizeof(oss));
  v0 = 0LL;
  sigaltstack(0LL, &oss);
  if ( (oss.ss_flags & 2) != 0 )
  {
    v1 = getauxval(0x33uLL);
    v2 = 0x2000LL;
    if ( v1 >= 0x2001 )
      v2 = v1;
    v3 = sysconf(30);
    v4 = (char *)mmap64(0LL, v2 + v3, 3, 131106, -1, 0LL);
    if ( v4 == (char *)-1LL )
    {
      v7 = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
      v9 = &v7;
      v10 = <std::io::error::Error as core::fmt::Display>::fmt;
      v11 = &off_59288;
      v12 = 1LL;
      v15 = 0LL;
      v13 = (__int64 *)&v9;
      v14 = 1LL;
      core::panicking::panic_fmt((__int64)&v11, (__int64)&off_59298);
    }
    v5 = v4;
    if ( mprotect(v4, v3, 0) )
    {
      v7 = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
      v9 = &v7;
      v10 = <std::io::error::Error as core::fmt::Display>::fmt;
      v11 = &off_59260;
      v12 = 1LL;
      v15 = 0LL;
      v13 = (__int64 *)&v9;
      v14 = 1LL;
      core::panicking::panic_fmt((__int64)&v11, (__int64)&off_59270);
    }
    oss.ss_sp = &v5[v3];
    oss.ss_flags = 0;
    oss.ss_size = v2;
    sigaltstack(&oss, 0LL);
    return oss.ss_sp;
  }
  return (void *)v0;
}
// 59260: using guessed type char *off_59260;
// 59270: using guessed type char *off_59270;
// 59288: using guessed type char *off_59288;
// 59298: using guessed type char *off_59298;
// 5B158: using guessed type char std::sys::pal::unix::stack_overflow::imp::NEED_ALTSTACK;

//----- (00000000000288A0) ----------------------------------------------------
__int64 __fastcall <std::sys::pal::unix::stdio::Stderr as std::io::Write>::write(__int64 a1, const void *a2, size_t a3)
{
  if ( a3 >= 0x7FFFFFFFFFFFFFFFLL )
    a3 = 0x7FFFFFFFFFFFFFFFLL;
  if ( write(2, a2, a3) != -1 )
    return 0LL;
  _errno_location();
  return 1LL;
}

//----- (00000000000288F0) ----------------------------------------------------
__int64 __fastcall <std::sys::pal::unix::stdio::Stderr as std::io::Write>::write_vectored(
        __int64 a1,
        const struct iovec *a2,
        unsigned __int64 a3)
{
  if ( a3 >= 0x400 )
    LODWORD(a3) = 1024;
  if ( writev(2, a2, a3) != -1 )
    return 0LL;
  _errno_location();
  return 1LL;
}

//----- (0000000000028930) ----------------------------------------------------
char <std::sys::pal::unix::stdio::Stderr as std::io::Write>::is_write_vectored()
{
  return 1;
}

//----- (0000000000028940) ----------------------------------------------------
__int64 <std::sys::pal::unix::stdio::Stderr as std::io::Write>::flush()
{
  return 0LL;
}
// 28940: using guessed type __int64 <std::sys::pal::unix::stdio::Stderr as std::io::Write>::flush();

//----- (0000000000028950) ----------------------------------------------------
__int64 __fastcall std::sys::pal::unix::thread_local_dtor::register_dtor(__int64 a1, __int64 a2)
{
  pthread_key_t v4; // edi
  _QWORD *v5; // rax
  _QWORD *v6; // r15
  __int64 v7; // rsi
  __int64 result; // rax
  __int64 v9; // rcx
  pthread_key_t v10; // eax
  _QWORD *v11; // rax
  pthread_key_t v12; // edi
  _QWORD *v13; // r15
  pthread_key_t v14; // eax
  __int64 v15; // [rsp+0h] [rbp-58h] BYREF
  char **v16; // [rsp+8h] [rbp-50h] BYREF
  __int64 v17[3]; // [rsp+10h] [rbp-48h] BYREF
  __int128 v18; // [rsp+28h] [rbp-30h]

  if ( &_cxa_thread_atexit_impl )
    return _cxa_thread_atexit_impl(a2, a1, &rust_extern_with_linkage___dso_handle);
  if ( *(_QWORD *)&std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS )
  {
    if ( pthread_getspecific(std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS) )
      goto LABEL_4;
  }
  else
  {
    v10 = std::sys_common::thread_local_key::StaticKey::lazy_init();
    if ( pthread_getspecific(v10) )
    {
LABEL_4:
      v4 = std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS;
      if ( *(_QWORD *)&std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS )
        goto LABEL_5;
LABEL_15:
      v14 = std::sys_common::thread_local_key::StaticKey::lazy_init();
      v5 = pthread_getspecific(v14);
      if ( !*v5 )
        goto LABEL_6;
LABEL_16:
      v17[0] = (__int64)&off_58EC0;
      v17[1] = 1LL;
      v17[2] = (__int64)&v15;
      v18 = 0LL;
      v16 = std::io::Write::write_fmt((__int64)&v15, v17);
      core::ptr::drop_in_place<core::result::Result<(),std::io::error::Error>>((__int64 *)&v16);
      std::sys::pal::unix::abort_internal();
    }
  }
  v11 = (_QWORD *)_rust_alloc(32LL, 8LL);
  if ( !v11 )
    alloc::alloc::handle_alloc_error(8LL, 32LL);
  *(_OWORD *)v11 = 0LL;
  v11[2] = 8LL;
  v11[3] = 0LL;
  v12 = std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS;
  if ( !*(_QWORD *)&std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS )
  {
    v13 = v11;
    v12 = std::sys_common::thread_local_key::StaticKey::lazy_init();
    v11 = v13;
  }
  pthread_setspecific(v12, v11);
  v4 = std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS;
  if ( !*(_QWORD *)&std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS )
    goto LABEL_15;
LABEL_5:
  v5 = pthread_getspecific(v4);
  if ( *v5 )
    goto LABEL_16;
LABEL_6:
  v6 = v5;
  *v5 = -1LL;
  v7 = v5[3];
  if ( v7 == v5[1] )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(v5 + 1, v7);
    v7 = v6[3];
  }
  result = v6[2];
  v9 = 16 * v7;
  *(_QWORD *)(result + v9) = a1;
  *(_QWORD *)(result + v9 + 8) = a2;
  v6[3] = v7 + 1;
  ++*v6;
  return result;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 58EC0: using guessed type char *off_58EC0;
// 5B028: using guessed type void **rust_extern_with_linkage___dso_handle;
// 5B228: using guessed type __int64 __fastcall _cxa_thread_atexit_impl(_QWORD, _QWORD, _QWORD);

//----- (0000000000028B10) ----------------------------------------------------
char __fastcall std::sys::pal::unix::decode_error_kind(int a1)
{
  char result; // al

  switch ( a1 )
  {
    case 1:
    case 13:
      result = 1;
      break;
    case 2:
      result = 0;
      break;
    case 4:
      result = 35;
      break;
    case 7:
      result = 34;
      break;
    case 11:
      result = 13;
      break;
    case 12:
      result = 38;
      break;
    case 16:
      result = 28;
      break;
    case 17:
      result = 12;
      break;
    case 18:
      result = 31;
      break;
    case 20:
      result = 14;
      break;
    case 21:
      result = 15;
      break;
    case 22:
      result = 20;
      break;
    case 26:
      result = 29;
      break;
    case 27:
      result = 27;
      break;
    case 28:
      result = 24;
      break;
    case 29:
      result = 25;
      break;
    case 30:
      result = 17;
      break;
    case 31:
      result = 32;
      break;
    case 32:
      result = 11;
      break;
    case 35:
      result = 30;
      break;
    case 36:
      result = 33;
      break;
    case 38:
      result = 36;
      break;
    case 39:
      result = 16;
      break;
    case 40:
      result = 18;
      break;
    case 98:
      result = 8;
      break;
    case 99:
      result = 9;
      break;
    case 100:
      result = 10;
      break;
    case 101:
      result = 5;
      break;
    case 103:
      result = 6;
      break;
    case 104:
      result = 3;
      break;
    case 107:
      result = 7;
      break;
    case 110:
      result = 22;
      break;
    case 111:
      result = 2;
      break;
    case 113:
      result = 4;
      break;
    case 116:
      result = 19;
      break;
    case 122:
      result = 26;
      break;
    default:
      result = 40;
      break;
  }
  return result;
}

//----- (0000000000028BA0) ----------------------------------------------------
void __noreturn std::sys::pal::unix::abort_internal()
{
  abort();
}

//----- (0000000000028BB0) ----------------------------------------------------
__int64 __fastcall std::sys::pal::unix::fs::try_statx(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rcx
  int v7; // edx
  unsigned __int64 v8; // r14
  int v9; // eax
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // [rsp+0h] [rbp-128h] BYREF
  unsigned __int64 v12; // [rsp+8h] [rbp-120h] BYREF
  __int128 v13; // [rsp+10h] [rbp-118h] BYREF
  __int128 v14; // [rsp+20h] [rbp-108h]
  __int128 v15; // [rsp+30h] [rbp-F8h]
  __int128 v16; // [rsp+40h] [rbp-E8h]
  __int128 v17; // [rsp+50h] [rbp-D8h]
  __int128 v18; // [rsp+60h] [rbp-C8h]
  __int128 v19; // [rsp+70h] [rbp-B8h]
  __int128 v20; // [rsp+80h] [rbp-A8h]
  __int128 v21; // [rsp+90h] [rbp-98h]
  __int128 v22; // [rsp+A0h] [rbp-88h]
  __int128 v23; // [rsp+B0h] [rbp-78h]
  __int128 v24; // [rsp+C0h] [rbp-68h]
  __int128 v25; // [rsp+D0h] [rbp-58h]
  __int128 v26; // [rsp+E0h] [rbp-48h]
  __int128 v27; // [rsp+F0h] [rbp-38h]
  __int128 v28; // [rsp+100h] [rbp-28h]

  result = (unsigned __int8)std::sys::pal::unix::fs::try_statx::STATX_SAVED_STATE;
  if ( std::sys::pal::unix::fs::try_statx::STATX_SAVED_STATE == 2 )
  {
    *(_QWORD *)a1 = 3LL;
    return result;
  }
  v28 = 0LL;
  v27 = 0LL;
  v26 = 0LL;
  v25 = 0LL;
  v24 = 0LL;
  v23 = 0LL;
  v22 = 0LL;
  v21 = 0LL;
  v20 = 0LL;
  v19 = 0LL;
  v18 = 0LL;
  v17 = 0LL;
  v16 = 0LL;
  v15 = 0LL;
  v14 = 0LL;
  v13 = 0LL;
  if ( &statx )
  {
    if ( (unsigned int)statx((unsigned int)a2, a3, (unsigned int)a4, 4095LL, &v13) != -1 )
      goto LABEL_5;
  }
  else if ( (unsigned int)syscall(332LL, a2, a3, a4, 4095LL, &v13) != -1 )
  {
LABEL_5:
    v5 = (DWORD2(v21) << 8) & 0xFFF00 | ((unsigned __int64)(DWORD2(v21) & 0xFFFFF000) << 32) | BYTE12(v21) | ((unsigned __int64)HIDWORD(v21) << 12) & 0xFFFFFFFFFFF00000LL;
    v6 = ((_DWORD)v21 << 8) & 0xFFF00 | ((unsigned __int64)((unsigned int)v21 & 0xFFFFF000) << 32) | BYTE4(v21) | ((unsigned __int64)DWORD1(v21) << 12) & 0xFFFFFFFFFFF00000LL;
    v7 = v13;
    *(_QWORD *)a1 = 1LL;
    *(_OWORD *)(a1 + 8) = v18;
    *(_DWORD *)(a1 + 24) = v7;
    *(_QWORD *)(a1 + 32) = v5;
    *(_QWORD *)(a1 + 40) = v15;
    *(_QWORD *)(a1 + 48) = (unsigned int)v14;
    *(_DWORD *)(a1 + 56) = WORD6(v14);
    *(_QWORD *)(a1 + 60) = *(_QWORD *)((char *)&v14 + 4);
    *(_DWORD *)(a1 + 68) = 0;
    *(_QWORD *)(a1 + 72) = v6;
    *(_QWORD *)(a1 + 80) = *((_QWORD *)&v15 + 1);
    *(_QWORD *)(a1 + 88) = DWORD1(v13);
    *(_QWORD *)(a1 + 96) = v16;
    *(_QWORD *)(a1 + 104) = v17;
    *(_QWORD *)(a1 + 112) = DWORD2(v17);
    *(_QWORD *)(a1 + 120) = v20;
    *(_QWORD *)(a1 + 128) = DWORD2(v20);
    *(_QWORD *)(a1 + 136) = v19;
    result = DWORD2(v19);
    *(_QWORD *)(a1 + 144) = DWORD2(v19);
    *(_OWORD *)(a1 + 152) = 0LL;
    *(_QWORD *)(a1 + 168) = 0LL;
    return result;
  }
  v8 = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
  v11 = v8;
  result = (unsigned __int8)std::sys::pal::unix::fs::try_statx::STATX_SAVED_STATE;
  if ( std::sys::pal::unix::fs::try_statx::STATX_SAVED_STATE == 1 )
    goto LABEL_8;
  if ( HIDWORD(v8) != 38 )
  {
    v9 = &statx ? statx(0LL, 0LL, 0LL, 4095LL, 0LL) : syscall(332LL, 0LL, 0LL, 0LL, 4095LL, 0LL, v11);
    if ( v9 == -1 )
    {
      v10 = ((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2;
      v12 = v10;
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v12);
      result = 0xE00000000LL;
      if ( (v10 & 0xFFFFFFFF00000000LL) == 0xE00000000LL )
      {
        std::sys::pal::unix::fs::try_statx::STATX_SAVED_STATE = 1;
LABEL_8:
        *(_QWORD *)a1 = 2LL;
        *(_QWORD *)(a1 + 8) = v8;
        return result;
      }
    }
  }
  std::sys::pal::unix::fs::try_statx::STATX_SAVED_STATE = 2;
  *(_QWORD *)a1 = 3LL;
  return core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v11);
}
// 5B169: using guessed type char std::sys::pal::unix::fs::try_statx::STATX_SAVED_STATE;
// 5B330: using guessed type __int64 __fastcall statx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028ED0) ----------------------------------------------------
_Unwind_Ptr __fastcall std::sys::personality::gcc::find_eh_action::{{closure}}(struct _Unwind_Context ***a1)
{
  return Unwind_GetTextRelBase(**a1);
}

//----- (0000000000028EE0) ----------------------------------------------------
_Unwind_Ptr __fastcall std::sys::personality::gcc::find_eh_action::{{closure}}(struct _Unwind_Context ***a1)
{
  return Unwind_GetDataRelBase(**a1);
}

//----- (0000000000028EF0) ----------------------------------------------------
__int64 __fastcall rust_eh_personality(int a1, int a2, __int64 a3, __int64 a4, struct _Unwind_Context *a5)
{
  unsigned int v5; // r12d
  unsigned __int8 *LanguageSpecificData; // r15
  __int64 v8; // rax
  unsigned __int64 v9; // r13
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned int v13; // ebp
  char *v14; // r14
  __int64 v15; // r8
  __int64 **v16; // rdi
  __int64 (__fastcall **v17)(); // rax
  _QWORD *v18; // r8
  __int64 v19; // rax
  unsigned __int8 *v20; // r15
  __int64 v21; // rax
  unsigned int v22; // ecx
  char v23; // dl
  unsigned __int64 v24; // rsi
  __int64 v25; // rsi
  __int64 v26; // rcx
  char v27; // dl
  unsigned __int64 v28; // rsi
  char *v29; // rax
  unsigned __int8 *v30; // r11
  unsigned int v32; // esi
  char *v33; // r11
  __int64 v34; // rcx
  __int64 v35; // rdx
  char v36; // al
  unsigned __int64 v37; // rdi
  char *v38; // rax
  __int64 v39; // rdi
  __int64 v40; // r14
  __int64 v41; // rbp
  __int64 v42; // r15
  __int64 v43; // rcx
  char v44; // r10
  unsigned __int64 v45; // r15
  __int64 v46; // r14
  unsigned int v47; // ecx
  char v48; // r10
  unsigned __int64 v49; // r15
  __int64 v50; // r15
  __int64 v51; // rcx
  char v52; // r10
  unsigned __int64 v53; // r15
  __int64 v54; // rcx
  __int64 v55; // r10
  char v56; // r9
  unsigned __int64 v57; // r8
  char *v58; // r14
  __int64 v59; // rbp
  unsigned int v60; // ecx
  char v61; // r10
  unsigned __int64 v62; // r15
  __int64 v63; // r15
  __int64 v64; // rcx
  char v65; // r8
  unsigned __int64 v66; // r10
  __int64 v67; // r15
  unsigned int v68; // ecx
  char v69; // r8
  unsigned __int64 v70; // r10
  __int64 v71; // r10
  char v72; // dl
  __int128 v73; // rax
  unsigned int v74; // ecx
  char v75; // si
  unsigned __int64 v76; // rdi
  int v78; // [rsp+Ch] [rbp-7Ch] BYREF
  __int64 v79; // [rsp+10h] [rbp-78h]
  _QWORD *v80; // [rsp+18h] [rbp-70h]
  int v81; // [rsp+24h] [rbp-64h]
  _Unwind_Ptr v82[2]; // [rsp+28h] [rbp-60h]
  _Unwind_Word v83[2]; // [rsp+30h] [rbp-58h]
  unsigned __int64 v84; // [rsp+38h] [rbp-50h]
  struct _Unwind_Context *v85; // [rsp+40h] [rbp-48h] BYREF
  __int64 *v86; // [rsp+48h] [rbp-40h] BYREF
  __int64 *v87; // [rsp+50h] [rbp-38h] BYREF

  v5 = 3;
  if ( a1 == 1 )
  {
    v81 = a2;
    *(_QWORD *)v83 = a4;
    v85 = a5;
    LanguageSpecificData = (unsigned __int8 *)Unwind_GetLanguageSpecificData(a5);
    v78 = 0;
    LODWORD(v8) = Unwind_GetIPInfo(a5, &v78);
    v9 = v8 - (v78 == 0);
    LODWORD(v10) = Unwind_GetRegionStart(a5);
    v80 = (_QWORD *)v10;
    v86 = (__int64 *)&v85;
    v87 = (__int64 *)&v85;
    if ( LanguageSpecificData )
    {
      v13 = *LanguageSpecificData;
      v14 = (char *)(LanguageSpecificData + 1);
      if ( v13 == 255 )
      {
        v18 = v80;
      }
      else
      {
        v15 = (__int64)(LanguageSpecificData + 1);
        switch ( (v13 >> 4) & 7 )
        {
          case 0u:
            goto LABEL_14;
          case 1u:
            goto LABEL_11;
          case 2u:
            v16 = &v86;
            v17 = &off_59320;
            goto LABEL_10;
          case 3u:
            v16 = &v87;
            v17 = &off_59350;
LABEL_10:
            v15 = ((__int64 (__fastcall *)(__int64 **, int *, __int64, __int64, __int64))v17[5])(
                    v16,
                    &v78,
                    v11,
                    v12,
                    v15);
            if ( v15 )
              goto LABEL_11;
            goto LABEL_14;
          case 4u:
            v15 = (__int64)v80;
            if ( !v80 )
              return v5;
LABEL_11:
            switch ( v13 & 0xF )
            {
              case 0u:
              case 4u:
              case 0xCu:
                v19 = *(_QWORD *)(LanguageSpecificData + 1);
                v20 = LanguageSpecificData + 9;
                goto LABEL_31;
              case 1u:
                v19 = 0LL;
                v26 = 0LL;
                do
                {
                  v27 = *v14;
                  v28 = (unsigned __int64)(*v14++ & 0x7F) << v26;
                  v19 |= v28;
                  v26 += 7LL;
                }
                while ( v27 < 0 );
                goto LABEL_32;
              case 2u:
                v19 = *(unsigned __int16 *)(LanguageSpecificData + 1);
                v20 = LanguageSpecificData + 3;
                goto LABEL_31;
              case 3u:
                v19 = *(unsigned int *)(LanguageSpecificData + 1);
                goto LABEL_30;
              case 9u:
                v21 = 0LL;
                v22 = 0;
                do
                {
                  v23 = *v14;
                  v24 = (unsigned __int64)(*v14++ & 0x7F) << v22;
                  v21 |= v24;
                  v22 += 7;
                }
                while ( v23 < 0 );
                v25 = -1LL << v22;
                if ( (unsigned __int8)v23 < 0x40u )
                  v25 = 0LL;
                if ( v22 >= 0x40 )
                  v25 = 0LL;
                v19 = v25 | v21;
                goto LABEL_32;
              case 0xAu:
                v19 = *(__int16 *)(LanguageSpecificData + 1);
                v20 = LanguageSpecificData + 3;
                goto LABEL_31;
              case 0xBu:
                v19 = *(int *)(LanguageSpecificData + 1);
LABEL_30:
                v20 = LanguageSpecificData + 5;
LABEL_31:
                v14 = (char *)v20;
LABEL_32:
                v18 = (_QWORD *)(v19 + v15);
                goto LABEL_33;
              default:
                return v5;
            }
          case 5u:
            v14 = (char *)((unsigned __int64)(LanguageSpecificData + 8) & 0xFFFFFFFFFFFFFFF8LL);
LABEL_14:
            if ( (v13 & 0xF) != 0 )
              return v5;
            v18 = *(_QWORD **)v14;
            v14 += 8;
LABEL_33:
            if ( (v13 & 0x80u) != 0 )
              v18 = (_QWORD *)*v18;
            break;
          default:
            return v5;
        }
      }
      v29 = v14 + 1;
      if ( *v14 == -1 )
      {
        v30 = (unsigned __int8 *)(v14 + 1);
      }
      else
      {
        do
          v30 = (unsigned __int8 *)(v29 + 1);
        while ( *v29++ < 0 );
      }
      v32 = *v30;
      v33 = (char *)(v30 + 1);
      v34 = 0LL;
      v35 = 0LL;
      do
      {
        v36 = *v33;
        v37 = (unsigned __int64)(*v33++ & 0x7F) << v34;
        v35 |= v37;
        v34 += 7LL;
      }
      while ( v36 < 0 );
      if ( (unsigned __int8)v32 > 0xFu )
      {
        if ( v35 > 0 )
          return v5;
        v39 = 4LL;
      }
      else
      {
        *(_QWORD *)v82 = v18;
        v84 = (unsigned __int64)&v33[v35];
        v79 = v32;
        v38 = v33;
        v39 = 4LL;
        while ( 2 )
        {
          if ( (unsigned __int64)v38 < v84 )
          {
            switch ( v32 )
            {
              case 0u:
              case 4u:
              case 0xCu:
                v40 = *(_QWORD *)v38;
                v38 += 8;
LABEL_46:
                v41 = *(_QWORD *)v38;
                v38 += 8;
LABEL_47:
                v42 = *(_QWORD *)v38;
                v38 += 8;
                goto LABEL_75;
              case 1u:
                v40 = 0LL;
                v43 = 0LL;
                do
                {
                  v44 = *v38;
                  v45 = (unsigned __int64)(*v38++ & 0x7F) << v43;
                  v40 |= v45;
                  v43 += 7LL;
                }
                while ( v44 < 0 );
                goto LABEL_64;
              case 2u:
                v40 = *(unsigned __int16 *)v38;
                v38 += 2;
LABEL_69:
                v41 = *(unsigned __int16 *)v38;
                v38 += 2;
LABEL_70:
                v42 = *(unsigned __int16 *)v38;
                goto LABEL_74;
              case 3u:
                v40 = *(unsigned int *)v38;
                v38 += 4;
LABEL_49:
                v41 = *(unsigned int *)v38;
                v38 += 4;
LABEL_50:
                v42 = *(unsigned int *)v38;
                v38 += 4;
                goto LABEL_75;
              case 9u:
                v46 = 0LL;
                v47 = 0;
                do
                {
                  v48 = *v38;
                  v49 = (unsigned __int64)(*v38++ & 0x7F) << v47;
                  v46 |= v49;
                  v47 += 7;
                }
                while ( v48 < 0 );
                v50 = -1LL << v47;
                if ( (unsigned __int8)v48 < 0x40u )
                  v50 = 0LL;
                if ( v47 >= 0x40 )
                  v50 = 0LL;
                v40 = v50 | v46;
LABEL_64:
                switch ( v32 )
                {
                  case 0u:
                  case 4u:
                  case 0xCu:
                    goto LABEL_46;
                  case 1u:
                    v41 = 0LL;
                    v51 = 0LL;
                    do
                    {
                      v52 = *v38;
                      v53 = (unsigned __int64)(*v38++ & 0x7F) << v51;
                      v41 |= v53;
                      v51 += 7LL;
                    }
                    while ( v52 < 0 );
                    goto LABEL_87;
                  case 2u:
                    goto LABEL_69;
                  case 3u:
                    goto LABEL_49;
                  case 9u:
                    v59 = 0LL;
                    v60 = 0;
                    do
                    {
                      v61 = *v38;
                      v62 = (unsigned __int64)(*v38++ & 0x7F) << v60;
                      v59 |= v62;
                      v60 += 7;
                    }
                    while ( v61 < 0 );
                    v63 = -1LL << v60;
                    if ( (unsigned __int8)v61 < 0x40u )
                      v63 = 0LL;
                    if ( v60 >= 0x40 )
                      v63 = 0LL;
                    v41 = v63 | v59;
LABEL_87:
                    switch ( v32 )
                    {
                      case 0u:
                      case 4u:
                      case 0xCu:
                        goto LABEL_47;
                      case 1u:
                        v42 = 0LL;
                        v64 = 0LL;
                        do
                        {
                          v65 = *v38;
                          v66 = (unsigned __int64)(*v38++ & 0x7F) << v64;
                          v42 |= v66;
                          v64 += 7LL;
                        }
                        while ( v65 < 0 );
                        goto LABEL_75;
                      case 2u:
                        goto LABEL_70;
                      case 3u:
                        goto LABEL_50;
                      case 9u:
                        v67 = 0LL;
                        v68 = 0;
                        do
                        {
                          v69 = *v38;
                          v70 = (unsigned __int64)(*v38++ & 0x7F) << v68;
                          v67 |= v70;
                          v68 += 7;
                        }
                        while ( v69 < 0 );
                        v71 = -1LL << v68;
                        if ( (unsigned __int8)v69 < 0x40u )
                          v71 = 0LL;
                        if ( v68 >= 0x40 )
                          v71 = 0LL;
                        v42 = v71 | v67;
                        goto LABEL_75;
                      case 0xAu:
                        goto LABEL_73;
                      case 0xBu:
                        goto LABEL_56;
                      default:
                        return v5;
                    }
                  case 0xAu:
                    goto LABEL_72;
                  case 0xBu:
                    goto LABEL_55;
                  default:
                    return v5;
                }
                return v5;
              case 0xAu:
                v40 = *(__int16 *)v38;
                v38 += 2;
LABEL_72:
                v41 = *(__int16 *)v38;
                v38 += 2;
LABEL_73:
                v42 = *(__int16 *)v38;
LABEL_74:
                v38 += 2;
                goto LABEL_75;
              case 0xBu:
                v40 = *(int *)v38;
                v38 += 4;
LABEL_55:
                v41 = *(int *)v38;
                v38 += 4;
LABEL_56:
                v42 = *(int *)v38;
                v38 += 4;
LABEL_75:
                v54 = 0LL;
                v55 = 0LL;
                do
                {
                  v56 = *v38;
                  v57 = (unsigned __int64)(*v38++ & 0x7F) << v54;
                  v55 |= v57;
                  v54 += 7LL;
                }
                while ( v56 < 0 );
                v58 = (char *)v80 + v40;
                if ( v9 < (unsigned __int64)v58 )
                  goto LABEL_115;
                if ( v9 >= (unsigned __int64)&v58[v41] )
                  continue;
                if ( !v42 )
                  goto LABEL_114;
                *(_QWORD *)v82 += v42;
                if ( v55 )
                {
                  *((_QWORD *)&v73 + 1) = &v33[v55 - 1 + v35];
                  *(_QWORD *)&v73 = 0LL;
                  v74 = 0;
                  do
                  {
                    v75 = **((_BYTE **)&v73 + 1);
                    v76 = (unsigned __int64)(**((_BYTE **)&v73 + 1) & 0x7F) << v74;
                    ++*((_QWORD *)&v73 + 1);
                    *(_QWORD *)&v73 = v76 | v73;
                    v74 += 7;
                  }
                  while ( v75 < 0 );
                  *((_QWORD *)&v73 + 1) = -1LL << v74;
                  if ( (unsigned __int8)v75 < 0x40u )
                    *((_QWORD *)&v73 + 1) = 0LL;
                  if ( v74 >= 0x40 )
                    *((_QWORD *)&v73 + 1) = 0LL;
                  v39 = 1LL;
                  if ( v73 != 0 )
                    v39 = ((__int64)(*((_QWORD *)&v73 + 1) | v73) >= 0 && v73 != 0) ^ 3LL;
                  v72 = v81;
                  if ( (v81 & 1) == 0 )
                    goto LABEL_116;
                }
                else
                {
                  v39 = 1LL;
                  v72 = v81;
                  if ( (v81 & 1) == 0 )
                    goto LABEL_116;
                }
                break;
              default:
                return v5;
            }
            return dword_4A994[v39];
          }
          break;
        }
      }
      v72 = v81;
      if ( (v81 & 1) != 0 )
        return dword_4A994[v39];
    }
    else
    {
LABEL_114:
      v39 = 0LL;
LABEL_115:
      v72 = v81;
      if ( (v81 & 1) != 0 )
        return dword_4A994[v39];
    }
LABEL_116:
    v5 = 8;
    switch ( v39 )
    {
      case 0LL:
        return v5;
      case 1LL:
      case 2LL:
        goto LABEL_117;
      case 3LL:
        if ( (v72 & 8) == 0 )
        {
LABEL_117:
          Unwind_SetGR(a5, 0, v83[0]);
          Unwind_SetGR(a5, 1, 0);
          Unwind_SetIP(a5, v82[0]);
          v5 = 7;
        }
        break;
      case 4LL:
        v5 = 2;
        break;
    }
  }
  return v5;
}
// 28F48: variable 'v8' is possibly undefined
// 28F55: variable 'v10' is possibly undefined
// 28FDC: variable 'v11' is possibly undefined
// 28FDC: variable 'v12' is possibly undefined
// 4A994: using guessed type unsigned int dword_4A994[5];
// 59320: using guessed type __int64 (__fastcall *off_59320)();
// 59350: using guessed type __int64 (__fastcall *off_59350)();

//----- (0000000000029520) ----------------------------------------------------
char __fastcall <std::sys::os_str::bytes::Slice as core::fmt::Display>::fmt(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rsi
  char v5; // bp
  __int64 v7[2]; // [rsp+8h] [rbp-60h] BYREF
  __int64 v8[10]; // [rsp+18h] [rbp-50h] BYREF

  if ( !a2 )
    return <str as core::fmt::Display>::fmt((__int64)aRustc9b00956e5, 0LL, a3);
  v7[0] = a1;
  v7[1] = a2;
  <core::str::lossy::Utf8Chunks as core::iter::traits::iterator::Iterator>::next(v8, v7);
  v4 = v8[0];
  if ( !v8[0] )
    return 0;
  while ( v8[3] )
  {
    v5 = 1;
    if ( (unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str(a3)
      || (unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_char(a3) )
    {
      return v5;
    }
    <core::str::lossy::Utf8Chunks as core::iter::traits::iterator::Iterator>::next(v8, v7);
    v4 = v8[0];
    if ( !v8[0] )
      return 0;
  }
  return <str as core::fmt::Display>::fmt(v4, v8[1], a3);
}

//----- (0000000000029610) ----------------------------------------------------
unsigned __int64 __fastcall std::sys::thread_local::fast_local::Key<T>::try_initialize(__int64 *a1)
{
  unsigned __int64 v1; // rbx
  __int64 v3; // rcx
  __int64 v4; // rsi
  volatile signed __int64 *v5; // rdx
  volatile signed __int64 *v6; // [rsp+8h] [rbp-20h] BYREF

  v1 = __readfsqword(0);
  if ( *(_BYTE *)(v1 - 8) )
  {
    if ( *(_BYTE *)(v1 - 8) != 1 )
      return 0LL;
  }
  else
  {
    std::sys::pal::unix::thread_local_dtor::register_dtor(
      v1 - 24,
      (__int64)std::sys::thread_local::fast_local::destroy_value);
    *(_BYTE *)(v1 - 8) = 1;
  }
  if ( a1 )
  {
    v3 = *a1;
    *a1 = 0LL;
    if ( v3 )
      v3 = a1[1];
  }
  else
  {
    v3 = 0LL;
  }
  v5 = *(volatile signed __int64 **)(v1 - 16);
  v4 = *(_QWORD *)(v1 - 24);
  v6 = v5;
  *(_QWORD *)(v1 - 24) = 1LL;
  *(_QWORD *)(v1 - 16) = v3;
  if ( v4 && v5 && !_InterlockedDecrement64(v5) )
    alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v6);
  return v1 - 16;
}

//----- (00000000000296E0) ----------------------------------------------------
volatile signed __int64 *__fastcall std::sys::thread_local::fast_local::destroy_value(__int64 *a1)
{
  __int64 v1; // rcx
  volatile signed __int64 *result; // rax
  volatile signed __int64 *v3; // [rsp+10h] [rbp-8h] BYREF

  v1 = *a1;
  result = (volatile signed __int64 *)a1[1];
  *a1 = 0LL;
  *((_BYTE *)a1 + 16) = 2;
  v3 = result;
  if ( v1 && result && !_InterlockedDecrement64(result) )
    return (volatile signed __int64 *)alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v3);
  return result;
}

//----- (0000000000029720) ----------------------------------------------------
signed __int64 std::sys_common::thread_local_key::StaticKey::lazy_init()
{
  pthread_key_t v0; // ebx
  __int64 v1; // rdi
  signed __int64 v2; // rax
  signed __int64 v3; // rbx
  pthread_key_t key; // [rsp+Ch] [rbp-4Ch] BYREF
  char v6[8]; // [rsp+10h] [rbp-48h] BYREF
  char **v7; // [rsp+18h] [rbp-40h] BYREF
  __int128 v8; // [rsp+20h] [rbp-38h] BYREF
  char *v9; // [rsp+30h] [rbp-28h]
  __int128 v10; // [rsp+38h] [rbp-20h]

  key = 0;
  LODWORD(v7) = pthread_key_create(&key, destr_function);
  if ( (_DWORD)v7 )
    goto LABEL_8;
  v0 = key;
  if ( key )
    goto LABEL_5;
  key = 0;
  LODWORD(v7) = pthread_key_create(&key, destr_function);
  if ( (_DWORD)v7 )
  {
LABEL_8:
    *(_QWORD *)&v8 = 0LL;
    core::panicking::assert_failed(0, (__int64)&v7, (__int64)&unk_4949C, &v8, (__int64)&off_593E0);
  }
  v0 = key;
  pthread_key_delete(0);
  if ( !v0 )
  {
    *(_QWORD *)&v8 = &off_593F8;
    *((_QWORD *)&v8 + 1) = 1LL;
    v9 = v6;
    v10 = 0LL;
    v7 = std::io::Write::write_fmt((__int64)v6, &v8);
    core::ptr::drop_in_place<core::result::Result<(),std::io::error::Error>>((__int64 *)&v7);
    std::sys::pal::unix::abort_internal();
  }
LABEL_5:
  v1 = v0;
  v2 = _InterlockedCompareExchange64(
         (volatile signed __int64 *)&std::sys_common::thread_local_dtor::register_dtor_fallback::DTORS,
         v0,
         0LL);
  if ( v2 )
  {
    v3 = v2;
    pthread_key_delete(v1);
    return v3;
  }
  return v1;
}
// 593E0: using guessed type char *off_593E0;
// 593F8: using guessed type char *off_593F8;
// 29720: using guessed type char var_48[8];

//----- (0000000000029820) ----------------------------------------------------
void __fastcall __noreturn std::alloc::rust_oom(__int64 a1)
{
  char (__fastcall *v1)(__int64, __int64); // rcx

  v1 = std::alloc::default_alloc_error_hook;
  if ( std::alloc::HOOK )
    v1 = (char (__fastcall *)(__int64, __int64))std::alloc::HOOK;
  ((void (__fastcall *)(__int64))v1)(a1);
  std::process::abort();
}
// 5B0F8: using guessed type __int64 std::alloc::HOOK;

//----- (0000000000029840) ----------------------------------------------------
void __fastcall __noreturn _rg_oom(__int64 a1, __int64 a2)
{
  std::alloc::rust_oom(a2);
}

//----- (0000000000029850) ----------------------------------------------------
__int64 __fastcall std::backtrace_rs::backtrace::libunwind::trace::trace_fn(struct _Unwind_Context *a1, _QWORD *a2)
{
  __int64 v3[4]; // [rsp+8h] [rbp-20h] BYREF

  v3[0] = 0LL;
  v3[1] = (__int64)a1;
  return 9 * ((*(unsigned __int8 (__fastcall **)(_QWORD, __int64 *))(a2[1] + 32LL))(*a2, v3) ^ 1u);
}

//----- (0000000000029890) ----------------------------------------------------
char __fastcall <std::backtrace_rs::symbolize::SymbolName as core::fmt::Display>::fmt(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v2; // r14
  __int64 v3; // r15
  __int64 v4; // rbp
  char v5; // r12
  __int64 v6; // r13
  unsigned __int64 v7; // rbp
  __int64 v9; // [rsp+0h] [rbp-48h] BYREF
  __int64 v10; // [rsp+8h] [rbp-40h]
  unsigned __int64 v11; // [rsp+10h] [rbp-38h]

  if ( *(_DWORD *)a1 != 2 )
    return <rustc_demangle::Demangle as core::fmt::Display>::fmt(a1, a2);
  v2 = a1[9];
  if ( !v2 )
    return 0;
  v3 = a1[8];
  while ( 1 )
  {
    core::str::converts::from_utf8((__int64)&v9, v3, v2);
    if ( !v9 )
      break;
    v4 = v10;
    v5 = v11;
    v6 = BYTE1(v11);
    if ( <str as core::fmt::Display>::fmt((__int64)asc_49D69, 3uLL, a2) )
      return 1;
    if ( (v5 & 1) != 0 )
    {
      v7 = v6 + v4;
      if ( v2 < v7 )
        core::slice::index::slice_start_index_len_fail(v7, v2, (__int64)&off_59188);
      v3 += v7;
      v2 -= v7;
      if ( v2 )
        continue;
    }
    return 0;
  }
  return <str as core::fmt::Display>::fmt(v10, v11, a2) != 0;
}
// 59188: using guessed type char *off_59188;

//----- (0000000000029970) ----------------------------------------------------
__int64 __fastcall std::backtrace_rs::symbolize::gimli::stash::Stash::allocate(__int64 *a1, __int64 a2)
{
  unsigned __int64 v3; // r14
  __int64 v4; // rax
  __int64 v5; // r12
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 v8; // rcx
  unsigned __int64 v9; // rsi

  v3 = a1[2];
  if ( !a2 )
  {
    v5 = 1LL;
    v6 = a1[2];
    if ( v3 != *a1 )
      goto LABEL_8;
    goto LABEL_7;
  }
  if ( a2 < 0 )
    alloc::raw_vec::capacity_overflow();
  v4 = _rust_alloc_zeroed(a2, 1LL);
  if ( !v4 )
    alloc::alloc::handle_alloc_error(1LL, a2);
  v5 = v4;
  v6 = a1[2];
  if ( v6 == *a1 )
  {
LABEL_7:
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(a1, v6);
    v6 = a1[2];
  }
LABEL_8:
  v7 = a1[1];
  v8 = 3 * v6;
  *(_QWORD *)(v7 + 8 * v8) = a2;
  *(_QWORD *)(v7 + 8 * v8 + 8) = v5;
  *(_QWORD *)(v7 + 8 * v8 + 16) = a2;
  v9 = v6 + 1;
  a1[2] = v9;
  if ( v3 >= v9 )
    core::panicking::panic_bounds_check(v3, v9, (__int64)&off_59408);
  return *(_QWORD *)(a1[1] + 24 * v3 + 8);
}
// 9B40: using guessed type __int64 __fastcall _rust_alloc_zeroed(_QWORD, _QWORD);
// 59408: using guessed type char *off_59408;

//----- (0000000000029A50) ----------------------------------------------------
__int64 __fastcall std::backtrace_rs::symbolize::gimli::Context::new(
        _QWORD *a1,
        __int64 *a2,
        _QWORD *a3,
        __int64 *a4,
        _QWORD *a5)
{
  const char *v6; // rax
  void *v7; // rdx
  const char *v8; // rdx
  void *v9; // rcx
  const char *v10; // rax
  __int64 v11; // rdx
  const char *v12; // rdx
  __int64 v13; // rcx
  const char *v14; // rax
  __int64 v15; // rdx
  const char *v16; // rdx
  __int64 v17; // rcx
  const char *v18; // rax
  __int64 v19; // rdx
  const char *v20; // rdx
  __int64 v21; // rcx
  const char *v22; // rax
  __int64 v23; // rdx
  const char *v24; // rdx
  __int64 v25; // rcx
  const char *v26; // rax
  __int64 v27; // rdx
  const char *v28; // rdx
  __int64 v29; // rcx
  const char *v30; // rax
  __int64 v31; // rdx
  const char *v32; // rdx
  __int64 v33; // rcx
  const char *v34; // rax
  __int64 v35; // rdx
  const char *v36; // rdx
  __int64 v37; // rcx
  const char *v38; // rax
  __int64 v39; // rdx
  const char *v40; // rdx
  __int64 v41; // rcx
  const char *v42; // rax
  void *v43; // rdx
  const char *v44; // rdx
  void *v45; // rcx
  const char *v46; // rax
  __int64 v47; // rdx
  __int64 v48; // r13
  const char *v49; // r14
  const char *v50; // rbx
  __int64 v51; // rdx
  __int64 v52; // rbp
  const char *v53; // rax
  __int64 v54; // rdx
  int v55; // eax
  __int64 v56; // rcx
  const char *v57; // rax
  void *v58; // rdx
  const char *v59; // rdx
  void *v60; // rcx
  const char *v61; // rax
  __int64 v62; // rdx
  const char *v63; // rdx
  __int64 v64; // rcx
  const char *v65; // rax
  __int64 v66; // rdx
  const char *v67; // rdx
  __int64 v68; // rcx
  const char *v69; // rax
  __int64 v70; // rdx
  const char *v71; // rdx
  __int64 v72; // rcx
  const char *v73; // rax
  __int64 v74; // rdx
  const char *v75; // rdx
  __int64 v76; // rcx
  const char *v77; // rax
  __int64 v78; // rdx
  const char *v79; // rdx
  __int64 v80; // rcx
  const char *v81; // rax
  __int64 v82; // rdx
  const char *v83; // rdx
  __int64 v84; // rcx
  const char *v85; // rax
  __int64 v86; // rdx
  const char *v87; // rdx
  __int64 v88; // rcx
  const char *v89; // rax
  __int64 v90; // rdx
  const char *v91; // rdx
  __int64 v92; // rcx
  const char *v93; // rax
  void *v94; // rdx
  const char *v95; // rdx
  void *v96; // rcx
  const char *v97; // rax
  __int64 v98; // rdx
  __int64 v99; // r13
  const char *v100; // r14
  const char *v101; // rbx
  __int64 v102; // rdx
  __int64 v103; // rbp
  const char *v104; // rax
  __int64 v105; // rdx
  void *v106; // rax
  void *v107; // rbx
  void *v108; // rax
  __int64 v109; // r14
  __int64 v110; // rcx
  __int64 v111; // r12
  unsigned __int64 v112; // rsi
  __int64 v113; // r15
  __int64 v114; // r14
  __int64 v115; // rax
  __int64 v116; // r13
  __int64 v117; // rbp
  __int64 v118; // r14
  __int64 v119; // rax
  char *v120; // r14
  unsigned __int64 v121; // rcx
  unsigned __int64 v122; // r12
  const char *v123; // r13
  unsigned __int64 v124; // rsi
  unsigned __int64 v125; // r15
  unsigned __int64 v126; // rcx
  __int64 v127; // rax
  char *v128; // rdi
  unsigned __int64 v129; // rdx
  char *v130; // rbp
  unsigned __int64 v131; // rcx
  unsigned __int64 v132; // r14
  __int64 v133; // r14
  unsigned __int64 v134; // r11
  unsigned __int64 *v135; // r9
  unsigned __int64 v136; // r10
  __int64 v137; // r10
  const char *v138; // rbx
  char *v139; // rax
  char *v140; // r15
  unsigned __int64 v141; // r13
  size_t v142; // r12
  size_t v143; // rsi
  __int64 v144; // rax
  char *v145; // rsi
  char *v146; // r12
  unsigned __int64 v147; // r10
  __int64 v148; // rcx
  unsigned __int64 v149; // rax
  unsigned __int64 v150; // r8
  unsigned __int64 v151; // r11
  unsigned __int64 v152; // rcx
  unsigned __int64 v153; // rbp
  __int64 v154; // rcx
  unsigned __int64 v155; // r12
  __int64 v156; // r13
  unsigned __int64 v157; // rax
  char *v158; // rbp
  __int64 v159; // r15
  char *v160; // r14
  __int64 v161; // r12
  __int64 v162; // rbx
  char *v163; // r15
  unsigned __int8 *v164; // r12
  __int64 v165; // rbx
  unsigned __int64 v166; // rdx
  unsigned __int64 v167; // rsi
  char *v168; // rax
  char *v169; // r12
  char *v170; // rdx
  int v171; // eax
  bool v172; // cf
  _BOOL4 v173; // esi
  char *v174; // rdi
  unsigned __int64 *v175; // rax
  unsigned __int64 v176; // r9
  __int64 v177; // r9
  unsigned __int64 v178; // rcx
  __int64 v179; // rsi
  __int64 v180; // r8
  unsigned __int8 *v181; // rax
  unsigned __int8 *v182; // r10
  __int128 v183; // xmm0
  __int64 v184; // r11
  __int128 v185; // xmm0
  unsigned __int64 v186; // rcx
  __int64 v187; // r8
  __int128 v188; // xmm0
  __int64 v189; // r13
  __int64 v190; // r8
  const char *v191; // r9
  __int64 v192; // r10
  const char *v193; // r11
  __int64 v194; // rax
  __int64 v195; // rbx
  __int64 v196; // r15
  __int64 v197; // rdi
  volatile signed __int64 *v198; // r15
  __int64 *v199; // r12
  unsigned __int64 v200; // rbp
  __int64 v201; // r14
  double v202; // xmm0_8
  __m128 v203; // xmm1
  __int64 v204; // r8
  __int64 v205; // r9
  unsigned __int64 v206; // rax
  int v207; // ecx
  char v208; // r10
  __int64 v209; // rdi
  __int64 v210; // rdi
  __int64 v211; // rcx
  __int64 v212; // rdx
  __int64 v213; // rsi
  char v214; // r10
  __int64 v215; // rdx
  __int64 v216; // rbx
  __int64 v217; // rsi
  __int64 v218; // rdx
  __int64 v219; // rax
  unsigned __int64 v220; // rcx
  char *v221; // rax
  __int64 v222; // rax
  unsigned __int64 v223; // rcx
  __int64 v224; // rax
  __int64 v225; // rax
  unsigned __int64 v226; // rcx
  const char *v227; // rax
  __int64 v228; // rdx
  __int64 v229; // rdx
  const char *v230; // rax
  char v231; // al
  char *v232; // rax
  unsigned __int64 v233; // rdx
  unsigned __int64 v234; // rdx
  unsigned __int64 v235; // rsi
  __int64 v236; // rax
  unsigned __int64 v237; // rcx
  unsigned __int64 v238; // rsi
  unsigned __int64 v239; // rdi
  unsigned __int64 v240; // rcx
  __int64 v241; // rdx
  unsigned __int64 v242; // r8
  unsigned __int64 v243; // rsi
  unsigned __int8 *v244; // rbx
  __int64 v245; // rax
  __int64 v246; // rcx
  char *v247; // rcx
  __int64 v248; // rsi
  char *v249; // rdi
  char *v250; // rbx
  __int64 v251; // rax
  unsigned __int64 v252; // rdx
  unsigned __int64 v253; // rsi
  unsigned __int16 *v254; // r8
  __int64 v255; // r9
  __int64 v256; // r11
  unsigned __int64 v257; // r10
  char v258; // cl
  unsigned __int64 v259; // rbx
  unsigned __int64 v260; // rax
  char v261; // cl
  unsigned __int64 v262; // rdx
  char v263; // cl
  unsigned __int64 v264; // rsi
  char *v265; // rbx
  __int64 v266; // rax
  __int64 v267; // rcx
  __int64 v268; // rdi
  __int128 v269; // rcx
  char v270; // al
  unsigned __int64 v271; // rsi
  __int64 v272; // rax
  __int64 v273; // rax
  __int64 v274; // rcx
  __int64 v275; // rbx
  unsigned __int64 v276; // rsi
  __int64 v277; // rsi
  char *v278; // rbx
  __int64 v279; // rax
  __int64 v280; // rcx
  __int64 v281; // rbp
  __int64 result; // rax
  __int64 v283; // r14
  unsigned __int64 v284; // rbp
  __int64 v285; // rax
  char *v286; // r12
  __int64 v287; // rax
  _QWORD *v288; // r15
  unsigned __int64 v289; // rdx
  unsigned __int64 v290; // r13
  __int64 v291; // rcx
  unsigned __int64 v292; // r14
  unsigned __int64 v293; // rsi
  __int64 v294; // rax
  unsigned __int64 *v295; // rdi
  unsigned __int64 v296; // rdx
  unsigned __int64 v297; // rsi
  unsigned __int64 v298; // rbx
  unsigned __int64 v299; // rbx
  unsigned __int64 v300; // r8
  unsigned __int64 i; // rcx
  unsigned __int64 *v302; // rdx
  unsigned __int64 v303; // r9
  unsigned __int64 v304; // rdx
  __int128 *v305; // rax
  __int128 *v306; // rsi
  __int128 v307; // xmm0
  __int128 v308; // xmm0
  _QWORD *v309; // rax
  __int64 v310; // rax
  __int128 *v311; // r13
  char *v312; // rsi
  _QWORD *v313; // r14
  __int64 v314; // rcx
  unsigned __int64 v315; // rax
  unsigned __int64 v316; // rsi
  unsigned __int64 v317; // r9
  unsigned __int64 v318; // rcx
  unsigned __int64 v319; // rdi
  __int64 v320; // rax
  __int64 v321; // rdx
  unsigned __int64 v322; // r15
  __int64 v323; // r12
  unsigned __int64 v324; // rax
  __int64 v325; // rbx
  __int128 *v326; // rbp
  __int64 v327; // r15
  __int64 v328; // r14
  char *v329; // rbx
  __int64 v330; // r12
  _OWORD *v331; // r15
  unsigned __int64 v332; // rdx
  unsigned __int64 v333; // rsi
  char *v334; // rax
  __int128 v335; // xmm0
  unsigned __int64 v336; // r15
  __int128 *v337; // rdx
  int v338; // eax
  bool v339; // cf
  _BOOL4 v340; // esi
  __int128 *v341; // rdi
  __int128 v342; // xmm0
  unsigned __int64 *v343; // rax
  unsigned __int64 v344; // rcx
  unsigned __int64 v345; // rcx
  __int64 v346; // rdx
  __int64 v347; // r12
  __int64 v348; // r12
  __int64 v349; // rax
  __int64 v350; // rbx
  __int64 v351; // r12
  __int64 v352; // rdi
  __int64 v353; // rdi
  unsigned __int64 v354; // r12
  unsigned __int64 v355; // r14
  _QWORD *v356; // r12
  __int64 v357; // r13
  __int64 v358; // rax
  __int64 v359; // rbp
  __int64 v360; // rbx
  __int64 v361; // rsi
  __int64 v362; // rsi
  __int64 *v363; // rsi
  _QWORD *v364; // rdi
  __int64 v365; // rbx
  char v366; // r13
  _QWORD *v367; // rdx
  __int128 v368; // xmm1
  __int128 v369; // xmm2
  __int128 v370; // xmm3
  __int128 v371; // xmm4
  __int128 v372; // xmm5
  __int128 v373; // xmm6
  __int128 v374; // xmm1
  __int128 v375; // xmm2
  __int128 v376; // xmm3
  __int128 v377; // xmm1
  __int128 v378; // xmm2
  __int128 v379; // xmm3
  __int128 v380; // xmm0
  __int128 v381; // xmm1
  char *v382; // rax
  unsigned __int64 v383; // rdx
  char v384; // r12
  char *v385; // rax
  unsigned __int64 v386; // rdx
  _QWORD *v387; // r14
  __int64 *v388; // r15
  const char *v389; // rax
  __int64 v390; // rdx
  __int64 v391; // rcx
  const char *v392; // rax
  void *v393; // rdx
  void *v394; // rcx
  const char *v395; // rax
  unsigned __int64 v396; // rdx
  unsigned __int64 v397; // rcx
  const char *v398; // rax
  unsigned __int64 v399; // rdx
  unsigned __int64 v400; // rcx
  const char *v401; // rax
  __int64 v402; // rdx
  __int64 v403; // r13
  const char *v404; // rax
  _QWORD *v405; // rdx
  _QWORD *v406; // rcx
  const char *v407; // rax
  __int64 v408; // rdx
  __int64 v409; // rcx
  const char *v410; // rax
  __int64 v411; // rdx
  const char *v412; // rax
  __int64 v413; // rdx
  char **v414; // rsi
  __int64 v415; // rdi
  char **v416; // rsi
  __int64 v417; // rdi
  __int64 v418; // rdi
  __int64 v419; // rsi
  void *v420; // [rsp+8h] [rbp-8C0h]
  void *v421; // [rsp+8h] [rbp-8C0h]
  void *v422; // [rsp+8h] [rbp-8C0h]
  void *v423; // [rsp+8h] [rbp-8C0h]
  char *v424; // [rsp+8h] [rbp-8C0h]
  void *v425; // [rsp+8h] [rbp-8C0h]
  char *v426; // [rsp+8h] [rbp-8C0h]
  char *v427; // [rsp+8h] [rbp-8C0h]
  char *v428; // [rsp+8h] [rbp-8C0h]
  _QWORD *v429; // [rsp+8h] [rbp-8C0h]
  const char *v430; // [rsp+10h] [rbp-8B8h]
  const char *v431; // [rsp+10h] [rbp-8B8h]
  unsigned __int64 v432; // [rsp+10h] [rbp-8B8h]
  __int64 v433; // [rsp+10h] [rbp-8B8h]
  unsigned __int64 v434; // [rsp+10h] [rbp-8B8h]
  unsigned __int64 v435; // [rsp+10h] [rbp-8B8h]
  __int64 v436; // [rsp+10h] [rbp-8B8h]
  void *v437; // [rsp+10h] [rbp-8B8h]
  __int64 v438; // [rsp+10h] [rbp-8B8h]
  __int64 v439; // [rsp+18h] [rbp-8B0h]
  __int64 v440; // [rsp+18h] [rbp-8B0h]
  __int64 v441; // [rsp+18h] [rbp-8B0h]
  __int64 v442; // [rsp+18h] [rbp-8B0h]
  unsigned __int64 v443; // [rsp+18h] [rbp-8B0h]
  __int64 v444; // [rsp+18h] [rbp-8B0h]
  unsigned __int64 v445; // [rsp+18h] [rbp-8B0h]
  unsigned __int64 v446; // [rsp+18h] [rbp-8B0h]
  unsigned __int64 v447; // [rsp+18h] [rbp-8B0h]
  const char *v448; // [rsp+20h] [rbp-8A8h]
  const char *v449; // [rsp+20h] [rbp-8A8h]
  unsigned __int64 v450; // [rsp+20h] [rbp-8A8h]
  __int64 v451; // [rsp+20h] [rbp-8A8h]
  __int64 v452; // [rsp+20h] [rbp-8A8h]
  __int64 v453; // [rsp+20h] [rbp-8A8h]
  unsigned __int64 v454; // [rsp+20h] [rbp-8A8h]
  const char *v455; // [rsp+20h] [rbp-8A8h]
  __int64 v456; // [rsp+28h] [rbp-8A0h]
  __int64 v457; // [rsp+28h] [rbp-8A0h]
  __int64 v458; // [rsp+28h] [rbp-8A0h]
  const char *v459; // [rsp+30h] [rbp-898h]
  const char *v460; // [rsp+30h] [rbp-898h]
  char *v461; // [rsp+30h] [rbp-898h]
  __int64 v462; // [rsp+30h] [rbp-898h]
  unsigned __int16 *v463; // [rsp+30h] [rbp-898h]
  unsigned __int16 *v464; // [rsp+30h] [rbp-898h]
  unsigned __int64 v465; // [rsp+30h] [rbp-898h]
  unsigned __int64 v466; // [rsp+30h] [rbp-898h]
  char v467; // [rsp+30h] [rbp-898h]
  __int64 v468; // [rsp+38h] [rbp-890h]
  __int64 v469; // [rsp+38h] [rbp-890h]
  __int64 v470; // [rsp+38h] [rbp-890h]
  __int64 v471; // [rsp+38h] [rbp-890h]
  __int64 v472; // [rsp+38h] [rbp-890h]
  __int64 v473; // [rsp+38h] [rbp-890h]
  __int64 v474; // [rsp+38h] [rbp-890h]
  __int64 v475; // [rsp+38h] [rbp-890h]
  const char *v476; // [rsp+40h] [rbp-888h]
  const char *v477; // [rsp+40h] [rbp-888h]
  __int64 v478; // [rsp+40h] [rbp-888h]
  unsigned __int64 v479; // [rsp+40h] [rbp-888h]
  unsigned __int64 v480; // [rsp+40h] [rbp-888h]
  unsigned __int64 v481; // [rsp+40h] [rbp-888h]
  __int64 v482; // [rsp+40h] [rbp-888h]
  char *v483; // [rsp+40h] [rbp-888h]
  _QWORD *v484; // [rsp+48h] [rbp-880h]
  const char *v485; // [rsp+50h] [rbp-878h]
  __int64 v486; // [rsp+50h] [rbp-878h]
  const char *v487; // [rsp+50h] [rbp-878h]
  __int64 v488; // [rsp+58h] [rbp-870h]
  __int64 v489; // [rsp+58h] [rbp-870h]
  __int64 v490; // [rsp+58h] [rbp-870h]
  __int64 v491; // [rsp+58h] [rbp-870h]
  unsigned __int64 v492; // [rsp+58h] [rbp-870h]
  unsigned __int64 v493; // [rsp+58h] [rbp-870h]
  void *v494; // [rsp+60h] [rbp-868h]
  void *v495; // [rsp+60h] [rbp-868h]
  void *v496; // [rsp+60h] [rbp-868h]
  void *v497; // [rsp+60h] [rbp-868h]
  char *v498; // [rsp+60h] [rbp-868h]
  _QWORD *v499; // [rsp+60h] [rbp-868h]
  void *v500; // [rsp+60h] [rbp-868h]
  _QWORD *v501; // [rsp+60h] [rbp-868h]
  void *v502; // [rsp+60h] [rbp-868h]
  __m128 v503; // [rsp+60h] [rbp-868h]
  const char *v504; // [rsp+70h] [rbp-858h]
  const char *v505; // [rsp+70h] [rbp-858h]
  __int64 v506; // [rsp+70h] [rbp-858h]
  unsigned __int64 v507; // [rsp+70h] [rbp-858h]
  __int64 v508; // [rsp+70h] [rbp-858h]
  __int64 v509; // [rsp+70h] [rbp-858h]
  __int64 v510; // [rsp+70h] [rbp-858h]
  __int64 v511; // [rsp+70h] [rbp-858h]
  __int64 v512; // [rsp+78h] [rbp-850h]
  __int64 v513; // [rsp+78h] [rbp-850h]
  __int64 v514; // [rsp+78h] [rbp-850h]
  __int64 v515; // [rsp+78h] [rbp-850h]
  __int64 v516; // [rsp+78h] [rbp-850h]
  unsigned __int64 v517; // [rsp+78h] [rbp-850h]
  __int64 v518; // [rsp+80h] [rbp-848h]
  __int64 v519; // [rsp+80h] [rbp-848h]
  __int64 v520; // [rsp+80h] [rbp-848h]
  __int64 v521; // [rsp+88h] [rbp-840h]
  __int64 v522; // [rsp+88h] [rbp-840h]
  __int64 v523; // [rsp+88h] [rbp-840h]
  __int64 v524; // [rsp+88h] [rbp-840h]
  unsigned __int64 v525; // [rsp+88h] [rbp-840h]
  __int64 v526; // [rsp+88h] [rbp-840h]
  __int64 v527; // [rsp+90h] [rbp-838h] BYREF
  __int64 v528; // [rsp+98h] [rbp-830h]
  unsigned __int64 v529; // [rsp+A0h] [rbp-828h]
  char *v530; // [rsp+A8h] [rbp-820h]
  __int128 v531; // [rsp+B0h] [rbp-818h]
  unsigned __int64 v532; // [rsp+C0h] [rbp-808h]
  __int64 *v533; // [rsp+C8h] [rbp-800h]
  _BYTE *v534; // [rsp+D0h] [rbp-7F8h]
  unsigned __int64 v535; // [rsp+D8h] [rbp-7F0h]
  _BYTE v536[24]; // [rsp+E0h] [rbp-7E8h] BYREF
  unsigned __int64 v537; // [rsp+F8h] [rbp-7D0h]
  _QWORD *v538; // [rsp+100h] [rbp-7C8h]
  char **v539; // [rsp+108h] [rbp-7C0h]
  unsigned __int64 v540; // [rsp+110h] [rbp-7B8h]
  unsigned __int64 v541; // [rsp+118h] [rbp-7B0h]
  __int64 *v542; // [rsp+120h] [rbp-7A8h]
  unsigned __int64 v543; // [rsp+128h] [rbp-7A0h]
  __int64 v544; // [rsp+130h] [rbp-798h] BYREF
  __int64 v545; // [rsp+138h] [rbp-790h] BYREF
  char *v546; // [rsp+140h] [rbp-788h]
  __int64 v547; // [rsp+148h] [rbp-780h]
  _BYTE v548[24]; // [rsp+150h] [rbp-778h] BYREF
  char **v549; // [rsp+168h] [rbp-760h]
  __m256i v550; // [rsp+170h] [rbp-758h] BYREF
  __int128 v551; // [rsp+190h] [rbp-738h]
  __int128 v552; // [rsp+1A0h] [rbp-728h]
  _BYTE v553[72]; // [rsp+1B0h] [rbp-718h] BYREF
  __int64 v554; // [rsp+1F8h] [rbp-6D0h]
  _QWORD *v555; // [rsp+208h] [rbp-6C0h]
  int v556; // [rsp+214h] [rbp-6B4h]
  __int64 v557; // [rsp+218h] [rbp-6B0h]
  unsigned __int64 v558; // [rsp+220h] [rbp-6A8h]
  unsigned __int64 v559; // [rsp+228h] [rbp-6A0h] BYREF
  __int64 v560; // [rsp+230h] [rbp-698h]
  __int64 v561; // [rsp+238h] [rbp-690h]
  __int64 v562; // [rsp+240h] [rbp-688h]
  __int64 v563; // [rsp+248h] [rbp-680h]
  unsigned __int64 v564; // [rsp+250h] [rbp-678h]
  __int64 v565; // [rsp+258h] [rbp-670h]
  _BYTE src[536]; // [rsp+260h] [rbp-668h] BYREF
  __int128 v567; // [rsp+478h] [rbp-450h] BYREF
  __int128 v568; // [rsp+488h] [rbp-440h]
  __int128 v569; // [rsp+498h] [rbp-430h]
  __int64 v570; // [rsp+4A8h] [rbp-420h]
  __int128 v571; // [rsp+4B0h] [rbp-418h] BYREF
  __m128 v572; // [rsp+4C0h] [rbp-408h]
  __int128 v573; // [rsp+4D0h] [rbp-3F8h]
  __int128 v574; // [rsp+4E0h] [rbp-3E8h]
  _BYTE v575[23]; // [rsp+4F0h] [rbp-3D8h]
  __int128 v576; // [rsp+510h] [rbp-3B8h]
  __int64 v577; // [rsp+520h] [rbp-3A8h]
  _BYTE v578[424]; // [rsp+530h] [rbp-398h] BYREF
  _BYTE v579[248]; // [rsp+6D8h] [rbp-1F0h] BYREF
  __int128 v580; // [rsp+7D0h] [rbp-F8h]
  __int128 v581; // [rsp+7E0h] [rbp-E8h]
  __int128 v582; // [rsp+7F0h] [rbp-D8h]
  __int128 v583; // [rsp+800h] [rbp-C8h]
  _OWORD v584[2]; // [rsp+810h] [rbp-B8h]
  __m256i v585; // [rsp+830h] [rbp-98h]
  __int128 v586; // [rsp+850h] [rbp-78h]
  __int128 v587; // [rsp+860h] [rbp-68h]
  __int128 v588; // [rsp+870h] [rbp-58h]
  __int128 v589[4]; // [rsp+880h] [rbp-48h] BYREF

  v538 = a5;
  v533 = a4;
  v555 = a1;
  v6 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugLoc, 0xAuLL);
  v494 = v7;
  v8 = v6;
  if ( !v6 )
    v8 = aRustc9b00956e5;
  v430 = v8;
  v9 = v494;
  if ( !v6 )
    v9 = 0LL;
  v495 = v9;
  v10 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugLoclists, 0xFuLL);
  v439 = v11;
  v12 = v10;
  if ( !v10 )
    v12 = aRustc9b00956e5;
  v459 = v12;
  v13 = v439;
  if ( !v10 )
    v13 = 0LL;
  v440 = v13;
  v14 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugRanges, 0xDuLL);
  v488 = v15;
  v16 = v14;
  if ( !v14 )
    v16 = aRustc9b00956e5;
  v485 = v16;
  v17 = v488;
  if ( !v14 )
    v17 = 0LL;
  v489 = v17;
  v18 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugRnglists, 0xFuLL);
  v512 = v19;
  v20 = v18;
  if ( !v18 )
    v20 = aRustc9b00956e5;
  v448 = v20;
  v21 = v512;
  if ( !v18 )
    v21 = 0LL;
  v513 = v21;
  v22 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugAbbrev, 0xDuLL);
  v521 = v23;
  v24 = v22;
  if ( !v22 )
    v24 = aRustc9b00956e5;
  v476 = v24;
  v25 = v521;
  if ( !v22 )
    v25 = 0LL;
  v522 = v25;
  v26 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugAddr, 0xBuLL);
  v518 = v27;
  v28 = v26;
  if ( !v26 )
    v28 = aRustc9b00956e5;
  v537 = (unsigned __int64)v28;
  v29 = v518;
  if ( !v26 )
    v29 = 0LL;
  v519 = v29;
  v30 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugAranges, 0xEuLL);
  *(_QWORD *)&v531 = v31;
  v32 = v30;
  if ( !v30 )
    v32 = aRustc9b00956e5;
  v532 = (unsigned __int64)v32;
  v33 = v531;
  if ( !v30 )
    v33 = 0LL;
  *(_QWORD *)&v531 = v33;
  v34 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugInfo, 0xBuLL);
  v456 = v35;
  v36 = v34;
  if ( !v34 )
    v36 = aRustc9b00956e5;
  v504 = v36;
  v37 = v456;
  if ( !v34 )
    v37 = 0LL;
  v457 = v37;
  v38 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugLine, 0xBuLL);
  v468 = v39;
  v40 = v38;
  if ( !v38 )
    v40 = aRustc9b00956e5;
  v534 = v40;
  v41 = v468;
  if ( !v38 )
    v41 = 0LL;
  v469 = v41;
  v42 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugLineStr, 0xFuLL);
  v420 = v43;
  v44 = v42;
  if ( !v42 )
    v44 = aRustc9b00956e5;
  v540 = (unsigned __int64)v44;
  v45 = v420;
  if ( !v42 )
    v45 = 0LL;
  v421 = v45;
  v46 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugStr, 0xAuLL);
  v48 = v47;
  v49 = v46;
  if ( !v46 )
  {
    v49 = aRustc9b00956e5;
    v48 = 0LL;
  }
  v50 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugStrOffset, 0x12uLL);
  v52 = v51;
  v53 = std::backtrace_rs::symbolize::gimli::elf::Object::section(a3, a2, aDebugTypes, 0xCuLL);
  v542 = a2;
  v484 = a3;
  *(_OWORD *)&v579[208] = 0LL;
  *(_QWORD *)v579 = v476;
  *(_QWORD *)&v579[8] = v522;
  *(_QWORD *)&v579[16] = v537;
  *(_QWORD *)&v579[24] = v519;
  *(_QWORD *)&v579[32] = v532;
  *(_QWORD *)&v579[40] = v531;
  *(_QWORD *)&v579[48] = v504;
  *(_QWORD *)&v579[56] = v457;
  *(_QWORD *)&v579[64] = v534;
  *(_QWORD *)&v579[72] = v469;
  *(_QWORD *)&v579[80] = v540;
  *(_QWORD *)&v579[88] = v421;
  *(_QWORD *)&v579[96] = v49;
  *(_QWORD *)&v579[104] = v48;
  if ( !v50 )
  {
    v52 = 0LL;
    v50 = aRustc9b00956e5;
  }
  *(_QWORD *)&v579[112] = v50;
  if ( !v53 )
    v54 = 0LL;
  *(_QWORD *)&v579[120] = v52;
  if ( !v53 )
    v53 = aRustc9b00956e5;
  *(_QWORD *)&v579[128] = v53;
  *(_QWORD *)&v579[136] = v54;
  *(_QWORD *)&v579[144] = v430;
  *(_QWORD *)&v579[152] = v495;
  *(_QWORD *)&v579[160] = v459;
  *(_QWORD *)&v579[168] = v440;
  *(_QWORD *)&v579[176] = v485;
  *(_QWORD *)&v579[184] = v489;
  *(_QWORD *)&v579[192] = v448;
  *(_QWORD *)&v579[200] = v513;
  *(_QWORD *)&v579[232] = 0LL;
  v579[240] = 0;
  v55 = (int)v533;
  v56 = *v533;
  LOBYTE(v55) = 1;
  LODWORD(v532) = v55;
  v537 = v56;
  if ( v56 != 0x8000000000000000LL )
  {
    v57 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugLoc, 0xAuLL);
    v496 = v58;
    v59 = v57;
    if ( !v57 )
      v59 = aRustc9b00956e5;
    v431 = v59;
    v60 = v496;
    if ( !v57 )
      v60 = 0LL;
    v497 = v60;
    v61 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugLoclists, 0xFuLL);
    v441 = v62;
    v63 = v61;
    if ( !v61 )
      v63 = aRustc9b00956e5;
    v460 = v63;
    v64 = v441;
    if ( !v61 )
      v64 = 0LL;
    v442 = v64;
    v65 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugRanges, 0xDuLL);
    v490 = v66;
    v67 = v65;
    if ( !v65 )
      v67 = aRustc9b00956e5;
    v485 = v67;
    v68 = v490;
    if ( !v65 )
      v68 = 0LL;
    v491 = v68;
    v69 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugRnglists, 0xFuLL);
    v514 = v70;
    v71 = v69;
    if ( !v69 )
      v71 = aRustc9b00956e5;
    v449 = v71;
    v72 = v514;
    if ( !v69 )
      v72 = 0LL;
    v515 = v72;
    v73 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugAbbrev, 0xDuLL);
    v523 = v74;
    v75 = v73;
    if ( !v73 )
      v75 = aRustc9b00956e5;
    v477 = v75;
    v76 = v523;
    if ( !v73 )
      v76 = 0LL;
    v524 = v76;
    v77 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugAddr, 0xBuLL);
    v520 = v78;
    v79 = v77;
    if ( !v77 )
      v79 = aRustc9b00956e5;
    v532 = (unsigned __int64)v79;
    v80 = v520;
    if ( !v77 )
      v80 = 0LL;
    v519 = v80;
    v81 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugAranges, 0xEuLL);
    *(_QWORD *)&v531 = v82;
    v83 = v81;
    if ( !v81 )
      v83 = aRustc9b00956e5;
    v505 = v83;
    v84 = v531;
    if ( !v81 )
      v84 = 0LL;
    *(_QWORD *)&v531 = v84;
    v85 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugInfo, 0xBuLL);
    v458 = v86;
    v87 = v85;
    if ( !v85 )
      v87 = aRustc9b00956e5;
    v534 = v87;
    v88 = v458;
    if ( !v85 )
      v88 = 0LL;
    v457 = v88;
    v89 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugLine, 0xBuLL);
    v470 = v90;
    v91 = v89;
    if ( !v89 )
      v91 = aRustc9b00956e5;
    v540 = (unsigned __int64)v91;
    v92 = v470;
    if ( !v89 )
      v92 = 0LL;
    v471 = v92;
    v93 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugLineStr, 0xFuLL);
    v422 = v94;
    v95 = v93;
    if ( !v93 )
      v95 = aRustc9b00956e5;
    v543 = (unsigned __int64)v95;
    v96 = v422;
    if ( !v93 )
      v96 = 0LL;
    v423 = v96;
    v97 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugStr, 0xAuLL);
    v99 = v98;
    v100 = v97;
    if ( !v97 )
    {
      v100 = aRustc9b00956e5;
      v99 = 0LL;
    }
    v101 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugStrOffset, 0x12uLL);
    v103 = v102;
    v104 = std::backtrace_rs::symbolize::gimli::elf::Object::section(v533, v542, aDebugTypes, 0xCuLL);
    *(_OWORD *)&src[224] = 0LL;
    *(_QWORD *)src = 1LL;
    *(_QWORD *)&src[8] = 1LL;
    *(_QWORD *)&src[16] = v477;
    *(_QWORD *)&src[24] = v524;
    *(_QWORD *)&src[32] = v532;
    *(_QWORD *)&src[40] = v519;
    *(_QWORD *)&src[48] = v505;
    *(_QWORD *)&src[56] = v531;
    *(_QWORD *)&src[64] = v534;
    *(_QWORD *)&src[72] = v457;
    *(_QWORD *)&src[80] = v540;
    *(_QWORD *)&src[88] = v471;
    *(_QWORD *)&src[96] = v543;
    *(_QWORD *)&src[104] = v423;
    *(_QWORD *)&src[112] = v100;
    *(_QWORD *)&src[120] = v99;
    if ( !v101 )
    {
      v103 = 0LL;
      v101 = aRustc9b00956e5;
    }
    *(_QWORD *)&src[128] = v101;
    *(_QWORD *)&src[136] = v103;
    if ( !v104 )
    {
      v105 = 0LL;
      v104 = aRustc9b00956e5;
    }
    *(_QWORD *)&src[144] = v104;
    *(_QWORD *)&src[152] = v105;
    *(_QWORD *)&src[160] = v431;
    *(_QWORD *)&src[168] = v497;
    *(_QWORD *)&src[176] = v460;
    *(_QWORD *)&src[184] = v442;
    *(_QWORD *)&src[192] = v485;
    *(_QWORD *)&src[200] = v491;
    *(_QWORD *)&src[208] = v449;
    *(_QWORD *)&src[216] = v515;
    *(_QWORD *)&src[248] = 0LL;
    src[256] = 0;
    v106 = (void *)_rust_alloc(264LL, 8LL);
    if ( !v106 )
      alloc::alloc::handle_alloc_error(8LL, 264LL);
    v107 = v106;
    memcpy(v106, src, 0x108uLL);
    if ( *(_QWORD *)&v579[208] && !_InterlockedDecrement64(*(volatile signed __int64 **)&v579[208]) )
      alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v579[208]);
    *(_QWORD *)&v579[208] = v107;
    if ( *v533 )
      _rust_dealloc(v533[1], 24 * *v533, 8LL);
    LODWORD(v532) = 0;
  }
  memcpy(&src[16], v579, 0xF8uLL);
  *(_QWORD *)src = 1LL;
  *(_QWORD *)&src[8] = 1LL;
  v108 = (void *)_rust_alloc(264LL, 8LL);
  if ( !v108 )
    alloc::alloc::handle_alloc_error(8LL, 264LL);
  v109 = (__int64)v108;
  memcpy(v108, src, 0x108uLL);
  v544 = v109;
  v545 = 0LL;
  v546 = &byte_8;
  v547 = 0LL;
  v110 = *(_QWORD *)(v109 + 56);
  v543 = *(_QWORD *)(v109 + 48);
  v559 = v543;
  v560 = v110;
  v561 = 0LL;
  v540 = v110;
  if ( !v110 )
    goto LABEL_198;
  v535 = v109;
  v111 = 8LL;
  v112 = 0LL;
  v539 = (char **)src;
  v113 = 0LL;
  v114 = v110;
  do
  {
    v116 = v112;
    gimli::read::aranges::ArangeHeader<R,Offset>::parse((__int64)src, &v559, v113);
    if ( src[41] == 3 )
      goto LABEL_206;
    v113 = v561 + v114 - v560;
    v561 = v113;
    v117 = *(_QWORD *)&src[16];
    v118 = *(_QWORD *)&src[32];
    if ( v112 == v545 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v545, v112);
      v111 = (__int64)v546;
      v116 = v547;
    }
    v115 = 16 * v116;
    *(_QWORD *)(v111 + v115) = v118;
    *(_QWORD *)(v111 + v115 + 8) = v117;
    v112 = v116 + 1;
    v547 = v116 + 1;
    v114 = v560;
  }
  while ( v560 );
  v424 = v546;
  if ( v112 >= 0x15 )
  {
    v432 = v116 + 1;
    v541 = (8 * v112) & 0x7FFFFFFFFFFFFFF0LL;
    v498 = (char *)_rust_alloc(v541, 8LL);
    if ( !v498 )
      core::option::unwrap_failed((__int64)&off_58430);
    v119 = _rust_alloc(256LL, 8LL);
    if ( !v119 )
      core::option::unwrap_failed((__int64)&off_58448);
    v120 = (char *)v119;
    v506 = 1 - v116;
    v534 = v424 + 32;
    v530 = v424 + 16;
    v485 = v424 - 16;
    v478 = 16LL;
    v121 = 0LL;
    v549 = &off_583D0;
    v122 = 0LL;
    v123 = aRustc9b00956e5;
    v124 = v432;
    while ( 1 )
    {
      v125 = v121;
      v126 = v124 - v121;
      v127 = 16 * v125;
      v128 = &v424[16 * v125];
      if ( v126 < 2 )
        break;
      v134 = *((_QWORD *)v128 + 2);
      if ( v134 >= *(_QWORD *)v128 )
      {
        v129 = 2LL;
        if ( v126 != 2 )
        {
          v175 = (unsigned __int64 *)&v534[v127];
          v129 = 2LL;
          while ( 1 )
          {
            v176 = v134;
            v134 = *v175;
            if ( *v175 < v176 )
              break;
            v177 = v506 + v125 + v129++ + 1;
            v175 += 2;
            if ( v177 == 2 )
              goto LABEL_120;
          }
        }
        goto LABEL_121;
      }
      v129 = 2LL;
      if ( v126 != 2 )
      {
        v135 = (unsigned __int64 *)&v534[v127];
        v129 = 2LL;
        while ( 1 )
        {
          v136 = v134;
          v134 = *v135;
          if ( *v135 >= v136 )
            break;
          v137 = v506 + v125 + v129++ + 1;
          v135 += 2;
          if ( v137 == 2 )
          {
            v129 = v126;
            break;
          }
        }
      }
      v131 = v125 + v129;
      if ( __CFADD__(v125, v129) )
      {
        v418 = v125;
        v419 = v125 + v129;
LABEL_674:
        core::slice::index::slice_index_order_fail(v418, v419, (__int64)v549);
      }
      v130 = v120;
      if ( v131 > v124 )
        core::slice::index::slice_end_index_len_fail(v131, v124, (__int64)&off_583D0);
      if ( v129 >= 2 )
      {
        v178 = v129 >> 1;
        v179 = (__int64)&v128[16 * v129 + -16 * (v129 >> 1)];
        if ( v129 >> 1 == 1 )
        {
          v180 = 0LL;
        }
        else
        {
          v181 = (unsigned __int8 *)&v530[v127];
          v182 = (unsigned __int8 *)&v485[16 * v125 + 16 * v129];
          v180 = 0LL;
          do
          {
            v183 = *((_OWORD *)v181 - 1);
            *((_OWORD *)v181 - 1) = *(_OWORD *)v182;
            *(_OWORD *)v182 = v183;
            v184 = 16 * (v178 + (v180 ^ 0xFFFFFFFFFFFFFFELL));
            v185 = *(_OWORD *)v181;
            *(_OWORD *)v181 = *(_OWORD *)(v179 + v184);
            *(_OWORD *)(v179 + v184) = v185;
            v180 += 2LL;
            v181 += 32;
            v182 -= 32;
          }
          while ( (v178 & 0x7FFFFFFFFFFFFFFELL) != v180 );
        }
        if ( (v129 & 2) != 0 )
        {
          v186 = ~v180 + v178;
          v187 = 16 * v180;
          v186 *= 16LL;
          v188 = *(_OWORD *)&v128[v187];
          *(_OWORD *)&v128[v187] = *(_OWORD *)(v179 + v186);
          *(_OWORD *)(v179 + v186) = v188;
        }
        v124 = v432;
        v131 = v125 + v129;
      }
      else
      {
        v129 = 1LL;
      }
LABEL_122:
      v132 = v131 - v125;
      if ( v131 < v125 || v131 > v124 )
        core::panicking::panic((__int64)aAssertionFaile, 44LL, (__int64)&off_584A0);
      if ( v131 < v124 && v129 < 0xA )
      {
        v133 = v125 + 10;
        if ( v125 + 10 >= v124 )
          v133 = v124;
        if ( v125 > 0xFFFFFFFFFFFFFFF5LL )
        {
          v418 = v125;
          v419 = v133;
          v549 = &off_584B8;
          goto LABEL_674;
        }
        v450 = v133;
        v132 = v133 - v125;
        core::slice::sort::insertion_sort_shift_left((__int64)v128, v132, (v129 == 0) + v129);
        v124 = v432;
        if ( v122 != v478 )
          goto LABEL_144;
LABEL_142:
        v443 = v125;
        v138 = v123;
        v478 = 2 * v122;
        v139 = (char *)_rust_alloc(32 * v122, 8LL);
        if ( !v139 )
          core::option::unwrap_failed((__int64)&off_58460);
        v140 = v139;
        v141 = v122;
        v142 = 16 * v122;
        memcpy(v139, v130, v142);
        v143 = v142;
        v122 = v141;
        _rust_dealloc(v130, v143, 8LL);
        v130 = v140;
        v124 = v432;
        v123 = v138;
        v125 = v443;
        goto LABEL_144;
      }
      v450 = v131;
      if ( v122 == v478 )
        goto LABEL_142;
LABEL_144:
      v144 = 16 * v122;
      *(_QWORD *)&v130[v144] = v132;
      *(_QWORD *)&v130[v144 + 8] = v125;
      ++v122;
      v120 = v130;
      if ( v122 < 2 )
        goto LABEL_118;
      v461 = v130;
      while ( 1 )
      {
        v147 = v122;
        v148 = 16 * (v122 - 1);
        v149 = *(_QWORD *)&v120[v148];
        if ( v149 + *(_QWORD *)&v120[v148 + 8] != v124 )
        {
          v150 = *(_QWORD *)&v120[16 * v122 - 32];
          if ( v150 > v149 )
            break;
        }
        if ( v122 != 2 )
        {
          v151 = v122 - 3;
          v152 = *(_QWORD *)&v120[16 * v122 - 48];
          goto LABEL_157;
        }
LABEL_158:
        v151 = v122 - 2;
LABEL_159:
        if ( v122 <= v151 )
        {
          *(_QWORD *)src = &off_582D0;
          v414 = &off_583E8;
LABEL_660:
          v415 = (__int64)v539;
          v539[1] = (_BYTE *)(&dword_0 + 1);
          *(_QWORD *)(v415 + 16) = v123;
          *(_OWORD *)(v415 + 24) = 0LL;
          core::panicking::panic_fmt(v415, (__int64)v414);
        }
        v492 = v122 - 1;
        if ( v122 <= v151 + 1 )
        {
          *(_QWORD *)src = &off_582D0;
          v414 = &off_58400;
          v123 = aRustc9b00956e5;
          goto LABEL_660;
        }
        v153 = *(_QWORD *)&v120[16 * v151 + 8];
        v154 = 16 * (v151 + 1);
        v155 = *(_QWORD *)&v120[v154] + *(_QWORD *)&v120[v154 + 8];
        v156 = v155 - v153;
        if ( v155 < v153 )
          core::slice::index::slice_index_order_fail(*(_QWORD *)&v120[16 * v151 + 8], v155, (__int64)&off_58418);
        v516 = 16 * (v151 + 1);
        if ( v155 > v124 )
          core::slice::index::slice_end_index_len_fail(v155, v124, (__int64)&off_58418);
        v457 = *(_QWORD *)&v120[v154];
        v519 = v151;
        v525 = v147;
        v472 = 16 * v151;
        v157 = *(_QWORD *)&v120[16 * v151];
        *(_QWORD *)&v531 = *(_QWORD *)&v120[16 * v151 + 8];
        v158 = &v424[16 * v153];
        v159 = 16 * v157;
        v160 = &v158[16 * v157];
        v161 = 16 * v155;
        v162 = v156 - v157;
        v444 = v157;
        if ( v156 - v157 >= v157 )
        {
          memcpy(v498, v158, 16 * v157);
          v163 = &v498[v159];
          if ( v444 > 0 )
          {
            v165 = v472;
            if ( v156 <= v444 )
            {
              v145 = v498;
              v123 = aRustc9b00956e5;
            }
            else
            {
              v169 = &v424[v161];
              v145 = v498;
              v123 = aRustc9b00956e5;
              do
              {
                v170 = v145;
                v171 = 0;
                v172 = *(_QWORD *)v160 < *(_QWORD *)v145;
                v173 = *(_QWORD *)v160 >= *(_QWORD *)v145;
                v174 = v170;
                if ( *(_QWORD *)v160 < *(_QWORD *)v170 )
                  v174 = v160;
                *(_OWORD *)v158 = *(_OWORD *)v174;
                v158 += 16;
                v145 = &v170[16 * v173];
                if ( v145 >= v163 )
                  break;
                LOBYTE(v171) = v172;
                v160 += (unsigned int)(16 * v171);
              }
              while ( v160 < v169 );
            }
            goto LABEL_147;
          }
          v145 = v498;
          v123 = aRustc9b00956e5;
        }
        else
        {
          memcpy(v498, &v158[16 * v157], 16 * v162);
          v163 = &v498[16 * v162];
          v123 = aRustc9b00956e5;
          if ( v444 > 0 && v162 > 0 )
          {
            v164 = (unsigned __int8 *)&v485[v161];
            v165 = v472;
            do
            {
              v166 = *((_QWORD *)v163 - 2);
              v167 = *((_QWORD *)v160 - 2);
              v160 -= 16 * (v166 < v167);
              v163 += 16 * (v166 < v167) - 16;
              v168 = v163;
              if ( v166 < v167 )
                v168 = v160;
              *(_OWORD *)v164 = *(_OWORD *)v168;
              if ( v160 <= v158 )
                break;
              v164 -= 16;
            }
            while ( v163 > v498 );
            v158 = v160;
            v145 = v498;
            goto LABEL_147;
          }
          v158 = v160;
          v145 = v498;
        }
        v165 = v472;
LABEL_147:
        v120 = v461;
        v146 = &v461[v516];
        memcpy(v158, v145, v163 - v145);
        *(_QWORD *)v146 = v444 + v457;
        *((_QWORD *)v146 + 1) = v531;
        memmove(&v461[v165], &v461[v165 + 16], 16 * (~v519 + v525));
        v122 = v492;
        v124 = v432;
        if ( v492 <= 1 )
        {
          v122 = 1LL;
          goto LABEL_118;
        }
      }
      if ( v122 == 2 )
      {
        v122 = 2LL;
        goto LABEL_118;
      }
      v151 = v122 - 3;
      v152 = *(_QWORD *)&v120[16 * v122 - 48];
      if ( v152 <= v150 + v149 )
        goto LABEL_157;
      if ( v122 > 3 )
      {
        if ( *(_QWORD *)&v120[16 * v122 - 64] > v152 + v150 )
          goto LABEL_118;
LABEL_157:
        if ( v152 < v149 )
          goto LABEL_159;
        goto LABEL_158;
      }
      v122 = 3LL;
LABEL_118:
      v121 = v450;
      if ( v450 >= v124 )
      {
        _rust_dealloc(v120, 16 * v478, 8LL);
        _rust_dealloc(v498, v541, 8LL);
        v109 = v535;
        goto LABEL_198;
      }
    }
LABEL_120:
    v129 = v126;
LABEL_121:
    v130 = v120;
    v131 = v129 + v125;
    goto LABEL_122;
  }
  v109 = v535;
  if ( v112 > 1 )
    core::slice::sort::insertion_sort_shift_left((__int64)v546, v112, 1uLL);
LABEL_198:
  v527 = 0LL;
  v528 = 8LL;
  v529 = 0LL;
  *(_QWORD *)v536 = 0LL;
  *(_QWORD *)&v536[8] = 8LL;
  *(_QWORD *)&v536[16] = 0LL;
  v189 = v109;
  *(_OWORD *)v548 = *(_OWORD *)(v109 + 64);
  *(_QWORD *)&v548[16] = 0LL;
  gimli::read::unit::DebugInfoUnitHeadersIter<R>::next((__int64)src, (__int64)v548);
  v194 = *(_QWORD *)src;
  if ( *(_QWORD *)src == 3LL )
    goto LABEL_199;
  v499 = (_QWORD *)(v109 + 16);
  v526 = *(_QWORD *)(v109 + 208);
  v493 = *(_QWORD *)(v109 + 216);
  LOBYTE(v519) = *(_BYTE *)(v109 + 256);
  v517 = *(_QWORD *)(v109 + 32);
  v445 = *(_QWORD *)(v109 + 40);
  v534 = src;
  do
  {
    v200 = *(_QWORD *)&src[8];
    *(_QWORD *)&v578[48] = *(_QWORD *)&src[72];
    *(_OWORD *)&v578[32] = *(_OWORD *)&src[56];
    *(_OWORD *)&v578[16] = *(_OWORD *)&src[40];
    *(_OWORD *)v578 = *(_OWORD *)&src[24];
    v588 = *(_OWORD *)&src[24];
    v571 = *(_OWORD *)&src[40];
    v572 = *(__m128 *)&src[56];
    *(_QWORD *)&v573 = *(_QWORD *)&src[72];
    if ( v194 == 2 )
    {
      v283 = v528;
      v284 = v529;
      if ( v529 < 0x15 )
      {
        if ( v529 <= 1 )
          goto LABEL_559;
        core::slice::sort::insertion_sort_shift_left(v528, v529, 1uLL);
        goto LABEL_560;
      }
      v535 = (16 * v529) & 0x7FFFFFFFFFFFFFE0LL;
      v285 = _rust_alloc(v535, 8LL);
      if ( !v285 )
        core::option::unwrap_failed((__int64)&off_58430);
      v286 = (char *)v285;
      v287 = _rust_alloc(256LL, 8LL);
      v428 = v286;
      if ( !v287 )
        core::option::unwrap_failed((__int64)&off_58448);
      v288 = (_QWORD *)v287;
      v510 = v283 + 64;
      v540 = v283 + 16;
      v543 = v283 - 16;
      v486 = v283 - 32;
      v482 = 16LL;
      v289 = 0LL;
      v539 = &off_583D0;
      v290 = 0LL;
      v436 = v283;
      v465 = v284;
LABEL_483:
      while ( 2 )
      {
        v291 = v283;
        v292 = v289;
        v293 = v284 - v289;
        v294 = 32 * v289;
        v295 = (unsigned __int64 *)(v291 + 32 * v289);
        if ( v284 - v289 >= 2 )
        {
          v300 = v295[4];
          if ( v300 < *v295 )
          {
            i = 2LL;
            if ( v293 != 2 )
            {
              v302 = (unsigned __int64 *)(v510 + v294);
              for ( i = 2LL; i != v293; ++i )
              {
                v303 = v300;
                v300 = *v302;
                if ( *v302 >= v303 )
                  goto LABEL_501;
                v302 += 4;
              }
              i = v293;
            }
LABEL_501:
            v297 = v292 + i;
            if ( __CFADD__(v292, i) )
              goto LABEL_680;
            if ( v297 > v284 )
              core::slice::index::slice_end_index_len_fail(v292 + i, v284, (__int64)&off_583D0);
            v296 = 1LL;
            if ( i >= 2 )
            {
              v304 = i >> 1;
              v305 = (__int128 *)(v540 + v294);
              v306 = (__int128 *)(v543 + 32 * v297);
              do
              {
                v307 = *(v305 - 1);
                *(v305 - 1) = *(v306 - 1);
                *(v306 - 1) = v307;
                v308 = *v305;
                *v305 = *v306;
                *v306 = v308;
                v305 += 2;
                v306 -= 2;
                --v304;
              }
              while ( v304 );
              v296 = i;
              v297 = v292 + i;
            }
LABEL_486:
            v298 = v297 - v292;
            if ( v297 < v292 || v297 > v284 )
              core::panicking::panic((__int64)aAssertionFaile, 44LL, (__int64)&off_584A0);
            if ( v297 >= v284 || v296 >= 0xA )
            {
              v454 = v297;
              if ( v290 != v482 )
              {
LABEL_510:
                v310 = 2 * v290;
                v288[v310] = v298;
                v288[v310 + 1] = v292;
                if ( ++v290 < 2 )
                {
                  v283 = v436;
                  v289 = v454;
                  if ( v454 >= v284 )
                    goto LABEL_558;
                  continue;
                }
                v283 = v436;
                v501 = v288;
                while ( 1 )
                {
                  v314 = 2 * (v290 - 1);
                  v315 = v288[v314];
                  if ( v315 + v288[v314 + 1] != v284 )
                  {
                    v316 = v288[2 * v290 - 4];
                    if ( v316 > v315 )
                      break;
                  }
                  if ( v290 != 2 )
                  {
                    v317 = v290 - 3;
                    v318 = v288[2 * v290 - 6];
                    goto LABEL_523;
                  }
LABEL_524:
                  v317 = v290 - 2;
LABEL_525:
                  if ( v290 <= v317 )
                  {
                    *(_QWORD *)src = &off_582D0;
                    v416 = &off_583E8;
LABEL_667:
                    v417 = (__int64)v534;
                    *((_QWORD *)v534 + 1) = 1LL;
                    *(_QWORD *)(v417 + 16) = aRustc9b00956e5;
                    *(_OWORD *)(v417 + 24) = 0LL;
                    core::panicking::panic_fmt(v417, (__int64)v416);
                  }
                  if ( v290 <= v317 + 1 )
                  {
                    *(_QWORD *)src = &off_582D0;
                    v416 = &off_58400;
                    goto LABEL_667;
                  }
                  v319 = v288[2 * v317 + 1];
                  v320 = 2 * (v317 + 1);
                  v321 = v288[v320];
                  v322 = v321 + v288[v320 + 1];
                  v323 = v322 - v319;
                  if ( v322 < v319 )
                    core::slice::index::slice_index_order_fail(v319, v322, (__int64)&off_58418);
                  v446 = v290 - 1;
                  if ( v322 > v284 )
                    core::slice::index::slice_end_index_len_fail(v322, v465, (__int64)&off_58418);
                  v457 = v321;
                  v519 = 16 * (v317 + 1);
                  v517 = v317;
                  v493 = v290;
                  v526 = 16 * v317;
                  v324 = v501[2 * v317];
                  *(_QWORD *)&v531 = v319;
                  v311 = (__int128 *)(v283 + 32 * v319);
                  v325 = 32 * v324;
                  v326 = &v311[2 * v324];
                  v327 = 32 * v322;
                  v328 = v323 - v324;
                  v474 = v324;
                  if ( v323 - v324 >= v324 )
                  {
                    memcpy(v428, v311, 32 * v324);
                    v329 = &v428[v325];
                    if ( v474 <= 0 || v323 <= v474 )
                    {
                      v330 = v474;
                      v312 = v428;
                    }
                    else
                    {
                      v336 = v436 + v327;
                      v312 = v428;
                      do
                      {
                        v337 = (__int128 *)v312;
                        v338 = 0;
                        v339 = *(_QWORD *)v326 < *(_QWORD *)v312;
                        v340 = *(_QWORD *)v326 >= *(_QWORD *)v312;
                        v341 = v337;
                        if ( *(_QWORD *)v326 < *(_QWORD *)v337 )
                          v341 = v326;
                        v342 = *v341;
                        v311[1] = v341[1];
                        *v311 = v342;
                        v311 += 2;
                        v312 = (char *)v337 + (unsigned int)(32 * v340);
                        if ( v312 >= v329 )
                          break;
                        LOBYTE(v338) = v339;
                        v326 = (__int128 *)((char *)v326 + (unsigned int)(32 * v338));
                      }
                      while ( (unsigned __int64)v326 < v336 );
                      v330 = v474;
                    }
                  }
                  else
                  {
                    memcpy(v428, &v311[2 * v324], 32 * v328);
                    v329 = &v428[32 * v328];
                    v330 = v474;
                    if ( v474 > 0 && v328 > 0 )
                    {
                      v331 = (_OWORD *)(v486 + v327);
                      do
                      {
                        v332 = *((_QWORD *)v329 - 4);
                        v333 = *((_QWORD *)v326 - 4);
                        v326 -= 2 * (v332 < v333);
                        v329 += 32 * (v332 < v333) - 32;
                        v334 = v329;
                        if ( v332 < v333 )
                          v334 = (char *)v326;
                        v335 = *(_OWORD *)v334;
                        v331[1] = *((_OWORD *)v334 + 1);
                        *v331 = v335;
                        if ( v326 <= v311 )
                          break;
                        v331 -= 2;
                      }
                      while ( v329 > v428 );
                    }
                    v311 = v326;
                    v312 = v428;
                  }
                  v288 = v501;
                  v313 = (_QWORD *)((char *)v501 + v519);
                  memcpy(v311, v312, v329 - v312);
                  *v313 = v330 + v457;
                  v313[1] = v531;
                  memmove((char *)v501 + v526, (char *)v501 + v526 + 16, 16 * (~v517 + v493));
                  v290 = v446;
                  v284 = v465;
                  v283 = v436;
                  if ( v446 <= 1 )
                  {
                    v290 = 1LL;
                    v289 = v454;
                    v286 = v428;
                    if ( v454 >= v465 )
                      goto LABEL_558;
                    goto LABEL_483;
                  }
                }
                if ( v290 == 2 )
                {
                  v290 = 2LL;
LABEL_555:
                  v289 = v454;
                  v286 = v428;
                  if ( v454 >= v284 )
                  {
LABEL_558:
                    _rust_dealloc(v288, 16 * v482, 8LL);
                    _rust_dealloc(v286, v535, 8LL);
                    v283 = v528;
                    v284 = v529;
LABEL_559:
                    if ( v284 )
                    {
LABEL_560:
                      v345 = 0LL;
                      v346 = v283;
                      do
                      {
                        if ( v345 <= *(_QWORD *)(v346 + 8) )
                          v345 = *(_QWORD *)(v346 + 8);
                        *(_QWORD *)(v346 + 24) = v345;
                        v346 += 32LL;
                      }
                      while ( v346 != v283 + 32 * v284 );
                    }
                    else
                    {
                      v284 = 0LL;
                    }
                    v347 = v527;
                    v576 = *(_OWORD *)v536;
                    v577 = *(_QWORD *)&v536[16];
                    if ( v545 )
                      _rust_dealloc(v546, 16 * v545, 8LL);
                    v198 = (volatile signed __int64 *)v544;
                    if ( v347 == 0x8000000000000000LL )
                      goto LABEL_209;
                    v447 = v347;
                    v437 = (void *)v283;
                    *(_QWORD *)&v536[16] = v577;
                    *(_OWORD *)v536 = v576;
                    v348 = *(_QWORD *)(v544 + 224);
                    v466 = v284;
                    if ( !v348 )
                    {
                      *(_QWORD *)v548 = 0LL;
                      *(_QWORD *)&v548[8] = 8LL;
                      v353 = 8LL;
                      v354 = 0LL;
                      v355 = 0LL;
                      goto LABEL_580;
                    }
                    v550.m256i_i64[0] = 0LL;
                    *(_OWORD *)&v550.m256i_u64[1] = 8uLL;
                    v571 = *(_OWORD *)(v348 + 64);
                    v572.m128_u64[0] = 0LL;
                    gimli::read::unit::DebugInfoUnitHeadersIter<R>::next((__int64)src, (__int64)&v571);
                    v349 = *(_QWORD *)src;
                    if ( *(_QWORD *)src == 3LL )
                    {
LABEL_571:
                      core::ptr::drop_in_place<alloc::vec::Vec<addr2line::SupUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>>(v550.m256i_i64);
                      goto LABEL_572;
                    }
                    v356 = (_QWORD *)(v348 + 16);
                    v357 = 8LL;
                    v355 = 0LL;
                    while ( 1 )
                    {
                      *(_OWORD *)v553 = *(_OWORD *)&src[24];
                      *(_OWORD *)&v553[16] = *(_OWORD *)&src[40];
                      *(_OWORD *)&v553[32] = *(_OWORD *)&src[56];
                      *(_QWORD *)&v553[48] = *(_QWORD *)&src[72];
                      if ( v349 )
                      {
                        if ( v349 == 2 )
                        {
                          v354 = v550.m256i_i64[0];
                          if ( v550.m256i_i64[0] != 0x8000000000000000LL )
                          {
                            *(_QWORD *)v548 = v550.m256i_i64[0];
                            v353 = v357;
                            *(_QWORD *)&v548[8] = v357;
LABEL_580:
                            *(_QWORD *)&v548[16] = v355;
                            *(_QWORD *)src = v198;
                            v502 = v437;
                            if ( v447 > v284 )
                            {
                              v493 = v353;
                              if ( v284 )
                              {
                                v502 = (void *)_rust_realloc(v437, 32 * v447, 8LL, 32 * v284);
                                if ( !v502 )
                                  alloc::alloc::handle_alloc_error(8LL, 32 * v284);
                              }
                              else
                              {
                                v502 = &byte_8;
                                _rust_dealloc(v437, 32 * v447, 8LL);
                              }
                            }
                            v359 = *(_QWORD *)&v536[8];
                            v360 = *(_QWORD *)&v536[16];
                            if ( *(_QWORD *)v536 > *(_QWORD *)&v536[16] )
                            {
                              v361 = 536LL * *(_QWORD *)v536;
                              if ( *(_QWORD *)&v536[16] )
                              {
                                v493 = 536LL * *(_QWORD *)&v536[16];
                                v359 = _rust_realloc(*(_QWORD *)&v536[8], v361, 8LL, 536LL * *(_QWORD *)&v536[16]);
                                if ( !v359 )
                                  alloc::alloc::handle_alloc_error(8LL, v493);
                              }
                              else
                              {
                                _rust_dealloc(*(_QWORD *)&v536[8], v361, 8LL);
                                v359 = 8LL;
                              }
                            }
                            if ( v354 > v355 )
                            {
                              v362 = 432 * v354;
                              if ( v355 )
                              {
                                v353 = _rust_realloc(v353, v362, 8LL, 432 * v355);
                                v363 = v542;
                                if ( !v353 )
                                  alloc::alloc::handle_alloc_error(8LL, 432 * v355);
LABEL_607:
                                if ( !v198 )
                                  goto LABEL_211;
                                *(_QWORD *)&v567 = v198;
                                *((_QWORD *)&v567 + 1) = v502;
                                *(_QWORD *)&v568 = v466;
                                *((_QWORD *)&v568 + 1) = v359;
                                *(_QWORD *)&v569 = v360;
                                *((_QWORD *)&v569 + 1) = v353;
                                v570 = v355;
                                v364 = v538;
                                v365 = *v538;
                                if ( *v538 == 0x8000000000000000LL )
                                {
                                  v366 = 22;
LABEL_610:
                                  v367 = v555;
                                  v555[14] = v484[14];
                                  v368 = *((_OWORD *)v484 + 5);
                                  v369 = *((_OWORD *)v484 + 4);
                                  v370 = *(_OWORD *)v484;
                                  v371 = *((_OWORD *)v484 + 1);
                                  v372 = *((_OWORD *)v484 + 2);
                                  v373 = *((_OWORD *)v484 + 3);
                                  *((_OWORD *)v367 + 6) = *((_OWORD *)v484 + 6);
                                  *((_OWORD *)v367 + 5) = v368;
                                  *((_OWORD *)v367 + 4) = v369;
                                  *((_OWORD *)v367 + 3) = v373;
                                  *((_OWORD *)v367 + 2) = v372;
                                  *((_OWORD *)v367 + 1) = v371;
                                  *(_OWORD *)v367 = v370;
                                  *((_BYTE *)v367 + 120) = v366;
                                  *(_OWORD *)((char *)v367 + 185) = v584[0];
                                  v367[25] = *(_QWORD *)((char *)v584 + 15);
                                  v374 = v581;
                                  v375 = v582;
                                  v376 = v583;
                                  *(_OWORD *)((char *)v367 + 121) = v580;
                                  *(_OWORD *)((char *)v367 + 137) = v374;
                                  *(_OWORD *)((char *)v367 + 153) = v375;
                                  *(_OWORD *)((char *)v367 + 169) = v376;
                                  *((_BYTE *)v367 + 208) = (_BYTE)v363;
                                  v367[28] = *(_QWORD *)&v575[15];
                                  *(_OWORD *)((char *)v367 + 209) = *(_OWORD *)v575;
                                  v377 = *(_OWORD *)&v585.m256i_u64[2];
                                  v378 = v586;
                                  v379 = v587;
                                  *(_OWORD *)(v367 + 29) = *(_OWORD *)v585.m256i_i8;
                                  *(_OWORD *)(v367 + 31) = v377;
                                  *(_OWORD *)(v367 + 33) = v378;
                                  *(_OWORD *)(v367 + 35) = v379;
                                  v367[37] = v517;
                                  v367[38] = v190;
                                  v367[39] = v191;
                                  v367[40] = v502;
                                  v367[41] = v193;
                                  v367[42] = v447;
                                  v367[43] = v198;
                                  v367[44] = v493;
                                  v367[45] = v354;
                                  v367[46] = v355;
                                  v367[47] = v526;
                                  v367[48] = v364;
                                  v367[49] = v519;
                                  v367[50] = v192;
                                  v367[51] = v531;
                                  v367[52] = v365;
                                  v367[53] = v457;
                                  v367[54] = v359;
                                  v367[55] = aRustc9b00956e5;
                                  v367[56] = 0LL;
                                  result = v570;
                                  v367[63] = v570;
                                  v380 = v567;
                                  v381 = v568;
                                  *(_OWORD *)(v367 + 61) = v569;
                                  *(_OWORD *)(v367 + 59) = v381;
                                  *(_OWORD *)(v367 + 57) = v380;
                                  return result;
                                }
                                v382 = (char *)std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                                 v538,
                                                 v363,
                                                 aDebugCuIndex,
                                                 0xFuLL);
                                if ( !v382 )
                                {
                                  v383 = 0LL;
                                  v382 = aRustc9b00956e5;
                                }
                                gimli::read::index::UnitIndex<R>::parse((__int64)src, (unsigned int *)v382, v383);
                                v384 = src[0];
                                if ( src[0] != 22 )
                                {
                                  *(_QWORD *)&v536[15] = *(_QWORD *)&src[16];
                                  *(_OWORD *)v536 = *(_OWORD *)&src[1];
                                  *(_OWORD *)v553 = *(_OWORD *)&src[24];
                                  *(_OWORD *)&v553[16] = *(_OWORD *)&src[40];
                                  *(_OWORD *)&v553[32] = *(_OWORD *)&src[56];
                                  *(_OWORD *)&v553[48] = *(_OWORD *)&src[72];
                                  v385 = (char *)std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                                   v538,
                                                   v542,
                                                   aDebugTuIndex,
                                                   0xFuLL);
                                  if ( !v385 )
                                  {
                                    v386 = 0LL;
                                    v385 = aRustc9b00956e5;
                                  }
                                  gimli::read::index::UnitIndex<R>::parse((__int64)src, (unsigned int *)v385, v386);
                                  if ( src[0] != 22 )
                                  {
                                    v467 = src[0];
                                    *(_QWORD *)&v548[15] = *(_QWORD *)&src[16];
                                    *(_OWORD *)v548 = *(_OWORD *)&src[1];
                                    v550 = *(__m256i *)&src[24];
                                    v551 = *(_OWORD *)&src[56];
                                    v552 = *(_OWORD *)&src[72];
                                    v387 = v538;
                                    v388 = v542;
                                    v389 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                             v538,
                                             v542,
                                             aDebugAbbrevDwo,
                                             0x11uLL);
                                    v391 = v390;
                                    if ( !v389 )
                                      v391 = 0LL;
                                    v475 = v391;
                                    if ( !v389 )
                                      v389 = aRustc9b00956e5;
                                    v517 = (unsigned __int64)v389;
                                    v392 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                             v387,
                                             v388,
                                             aDebugInfoDwo,
                                             0xFuLL);
                                    v394 = v393;
                                    if ( !v392 )
                                      v394 = 0LL;
                                    v502 = v394;
                                    if ( !v392 )
                                      v392 = aRustc9b00956e5;
                                    v487 = v392;
                                    v395 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                             v387,
                                             v388,
                                             aDebugLineDwo,
                                             0xFuLL);
                                    v397 = v396;
                                    if ( !v395 )
                                      v397 = 0LL;
                                    v447 = v397;
                                    if ( !v395 )
                                      v395 = aRustc9b00956e5;
                                    v455 = v395;
                                    v398 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                             v387,
                                             v388,
                                             aDebugStrDwo,
                                             0xEuLL);
                                    v400 = v399;
                                    if ( !v398 )
                                      v400 = 0LL;
                                    v493 = v400;
                                    if ( !v398 )
                                      v398 = aRustc9b00956e5;
                                    v483 = (char *)v398;
                                    v401 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                             v387,
                                             v388,
                                             aDebugStrOffset_0,
                                             0x16uLL);
                                    v403 = v402;
                                    if ( !v401 )
                                    {
                                      v403 = 0LL;
                                      v401 = aRustc9b00956e5;
                                    }
                                    v537 = (unsigned __int64)v401;
                                    v404 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                             v387,
                                             v388,
                                             aDebugLocDwo,
                                             0xEuLL);
                                    v406 = v405;
                                    if ( !v404 )
                                      v406 = 0LL;
                                    v429 = v406;
                                    if ( !v404 )
                                      v404 = aRustc9b00956e5;
                                    v526 = (__int64)v404;
                                    v407 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                             v387,
                                             v388,
                                             aDebugLoclistsD,
                                             0x13uLL);
                                    v409 = v408;
                                    if ( !v407 )
                                      v409 = 0LL;
                                    v438 = v409;
                                    if ( !v407 )
                                      v407 = aRustc9b00956e5;
                                    v519 = (__int64)v407;
                                    v410 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                             v387,
                                             v388,
                                             aDebugRnglistsD,
                                             0x13uLL);
                                    if ( !v410 )
                                      v411 = 0LL;
                                    v511 = v411;
                                    if ( !v410 )
                                      v410 = aRustc9b00956e5;
                                    *(_QWORD *)&v531 = v410;
                                    v412 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                             v387,
                                             v388,
                                             aDebugTypesDwo,
                                             0x10uLL);
                                    v532 = v403;
                                    LOBYTE(v533) = v384;
                                    if ( !v412 )
                                      v413 = 0LL;
                                    v534 = (_BYTE *)v413;
                                    if ( !v412 )
                                      v412 = aRustc9b00956e5;
                                    v457 = (__int64)v412;
                                    v574 = *(_OWORD *)&v553[48];
                                    v573 = *(_OWORD *)&v553[32];
                                    v572 = *(__m128 *)&v553[16];
                                    v571 = *(_OWORD *)v553;
                                    *(_OWORD *)v578 = *(_OWORD *)v536;
                                    *(_QWORD *)&v578[15] = *(_QWORD *)&v536[15];
                                    *(_OWORD *)&v578[23] = *(_OWORD *)v553;
                                    *(_OWORD *)&v578[39] = *(_OWORD *)&v553[16];
                                    *(_OWORD *)&v578[55] = *(_OWORD *)&v553[32];
                                    *(_OWORD *)&v578[71] = *(_OWORD *)&v553[48];
                                    *(_QWORD *)&v575[15] = *(_QWORD *)&v548[15];
                                    *(_OWORD *)v575 = *(_OWORD *)v548;
                                    v587 = v552;
                                    v586 = v551;
                                    v585 = v550;
                                    *(_QWORD *)((char *)v584 + 15) = *(_QWORD *)&v553[56];
                                    v584[0] = *(_OWORD *)&v578[64];
                                    v583 = *(_OWORD *)&v578[48];
                                    v582 = *(_OWORD *)&v578[32];
                                    v581 = *(_OWORD *)&v578[16];
                                    v580 = *(_OWORD *)v578;
                                    if ( v365 )
                                      _rust_dealloc(v538[1], 24 * v365, 8LL);
                                    LOBYTE(v363) = v467;
                                    v190 = v475;
                                    v191 = v487;
                                    v193 = v455;
                                    v198 = (volatile signed __int64 *)v483;
                                    v354 = v537;
                                    v366 = (char)v533;
                                    v355 = v532;
                                    v364 = v429;
                                    v192 = v438;
                                    v365 = v511;
                                    v359 = (__int64)v534;
                                    goto LABEL_610;
                                  }
                                }
                                *v555 = 0x8000000000000000LL;
                                v199 = v484;
                                if ( v365 )
                                  _rust_dealloc(v538[1], 24 * v365, 8LL);
                                core::ptr::drop_in_place<addr2line::Context<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>((__int64 *)&v567);
                                if ( v537 != 0x8000000000000000LL )
                                  goto LABEL_459;
LABEL_457:
                                if ( 2 * *v533 )
                                  _rust_dealloc(v533[1], 24 * *v533, 8LL);
                                goto LABEL_459;
                              }
                              _rust_dealloc(v353, v362, 8LL);
                              v353 = 8LL;
                            }
                            v363 = v542;
                            goto LABEL_607;
                          }
LABEL_572:
                          v350 = *(_QWORD *)&v536[8];
                          v351 = *(_QWORD *)&v536[16] + 1LL;
                          v352 = *(_QWORD *)&v536[8];
                          while ( v351 != 1 )
                          {
                            --v351;
                            core::ptr::drop_in_place<addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(v352);
                            v352 += 536LL;
                          }
                          if ( *(_QWORD *)v536 )
                            _rust_dealloc(v350, 536LL * *(_QWORD *)v536, 8LL);
                          if ( v447 )
                            _rust_dealloc(v437, 32 * v447, 8LL);
                          goto LABEL_209;
                        }
                      }
                      else
                      {
                        *(_QWORD *)src = 0LL;
                        v503 = *(__m128 *)&src[8];
                        *(_QWORD *)&src[72] = *(_QWORD *)&v553[48];
                        *(_OWORD *)&src[56] = *(_OWORD *)&v553[32];
                        *(_OWORD *)&src[40] = *(_OWORD *)&v553[16];
                        *(_OWORD *)&src[24] = *(_OWORD *)v553;
                        gimli::read::dwarf::Unit<R>::new(v578, v356, (__int64)src);
                        if ( *(_DWORD *)v578 != 2 )
                        {
                          memcpy(src, v578, 0x1A8uLL);
                          _mm_storel_ps((double *)&src[424], v503);
                          if ( v355 == v550.m256i_i64[0] )
                          {
                            alloc::raw_vec::RawVec<T,A>::reserve_for_push(v550.m256i_i64, v355);
                            v355 = v550.m256i_u64[2];
                            v358 = v550.m256i_i64[1];
                          }
                          else
                          {
                            v358 = v357;
                          }
                          v357 = v358;
                          memcpy((void *)(v358 + 432 * v355++), src, 0x1B0uLL);
                          v550.m256i_i64[2] = v355;
                        }
                      }
                      gimli::read::unit::DebugInfoUnitHeadersIter<R>::next((__int64)src, (__int64)&v571);
                      v349 = *(_QWORD *)src;
                      if ( *(_QWORD *)src == 3LL )
                        goto LABEL_571;
                    }
                  }
                  continue;
                }
                v317 = v290 - 3;
                v318 = v288[2 * v290 - 6];
                if ( v318 > v316 + v315 )
                {
                  if ( v290 <= 3 )
                  {
                    v290 = 3LL;
                    v289 = v454;
                    v286 = v428;
                    if ( v454 >= v284 )
                      goto LABEL_558;
                    continue;
                  }
                  if ( v288[2 * v290 - 8] > v318 + v316 )
                    goto LABEL_555;
                }
LABEL_523:
                if ( v318 < v315 )
                  goto LABEL_525;
                goto LABEL_524;
              }
            }
            else
            {
              v299 = v292 + 10;
              if ( v292 + 10 >= v284 )
                v299 = v284;
              if ( v292 > 0xFFFFFFFFFFFFFFF5LL )
              {
                v297 = v299;
                v539 = &off_584B8;
LABEL_680:
                core::slice::index::slice_index_order_fail(v292, v297, (__int64)v539);
              }
              v454 = v299;
              v298 = v299 - v292;
              core::slice::sort::insertion_sort_shift_left((__int64)v295, v298, (v296 == 0) + v296);
              if ( v290 != v482 )
                goto LABEL_510;
            }
            v500 = v288;
            v482 = 2 * v290;
            v309 = (_QWORD *)_rust_alloc(32 * v290, 8LL);
            if ( !v309 )
              core::option::unwrap_failed((__int64)&off_58460);
            v288 = v309;
            memcpy(v309, v500, 16 * v290);
            _rust_dealloc(v500, 16 * v290, 8LL);
            v286 = v428;
            goto LABEL_510;
          }
          v296 = 2LL;
          if ( v293 != 2 )
          {
            v343 = (unsigned __int64 *)(v510 + v294);
            while ( 1 )
            {
              v344 = v300;
              v300 = *v343;
              if ( *v343 < v344 )
                break;
              ++v296;
              v343 += 4;
              if ( v293 == v296 )
                goto LABEL_484;
            }
          }
        }
        else
        {
LABEL_484:
          v296 = v293;
        }
        break;
      }
      v297 = v296 + v292;
      goto LABEL_486;
    }
    if ( v194 )
      goto LABEL_218;
    if ( (*(_QWORD *)&src[16] | 4LL) == 5 )
      goto LABEL_218;
    v201 = *(_QWORD *)&v536[16];
    *(_QWORD *)v553 = 0LL;
    *(_QWORD *)&v553[8] = *(_QWORD *)&src[8];
    *(_QWORD *)&v553[16] = *(_QWORD *)&src[16];
    *(_OWORD *)&v553[24] = v588;
    v554 = v573;
    v202 = *(double *)&v571;
    v203 = v572;
    *(__m128 *)&v553[56] = v572;
    *(_OWORD *)&v553[40] = v571;
    gimli::read::dwarf::Unit<R>::new(src, v499, (__int64)v553);
    if ( *(_DWORD *)src == 2 )
      goto LABEL_218;
    memcpy(v578, src, sizeof(v578));
    *(_OWORD *)v553 = *(_OWORD *)&v578[40];
    *(_QWORD *)&v553[16] = v578;
    *(_QWORD *)&v553[24] = *(_QWORD *)&v578[344] + 16LL;
    *(_QWORD *)&v553[32] = 0LL;
    if ( !*(_QWORD *)&v578[48] )
      goto LABEL_466;
    v204 = 1LL - *(_QWORD *)&v578[48];
    v205 = *(_QWORD *)&v578[40] + 1LL;
    v206 = 0LL;
    v207 = 0;
    while ( 1 )
    {
      v208 = *(_BYTE *)(v205 - 1);
      if ( v207 == 63 && (unsigned __int8)v208 >= 2u )
      {
        *(_QWORD *)v553 = v205;
        *(_QWORD *)&v553[8] = -v204;
        goto LABEL_466;
      }
      v206 |= (unsigned __int64)(v208 & 0x7F) << v207;
      if ( v208 >= 0 )
        break;
      v207 += 7;
      ++v204;
      ++v205;
      if ( v204 == 1 )
      {
        *(_OWORD *)v553 = (unsigned __int64)(*(_QWORD *)&v578[48] + *(_QWORD *)&v578[40]);
        if ( !_InterlockedDecrement64(*(volatile signed __int64 **)&v578[344]) )
          goto LABEL_469;
        goto LABEL_470;
      }
    }
    *(_QWORD *)v553 = v205;
    *(_QWORD *)&v553[8] = -v204;
    if ( !v206 )
    {
      if ( !_InterlockedDecrement64(*(volatile signed __int64 **)&v578[344]) )
        alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v578[344]);
      if ( *(_DWORD *)&v578[96] != 47 )
      {
        if ( *(_QWORD *)&v578[160] )
          _rust_dealloc(*(_QWORD *)&v578[168], 4LL * *(_QWORD *)&v578[160], 2LL);
        if ( *(_QWORD *)&v578[184] )
          _rust_dealloc(*(_QWORD *)&v578[192], 24LL * *(_QWORD *)&v578[184], 8LL);
        if ( *(_QWORD *)&v578[208] )
          _rust_dealloc(*(_QWORD *)&v578[216], 4LL * *(_QWORD *)&v578[208], 2LL);
        if ( *(_QWORD *)&v578[232] )
          _rust_dealloc(*(_QWORD *)&v578[240], *(_QWORD *)&v578[232] << 6, 8LL);
      }
      goto LABEL_218;
    }
    if ( v206 - 1 < *(_QWORD *)(*(_QWORD *)&v578[344] + 32LL) )
    {
      v209 = *(_QWORD *)(*(_QWORD *)&v578[344] + 24LL) + 112 * (v206 - 1);
      goto LABEL_254;
    }
    v210 = *(_QWORD *)(*(_QWORD *)&v578[344] + 40LL);
    if ( !v210 )
      goto LABEL_466;
    v211 = *(_QWORD *)(*(_QWORD *)&v578[344] + 48LL);
LABEL_244:
    v212 = -1LL;
    v213 = 0LL;
    do
    {
      if ( !(v213 + 112LL * *(unsigned __int16 *)(v210 + 1330)) )
      {
        v212 = *(unsigned __int16 *)(v210 + 1330);
LABEL_252:
        v172 = v211-- == 0;
        if ( v172 )
          goto LABEL_466;
        v210 = *(_QWORD *)(v210 + 8 * v212 + 1336);
        goto LABEL_244;
      }
      v214 = *(_QWORD *)(v210 + 8 * v212 + 1248) != v206;
      if ( *(_QWORD *)(v210 + 8 * v212 + 1248) > v206 )
        v214 = -1;
      ++v212;
      v213 -= 112LL;
    }
    while ( v214 == 1 );
    if ( v214 )
      goto LABEL_252;
    v209 = v210 - v213 - 112;
LABEL_254:
    if ( *(_BYTE *)(v209 + 106) == 1 )
      *(_QWORD *)&v553[32] = 1LL;
    *(_QWORD *)&v531 = <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref((_QWORD *)v209);
    if ( !v215 )
    {
      LOWORD(v473) = 0;
      v462 = 0LL;
      v451 = 0LL;
      v541 = 0LL;
LABEL_332:
      if ( v547 )
      {
        v237 = v547;
        v238 = 0LL;
        v239 = v547;
        while ( 1 )
        {
          v240 = v237 >> 1;
          v241 = v240 + v238;
          v242 = *(_QWORD *)&v546[16 * v240 + 16 * v238];
          if ( v242 == v200 )
            break;
          if ( v242 > v200 )
            v239 = v240 + v238;
          if ( v242 < v200 )
            v238 = v241 + 1;
          v237 = v239 - v238;
          if ( v239 <= v238 )
            goto LABEL_340;
        }
        v247 = &v546[16 * v238 + 16 * v240];
        do
        {
          v248 = v241;
          v249 = v247;
          v172 = v241-- == 0;
          if ( v172 )
            break;
          v247 -= 16;
        }
        while ( *((_QWORD *)v249 - 2) == v200 );
        if ( v547 != v248 )
        {
          v250 = &v546[16 * v547];
          v251 = 0LL;
          v426 = v250;
          while ( 1 )
          {
            *(_QWORD *)&v531 = v251;
            if ( *(_QWORD *)v249 != v200 )
              break;
            v457 = (__int64)v249;
            v252 = *((_QWORD *)v249 + 1);
            if ( v540 < v252 )
              goto LABEL_466;
            v550.m256i_i64[0] = v252 + v543;
            v550.m256i_i64[1] = v540 - v252;
            gimli::read::aranges::ArangeHeader<R,Offset>::parse((__int64)src, (unsigned __int64 *)&v550, v252);
            if ( src[41] == 3 )
              goto LABEL_466;
            v253 = *(_QWORD *)&src[8];
            if ( *(_QWORD *)&src[8] )
            {
              v254 = *(unsigned __int16 **)src;
              v255 = src[40];
              v256 = src[44];
              v257 = (unsigned __int8)(src[44] + 2 * src[40]);
              if ( src[44] )
              {
                while ( 2 )
                {
                  if ( v253 >= v257 )
                  {
                    switch ( (int)v256 )
                    {
                      case 1:
                        if ( !v253 )
                          goto LABEL_466;
                        --v253;
                        v260 = *(unsigned __int8 *)v254;
                        v254 = (unsigned __int16 *)((char *)v254 + 1);
                        break;
                      case 2:
                        if ( v253 <= 1 )
                          goto LABEL_371;
                        v253 -= 2LL;
                        v260 = *v254++;
                        v261 = 1;
                        goto LABEL_372;
                      case 4:
                        if ( v253 <= 3 )
                        {
LABEL_371:
                          v261 = 0;
                          v260 = (unsigned __int64)v254;
                        }
                        else
                        {
                          v253 -= 4LL;
                          v260 = *(unsigned int *)v254;
                          v254 += 2;
                          v261 = 1;
                        }
LABEL_372:
                        if ( v261 )
                          break;
                        goto LABEL_466;
                      case 8:
                        if ( v253 < 8 )
                          goto LABEL_466;
                        v253 -= 8LL;
                        v260 = *(_QWORD *)v254;
                        v254 += 4;
                        break;
                      default:
                        goto LABEL_466;
                    }
                    switch ( (int)v255 )
                    {
                      case 1:
                        if ( v253 < 2 )
                          goto LABEL_466;
                        v262 = *(unsigned __int8 *)v254;
                        v253 -= 2LL;
                        v259 = *((unsigned __int8 *)v254++ + 1);
                        goto LABEL_360;
                      case 2:
                        if ( v253 <= 1 )
                          goto LABEL_383;
                        v253 -= 2LL;
                        v262 = *v254++;
                        v263 = 1;
                        goto LABEL_384;
                      case 4:
                        if ( v253 <= 3 )
                        {
LABEL_383:
                          v263 = 0;
                          v262 = (unsigned __int64)v254;
                        }
                        else
                        {
                          v253 -= 4LL;
                          v262 = *(unsigned int *)v254;
                          v254 += 2;
                          v263 = 1;
                        }
LABEL_384:
                        if ( !v263 )
                          goto LABEL_466;
                        if ( (_DWORD)v255 == 4 )
                        {
                          if ( v253 <= 3 )
                            goto LABEL_358;
                          v253 -= 4LL;
                          v259 = *(unsigned int *)v254;
                          v254 += 2;
                          v258 = 1;
                        }
                        else
                        {
                          if ( (_DWORD)v255 != 2 )
                            goto LABEL_466;
                          if ( v253 <= 1 )
                          {
LABEL_358:
                            v258 = 0;
                            v259 = (unsigned __int64)v254;
                            goto LABEL_359;
                          }
                          v253 -= 2LL;
                          v259 = *v254++;
                          v258 = 1;
                        }
LABEL_359:
                        if ( !v258 )
                          goto LABEL_466;
LABEL_360:
                        if ( v262 | v259 | v260 )
                        {
                          v535 = v262;
                          v508 = v256;
                          v480 = v257;
                          v452 = v255;
                          v463 = v254;
                          v434 = v253;
                          if ( v259 )
                          {
                            v264 = v529;
                            if ( v529 == v527 )
                            {
                              alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v527, v529);
                              v264 = v529;
                            }
                            v265 = (char *)(v535 + v259);
                            v266 = v528;
                            v267 = 32 * v264;
                            *(_QWORD *)(v528 + v267) = v535;
                            *(_QWORD *)(v266 + v267 + 8) = v265;
                            *(_QWORD *)(v266 + v267 + 16) = v201;
                            *(_QWORD *)(v266 + v267 + 24) = 0LL;
                            v529 = v264 + 1;
                            LOBYTE(v266) = 1;
                            *(_QWORD *)&v531 = v266;
                          }
                          v253 = v434;
                          v250 = v426;
                          v268 = v457;
                          v254 = v463;
                          v255 = v452;
                          v257 = v480;
                          v256 = v508;
                          if ( !v434 )
                            goto LABEL_427;
                        }
                        continue;
                      case 8:
                        if ( v253 < 8 || (v253 & 0xFFFFFFFFFFFFFFF8LL) == 8 )
                          goto LABEL_466;
                        v262 = *(_QWORD *)v254;
                        v259 = *((_QWORD *)v254 + 1);
                        v253 -= 16LL;
                        v254 += 8;
                        goto LABEL_360;
                      default:
                        goto LABEL_466;
                    }
                  }
                  break;
                }
              }
              else
              {
                while ( 2 )
                {
                  if ( v253 >= v257 )
                  {
                    switch ( (int)v255 )
                    {
                      case 1:
                        if ( v253 < 2 )
                          goto LABEL_466;
                        *(_QWORD *)&v269 = *(unsigned __int8 *)v254;
                        v253 -= 2LL;
                        *((_QWORD *)&v269 + 1) = *((unsigned __int8 *)v254++ + 1);
                        goto LABEL_398;
                      case 2:
                        if ( v253 <= 1 )
                          goto LABEL_411;
                        v253 -= 2LL;
                        *(_QWORD *)&v269 = *v254++;
                        goto LABEL_410;
                      case 4:
                        if ( v253 <= 3 )
                        {
LABEL_411:
                          v270 = 0;
                          *(_QWORD *)&v269 = v254;
                        }
                        else
                        {
                          v253 -= 4LL;
                          *(_QWORD *)&v269 = *(unsigned int *)v254;
                          v254 += 2;
LABEL_410:
                          v270 = 1;
                        }
                        if ( !v270 )
                          goto LABEL_466;
                        if ( (_DWORD)v255 == 2 )
                        {
                          if ( v253 <= 1 )
                            goto LABEL_466;
                          v253 -= 2LL;
                          *((_QWORD *)&v269 + 1) = *v254++;
                        }
                        else
                        {
                          if ( (_DWORD)v255 != 4 || v253 <= 3 )
                            goto LABEL_466;
                          v253 -= 4LL;
                          *((_QWORD *)&v269 + 1) = *(unsigned int *)v254;
                          v254 += 2;
                        }
LABEL_398:
                        if ( v269 != 0 )
                        {
                          v509 = v269;
                          v481 = v257;
                          v453 = v255;
                          v464 = v254;
                          v435 = v253;
                          if ( *((_QWORD *)&v269 + 1) )
                          {
                            v271 = v529;
                            if ( v529 == v527 )
                            {
                              alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v527, v529);
                              v271 = v529;
                            }
                            v272 = v528;
                            *(_QWORD *)&v269 = 32 * v271;
                            *(_QWORD *)(v528 + v269) = v509;
                            *(_QWORD *)(v272 + v269 + 8) = v509 + *((_QWORD *)&v269 + 1);
                            *(_QWORD *)(v272 + v269 + 16) = v201;
                            *(_QWORD *)(v272 + v269 + 24) = 0LL;
                            v529 = v271 + 1;
                            LOBYTE(v272) = 1;
                            *(_QWORD *)&v531 = v272;
                          }
                          v253 = v435;
                          v250 = v426;
                          v268 = v457;
                          v254 = v464;
                          v255 = v453;
                          v257 = v481;
                          if ( !v435 )
                            goto LABEL_427;
                        }
                        continue;
                      case 8:
                        if ( v253 < 8 || (v253 & 0xFFFFFFFFFFFFFFF8LL) == 8 )
                          goto LABEL_466;
                        v269 = *(_OWORD *)v254;
                        v253 -= 16LL;
                        v254 += 8;
                        goto LABEL_398;
                      default:
                        goto LABEL_466;
                    }
                  }
                  break;
                }
              }
              v250 = v426;
            }
            v268 = v457;
LABEL_427:
            v249 = (char *)(v268 + 16);
            v251 = v531;
            if ( v249 == v250 )
              goto LABEL_444;
          }
          *(_QWORD *)v553 = 0LL;
          if ( (v531 & 1) == 0 )
            goto LABEL_445;
          goto LABEL_453;
        }
      }
      else
      {
LABEL_340:
        if ( v462 )
        {
          if ( v451 )
          {
            if ( v485 >= v530 )
              goto LABEL_433;
            v243 = v529;
            if ( v529 == v527 )
            {
              alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v527, v529);
              v243 = v529;
            }
            v244 = (unsigned __int8 *)v530;
          }
          else
          {
            if ( !v541 )
              goto LABEL_433;
            v244 = (unsigned __int8 *)&v485[v562];
            if ( v485 >= &v485[v562] )
            {
              LOBYTE(v251) = 0;
LABEL_444:
              *(_QWORD *)v553 = 0LL;
              if ( (v251 & 1) == 0 )
                goto LABEL_445;
              goto LABEL_453;
            }
            v243 = v529;
            if ( v529 == v527 )
            {
              alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v527, v529);
              v243 = v529;
            }
          }
          v245 = v528;
          v246 = 32 * v243;
          *(_QWORD *)(v528 + v246) = v485;
          *(_QWORD *)(v245 + v246 + 8) = v244;
          *(_QWORD *)(v245 + v246 + 16) = v201;
          *(_QWORD *)(v245 + v246 + 24) = 0LL;
          v529 = v243 + 1;
          *(_QWORD *)v553 = 0LL;
          goto LABEL_453;
        }
      }
LABEL_433:
      *(_QWORD *)v553 = 0LL;
      goto LABEL_445;
    }
    v564 = v493 - *(_QWORD *)&v578[416];
    v556 = *(_WORD *)&v578[72] & 0xFF00;
    v216 = 0LL;
    v217 = 0LL;
    if ( *(_WORD *)&v578[74] < 5u )
      v217 = *(_QWORD *)&v578[416];
    v563 = v578[73];
    if ( !(_BYTE)v519 )
      v217 = 0LL;
    v565 = v217;
    v507 = *(_QWORD *)&v578[416];
    v557 = *(_QWORD *)&v578[416] + v526;
    v433 = v578[72];
    v479 = v445 - *(_QWORD *)&v578[400];
    v535 = *(_QWORD *)&v578[400];
    v539 = (char **)(*(_QWORD *)&v578[400] + v517);
    v473 = 0LL;
    v462 = 0LL;
    v451 = 0LL;
    v541 = 0LL;
    v425 = 0LL;
    v457 = 16 * v215;
LABEL_262:
    v589[0] = *(_OWORD *)(v531 + v216);
    gimli::read::unit::parse_attribute(
      (__int64)src,
      (unsigned __int64 *)v553,
      *(_DWORD *)(*(_QWORD *)&v553[16] + 72LL),
      (__int64)v589);
    if ( *(_QWORD *)src == 46LL )
      goto LABEL_466;
    v202 = *(double *)&src[8];
    v550 = *(__m256i *)src;
    if ( *(unsigned __int16 *)&src[24] <= 0x12u )
    {
      if ( *(unsigned __int16 *)&src[24] == 17 )
      {
        gimli::read::unit::Attribute<R>::value(src, (__int64)&v550, v218);
        if ( *(_QWORD *)src )
        {
          if ( *(_DWORD *)src == 12 )
          {
            if ( v445 >= v535 )
            {
              v225 = v433 * *(_QWORD *)&src[8];
              v226 = v479 - v433 * *(_QWORD *)&src[8];
              if ( v479 >= v433 * *(_QWORD *)&src[8] )
              {
                v485 = (char *)v539 + v225;
                switch ( (int)v433 )
                {
                  case 1:
                    if ( v479 == v225 )
                      break;
                    v227 = (const char *)*(unsigned __int8 *)v485;
                    goto LABEL_306;
                  case 2:
                    if ( v226 <= 1 )
                      goto LABEL_310;
                    v230 = (const char *)*(unsigned __int16 *)v485;
                    goto LABEL_309;
                  case 4:
                    if ( v226 <= 3 )
                    {
LABEL_310:
                      v231 = 0;
                    }
                    else
                    {
                      v230 = (const char *)*(unsigned int *)v485;
LABEL_309:
                      v485 = v230;
                      v231 = 1;
                    }
                    v462 = 1LL;
LABEL_322:
                    if ( v231 )
                      goto LABEL_323;
                    break;
                  case 8:
                    if ( v226 < 8 )
                      break;
                    v227 = *(const char **)v485;
LABEL_306:
                    v485 = v227;
                    v462 = 1LL;
                    goto LABEL_323;
                  default:
                    break;
                }
              }
            }
LABEL_466:
            if ( !_InterlockedDecrement64(*(volatile signed __int64 **)&v578[344]) )
LABEL_469:
              alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v578[344]);
LABEL_470:
            if ( *(_DWORD *)&v578[96] != 47 )
            {
              if ( *(_QWORD *)&v578[160] )
                _rust_dealloc(*(_QWORD *)&v578[168], 4LL * *(_QWORD *)&v578[160], 2LL);
              if ( *(_QWORD *)&v578[184] )
                _rust_dealloc(*(_QWORD *)&v578[192], 24LL * *(_QWORD *)&v578[184], 8LL);
              if ( *(_QWORD *)&v578[208] )
                _rust_dealloc(*(_QWORD *)&v578[216], 4LL * *(_QWORD *)&v578[208], 2LL);
              if ( *(_QWORD *)&v578[232] )
                _rust_dealloc(*(_QWORD *)&v578[240], *(_QWORD *)&v578[232] << 6, 8LL);
            }
            break;
          }
        }
        else
        {
          v462 = 1LL;
          v485 = *(const char **)&src[8];
        }
      }
      else if ( *(unsigned __int16 *)&src[24] == 18 )
      {
        gimli::read::unit::Attribute<R>::value(src, (__int64)&v550, v218);
        if ( *(_QWORD *)src )
        {
          if ( *(_DWORD *)src == 7 )
          {
            v541 = 1LL;
            v562 = *(_QWORD *)&src[8];
          }
          else if ( *(_DWORD *)src == 12 )
          {
            if ( v445 >= v535 )
            {
              v219 = v433 * *(_QWORD *)&src[8];
              v220 = v479 - v433 * *(_QWORD *)&src[8];
              if ( v479 >= v433 * *(_QWORD *)&src[8] )
              {
                v530 = (char *)v539 + v219;
                switch ( (int)v433 )
                {
                  case 1:
                    if ( v479 == v219 )
                      goto LABEL_466;
                    v221 = (char *)(unsigned __int8)*v530;
                    goto LABEL_316;
                  case 2:
                    if ( v220 <= 1 )
                      goto LABEL_320;
                    v232 = (char *)*(unsigned __int16 *)v530;
                    goto LABEL_319;
                  case 4:
                    if ( v220 <= 3 )
                    {
LABEL_320:
                      v231 = 0;
                    }
                    else
                    {
                      v232 = (char *)*(unsigned int *)v530;
LABEL_319:
                      v530 = v232;
                      v231 = 1;
                    }
                    v451 = 1LL;
                    goto LABEL_322;
                  case 8:
                    if ( v220 < 8 )
                      goto LABEL_466;
                    v221 = *(char **)v530;
LABEL_316:
                    v530 = v221;
                    v451 = 1LL;
                    goto LABEL_323;
                  default:
                    goto LABEL_466;
                }
              }
            }
            goto LABEL_466;
          }
        }
        else
        {
          v451 = 1LL;
          v530 = *(char **)&src[8];
        }
      }
      goto LABEL_323;
    }
    if ( *(unsigned __int16 *)&src[24] == 19 )
    {
      gimli::read::unit::Attribute<R>::value(src, (__int64)&v550, v218);
      v228 = v473;
      if ( *(_QWORD *)src == 38LL )
        v228 = 1LL;
      v473 = v228;
      if ( *(_DWORD *)src == 38 )
        LOWORD(v549) = *(_WORD *)&src[8];
      goto LABEL_323;
    }
    if ( *(unsigned __int16 *)&src[24] != 85 )
      goto LABEL_323;
    gimli::read::unit::Attribute<R>::value(src, (__int64)&v550, v218);
    if ( *(_QWORD *)src == 22LL )
    {
      v425 = &dword_0 + 1;
      v558 = v565 + *(_QWORD *)&src[8];
LABEL_323:
      v229 = v457;
      goto LABEL_324;
    }
    if ( *(_DWORD *)src != 24 )
    {
      v425 = 0LL;
      goto LABEL_323;
    }
    if ( v493 < v507 )
      goto LABEL_466;
    v222 = v563 * *(_QWORD *)&src[8];
    v223 = v564 - v563 * *(_QWORD *)&src[8];
    if ( v564 < v563 * *(_QWORD *)&src[8] )
      goto LABEL_466;
    if ( v556 == 2048 )
    {
      if ( v223 <= 7 )
        goto LABEL_466;
      v224 = *(_QWORD *)(v557 + v222);
    }
    else
    {
      if ( v223 <= 3 )
        goto LABEL_466;
      v224 = *(unsigned int *)(v557 + v222);
    }
    v229 = v457;
    v558 = v507 + v224;
    v425 = &dword_0 + 1;
LABEL_324:
    v216 += 16LL;
    if ( v229 != v216 )
      goto LABEL_262;
    if ( !v425 )
      goto LABEL_332;
    v233 = *(_QWORD *)(v189 + 16 * (unsigned int)(*(_WORD *)&v578[74] >= 5u) + 200);
    v172 = v233 < v558;
    v234 = v233 - v558;
    if ( v172 )
      goto LABEL_466;
    v235 = v558 + *(_QWORD *)(v189 + 16 * (unsigned int)(*(_WORD *)&v578[74] >= 5u) + 192);
    src[52] = *(_WORD *)&v578[74] >= 5u;
    *(_QWORD *)src = v517;
    *(_QWORD *)&src[8] = v445;
    *(_QWORD *)&src[16] = *(_QWORD *)&v578[384];
    *(_QWORD *)&src[24] = *(_QWORD *)&v578[400];
    *(_QWORD *)&src[32] = v235;
    *(_QWORD *)&src[40] = v234;
    *(_DWORD *)&src[48] = *(_DWORD *)&v578[72];
    gimli::read::rnglists::RngListIter<R>::next(&v550, (__int64)src);
    v236 = v550.m256i_i64[0];
    if ( v550.m256i_i64[0] != 2 )
    {
      *(_QWORD *)&v531 = 0LL;
      while ( v236 == 1 )
      {
        v275 = v550.m256i_i64[1];
        if ( v550.m256i_i64[1] < (unsigned __int64)v550.m256i_i64[2] )
        {
          *(_QWORD *)&v531 = v550.m256i_i64[2];
          v276 = v529;
          if ( v529 == v527 )
          {
            alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v527, v529);
            v276 = v529;
          }
          v273 = v528;
          v274 = 32 * v276;
          *(_QWORD *)(v528 + v274) = v275;
          *(_QWORD *)(v273 + v274 + 8) = v531;
          *(_QWORD *)(v273 + v274 + 16) = v201;
          *(_QWORD *)(v273 + v274 + 24) = 0LL;
          v529 = v276 + 1;
          LOBYTE(v273) = 1;
          *(_QWORD *)&v531 = v273;
        }
        gimli::read::rnglists::RngListIter<R>::next(&v550, (__int64)src);
        v236 = v550.m256i_i64[0];
        if ( v550.m256i_i64[0] == 2 )
          goto LABEL_328;
      }
      *(_QWORD *)v553 = 0LL;
      if ( (v531 & 1) == 0 )
        goto LABEL_445;
      goto LABEL_453;
    }
LABEL_328:
    if ( v550.m256i_i8[8] != 75 )
      goto LABEL_466;
    *(_QWORD *)v553 = 0LL;
    if ( (v550.m256i_i8[9] & 1) != 0 )
      goto LABEL_453;
LABEL_445:
    if ( *(_QWORD *)&v578[96] != 47LL )
    {
      <gimli::read::line::LineProgramHeader<R,Offset> as core::clone::Clone>::clone(
        (__int64)src,
        (__int64 *)&v578[96],
        v202,
        v203);
      addr2line::Lines::parse(v550.m256i_i64, (__int64)v578, (__m128i *)src, (__int64)v499);
      *(_QWORD *)v553 = 1LL;
      *(__m256i *)&v553[8] = v550;
      if ( v550.m256i_i64[0] )
      {
        if ( *(_QWORD *)&v553[32] )
        {
          v457 = *(_QWORD *)&v553[24];
          v277 = v529;
          v427 = (char *)(32LL * *(_QWORD *)&v553[32]);
          v278 = 0LL;
          do
          {
            v531 = *(_OWORD *)&v278[v457 + 16];
            if ( v277 == v527 )
            {
              alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v527, v277);
              v277 = v529;
            }
            v279 = v528;
            v280 = 32 * v277;
            *(_OWORD *)(v528 + v280) = v531;
            *(_QWORD *)(v279 + v280 + 16) = v201;
            *(_QWORD *)(v279 + v280 + 24) = 0LL;
            v529 = ++v277;
            v278 += 32;
          }
          while ( v427 != v278 );
        }
      }
    }
LABEL_453:
    memcpy(src, v578, 0x1A8uLL);
    *(_OWORD *)&src[432] = *(_OWORD *)v553;
    *(_OWORD *)&src[448] = *(_OWORD *)&v553[16];
    *(_QWORD *)&src[464] = *(_QWORD *)&v553[32];
    *(_QWORD *)&src[424] = v200;
    *(_WORD *)&src[528] = v473;
    *(_WORD *)&src[530] = (_WORD)v549;
    *(_QWORD *)&src[472] = 0LL;
    src[512] = 76;
    v281 = *(_QWORD *)&v536[16];
    if ( *(_QWORD *)&v536[16] == *(_QWORD *)v536 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)v536, *(__int64 *)&v536[16]);
      v281 = *(_QWORD *)&v536[16];
    }
    memcpy((void *)(*(_QWORD *)&v536[8] + 536 * v281), src, 0x218uLL);
    *(_QWORD *)&v536[16] = v281 + 1;
LABEL_218:
    gimli::read::unit::DebugInfoUnitHeadersIter<R>::next((__int64)src, (__int64)v548);
    v194 = *(_QWORD *)src;
  }
  while ( *(_QWORD *)src != 3LL );
LABEL_199:
  v195 = *(_QWORD *)&v536[8];
  v196 = *(_QWORD *)&v536[16] + 1LL;
  v197 = *(_QWORD *)&v536[8];
  while ( v196 != 1 )
  {
    --v196;
    core::ptr::drop_in_place<addr2line::ResUnit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>(v197);
    v197 += 536LL;
  }
  if ( *(_QWORD *)v536 )
    _rust_dealloc(v195, 536LL * *(_QWORD *)v536, 8LL);
  if ( v527 )
    _rust_dealloc(v528, 32 * v527, 8LL);
LABEL_206:
  if ( v545 )
    _rust_dealloc(v546, 16 * v545, 8LL);
  v198 = (volatile signed __int64 *)v544;
LABEL_209:
  if ( !_InterlockedDecrement64(v198) )
    alloc::sync::Arc<T,A>::drop_slow(&v544);
LABEL_211:
  *v555 = 0x8000000000000000LL;
  v199 = v484;
  if ( 2LL * *v538 )
  {
    _rust_dealloc(v538[1], 24LL * *v538, 8LL);
    if ( v537 != 0x8000000000000000LL )
      goto LABEL_459;
    goto LABEL_457;
  }
  if ( v537 == 0x8000000000000000LL )
    goto LABEL_457;
LABEL_459:
  result = *v199;
  if ( *v199 )
    return _rust_dealloc(v199[1], 24 * result, 8LL);
  return result;
}
// 29A93: variable 'v7' is possibly undefined
// 29AD3: variable 'v11' is possibly undefined
// 29B13: variable 'v15' is possibly undefined
// 29B53: variable 'v19' is possibly undefined
// 29B93: variable 'v23' is possibly undefined
// 29BDC: variable 'v27' is possibly undefined
// 29C28: variable 'v31' is possibly undefined
// 29C74: variable 'v35' is possibly undefined
// 29CB4: variable 'v39' is possibly undefined
// 29CF7: variable 'v43' is possibly undefined
// 29D3A: variable 'v47' is possibly undefined
// 29D6C: variable 'v51' is possibly undefined
// 29E94: variable 'v54' is possibly undefined
// 29F6E: variable 'v58' is possibly undefined
// 29FAE: variable 'v62' is possibly undefined
// 29FEE: variable 'v66' is possibly undefined
// 2A02E: variable 'v70' is possibly undefined
// 2A06E: variable 'v74' is possibly undefined
// 2A0B7: variable 'v78' is possibly undefined
// 2A103: variable 'v82' is possibly undefined
// 2A14C: variable 'v86' is possibly undefined
// 2A18F: variable 'v90' is possibly undefined
// 2A1D2: variable 'v94' is possibly undefined
// 2A215: variable 'v98' is possibly undefined
// 2A247: variable 'v102' is possibly undefined
// 2A37A: variable 'v105' is possibly undefined
// 2B3C6: variable 'v215' is possibly undefined
// 2B552: variable 'v218' is possibly undefined
// 2D34B: variable 'v190' is possibly undefined
// 2D352: variable 'v191' is possibly undefined
// 2D365: variable 'v193' is possibly undefined
// 2D3BE: variable 'v192' is possibly undefined
// 2D476: variable 'v383' is possibly undefined
// 2D525: variable 'v386' is possibly undefined
// 2D634: variable 'v390' is possibly undefined
// 2D66A: variable 'v393' is possibly undefined
// 2D6A0: variable 'v396' is possibly undefined
// 2D6D6: variable 'v399' is possibly undefined
// 2D704: variable 'v402' is possibly undefined
// 2D739: variable 'v405' is possibly undefined
// 2D772: variable 'v408' is possibly undefined
// 2D7AA: variable 'v411' is possibly undefined
// 2D7E9: variable 'v413' is possibly undefined
// 0: using guessed type int dword_0;
// 8: using guessed type char byte_8;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);
// 582D0: using guessed type char *off_582D0;
// 583D0: using guessed type char *off_583D0;
// 583E8: using guessed type char *off_583E8;
// 58400: using guessed type char *off_58400;
// 58418: using guessed type char *off_58418;
// 58430: using guessed type char *off_58430;
// 58448: using guessed type char *off_58448;
// 58460: using guessed type char *off_58460;
// 584A0: using guessed type char *off_584A0;
// 584B8: using guessed type char *off_584B8;
// 29A50: using guessed type __int128 var_48[4];
// 29A50: using guessed type _OWORD var_B8[2];

//----- (000000000002E160) ----------------------------------------------------
int __fastcall std::backtrace_rs::symbolize::gimli::mmap(__int64 *a1, const void *a2, size_t a3)
{
  int result; // eax
  int v5; // ebp
  const char *v6; // r14
  size_t v7; // r14
  __int64 v8; // r15
  void *v9; // rax
  struct stat64 *p_buf; // [rsp+8h] [rbp-3A0h] BYREF
  int v11; // [rsp+10h] [rbp-398h]
  __int64 v12; // [rsp+18h] [rbp-390h] BYREF
  struct stat64 buf; // [rsp+20h] [rbp-388h] BYREF
  __int64 v14[20]; // [rsp+B8h] [rbp-2F0h] BYREF
  __int64 v15; // [rsp+158h] [rbp-250h] BYREF
  const char *v16; // [rsp+160h] [rbp-248h] BYREF
  size_t v17[20]; // [rsp+168h] [rbp-240h] BYREF
  __int64 dest[2]; // [rsp+208h] [rbp-1A0h] BYREF
  char src[160]; // [rsp+218h] [rbp-190h] BYREF

  buf.st_dev = 0x1B600000000LL;
  LODWORD(buf.st_ino) = 1;
  WORD2(buf.st_ino) = 0;
  p_buf = &buf;
  if ( a3 > 0x17F )
  {
    std::sys::pal::common::small_c_string::run_with_cstr_allocating((__int64)v14, a2, a3, (__int64 *)&p_buf);
    if ( LODWORD(v14[0]) )
      goto LABEL_5;
  }
  else
  {
    memcpy(dest, a2, a3);
    *((_BYTE *)dest + a3) = 0;
    core::ffi::c_str::CStr::from_bytes_with_nul(&v15, (__int64)dest, a3 + 1);
    if ( v15 )
    {
      v14[1] = (__int64)ptr;
      LODWORD(v14[0]) = 1;
LABEL_5:
      v12 = v14[1];
      v11 = 1;
      result = core::ptr::drop_in_place<std::io::error::Error>(&v12);
      *a1 = 0LL;
      return result;
    }
    std::sys::pal::unix::fs::File::open_c((__int64)v14, v16, (__int64)&buf);
    if ( LODWORD(v14[0]) )
      goto LABEL_5;
  }
  v5 = HIDWORD(v14[0]);
  std::sys::pal::unix::fs::try_statx((__int64)dest, HIDWORD(v14[0]), (__int64)&unk_48F69, 4096LL);
  if ( dest[0] == 3 )
  {
    memset(&buf, 0, sizeof(buf));
    if ( fstat64(v5, &buf) != -1 )
    {
      memcpy(&v14[2], &buf, 0x90uLL);
LABEL_11:
      memcpy(v17, v14, sizeof(v17));
      v7 = v17[8];
      v8 = 0LL;
      v9 = mmap64(0LL, v17[8], 1, 2, v5, 0LL);
      if ( v9 != (void *)-1LL )
      {
        a1[1] = (__int64)v9;
        a1[2] = v7;
        v8 = 1LL;
      }
      *a1 = v8;
      return close(v5);
    }
    v6 = (const char *)(((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2);
  }
  else
  {
    v6 = (const char *)dest[1];
    memcpy(v14, src, sizeof(v14));
    if ( LODWORD(dest[0]) != 2 )
      goto LABEL_11;
  }
  v16 = v6;
  v15 = 2LL;
  core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v16);
  *a1 = 0LL;
  return close(v5);
}

//----- (000000000002E400) ----------------------------------------------------
int __fastcall std::backtrace_rs::symbolize::gimli::resolve(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __m128 a5,
        __m128i a6)
{
  const __m128i *v6; // rax
  __int8 *v7; // r13
  unsigned __int64 v8; // rsi
  __int64 v9; // rax
  void *v10; // rbx
  __int64 v11; // rax
  __int64 v12; // r14
  _QWORD *v13; // r15
  __int64 v14; // rsi
  __int64 v15; // rsi
  void *v16; // r14
  char *v17; // rdi
  __int64 i; // r15
  unsigned __int64 v19; // rdi
  _QWORD *v20; // rdx
  _QWORD *v21; // r8
  __int64 v22; // r11
  __int64 v23; // rbp
  __int64 v24; // r11
  _QWORD *v25; // r9
  unsigned __int64 v26; // r10
  __int64 v27; // r15
  __int64 v28; // rbx
  __int64 v29; // rcx
  __int64 v30; // r12
  char *v31; // r14
  size_t v32; // r15
  __int64 v33; // r12
  __m128i v34; // xmm1
  char *v35; // rax
  unsigned __int64 v36; // rdx
  __int64 v37; // rbx
  unsigned __int64 v38; // r15
  unsigned __int64 v39; // r12
  volatile signed __int64 **v40; // rbx
  __int64 v41; // rbx
  size_t v42; // r13
  __int64 v43; // r12
  char *v44; // r15
  __int64 v45; // rdx
  unsigned __int64 v46; // rdx
  const __m128i *bytes_at_until; // rax
  __int64 v48; // rdx
  __int64 bytes_at; // rax
  unsigned __int64 v50; // rdx
  size_t v51; // r15
  unsigned __int64 v52; // rax
  __int64 v53; // rbx
  __int64 v54; // r13
  __int64 v55; // r15
  bool v56; // al
  __int128 v57; // xmm2
  __int128 v58; // xmm3
  __int128 v59; // xmm4
  __int128 v60; // xmm5
  __int128 v61; // xmm6
  __int128 v62; // xmm7
  __int128 v63; // xmm8
  __int128 v64; // xmm9
  __int128 v65; // xmm10
  __int128 v66; // xmm11
  __int128 v67; // xmm12
  __int128 v68; // xmm13
  __int128 v69; // xmm14
  __int128 v70; // xmm15
  __int64 v71; // r15
  __int64 v72; // rbx
  __int8 *v73; // r13
  unsigned __int64 v74; // r15
  __int64 v75; // r12
  unsigned __int64 v76; // rsi
  unsigned __int64 v77; // rdi
  volatile signed __int64 *v78; // rax
  unsigned __int64 v79; // rcx
  unsigned __int64 v80; // rax
  unsigned __int64 v81; // rdx
  volatile signed __int64 **v82; // rbx
  __int64 v83; // rdi
  __int64 v84; // rdi
  unsigned __int64 v85; // rdi
  unsigned __int64 v86; // rsi
  unsigned __int32 v87; // edx
  __int64 v88; // r14
  unsigned __int64 v89; // rbx
  __int64 v90; // rsi
  unsigned __int32 v91; // r9d
  unsigned __int64 v92; // rdi
  char v93; // r15
  int v94; // ecx
  __int64 v95; // rbx
  size_t v96; // r14
  __int64 v97; // rcx
  void *v98; // rdx
  bool v99; // bp
  bool v100; // r12
  __int64 *v101; // rax
  __int64 v102; // r15
  const __m128i *v103; // r12
  size_t v104; // rbp
  __int64 v105; // rax
  unsigned __int64 v106; // rcx
  __int64 v107; // rax
  unsigned __int64 v108; // rdx
  unsigned __int64 v109; // rsi
  unsigned __int64 v110; // rdi
  unsigned __int64 v111; // rdx
  __int8 *v112; // r8
  __int64 v113; // rax
  __int64 v114; // rdi
  __int64 v115; // rdx
  unsigned __int64 v116; // rdx
  __int8 *v117; // rdx
  __m128 *v118; // rax
  __int64 v119; // rcx
  size_t v120; // rax
  size_t v121; // rdx
  unsigned __int64 v122; // rcx
  unsigned __int64 v123; // rdx
  unsigned __int64 v124; // rsi
  unsigned __int64 v125; // rdi
  unsigned __int64 v126; // rsi
  unsigned __int64 v127; // r8
  __int64 v128; // rdi
  __int64 v129; // rdx
  unsigned __int64 v130; // rdx
  __int64 v131; // rdx
  __int64 v132; // rsi
  __m128i si128; // xmm1
  volatile signed __int64 *v134; // r14
  int v135; // esi
  __int32 v136; // eax
  __int64 v137; // rax
  __int64 v138; // rdi
  bool v139; // cf
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // rax
  unsigned __int64 v142; // rcx
  int v143; // eax
  unsigned int v144; // eax
  unsigned __int64 v145; // rcx
  __int64 v146; // rdi
  unsigned __int64 v147; // rdx
  unsigned __int64 v148; // rcx
  unsigned __int64 v149; // rsi
  unsigned __int64 v150; // rsi
  _QWORD *v151; // r10
  unsigned __int64 v152; // r8
  __int64 v153; // rdi
  unsigned __int64 v154; // rdx
  __int64 v155; // r9
  unsigned int v156; // ebp
  unsigned int v157; // ebx
  unsigned int v158; // r15d
  unsigned int v159; // eax
  unsigned int v160; // r10d
  unsigned int v161; // r11d
  __int64 v162; // r12
  __int64 v163; // rcx
  unsigned __int64 v164; // rdx
  unsigned __int64 v165; // rdx
  __int64 v166; // rdi
  unsigned __int64 v167; // rdx
  unsigned __int64 v168; // rdx
  __int64 v169; // r9
  __int64 v170; // rsi
  unsigned __int64 v171; // rax
  unsigned __int64 v172; // rax
  unsigned __int64 v173; // rax
  unsigned __int64 v174; // rax
  unsigned __int64 v175; // rax
  unsigned __int64 v176; // rax
  unsigned __int64 v177; // rax
  unsigned __int64 v178; // rax
  const void *v179; // r14
  __int64 v180; // rbx
  __int64 v181; // rax
  void *v182; // r12
  const void *v183; // r14
  __int64 v184; // rax
  void *v185; // r12
  __m128 *v186; // rbx
  unsigned __int64 v187; // rbx
  __int64 v188; // r12
  __int64 v189; // r14
  __int64 v190; // rsi
  __int64 v191; // rdx
  __int64 v192; // rcx
  __int64 v193; // rax
  __int64 v194; // rsi
  const char *v195; // rax
  const char *v196; // rdx
  const char *v197; // rcx
  bool v198; // zf
  const char *v199; // rax
  const char *v200; // rax
  const char *v201; // rdx
  const char *v202; // rcx
  bool v203; // zf
  const char *v204; // rax
  const char *v205; // rax
  size_t v206; // rdx
  const char *v207; // rcx
  bool v208; // zf
  size_t v209; // rax
  const char *v210; // rax
  void *v211; // rdx
  const char *v212; // rcx
  bool v213; // zf
  const char *v214; // rax
  const char *v215; // rax
  void *v216; // rdx
  const char *v217; // r14
  bool v218; // zf
  const char *v219; // rax
  const char *v220; // rax
  const char *v221; // rdx
  const char *v222; // rbp
  bool v223; // zf
  const char *v224; // rax
  const char *v225; // r12
  __int64 v226; // rdx
  __int64 v227; // r13
  const char *v228; // rbx
  __int64 v229; // rdx
  __int64 v230; // r15
  __m128i v231; // rax
  const char *v232; // rcx
  __int64 v233; // r9
  __int64 v234; // r10
  __int64 v235; // rdi
  __int64 v236; // r8
  volatile signed __int64 *v237; // rsi
  __m128 *v238; // rax
  __int64 v239; // r15
  char v240; // bp
  __int64 v241; // r12
  __int64 *v242; // r14
  __int64 *v243; // rax
  __int32 v244; // ecx
  __int64 v245; // rcx
  __int8 v246; // dl
  __int64 v247; // rax
  __int64 v248; // rsi
  int v249; // ecx
  _QWORD *v250; // rax
  __int64 v251; // r13
  __int16 v252; // dx
  __int64 v253; // rax
  __int64 v254; // r12
  __int64 *v255; // rax
  __int64 v256; // rcx
  __int64 v257; // rbp
  __int64 v258; // rsi
  __int64 v259; // rax
  __int64 v260; // rbx
  __int64 v261; // r15
  __int64 v262; // rdx
  __int64 v263; // r13
  __int64 v264; // r9
  __int64 v265; // r11
  __int64 v266; // r12
  __int64 v267; // r8
  volatile signed __int64 *v268; // r10
  __m128 *v269; // rax
  unsigned __int64 v270; // rax
  unsigned __int64 v271; // rax
  unsigned __int64 v272; // rdx
  unsigned __int64 v273; // rdx
  size_t v274; // rdx
  unsigned __int64 v275; // r14
  __int64 v276; // rax
  __int64 v277; // rbx
  __int64 v278; // r14
  size_t v279; // r12
  __int64 v280; // r14
  bool v281; // cl
  size_t v282; // rax
  _BYTE *v283; // rbx
  size_t v284; // r12
  bool v285; // al
  bool v286; // al
  __int64 v287; // r14
  size_t v288; // r15
  __int64 v289; // r15
  size_t v290; // rax
  __int64 v291; // r14
  bool v292; // cl
  size_t v293; // rax
  char *v294; // rbx
  size_t v295; // r15
  __int64 v296; // r15
  __int64 v297; // r12
  __int128 v298; // rdi
  size_t v299; // rdx
  size_t v300; // r14
  bool v301; // cl
  size_t v302; // rax
  __int64 v303; // r14
  bool v304; // cl
  size_t v305; // rax
  size_t v306; // r15
  __int8 *v308; // [rsp+8h] [rbp-1050h]
  __int8 *v309; // [rsp+8h] [rbp-1050h]
  size_t v310; // [rsp+10h] [rbp-1048h] BYREF
  __int128 v311; // [rsp+18h] [rbp-1040h]
  void *addr; // [rsp+28h] [rbp-1030h]
  size_t v313[2]; // [rsp+30h] [rbp-1028h]
  size_t len; // [rsp+48h] [rbp-1010h]
  size_t v315[2]; // [rsp+50h] [rbp-1008h]
  __int128 v316; // [rsp+60h] [rbp-FF8h]
  void *v317[2]; // [rsp+70h] [rbp-FE8h]
  void *v318[2]; // [rsp+80h] [rbp-FD8h]
  __int128 v319; // [rsp+90h] [rbp-FC8h]
  __int128 v320; // [rsp+A0h] [rbp-FB8h]
  __int128 v321; // [rsp+B0h] [rbp-FA8h]
  __int128 v322; // [rsp+C0h] [rbp-F98h]
  __int128 v323; // [rsp+D0h] [rbp-F88h]
  __int128 v324; // [rsp+E0h] [rbp-F78h]
  __int64 v325; // [rsp+F8h] [rbp-F60h]
  __int128 v326; // [rsp+100h] [rbp-F58h]
  __int128 v327; // [rsp+110h] [rbp-F48h]
  __int128 v328; // [rsp+120h] [rbp-F38h]
  __int128 v329; // [rsp+130h] [rbp-F28h]
  __int128 v330; // [rsp+140h] [rbp-F18h]
  __int128 v331; // [rsp+150h] [rbp-F08h]
  __m128 v332; // [rsp+168h] [rbp-EF0h] BYREF
  size_t v333; // [rsp+178h] [rbp-EE0h]
  __int16 v334; // [rsp+1A0h] [rbp-EB8h]
  bool v335; // [rsp+1A2h] [rbp-EB6h]
  __int64 v336; // [rsp+1A8h] [rbp-EB0h]
  __int64 v337; // [rsp+1B0h] [rbp-EA8h]
  __int64 v338[3]; // [rsp+1B8h] [rbp-EA0h] BYREF
  __int128 v339; // [rsp+1D0h] [rbp-E88h] BYREF
  __int128 v340; // [rsp+1E0h] [rbp-E78h]
  __int128 v341; // [rsp+1F0h] [rbp-E68h]
  __int64 v342; // [rsp+208h] [rbp-E50h] BYREF
  __int128 v343; // [rsp+210h] [rbp-E48h]
  __int128 v344; // [rsp+220h] [rbp-E38h]
  __m256 v345; // [rsp+230h] [rbp-E28h] BYREF
  __int128 v346; // [rsp+250h] [rbp-E08h]
  __int128 v347; // [rsp+260h] [rbp-DF8h]
  __int128 v348; // [rsp+270h] [rbp-DE8h]
  __int128 v349; // [rsp+280h] [rbp-DD8h]
  __int128 v350; // [rsp+290h] [rbp-DC8h]
  __int64 v351; // [rsp+2A0h] [rbp-DB8h]
  __int128 v352; // [rsp+2E0h] [rbp-D78h] BYREF
  __int128 v353; // [rsp+2F0h] [rbp-D68h]
  __int128 v354; // [rsp+300h] [rbp-D58h]
  __m128i v355; // [rsp+310h] [rbp-D48h] BYREF
  size_t n[2]; // [rsp+320h] [rbp-D38h]
  size_t v357[2]; // [rsp+330h] [rbp-D28h]
  __int128 v358; // [rsp+340h] [rbp-D18h]
  __int128 v359; // [rsp+350h] [rbp-D08h]
  __int128 v360; // [rsp+360h] [rbp-CF8h]
  __int128 v361; // [rsp+370h] [rbp-CE8h]
  __int64 v362; // [rsp+380h] [rbp-CD8h]
  __m128i data[37]; // [rsp+390h] [rbp-CC8h] BYREF
  __m128i v364; // [rsp+5E0h] [rbp-A78h] BYREF
  __int128 v365; // [rsp+5F0h] [rbp-A68h]
  __int128 v366; // [rsp+600h] [rbp-A58h]
  __int128 v367; // [rsp+610h] [rbp-A48h]
  __int128 v368; // [rsp+620h] [rbp-A38h]
  __int128 v369; // [rsp+630h] [rbp-A28h]
  __int128 v370; // [rsp+640h] [rbp-A18h]
  __int128 v371; // [rsp+650h] [rbp-A08h]
  __int128 v372; // [rsp+660h] [rbp-9F8h]
  __int128 v373; // [rsp+670h] [rbp-9E8h]
  __int128 v374; // [rsp+680h] [rbp-9D8h]
  __int128 v375; // [rsp+690h] [rbp-9C8h]
  __int128 v376; // [rsp+6A0h] [rbp-9B8h]
  __int128 v377; // [rsp+6B0h] [rbp-9A8h]
  __int128 v378; // [rsp+6C0h] [rbp-998h]
  __m128i v379; // [rsp+6D0h] [rbp-988h] BYREF
  __m128i v380; // [rsp+6E0h] [rbp-978h] BYREF
  __m128i v381; // [rsp+6F0h] [rbp-968h]
  __int16 v382; // [rsp+700h] [rbp-958h]
  __int128 v383; // [rsp+750h] [rbp-908h] BYREF
  _BYTE v384[72]; // [rsp+760h] [rbp-8F8h]
  __int128 v385; // [rsp+7A8h] [rbp-8B0h]
  __int128 v386; // [rsp+7B8h] [rbp-8A0h]
  __int128 v387; // [rsp+7C8h] [rbp-890h]
  __int128 v388; // [rsp+7D8h] [rbp-880h]
  __int128 v389; // [rsp+7E8h] [rbp-870h]
  __int128 v390; // [rsp+7F8h] [rbp-860h]
  __int128 v391; // [rsp+808h] [rbp-850h]
  __int128 v392; // [rsp+818h] [rbp-840h]
  __int128 v393; // [rsp+828h] [rbp-830h]
  __int128 v394; // [rsp+838h] [rbp-820h]
  __int128 v395; // [rsp+848h] [rbp-810h]
  __int128 v396; // [rsp+858h] [rbp-800h]
  __int128 v397; // [rsp+868h] [rbp-7F0h]
  __int128 v398; // [rsp+878h] [rbp-7E0h]
  __int128 v399; // [rsp+888h] [rbp-7D0h]
  __int128 v400; // [rsp+898h] [rbp-7C0h]
  __int128 v401; // [rsp+8A8h] [rbp-7B0h]
  __int128 v402; // [rsp+8B8h] [rbp-7A0h]
  __int128 v403; // [rsp+8C8h] [rbp-790h]
  __int128 v404; // [rsp+8D8h] [rbp-780h]
  __int128 v405; // [rsp+8E8h] [rbp-770h]
  __int128 v406; // [rsp+8F8h] [rbp-760h]
  __int128 v407; // [rsp+908h] [rbp-750h]
  __int128 v408; // [rsp+918h] [rbp-740h]
  __int128 v409; // [rsp+928h] [rbp-730h]
  __m128i v410; // [rsp+938h] [rbp-720h] BYREF
  unsigned __int64 v411; // [rsp+948h] [rbp-710h]
  __int128 src[36]; // [rsp+950h] [rbp-708h] BYREF
  __m128i dest[37]; // [rsp+B90h] [rbp-4C8h] BYREF
  __m128i v414[32]; // [rsp+DE0h] [rbp-278h] BYREF
  char v415; // [rsp+FE8h] [rbp-70h] BYREF

  addr = 0LL;
  v337 = a4;
  v336 = a3;
  if ( !a1 )
  {
    if ( !a2 )
      goto LABEL_12;
    v7 = (__int8 *)(a2 - 1);
    LODWORD(v6) = 0;
    if ( (_QWORD)std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE == 0x8000000000000000LL )
      goto LABEL_13;
LABEL_10:
    v8 = qword_5B040;
    if ( !qword_5B040 )
      return (int)v6;
    goto LABEL_31;
  }
  v6 = *(const __m128i **)(a2 + 8);
  if ( !*(_QWORD *)a2 )
  {
    LODWORD(v6) = Unwind_GetIP(*(struct _Unwind_Context **)(a2 + 8));
    if ( !v6 )
      goto LABEL_12;
    goto LABEL_9;
  }
  if ( v6 )
  {
LABEL_9:
    v7 = &v6[-1].m128i_i8[15];
    LODWORD(v6) = 0;
    if ( (_QWORD)std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE == 0x8000000000000000LL )
      goto LABEL_13;
    goto LABEL_10;
  }
LABEL_12:
  v7 = 0LL;
  LODWORD(v6) = 0;
  if ( (_QWORD)std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE != 0x8000000000000000LL )
    goto LABEL_10;
LABEL_13:
  v9 = _rust_alloc(2336LL, 8LL);
  if ( !v9 )
    alloc::alloc::handle_alloc_error(8LL, 2336LL);
  v10 = (void *)v9;
  data[0].m128i_i64[0] = 0LL;
  data[0].m128i_i64[1] = 8LL;
  data[1].m128i_i64[0] = 0LL;
  dl_iterate_phdr(
    (int (*)(struct dl_phdr_info *, size_t, void *))std::backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::callback,
    data);
  dest[0] = data[0];
  dest[1].m128i_i64[0] = data[1].m128i_i64[0];
  v11 = std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE;
  if ( (_QWORD)std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE != 0x8000000000000000LL )
  {
    v12 = qword_5B040;
    if ( qword_5B040 )
    {
      v13 = (_QWORD *)(*((_QWORD *)&std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE + 1) + 32LL);
      do
      {
        v14 = *(v13 - 4);
        if ( v14 )
          _rust_dealloc(*(v13 - 3), v14, 1LL);
        v15 = *(v13 - 1);
        if ( v15 )
          _rust_dealloc(*v13, 16 * v15, 8LL);
        v13 += 7;
        --v12;
      }
      while ( v12 );
      v11 = std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE;
    }
    if ( v11 )
      _rust_dealloc(
        *((_QWORD *)&std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE + 1),
        56 * v11,
        8LL);
    v16 = ::dest;
    v17 = (char *)::dest + 8;
    for ( i = qword_5B058 + 1; i != 1; --i )
    {
      core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::Mapping>((__int64)v17);
      v17 += 584;
    }
    if ( qword_5B048 )
      _rust_dealloc(v16, 584 * qword_5B048, 8LL);
  }
  LODWORD(v6) = dest[1].m128i_i32[0];
  qword_5B040 = dest[1].m128i_i64[0];
  a5 = (__m128)dest[0];
  std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE = (__int128)dest[0];
  qword_5B048 = 4LL;
  ::dest = v10;
  qword_5B058 = 0LL;
  v8 = dest[1].m128i_u64[0];
  if ( !dest[1].m128i_i64[0] )
    return (int)v6;
LABEL_31:
  LODWORD(v6) = DWORD2(std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE);
  v19 = 0LL;
  v20 = (_QWORD *)*((_QWORD *)&std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE + 1);
LABEL_32:
  v21 = (_QWORD *)v20[4];
  v22 = v20[5];
  v23 = v20[6];
  v20 += 7;
  v24 = 16 * v22;
  do
  {
    if ( !v24 )
    {
      ++v19;
      if ( v20 == (_QWORD *)(*((_QWORD *)&std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE + 1)
                           + 56 * v8) )
        return (int)v6;
      goto LABEL_32;
    }
    v25 = v21;
    v21 += 2;
    v26 = v23 + *v25;
    v24 -= 16LL;
  }
  while ( v26 > (unsigned __int64)v7 || v25[1] + v26 <= (unsigned __int64)v7 );
  v27 = qword_5B058;
  if ( !qword_5B058 )
  {
LABEL_43:
    if ( v8 <= v19 )
      core::panicking::panic_bounds_check(v19, v8, (__int64)&off_59438);
    v325 = v19;
    v31 = *(char **)(*((_QWORD *)&std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE + 1)
                   + 56 * v19
                   + 8);
    v32 = *(_QWORD *)(*((_QWORD *)&std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE + 1)
                    + 56 * v19
                    + 16);
    LODWORD(v6) = std::backtrace_rs::symbolize::gimli::mmap(data[0].m128i_i64, v31, v32);
    if ( !data[0].m128i_i64[0] )
      return (int)v6;
    v33 = data[1].m128i_i64[0];
    *(_QWORD *)&v352 = 0LL;
    *((_QWORD *)&v352 + 1) = 8LL;
    v353 = 0LL;
    v354 = 8uLL;
    addr = (void *)data[0].m128i_i64[1];
    std::backtrace_rs::symbolize::gimli::elf::Object::parse(
      (__int64 *)&v345,
      data[0].m128i_i64[1],
      data[1].m128i_u64[0]);
    if ( *(_QWORD *)v345.m256_f32 == 0x8000000000000000LL )
    {
LABEL_88:
      v37 = 0x8000000000000000LL;
      goto LABEL_89;
    }
    v362 = v351;
    v361 = v350;
    v360 = v349;
    v359 = v348;
    v34 = _mm_loadu_si128((const __m128i *)&v345.m256_f32[4]);
    v358 = v347;
    *(_OWORD *)v357 = v346;
    *(__m128i *)n = v34;
    v355 = *(__m128i *)v345.m256_f32;
    len = v33;
    v35 = (char *)std::backtrace_rs::symbolize::gimli::elf::Object::build_id(&v355);
    v308 = v7;
    if ( v35 )
    {
      std::backtrace_rs::symbolize::gimli::elf::locate_build_id(v338, v35, v36);
      if ( v338[0] != 0x8000000000000000LL )
      {
        std::backtrace_rs::symbolize::gimli::elf::<impl std::backtrace_rs::symbolize::gimli::Mapping>::new_debug(
          v414,
          v31,
          v32,
          (__int64)v338);
        v37 = v414[0].m128i_i64[0];
        if ( v414[0].m128i_i64[0] != 0x8000000000000000LL )
        {
          *(_QWORD *)&v319 = &v415;
          *(_QWORD *)&v320 = &v414[0].m128i_i64[1];
LABEL_50:
          v364 = *(__m128i *)v320;
          v344 = *(_OWORD *)(v320 + 16);
          v377 = *(_OWORD *)(v320 + 32);
          v376 = *(_OWORD *)(v320 + 48);
          v375 = *(_OWORD *)(v320 + 64);
          v374 = *(_OWORD *)(v320 + 80);
          v373 = *(_OWORD *)(v320 + 96);
          v372 = *(_OWORD *)(v320 + 112);
          v371 = *(_OWORD *)(v320 + 128);
          v370 = *(_OWORD *)(v320 + 144);
          v369 = *(_OWORD *)(v320 + 160);
          v368 = *(_OWORD *)(v320 + 176);
          v367 = *(_OWORD *)(v320 + 192);
          v366 = *(_OWORD *)(v320 + 208);
          v365 = *(_OWORD *)(v320 + 224);
          v341 = *(_OWORD *)(v319 + 40);
          v340 = *(_OWORD *)(v319 + 24);
          v339 = *(_OWORD *)(v319 + 8);
          *(_OWORD *)v315 = *(_OWORD *)(v320 + 240);
          v38 = *(_QWORD *)(v320 + 256);
          v39 = *(_QWORD *)(v320 + 264);
          v31 = *(char **)v319;
          v316 = *(_OWORD *)(v320 + 272);
          v322 = *(_OWORD *)(v320 + 288);
          v319 = *(_OWORD *)(v320 + 304);
          *(_OWORD *)v313 = *(_OWORD *)(v320 + 320);
          *(_OWORD *)v317 = *(_OWORD *)(v320 + 336);
          *(_OWORD *)v318 = *(_OWORD *)(v320 + 352);
          v321 = *(_OWORD *)(v320 + 368);
          v330 = *(_OWORD *)(v320 + 384);
          v324 = *(_OWORD *)(v320 + 400);
          v327 = *(_OWORD *)(v320 + 416);
          v326 = *(_OWORD *)(v320 + 432);
          v328 = *(_OWORD *)(v320 + 448);
          v329 = *(_OWORD *)(v320 + 464);
          v331 = *(_OWORD *)(v320 + 480);
          v323 = *(_OWORD *)(v320 + 496);
          if ( v355.m128i_i64[0] )
            _rust_dealloc(v355.m128i_i64[1], 24 * v355.m128i_i64[0], 8LL);
          v320 = (__int128)_mm_unpacklo_epi64((__m128i)v38, (__m128i)v39);
          v7 = v308;
          v33 = len;
LABEL_89:
          core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::stash::Stash>((__int64 *)&v352);
          LODWORD(v6) = munmap(addr, v33);
          v33 = (__int64)v31;
          a6 = _mm_load_si128(&v364);
          v57 = v344;
          v58 = v377;
          v59 = v376;
          v60 = v375;
          v61 = v374;
          v62 = v373;
          v63 = v372;
          v64 = v371;
          v65 = v370;
          v66 = v369;
          v67 = v368;
          v68 = v367;
          v69 = v366;
          v70 = v365;
          if ( v37 == 0x8000000000000000LL )
            return (int)v6;
          goto LABEL_92;
        }
      }
    }
    else
    {
      v338[0] = 0x8000000000000000LL;
    }
    *(_QWORD *)&v322 = v32;
    *(_QWORD *)&v316 = v31;
    if ( !(_QWORD)v358 )
      goto LABEL_87;
    v41 = *((_QWORD *)&v358 + 1);
    if ( !*((_QWORD *)&v358 + 1) )
      goto LABEL_87;
    *(_QWORD *)&v319 = &data[32].m128i_i64[1];
    *(_QWORD *)&v320 = &data[0].m128i_i64[1];
    v42 = v357[1];
    v315[0] = v359;
    *(_QWORD *)&v323 = v360;
    v43 = *((_QWORD *)&v359 + 1);
    v44 = (char *)((_QWORD)v358 << 6);
    v31 = 0LL;
    while ( 1 )
    {
      v45 = *(unsigned int *)&v31[v42];
      v139 = __CFADD__(v43, v45);
      v46 = v43 + v45;
      if ( !v139 )
      {
        bytes_at_until = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at_until(v41, v315[0], v46, v323, 0);
        if ( bytes_at_until )
        {
          if ( v48 == 14
            && !(bytes_at_until->m128i_i64[0] ^ 0x6265645F756E672ELL | *(__int64 *)((char *)bytes_at_until->m128i_i64 + 6) ^ 0x6B6E696C67756265LL) )
          {
            break;
          }
        }
      }
      v31 += 64;
      if ( v44 == v31 )
        goto LABEL_87;
    }
    if ( *(_DWORD *)&v31[v42 + 4] == 8 )
      goto LABEL_87;
    bytes_at = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
                 n[1],
                 v357[0],
                 *(_QWORD *)&v31[v42 + 24],
                 *(_QWORD *)&v31[v42 + 32]);
    v31 = (char *)bytes_at;
    if ( !bytes_at || !v50 )
      goto LABEL_87;
    v51 = 0LL;
    while ( *(_BYTE *)(bytes_at + v51) )
    {
      if ( v50 == ++v51 )
        goto LABEL_87;
    }
    v52 = (v51 & 0xFFFFFFFFFFFFFFFCLL) + 8;
    if ( (v51 & 0xFFFFFFFFFFFFFFFCLL) + 4 > v52 || v52 > v50 )
    {
LABEL_87:
      v33 = len;
      std::backtrace_rs::symbolize::gimli::elf::<impl std::backtrace_rs::symbolize::gimli::Mapping>::load_dwarf_package(
        (__int64)&v379,
        (_BYTE *)v316,
        v322,
        (__int64 *)&v352);
      v7 = v308;
      *(_QWORD *)v345.m256_f32 = 0x8000000000000000LL;
      std::backtrace_rs::symbolize::gimli::Context::new(&v383, (__int64 *)&v352, &v355, (__int64 *)&v345, &v379);
      v37 = v383;
      if ( (_QWORD)v383 != 0x8000000000000000LL )
      {
        a6 = _mm_loadu_si128((const __m128i *)((char *)&v383 + 8));
        v57 = *(_OWORD *)&v384[8];
        v58 = *(_OWORD *)&v384[24];
        v59 = *(_OWORD *)&v384[40];
        v60 = *(_OWORD *)&v384[56];
        v61 = v385;
        v62 = v386;
        v63 = v387;
        v64 = v388;
        v65 = v389;
        v66 = v390;
        v67 = v391;
        v68 = v392;
        v69 = v393;
        v339 = v352;
        v340 = v353;
        v341 = v354;
        v323 = (__int128)_mm_movelh_ps((__m128)v411, (__m128)(unsigned __int64)addr);
        v70 = v394;
        *(_OWORD *)v315 = v395;
        v320 = v396;
        v316 = v397;
        v322 = v398;
        v319 = v399;
        *(_OWORD *)v313 = v400;
        *(_OWORD *)v317 = v401;
        *(_OWORD *)v318 = v402;
        v321 = v403;
        v330 = v404;
        v324 = v405;
        v327 = v406;
        v326 = v407;
        v328 = v408;
        v329 = v409;
        v331 = (__int128)_mm_loadu_si128(&v410);
LABEL_92:
        src[35] = v341;
        src[34] = v340;
        src[33] = v339;
        *(_QWORD *)&src[0] = v37;
        *(__m128i *)((char *)src + 8) = a6;
        *(__int128 *)((char *)&src[1] + 8) = v57;
        *(__int128 *)((char *)&src[2] + 8) = v58;
        *(__int128 *)((char *)&src[3] + 8) = v59;
        *(__int128 *)((char *)&src[4] + 8) = v60;
        *(__int128 *)((char *)&src[5] + 8) = v61;
        *(__int128 *)((char *)&src[6] + 8) = v62;
        *(__int128 *)((char *)&src[7] + 8) = v63;
        *(__int128 *)((char *)&src[8] + 8) = v64;
        *(__int128 *)((char *)&src[9] + 8) = v65;
        *(__int128 *)((char *)&src[10] + 8) = v66;
        *(__int128 *)((char *)&src[11] + 8) = v67;
        *(__int128 *)((char *)&src[12] + 8) = v68;
        *(__int128 *)((char *)&src[13] + 8) = v69;
        *(__int128 *)((char *)&src[14] + 8) = v70;
        *(__int128 *)((char *)&src[15] + 8) = *(_OWORD *)v315;
        *(__int128 *)((char *)&src[16] + 8) = v320;
        *(__int128 *)((char *)&src[17] + 8) = v316;
        *(__int128 *)((char *)&src[18] + 8) = v322;
        *(__int128 *)((char *)&src[19] + 8) = v319;
        *(__int128 *)((char *)&src[20] + 8) = *(_OWORD *)v313;
        *(__int128 *)((char *)&src[21] + 8) = *(_OWORD *)v317;
        *(__int128 *)((char *)&src[22] + 8) = *(_OWORD *)v318;
        *(__int128 *)((char *)&src[23] + 8) = v321;
        *(__int128 *)((char *)&src[24] + 8) = v330;
        *(__int128 *)((char *)&src[25] + 8) = v324;
        *(__int128 *)((char *)&src[26] + 8) = v327;
        *(__int128 *)((char *)&src[27] + 8) = v326;
        *(__int128 *)((char *)&src[28] + 8) = v328;
        *(__int128 *)((char *)&src[29] + 8) = v329;
        *(__int128 *)((char *)&src[30] + 8) = v331;
        a5 = (__m128)v323;
        *(__int128 *)((char *)&src[31] + 8) = v323;
        *((_QWORD *)&src[32] + 1) = v33;
        v71 = qword_5B058;
        v72 = qword_5B048;
        if ( qword_5B058 == 4 )
        {
          qword_5B058 = 3LL;
          memcpy(data, (char *)::dest + 1752, 0x248uLL);
          v71 = 3LL;
          if ( data[0].m128i_i64[1] != 0x8000000000000000LL )
          {
            core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::Mapping>((__int64)&data[0].m128i_i64[1]);
            v71 = qword_5B058;
            v72 = qword_5B048;
          }
        }
        memcpy(&data[0].m128i_u64[1], src, 0x240uLL);
        data[0].m128i_i64[0] = v325;
        if ( v71 == v72 )
          alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(v72);
        v40 = (volatile signed __int64 **)::dest;
        if ( v71 )
        {
          memmove((char *)::dest + 584, ::dest, 584 * v71);
          memcpy(v40, data, 0x248uLL);
          qword_5B058 = v71 + 1;
          if ( v71 == -1 )
            core::panicking::panic_bounds_check(0LL, 0LL, (__int64)&off_59450);
        }
        else
        {
          memcpy(::dest, data, 0x248uLL);
          qword_5B058 = 1LL;
        }
        goto LABEL_101;
      }
      goto LABEL_88;
    }
    std::sys::pal::unix::fs::canonicalize((size_t *)&v345, (const void *)v316, v322);
    v53 = 0x8000000000000000LL;
    if ( *(_QWORD *)v345.m256_f32 == 0x8000000000000000LL )
    {
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v345.m256_f32[2]);
      goto LABEL_87;
    }
    v54 = *(_QWORD *)v345.m256_f32;
    v315[0] = v51;
    v55 = *(_QWORD *)&v345.m256_f32[4];
    if ( *(_QWORD *)&v345.m256_f32[4] )
      v56 = **(_BYTE **)&v345.m256_f32[2] == 47;
    else
      v56 = 0;
    *(_QWORD *)&v323 = *(_QWORD *)&v345.m256_f32[2];
    *(_OWORD *)v345.m256_f32 = *(_OWORD *)&v345.m256_f32[2];
    LOBYTE(v345.m256_f32[4]) = 6;
    BYTE10(v347) = v56;
    WORD4(v347) = 512;
    <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(
      (__int64)&v332,
      (__int64)&v345);
    if ( v332.m128_i8[0] == 10
      || (unsigned __int8)(v332.m128_i8[0] - 6) > 3u
      || (unsigned __int64)(unsigned __int8)(v332.m128_i8[0] - 6) - 1 > 2
      || (v317[0] = std::path::Components::as_path((__int64)&v345), v313[0] = v274, v318[0] = v31, !v317[0]) )
    {
LABEL_83:
      if ( v54 )
        _rust_dealloc(v323, v54, 1LL);
      if ( v53 != 0x8000000000000000LL )
      {
        v343 = v378;
        v342 = v53;
        std::backtrace_rs::symbolize::gimli::elf::<impl std::backtrace_rs::symbolize::gimli::Mapping>::new_debug(
          data,
          (_BYTE *)v316,
          v322,
          (__int64)&v342);
        v37 = data[0].m128i_i64[0];
        if ( data[0].m128i_i64[0] != 0x8000000000000000LL )
          goto LABEL_50;
      }
      goto LABEL_87;
    }
    v275 = v313[0] + v315[0] + 16;
    if ( v313[0] + v315[0] == -16LL )
    {
      v277 = 1LL;
    }
    else
    {
      if ( (signed __int64)(v313[0] + v315[0] + 16) < 0 )
        alloc::raw_vec::capacity_overflow();
      v276 = _rust_alloc(v313[0] + v315[0] + 16, 1LL);
      if ( !v276 )
        alloc::alloc::handle_alloc_error(1LL, v275);
      v277 = v276;
    }
    v310 = v313[0] + v315[0] + 16;
    v311 = (unsigned __int64)v277;
    if ( v275 >= v313[0] )
    {
      v278 = 0LL;
    }
    else
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, 0LL, v313[0]);
      v278 = *((_QWORD *)&v311 + 1);
      v277 = v311;
    }
    v279 = v313[0];
    memcpy((void *)(v277 + v278), v317[0], v313[0]);
    v198 = v279 + v278 == 0;
    v280 = v279 + v278;
    *((_QWORD *)&v311 + 1) = v280;
    v281 = v198 || *(_BYTE *)(v280 + v277 - 1) == 47;
    if ( v315[0] && *(_BYTE *)v318[0] == 47 )
    {
      v280 = 0LL;
    }
    else
    {
      v282 = v310;
      if ( v281 )
        goto LABEL_384;
      if ( v310 == v280 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v280, 1LL);
        v280 = *((_QWORD *)&v311 + 1);
        v277 = v311;
      }
      *(_BYTE *)(v277 + v280++) = 47;
    }
    *((_QWORD *)&v311 + 1) = v280;
    v282 = v310;
LABEL_384:
    if ( v282 - v280 < v315[0] )
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v280, v315[0]);
      v280 = *((_QWORD *)&v311 + 1);
    }
    v283 = (_BYTE *)v311;
    v284 = v315[0];
    memcpy((void *)(v311 + v280), v318[0], v315[0]);
    v198 = v284 + v280 == 0;
    v31 = (char *)(v284 + v280);
    *((_QWORD *)&v311 + 1) = v31;
    v285 = !v198 && *v283 == 47;
    v332.m128_u64[0] = (unsigned __int64)v283;
    v332.m128_u64[1] = (unsigned __int64)v31;
    LOBYTE(v333) = 6;
    v335 = v285;
    v334 = 512;
    if ( v55 )
      v286 = *(_BYTE *)v323 == 47;
    else
      v286 = 0;
    *(_QWORD *)v345.m256_f32 = v323;
    *(_QWORD *)&v345.m256_f32[2] = v55;
    LOBYTE(v345.m256_f32[4]) = 6;
    BYTE10(v347) = v286;
    WORD4(v347) = 512;
    if ( !<std::path::Components as core::cmp::PartialEq>::eq((__int64)&v332, (__int64)&v345) )
    {
      std::sys::pal::unix::fs::stat(&v345, v283, (size_t)v31);
      if ( LODWORD(v345.m256_f32[0]) == 2 )
      {
        v332.m128_u64[1] = *(_QWORD *)&v345.m256_f32[2];
        v332.m128_i8[0] = 1;
        core::ptr::drop_in_place<std::io::error::Error>(&v332.m128_i64[1]);
      }
      else if ( (WORD4(v347) & 0xF000) == 0x8000 )
      {
        goto LABEL_457;
      }
    }
    *((_QWORD *)&v311 + 1) = 0LL;
    if ( v310 >= v313[0] )
    {
      v287 = 0LL;
    }
    else
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, 0LL, v313[0]);
      v287 = *((_QWORD *)&v311 + 1);
      v283 = (_BYTE *)v311;
    }
    v288 = v313[0];
    memcpy(&v283[v287], v317[0], v313[0]);
    v198 = v287 + v288 == 0;
    v289 = v287 + v288;
    *((_QWORD *)&v311 + 1) = v289;
    if ( v198 )
    {
      v290 = v310;
      v289 = 0LL;
    }
    else
    {
      v290 = v310;
      if ( v283[v289 - 1] != 47 )
      {
        if ( v310 == v289 )
        {
          alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v289, 1LL);
          v289 = *((_QWORD *)&v311 + 1);
          v290 = v310;
          v283 = (_BYTE *)v311;
        }
        v283[v289++] = 47;
        *((_QWORD *)&v311 + 1) = v289;
      }
    }
    if ( v290 - v289 <= 5 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v289, 6LL);
      v289 = *((_QWORD *)&v311 + 1);
      v283 = (_BYTE *)v311;
    }
    *(_WORD *)&v283[v289 + 4] = 26485;
    *(_DWORD *)&v283[v289] = 1650811950;
    v291 = v289 + 6;
    *((_QWORD *)&v311 + 1) = v289 + 6;
    v292 = v289 == -6 || *(_BYTE *)(v289 + v311 + 5) == 47;
    if ( v315[0] && *(_BYTE *)v318[0] == 47 )
    {
      v291 = 0LL;
    }
    else
    {
      v293 = v310;
      if ( v292 )
      {
LABEL_418:
        if ( v293 - v291 < v315[0] )
        {
          alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v291, v315[0]);
          v291 = *((_QWORD *)&v311 + 1);
        }
        v294 = (char *)v311;
        v295 = v315[0];
        memcpy((void *)(v311 + v291), v318[0], v315[0]);
        v31 = (char *)(v295 + v291);
        *((_QWORD *)&v311 + 1) = v31;
        std::sys::pal::unix::fs::stat(&v345, v294, (size_t)v31);
        if ( LODWORD(v345.m256_f32[0]) == 2 )
        {
          v332.m128_u64[1] = *(_QWORD *)&v345.m256_f32[2];
          v332.m128_i8[0] = 1;
          core::ptr::drop_in_place<std::io::error::Error>(&v332.m128_i64[1]);
          goto LABEL_423;
        }
        if ( (WORD4(v347) & 0xF000) != 0x8000 )
        {
LABEL_423:
          if ( !std::backtrace_rs::symbolize::gimli::elf::debug_path_exists() )
          {
LABEL_458:
            if ( v310 )
              _rust_dealloc(v294, v310, 1LL);
            if ( v54 )
              _rust_dealloc(v323, v54, 1LL);
            goto LABEL_87;
          }
          *((_QWORD *)&v311 + 1) = 0LL;
          if ( v310 > 0xD )
          {
            v296 = 0LL;
          }
          else
          {
            alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, 0LL, 14LL);
            v296 = *((_QWORD *)&v311 + 1);
            v294 = (char *)v311;
          }
          qmemcpy(&v294[v296], "/usr/lib/debug", 14);
          v297 = v296 + 14;
          *((_QWORD *)&v311 + 1) = v296 + 14;
          *(void **)&v298 = v317[0];
          *((_QWORD *)&v298 + 1) = v313[0];
          v313[0] = (size_t)std::path::Path::_strip_prefix(v298, asc_49706, 1LL);
          if ( !v313[0] )
            core::result::unwrap_failed(
              (__int64)aCalledResultUn_2,
              43LL,
              (__int64)&v345,
              (__int64)&off_585F8,
              (__int64)&off_59480);
          v300 = v299;
          v301 = v296 == -14 || v294[v296 + 13] == 47;
          if ( v299 && *(_BYTE *)v313[0] == 47 )
          {
            v297 = 0LL;
          }
          else
          {
            v302 = v310;
            if ( v301 )
              goto LABEL_439;
            if ( v310 == v297 )
            {
              alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v296 + 14, 1LL);
              v297 = *((_QWORD *)&v311 + 1);
              v294 = (char *)v311;
            }
            v294[v297++] = 47;
          }
          *((_QWORD *)&v311 + 1) = v297;
          v302 = v310;
LABEL_439:
          if ( v302 - v297 < v300 )
          {
            alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v297, v300);
            v297 = *((_QWORD *)&v311 + 1);
            v294 = (char *)v311;
          }
          memcpy(&v294[v297], (const void *)v313[0], v300);
          v198 = v297 + v300 == 0;
          v303 = v297 + v300;
          *((_QWORD *)&v311 + 1) = v303;
          v304 = v198 || *(_BYTE *)(v303 + v311 - 1) == 47;
          if ( v315[0] && *(_BYTE *)v318[0] == 47 )
          {
            v303 = 0LL;
          }
          else
          {
            v305 = v310;
            if ( v304 )
            {
LABEL_452:
              if ( v305 - v303 < v315[0] )
              {
                alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v303, v315[0]);
                v303 = *((_QWORD *)&v311 + 1);
              }
              v294 = (char *)v311;
              v306 = v315[0];
              memcpy((void *)(v311 + v303), v318[0], v315[0]);
              v31 = (char *)(v306 + v303);
              *((_QWORD *)&v311 + 1) = v31;
              std::sys::pal::unix::fs::stat(&v345, v294, (size_t)v31);
              if ( LODWORD(v345.m256_f32[0]) == 2 )
              {
                v332.m128_u64[1] = *(_QWORD *)&v345.m256_f32[2];
                v332.m128_i8[0] = 1;
                core::ptr::drop_in_place<std::io::error::Error>(&v332.m128_i64[1]);
                goto LABEL_458;
              }
              if ( (WORD4(v347) & 0xF000) != 0x8000 )
                goto LABEL_458;
              goto LABEL_457;
            }
            if ( v310 == v303 )
            {
              alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v303, 1LL);
              v303 = *((_QWORD *)&v311 + 1);
            }
            *(_BYTE *)(v311 + v303++) = 47;
          }
          *((_QWORD *)&v311 + 1) = v303;
          v305 = v310;
          goto LABEL_452;
        }
LABEL_457:
        v53 = v310;
        v378 = v311;
        goto LABEL_83;
      }
      if ( v310 == v291 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v310, v289 + 6, 1LL);
        v291 = *((_QWORD *)&v311 + 1);
      }
      *(_BYTE *)(v311 + v291++) = 47;
    }
    *((_QWORD *)&v311 + 1) = v291;
    v293 = v310;
    goto LABEL_418;
  }
  v28 = 584 * qword_5B058;
  v29 = 0LL;
  v30 = 0LL;
  while ( *(_QWORD *)((char *)::dest + v30) != v19 )
  {
    v30 += 584LL;
    --v29;
    if ( v28 == v30 )
      goto LABEL_43;
  }
  if ( v29 )
  {
    memcpy(dest, (char *)::dest + v30, 0x248uLL);
    memmove((char *)::dest + v30, (char *)::dest + v30 + 584, v28 - v30 - 584);
    qword_5B058 = v27 - 1;
    if ( v27 - 1 == qword_5B048 )
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(v27 - 1);
    v40 = (volatile signed __int64 **)::dest;
    memmove((char *)::dest + 584, ::dest, 584 * (v27 - 1));
    memcpy(v40, dest, 0x248uLL);
    qword_5B058 = v27;
  }
  else
  {
    v40 = (volatile signed __int64 **)::dest;
  }
LABEL_101:
  v73 = &v7[-v23];
  v74 = (unsigned __int64)(v73 + 1);
  v75 = (__int64)v40[59];
  v76 = (unsigned __int64)v40[60];
  v77 = 0LL;
  if ( v76 )
  {
    v78 = v40[60];
    v79 = (unsigned __int64)v78;
    while ( 1 )
    {
      v80 = v77 + ((unsigned __int64)v78 >> 1);
      v81 = *(_QWORD *)(v75 + 32 * v80);
      if ( v81 == v74 )
        break;
      if ( v81 > v74 )
        v79 = v80;
      if ( v81 < v74 )
        v77 = v80 + 1;
      v78 = (volatile signed __int64 *)(v79 - v77);
      if ( v79 <= v77 )
        goto LABEL_111;
    }
    v77 = v80 + 1;
  }
LABEL_111:
  if ( v77 > v76 )
    core::slice::index::slice_end_index_len_fail(v77, v76, (__int64)&off_58868);
  v309 = v73;
  *(_QWORD *)&v322 = v40;
  if ( !v77 )
  {
    v87 = 3;
    v89 = (unsigned __int64)v73;
    goto LABEL_127;
  }
  addr = v40 + 67;
  v82 = v40 + 58;
  v83 = 32 * v77;
  v73 = (__int8 *)(v83 + v75 - 32);
  v84 = -v83;
  while ( 1 )
  {
    if ( *((_QWORD *)v73 + 3) <= (unsigned __int64)v309 )
    {
      v87 = 3;
      data[0].m128i_i64[1] = 0LL;
      goto LABEL_126;
    }
    if ( *((_QWORD *)v73 + 1) > (unsigned __int64)v309 && v74 > *(_QWORD *)v73 )
      break;
    v73 -= 32;
    v84 += 32LL;
    if ( !v84 )
    {
      v87 = 3;
      goto LABEL_126;
    }
  }
  v85 = *((_QWORD *)v73 + 2);
  v86 = *(_QWORD *)(v322 + 496);
  if ( v85 >= v86 )
    core::panicking::panic_bounds_check(v85, v86, (__int64)&off_58880);
  v87 = 3;
  data[0].m128i_i64[1] = *(_QWORD *)(v322 + 488) + 536 * v85;
  data[1].m128i_i64[0] = (__int64)v73;
  v88 = data[0].m128i_i64[1];
  if ( !data[0].m128i_i64[1] )
  {
LABEL_126:
    v89 = (unsigned __int64)v309;
    goto LABEL_127;
  }
  addr2line::ResUnit<R>::dwarf_and_unit_dwo(dest, data[0].m128i_i64[1], v82);
  *(_QWORD *)&src[0] = v88;
  *(_QWORD *)&src[1] = v309;
  *((_QWORD *)&src[0] + 1) = v82;
  if ( dest[3].m128i_i64[0] )
  {
    v414[1].m128i_i64[0] = dest[4].m128i_i64[0];
    a5 = (__m128)dest[3];
    *(__int128 *)((char *)&v414[1] + 8) = src[0];
    v414[2].m128i_i64[1] = *(_QWORD *)&src[1];
    a6 = _mm_loadu_si128(dest);
    data[0] = a6;
    data[1] = dest[1];
    data[2] = dest[2];
    data[3] = dest[3];
    data[4].m128i_i64[0] = dest[4].m128i_i64[0];
    *(__int128 *)((char *)&data[4] + 8) = src[0];
    data[5].m128i_i64[1] = *(_QWORD *)&src[1];
  }
  else
  {
    addr2line::ResUnit<R>::find_function_or_location::{{closure}}((__int64)data, src, (__int64)dest, a5, a6);
    data[3].m128i_i64[0] = 0LL;
  }
  dest[0].m128i_i64[0] = (__int64)v309;
  dest[0].m128i_i64[1] = v88;
  dest[1].m128i_i64[0] = (__int64)v82;
  dest[1].m128i_i64[1] = (__int64)v82;
  dest[2].m128i_i64[0] = (__int64)v309;
  dest[2].m128i_i64[1] = v74;
  dest[3].m128i_i64[0] = v75;
  dest[3].m128i_i64[1] = (__int64)v73;
  dest[4].m128i_i64[0] = v74;
  dest[4].m128i_i64[1] = (__int64)v309;
  dest[5].m128i_i8[0] = 0;
  addr2line::LoopingLookup<T,L,F>::new_lookup(v414, (__int64)data, (__int64)dest, (__m128i)a5, a6);
  if ( v414[11].m128i_i8[0] != 2 )
  {
    v132 = 0LL;
    LOBYTE(len) = *(_BYTE *)(v322 + 128);
    *(_QWORD *)&v344 = v322 + 128;
    if ( (_BYTE)len != 22 )
      v132 = v322 + 128;
    *(_QWORD *)&v320 = v132;
    *(_QWORD *)&v330 = *(unsigned int *)(v322 + 208);
    v315[0] = (unsigned int)(v330 - 1);
    *(_QWORD *)&v323 = *(_QWORD *)(v322 + 144);
    v325 = *(_QWORD *)(v322 + 136);
    v364.m128i_i64[0] = v322 + 560;
    do
    {
      si128 = _mm_loadu_si128(&v414[1]);
      *(__m128i *)v357 = v414[2];
      *(__m128i *)n = si128;
      v355 = v414[0];
      memcpy(src, &v414[3], 0x88uLL);
      if ( (_BYTE)len != 22 && (_DWORD)v330 )
      {
        v134 = (volatile signed __int64 *)v355.m128i_i64[0];
        v135 = v315[0];
        v136 = v355.m128i_i32[2];
        while ( 1 )
        {
          v137 = v315[0] & v136;
          if ( (unsigned __int64)v323 < 8 * v137 || (unsigned __int64)(v323 - 8 * v137) < 8 )
            goto LABEL_252;
          v138 = *(_QWORD *)(v325 + 8 * v137);
          if ( v138 == v355.m128i_i64[1] )
            break;
          v139 = v135-- == 0;
          if ( v138 )
          {
            v136 = (v315[0] & v355.m128i_i32[3] | 1) + v137;
            if ( !v139 )
              continue;
          }
          goto LABEL_252;
        }
        v140 = *(_QWORD *)(v320 + 32);
        v141 = 4 * v137;
        v139 = v140 < v141;
        v142 = v140 - v141;
        if ( !v139 && v142 >= 4 )
        {
          v143 = *(_DWORD *)(*(_QWORD *)(v320 + 24) + v141);
          if ( v143 )
          {
            v144 = v143 - 1;
            if ( v144 < *(_DWORD *)(v320 + 76) )
            {
              v145 = *(_QWORD *)(v320 + 48);
              v146 = *(unsigned int *)(v320 + 72);
              v147 = 4 * v146 * v144;
              v139 = v145 < v147;
              v148 = v145 - v147;
              if ( !v139 )
              {
                v149 = *(_QWORD *)(v320 + 64);
                v139 = v149 < v147;
                v150 = v149 - v147;
                if ( !v139 )
                {
                  if ( (unsigned int)v146 >= 9 )
                    core::slice::index::slice_end_index_len_fail(v146, 8LL, (__int64)&off_58710);
                  v151 = (_QWORD *)v320;
                  if ( !*(_DWORD *)(v320 + 72) )
                  {
                    v256 = *(_QWORD *)(v320 + 176);
                    v257 = *(_QWORD *)(v320 + 192);
                    v258 = *(_QWORD *)(v320 + 208);
                    *(_QWORD *)&v319 = *(_QWORD *)(v320 + 256);
                    v317[0] = *(void **)(v320 + 272);
                    *(_QWORD *)&v321 = *(_QWORD *)(v320 + 240);
                    *(_QWORD *)&v327 = *(_QWORD *)(v320 + 288);
                    *(_QWORD *)&v326 = *(_QWORD *)(v320 + 304);
                    *(_QWORD *)&v329 = 0LL;
                    *(_QWORD *)&v328 = 0LL;
                    *(_QWORD *)&v324 = 0LL;
                    v318[0] = 0LL;
                    v313[0] = 0LL;
                    *(_QWORD *)&v316 = 0LL;
                    v259 = 0LL;
                    v166 = 0LL;
LABEL_349:
                    v260 = v151[28];
                    v261 = v151[29];
                    v262 = *(_QWORD *)(v355.m128i_i64[0] + 32);
                    v263 = *(_QWORD *)(v355.m128i_i64[0] + 40);
                    v264 = *(_QWORD *)(v355.m128i_i64[0] + 192);
                    v265 = *(_QWORD *)(v355.m128i_i64[0] + 200);
                    v266 = v151[40];
                    v267 = v151[41];
                    v268 = *(volatile signed __int64 **)(v355.m128i_i64[0] + 224);
                    if ( v268 && _InterlockedIncrement64(v268) <= 0 )
                      goto LABEL_474;
                    data[0].m128i_i64[0] = 1LL;
                    data[0].m128i_i64[1] = 1LL;
                    data[1].m128i_i64[0] = v256;
                    data[1].m128i_i64[1] = v166;
                    data[2].m128i_i64[0] = v262;
                    data[2].m128i_i64[1] = v263;
                    data[3].m128i_i64[0] = v266;
                    data[3].m128i_i64[1] = v267;
                    data[4].m128i_i64[0] = v257;
                    data[4].m128i_i64[1] = v259;
                    data[5].m128i_i64[0] = v258;
                    data[5].m128i_i64[1] = v316;
                    data[6].m128i_i64[0] = v266;
                    data[6].m128i_i64[1] = v267;
                    data[7].m128i_i64[0] = v260;
                    data[7].m128i_i64[1] = v261;
                    data[8].m128i_i64[0] = v321;
                    data[8].m128i_i64[1] = v324;
                    data[9].m128i_i64[0] = v326;
                    data[9].m128i_i64[1] = v329;
                    data[10].m128i_i64[0] = v319;
                    data[10].m128i_i64[1] = v313[0];
                    data[11].m128i_i64[0] = (__int64)v317[0];
                    data[11].m128i_i64[1] = (__int64)v318[0];
                    data[12].m128i_i64[0] = v264;
                    data[12].m128i_i64[1] = v265;
                    data[13].m128i_i64[0] = v327;
                    data[13].m128i_i64[1] = v328;
                    data[14] = (__m128i)(unsigned __int64)v268;
                    data[15].m128i_i64[1] = 0LL;
                    data[16].m128i_i8[0] = 1;
                    v269 = (__m128 *)_rust_alloc(264LL, 8LL);
                    if ( !v269 )
                      alloc::alloc::handle_alloc_error(8LL, 264LL);
                    v186 = v269;
                    memcpy(v269, data, 0x108uLL);
                    v73 = &data[0].m128i_i8[9];
                    if ( !_InterlockedDecrement64(v134) )
                    {
LABEL_314:
                      alloc::sync::Arc<T,A>::drop_slow(v355.m128i_i64);
                      goto LABEL_315;
                    }
                    goto LABEL_315;
                  }
                  v152 = v147 + *(_QWORD *)(v320 + 40);
                  v153 = v320 + v146;
                  v154 = *(_QWORD *)(v320 + 56) + v147;
                  v155 = 0LL;
                  v156 = 0;
                  v157 = 0;
                  v158 = 0;
                  v159 = 0;
                  LODWORD(v316) = 0;
                  LODWORD(v319) = 0;
                  LODWORD(v313[0]) = 0;
                  LODWORD(v317[0]) = 0;
                  LODWORD(v318[0]) = 0;
                  LODWORD(v321) = 0;
                  LODWORD(v324) = 0;
                  LODWORD(v327) = 0;
                  LODWORD(v326) = 0;
                  LODWORD(v328) = 0;
                  LODWORD(v329) = 0;
                  LODWORD(v331) = 0;
                  while ( 2 )
                  {
                    if ( v148 >= 4 && v150 > 3 )
                    {
                      v160 = *(_DWORD *)(v152 + 4 * v155);
                      v161 = *(_DWORD *)(v154 + 4 * v155);
                      switch ( *(_BYTE *)(v344 + v155) )
                      {
                        case 0:
                          goto LABEL_237;
                        case 7:
                          v159 = *(_DWORD *)(v154 + 4 * v155);
                          v158 = *(_DWORD *)(v152 + 4 * v155);
                          goto LABEL_236;
                        case 8:
                          LODWORD(v319) = *(_DWORD *)(v154 + 4 * v155);
                          LODWORD(v316) = v160;
                          goto LABEL_236;
                        case 0xA:
                          LODWORD(v317[0]) = *(_DWORD *)(v154 + 4 * v155);
                          LODWORD(v313[0]) = v160;
                          goto LABEL_236;
                        case 0xB:
                          LODWORD(v321) = *(_DWORD *)(v154 + 4 * v155);
                          LODWORD(v318[0]) = v160;
                          goto LABEL_236;
                        case 0xC:
                        case 0xD:
                          goto LABEL_236;
                        case 0x11:
                          LODWORD(v328) = *(_DWORD *)(v154 + 4 * v155);
                          LODWORD(v326) = v160;
                          goto LABEL_236;
                        case 0x13:
                          LODWORD(v327) = *(_DWORD *)(v154 + 4 * v155);
                          LODWORD(v324) = v160;
                          goto LABEL_236;
                        case 0x15:
                          LODWORD(v331) = *(_DWORD *)(v154 + 4 * v155);
                          LODWORD(v329) = v160;
LABEL_236:
                          v161 = v157;
                          v160 = v156;
LABEL_237:
                          v162 = v344 + v155++ + 1;
                          v148 -= 4LL;
                          v150 -= 4LL;
                          v156 = v160;
                          v157 = v161;
                          if ( v162 == v153 )
                            goto LABEL_240;
                          continue;
                        default:
                          goto LABEL_252;
                      }
                    }
                    break;
                  }
                  v161 = v157;
                  v160 = v156;
LABEL_240:
                  v163 = v160;
                  v164 = *(_QWORD *)(v320 + 184);
                  v139 = v164 < v160;
                  v165 = v164 - v160;
                  if ( !v139 )
                  {
                    v166 = v161;
                    if ( v165 >= v161 )
                    {
                      v167 = *(_QWORD *)(v320 + 200);
                      v139 = v167 < v158;
                      v168 = v167 - v158;
                      if ( !v139 )
                      {
                        v169 = v159;
                        if ( v168 >= v159 )
                        {
                          v170 = (unsigned int)v316;
                          v171 = *(_QWORD *)(v320 + 216);
                          v139 = v171 < (unsigned int)v316;
                          v172 = v171 - (unsigned int)v316;
                          if ( !v139 )
                          {
                            *(_QWORD *)&v316 = (unsigned int)v319;
                            if ( v172 >= (unsigned int)v319 )
                            {
                              v173 = *(_QWORD *)(v320 + 264);
                              *(_QWORD *)&v319 = LODWORD(v313[0]);
                              v139 = v173 < LODWORD(v313[0]);
                              v174 = v173 - LODWORD(v313[0]);
                              if ( !v139 )
                              {
                                v313[0] = LODWORD(v317[0]);
                                if ( v174 >= LODWORD(v317[0]) )
                                {
                                  v175 = *(_QWORD *)(v320 + 280);
                                  v317[0] = (void *)LODWORD(v318[0]);
                                  v139 = v175 < LODWORD(v318[0]);
                                  v176 = v175 - LODWORD(v318[0]);
                                  if ( !v139 )
                                  {
                                    v318[0] = (void *)(unsigned int)v321;
                                    if ( v176 >= (unsigned int)v321 )
                                    {
                                      v177 = *(_QWORD *)(v320 + 248);
                                      *(_QWORD *)&v321 = (unsigned int)v324;
                                      v139 = v177 < (unsigned int)v324;
                                      v178 = v177 - (unsigned int)v324;
                                      if ( !v139 )
                                      {
                                        *(_QWORD *)&v324 = (unsigned int)v327;
                                        if ( v178 >= (unsigned int)v327 )
                                        {
                                          v270 = *(_QWORD *)(v320 + 296);
                                          *(_QWORD *)&v327 = (unsigned int)v326;
                                          v139 = v270 < (unsigned int)v326;
                                          v271 = v270 - (unsigned int)v326;
                                          if ( !v139 )
                                          {
                                            *(_QWORD *)&v328 = (unsigned int)v328;
                                            if ( v271 >= (unsigned int)v328 )
                                            {
                                              v272 = *(_QWORD *)(v320 + 312);
                                              *(_QWORD *)&v326 = (unsigned int)v329;
                                              v139 = v272 < (unsigned int)v329;
                                              v273 = v272 - (unsigned int)v329;
                                              if ( !v139 )
                                              {
                                                *(_QWORD *)&v329 = (unsigned int)v331;
                                                if ( v273 >= (unsigned int)v331 )
                                                {
                                                  v259 = v169;
                                                  v151 = (_QWORD *)v320;
                                                  v256 = *(_QWORD *)(v320 + 176) + v163;
                                                  v257 = *(_QWORD *)(v320 + 192) + v158;
                                                  v258 = *(_QWORD *)(v320 + 208) + v170;
                                                  *(_QWORD *)&v319 = *(_QWORD *)(v320 + 256) + v319;
                                                  v317[0] = (char *)v317[0] + *(_QWORD *)(v320 + 272);
                                                  *(_QWORD *)&v321 = *(_QWORD *)(v320 + 240) + v321;
                                                  *(_QWORD *)&v327 = *(_QWORD *)(v320 + 288) + v327;
                                                  *(_QWORD *)&v326 = *(_QWORD *)(v320 + 304) + v326;
                                                  goto LABEL_349;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
LABEL_252:
      v332.m128_u64[0] = 0LL;
      v332.m128_u64[1] = 1LL;
      v333 = 0LL;
      v179 = (const void *)n[0];
      if ( n[0] )
      {
        v180 = n[1];
        if ( n[1] )
        {
          if ( (n[1] & 0x8000000000000000LL) != 0LL )
            goto LABEL_462;
          v181 = _rust_alloc(n[1], 1LL);
          if ( !v181 )
            goto LABEL_463;
          v182 = (void *)v181;
        }
        else
        {
          v182 = &dword_0 + 1;
        }
        memcpy(v182, v179, v180);
        v379.m128i_i64[0] = v180;
        v379.m128i_i64[1] = (__int64)v182;
        v380.m128i_i64[0] = v180;
        std::path::PathBuf::push((__int64 *)&v332, v379.m128i_i64);
      }
      v183 = (const void *)v357[0];
      if ( v357[0] )
      {
        v180 = v357[1];
        if ( v357[1] )
        {
          if ( (v357[1] & 0x8000000000000000LL) != 0LL )
LABEL_462:
            alloc::raw_vec::capacity_overflow();
          v184 = _rust_alloc(v357[1], 1LL);
          if ( !v184 )
LABEL_463:
            alloc::alloc::handle_alloc_error(1LL, v180);
          v185 = (void *)v184;
        }
        else
        {
          v185 = &dword_0 + 1;
        }
        memcpy(v185, v183, v180);
        *(_QWORD *)v345.m256_f32 = v180;
        *(_QWORD *)&v345.m256_f32[2] = v185;
        *(_QWORD *)&v345.m256_f32[4] = v180;
        std::path::PathBuf::push((__int64 *)&v332, (__int64 *)&v345);
        v187 = v332.m128_u64[1];
        std::backtrace_rs::symbolize::gimli::mmap((__int64 *)&v383, (const void *)v332.m128_u64[1], v333);
        if ( !(_QWORD)v383 )
          goto LABEL_272;
        v188 = *((_QWORD *)&v383 + 1);
        v189 = *(_QWORD *)v384;
        v190 = *(_QWORD *)(v322 + 576);
        if ( v190 == *(_QWORD *)(v322 + 560) )
        {
          alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)v364.m128i_i64[0], v190);
          v191 = v322;
          v190 = *(_QWORD *)(v322 + 576);
        }
        else
        {
          v191 = v322;
        }
        v192 = *(_QWORD *)(v191 + 568);
        v193 = 16 * v190;
        *(_QWORD *)(v192 + v193) = v188;
        *(_QWORD *)(v192 + v193 + 8) = v189;
        v194 = v190 + 1;
        *(_QWORD *)(v191 + 576) = v194;
        if ( !v194 )
          core::option::unwrap_failed((__int64)&off_59420);
        std::backtrace_rs::symbolize::gimli::elf::Object::parse(
          dest[0].m128i_i64,
          *(_QWORD *)(*(_QWORD *)(v191 + 568) + v193),
          *(_QWORD *)(*(_QWORD *)(v191 + 568) + v193 + 8));
        if ( dest[0].m128i_i64[0] == 0x8000000000000000LL )
        {
LABEL_272:
          v73 = &data[0].m128i_i8[9];
          if ( v332.m128_u64[0] )
            _rust_dealloc(v187, v332.m128_u64[0], 1LL);
          v186 = 0LL;
          if ( !_InterlockedDecrement64((volatile signed __int64 *)v355.m128i_i64[0]) )
            goto LABEL_314;
          goto LABEL_315;
        }
        *(_QWORD *)&v331 = dest[0].m128i_i64[1];
        *(_QWORD *)&v324 = dest[0].m128i_i64[0];
        v195 = std::backtrace_rs::symbolize::gimli::elf::Object::section(dest, (__int64 *)addr, aDebugLocDwo, 0xEuLL);
        *(_QWORD *)&v316 = v196;
        v197 = v195;
        v198 = v195 == 0LL;
        v199 = v196;
        if ( v198 )
          v199 = v197;
        *(_QWORD *)&v316 = v199;
        if ( v198 )
          v197 = aRustc9b00956e5;
        *(_QWORD *)&v327 = v197;
        v200 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                 dest,
                 (__int64 *)addr,
                 aDebugLoclistsD,
                 0x13uLL);
        *(_QWORD *)&v319 = v201;
        v202 = v200;
        v203 = v200 == 0LL;
        v204 = v201;
        if ( v203 )
          v204 = v202;
        *(_QWORD *)&v319 = v204;
        if ( v203 )
          v202 = aRustc9b00956e5;
        *(_QWORD *)&v326 = v202;
        v205 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                 dest,
                 (__int64 *)addr,
                 aDebugRnglistsD,
                 0x13uLL);
        v313[0] = v206;
        v207 = v205;
        v208 = v205 == 0LL;
        v209 = v206;
        if ( v208 )
          v209 = (size_t)v207;
        v313[0] = v209;
        if ( v208 )
          v207 = aRustc9b00956e5;
        *(_QWORD *)&v328 = v207;
        v210 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                 dest,
                 (__int64 *)addr,
                 aDebugAbbrevDwo,
                 0x11uLL);
        v317[0] = v211;
        v212 = v210;
        v213 = v210 == 0LL;
        v214 = (const char *)v211;
        if ( v213 )
          v214 = v212;
        v317[0] = (void *)v214;
        if ( v213 )
          v212 = aRustc9b00956e5;
        *(_QWORD *)&v329 = v212;
        v215 = std::backtrace_rs::symbolize::gimli::elf::Object::section(dest, (__int64 *)addr, aDebugInfoDwo, 0xFuLL);
        v318[0] = v216;
        v217 = v215;
        v218 = v215 == 0LL;
        v219 = (const char *)v216;
        if ( v218 )
          v219 = v217;
        v318[0] = (void *)v219;
        if ( v218 )
          v217 = aRustc9b00956e5;
        v220 = std::backtrace_rs::symbolize::gimli::elf::Object::section(dest, (__int64 *)addr, aDebugLineDwo, 0xFuLL);
        *(_QWORD *)&v321 = v221;
        v222 = v220;
        v223 = v220 == 0LL;
        v224 = v221;
        if ( v223 )
          v224 = v222;
        *(_QWORD *)&v321 = v224;
        if ( v223 )
          v222 = aRustc9b00956e5;
        v225 = std::backtrace_rs::symbolize::gimli::elf::Object::section(dest, (__int64 *)addr, aDebugStrDwo, 0xEuLL);
        v227 = v226;
        if ( !v225 )
        {
          v227 = 0LL;
          v225 = aRustc9b00956e5;
        }
        v228 = std::backtrace_rs::symbolize::gimli::elf::Object::section(
                 dest,
                 (__int64 *)addr,
                 aDebugStrOffset_0,
                 0x16uLL);
        v230 = v229;
        v231.m128i_i64[0] = (__int64)std::backtrace_rs::symbolize::gimli::elf::Object::section(
                                       dest,
                                       (__int64 *)addr,
                                       aDebugTypesDwo,
                                       0x10uLL);
        v232 = v228;
        if ( !v228 )
        {
          v232 = aRustc9b00956e5;
          v230 = 0LL;
        }
        if ( !v231.m128i_i64[0] )
        {
          v231.m128i_i64[1] = 0LL;
          v231.m128i_i64[0] = (__int64)aRustc9b00956e5;
        }
        v233 = *(_QWORD *)(v355.m128i_i64[0] + 32);
        v234 = *(_QWORD *)(v355.m128i_i64[0] + 40);
        v235 = *(_QWORD *)(v355.m128i_i64[0] + 192);
        v236 = *(_QWORD *)(v355.m128i_i64[0] + 200);
        v237 = *(volatile signed __int64 **)(v355.m128i_i64[0] + 224);
        if ( v237 && _InterlockedIncrement64(v237) <= 0 )
LABEL_474:
          BUG();
        data[1].m128i_i64[0] = v329;
        data[1].m128i_i64[1] = (__int64)v317[0];
        data[2].m128i_i64[0] = v233;
        data[2].m128i_i64[1] = v234;
        data[3] = (__m128i)(unsigned __int64)aRustc9b00956e5;
        data[4].m128i_i64[0] = (__int64)v217;
        data[4].m128i_i64[1] = (__int64)v318[0];
        data[5].m128i_i64[0] = (__int64)v222;
        data[5].m128i_i64[1] = v321;
        data[6].m128i_i64[0] = (__int64)aRustc9b00956e5;
        data[6].m128i_i64[1] = 0LL;
        data[7].m128i_i64[0] = (__int64)v225;
        data[7].m128i_i64[1] = v227;
        data[8].m128i_i64[0] = (__int64)v232;
        data[8].m128i_i64[1] = v230;
        data[9] = v231;
        data[10].m128i_i64[0] = v327;
        data[10].m128i_i64[1] = v316;
        data[11].m128i_i64[0] = v326;
        data[11].m128i_i64[1] = v319;
        data[12].m128i_i64[0] = v235;
        data[12].m128i_i64[1] = v236;
        data[13].m128i_i64[0] = v328;
        data[13].m128i_i64[1] = v313[0];
        data[14] = (__m128i)(unsigned __int64)v237;
        data[15].m128i_i64[1] = 0LL;
        data[16].m128i_i8[0] = 1;
        data[0].m128i_i64[0] = 1LL;
        data[0].m128i_i64[1] = 1LL;
        v238 = (__m128 *)_rust_alloc(264LL, 8LL);
        if ( !v238 )
          alloc::alloc::handle_alloc_error(8LL, 264LL);
        v186 = v238;
        memcpy(v238, data, 0x108uLL);
        v73 = &data[0].m128i_i8[9];
        if ( (_QWORD)v324 )
          _rust_dealloc(v331, 24 * v324, 8LL);
      }
      else
      {
        v186 = 0LL;
        v73 = &data[0].m128i_i8[9];
      }
      if ( v332.m128_u64[0] )
        _rust_dealloc(v332.m128_u64[1], v332.m128_u64[0], 1LL);
      if ( !_InterlockedDecrement64((volatile signed __int64 *)v355.m128i_i64[0]) )
        goto LABEL_314;
LABEL_315:
      a5 = (__m128)src[0];
      v339 = src[0];
      *(_QWORD *)&v340 = *(_QWORD *)&src[1];
      v239 = *(_QWORD *)&src[0];
      *(_QWORD *)&v352 = (char *)&v339 + 8;
      *((_QWORD *)&v352 + 1) = v186;
      v240 = *(_BYTE *)(*(_QWORD *)&src[0] + 512LL);
      if ( v240 == 76 )
      {
        if ( v186 )
        {
          v241 = *((_QWORD *)&v339 + 1);
          v310 = (size_t)v186;
          a5 = v186[4];
          v332 = a5;
          v333 = 0LL;
          gimli::read::unit::DebugInfoUnitHeadersIter<R>::next((__int64)data, (__int64)&v332);
          v240 = data[0].m128i_i8[8];
          LODWORD(v338[0]) = *(__int32 *)((char *)&data[0].m128i_i32[2] + 1);
          *(_DWORD *)((char *)v338 + 3) = data[0].m128i_i32[3];
          v242 = (__int64 *)data[1].m128i_i64[0];
          if ( data[0].m128i_i64[0] == 3 )
          {
            v243 = v338;
            goto LABEL_319;
          }
          *(_QWORD *)&v347 = data[4].m128i_i64[1];
          a5 = *(__m128 *)((char *)&data[1] + 8);
          si128 = _mm_loadu_si128((const __m128i *)&data[2].m128i_u64[1]);
          v346 = *(__int128 *)((char *)&data[3] + 8);
          *(__m128i *)&v345.m256_f32[4] = si128;
          *(__m128i *)v345.m256_f32 = *(__m128i *)((char *)&data[1] + 8);
          if ( data[0].m128i_i32[0] == 2 )
          {
            v240 = 75;
            v242 = 0LL;
            if ( !_InterlockedDecrement64((volatile signed __int64 *)v186) )
              goto LABEL_330;
            goto LABEL_331;
          }
          *(_QWORD *)&v383 = data[0].m128i_i64[0];
          BYTE8(v383) = data[0].m128i_i8[8];
          HIDWORD(v383) = *(_DWORD *)((char *)v338 + 3);
          *(_DWORD *)((char *)&v383 + 9) = v338[0];
          *(_QWORD *)v384 = data[1].m128i_i64[0];
          *(_QWORD *)&v384[56] = v347;
          a5 = *(__m128 *)v345.m256_f32;
          si128 = _mm_load_si128((const __m128i *)&v345.m256_f32[4]);
          *(_OWORD *)&v384[40] = v346;
          *(__m128i *)&v384[24] = si128;
          *(_OWORD *)&v384[8] = *(_OWORD *)v345.m256_f32;
          gimli::read::dwarf::Unit<R>::new(data, (__m128 *)v186[1].m128_u64, (__int64)&v383);
          v251 = data[0].m128i_i64[0];
          v240 = data[0].m128i_i8[8];
          LODWORD(v342) = *(__int32 *)((char *)&data[0].m128i_i32[2] + 1);
          *(_DWORD *)((char *)&v342 + 3) = data[0].m128i_i32[3];
          v242 = (__int64 *)data[1].m128i_i64[0];
          if ( data[0].m128i_i64[0] == 2 )
          {
            v243 = &v342;
            v73 = &data[0].m128i_i8[9];
LABEL_319:
            v244 = *(_DWORD *)v243;
            *(__int32 *)((char *)data[0].m128i_i32 + 3) = *(_DWORD *)((char *)v243 + 3);
            data[0].m128i_i32[0] = v244;
            if ( !_InterlockedDecrement64((volatile signed __int64 *)v186) )
LABEL_330:
              alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v310);
LABEL_331:
            if ( *(_BYTE *)(v239 + 512) != 76 )
              goto LABEL_325;
          }
          else
          {
            v382 = data[4].m128i_i16[4];
            v381 = *(__m128i *)((char *)&data[3] + 8);
            v380 = *(__m128i *)((char *)&data[2] + 8);
            v379 = *(__m128i *)((char *)&data[1] + 8);
            LOWORD(v318[0]) = data[4].m128i_i16[5];
            memcpy(dest, (char *)&data[4].m128i_u64[1] + 4, 0x134uLL);
            v252 = data[4].m128i_i16[5];
            if ( data[4].m128i_i16[5] >= 5u )
              v253 = data[26].m128i_i64[0];
            else
              v253 = *(_QWORD *)(v241 + 416);
            *(_QWORD *)&v316 = v253;
            v313[0] = data[24].m128i_u64[1];
            *(_QWORD *)&v319 = data[25].m128i_i64[1];
            v317[0] = *(void **)(v241 + 384);
            v254 = *(_QWORD *)(v241 + 400);
            data[0].m128i_i64[0] = (__int64)v186;
            data[0].m128i_i64[1] = v251;
            data[1].m128i_i8[0] = v240;
            v73 = &data[0].m128i_i8[9];
            data[1].m128i_i32[1] = *(_DWORD *)((char *)&v342 + 3);
            *(__int32 *)((char *)data[1].m128i_i32 + 1) = v342;
            data[1].m128i_i64[1] = (__int64)v242;
            data[5].m128i_i16[0] = v382;
            a5 = (__m128)v379;
            si128 = _mm_load_si128(&v380);
            data[4] = v381;
            data[3] = si128;
            data[2] = v379;
            data[5].m128i_i16[1] = v252;
            memcpy((char *)data[5].m128i_i64 + 4, dest, 0x134uLL);
            data[24].m128i_i64[1] = (__int64)v317[0];
            data[25].m128i_i64[0] = v313[0];
            data[25].m128i_i64[1] = v254;
            data[26].m128i_i64[0] = v319;
            data[26].m128i_i64[1] = v316;
            v255 = (__int64 *)_rust_alloc(432LL, 8LL);
            if ( !v255 )
              alloc::alloc::handle_alloc_error(8LL, 432LL);
            v242 = v255;
            memcpy(v255, data, 0x1B0uLL);
            v240 = 75;
            if ( *(_BYTE *)(v239 + 512) != 76 )
            {
LABEL_325:
              core::ptr::drop_in_place<core::result::Result<core::option::Option<alloc::boxed::Box<(alloc::sync::Arc<gimli::read::dwarf::Dwarf<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>>>,gimli::read::dwarf::Unit<gimli::read::endian_slice::EndianSlice<gimli::endianity::LittleEndian>,usize>)>>,gimli::read::Error>>(
                v240,
                v242);
              goto LABEL_326;
            }
          }
        }
        else
        {
          v240 = 75;
          v242 = 0LL;
          if ( *(_BYTE *)(*(_QWORD *)&src[0] + 512LL) != 76 )
            goto LABEL_325;
        }
        *(_BYTE *)(v239 + 512) = v240;
        v249 = *(__int32 *)((char *)data[0].m128i_i32 + 3);
        *(_DWORD *)(v239 + 513) = data[0].m128i_i32[0];
        *(_DWORD *)(v239 + 516) = v249;
        *(_QWORD *)(v239 + 520) = v242;
        goto LABEL_333;
      }
      if ( v186 )
      {
        if ( !_InterlockedDecrement64((volatile signed __int64 *)v186) )
          alloc::sync::Arc<T,A>::drop_slow((__int64 *)&v352 + 1);
LABEL_326:
        if ( *(_BYTE *)(v239 + 512) == 75 )
          goto LABEL_334;
        goto LABEL_327;
      }
LABEL_333:
      if ( v240 == 75 )
      {
LABEL_334:
        v250 = *(_QWORD **)(v239 + 520);
        if ( v250 )
        {
          v245 = *v250 + 16LL;
          v247 = (__int64)(v250 + 1);
          v246 = 2;
        }
        else
        {
          v247 = v339;
          v245 = *(_QWORD *)v340 + 16LL;
          v246 = 0;
        }
        v248 = 0LL;
        goto LABEL_338;
      }
LABEL_327:
      v245 = *(_QWORD *)(v239 + 512);
      v246 = *(_BYTE *)(v239 + 520);
      *(_DWORD *)((char *)&v383 + 3) = *(_DWORD *)(v239 + 524);
      v247 = *(unsigned int *)(v239 + 521);
      LODWORD(v383) = *(_DWORD *)(v239 + 521);
      v248 = 1LL;
LABEL_338:
      data[0].m128i_i64[0] = v248;
      data[0].m128i_i64[1] = v245;
      data[1].m128i_i8[0] = v246;
      data[1].m128i_i32[1] = *(_DWORD *)((char *)&v383 + 3);
      *(__int32 *)((char *)data[1].m128i_i32 + 1) = v383;
      data[1].m128i_i64[1] = v247;
      addr2line::ResUnit<R>::find_function_or_location::{{closure}}(
        (__int64)dest,
        (_QWORD *)&src[1] + 1,
        (__int64)data,
        a5,
        si128);
      dest[3].m128i_i64[0] = 0LL;
      *(_QWORD *)&v384[64] = *(_QWORD *)&src[8];
      *(_OWORD *)&v384[48] = src[7];
      a5.m128_u64[0] = *(_QWORD *)&src[3];
      a6 = _mm_loadu_si128((const __m128i *)&src[4]);
      *(_OWORD *)&v384[32] = src[6];
      *(_OWORD *)&v384[16] = src[5];
      *(__m128i *)v384 = a6;
      v383 = src[3];
      addr2line::LoopingLookup<T,L,F>::new_lookup(data, (__int64)dest, (__int64)&v383, (__m128i)src[3], a6);
      memcpy(v414, data, 0xB8uLL);
    }
    while ( v414[11].m128i_i8[0] != 2 );
  }
  v87 = v414[0].m128i_i32[0];
  v89 = (unsigned __int64)v309;
  if ( v414[0].m128i_i32[0] == 5 )
    goto LABEL_187;
LABEL_127:
  v90 = v414[0].m128i_u32[1];
  v91 = v414[0].m128i_u32[2];
  v92 = v414[0].m128i_u32[3];
  *(_QWORD *)&v316 = v414[1].m128i_i64[1];
  len = v414[1].m128i_u64[0];
  *(_QWORD *)&v329 = v414[2].m128i_i64[1];
  *(_QWORD *)&v321 = v414[3].m128i_i64[1];
  *(_QWORD *)&v327 = v414[3].m128i_i64[0];
  v318[0] = (void *)v414[4].m128i_i64[0];
  *(_QWORD *)&v319 = v414[5].m128i_i64[0];
  *(_QWORD *)&v324 = v414[2].m128i_i64[0] + 96;
  v313[0] = v414[2].m128i_u64[0];
  *(_QWORD *)&v328 = v414[2].m128i_i64[0] + 440;
  v317[0] = (void *)v414[4].m128i_i64[1];
  *(_QWORD *)&v330 = 8 * v414[4].m128i_i64[1];
  v93 = 0;
  while ( 1 )
  {
    LODWORD(v6) = v87 - 3;
    v94 = 2;
    if ( v87 - 3 < 2 )
      v94 = v87 - 3;
    if ( v94 == 1 )
    {
      v95 = v91 | (v92 << 32);
      v325 = v90;
      addr = (void *)v92;
      if ( (unsigned int)v6 < 2 )
      {
        LODWORD(v323) = 2;
        v315[0] = 3LL;
        v102 = v313[0];
      }
      else
      {
        LODWORD(v323) = 2;
        v315[0] = 3LL;
        v102 = v313[0];
        if ( v317[0] )
          _rust_dealloc(v321, v330, 8LL);
      }
      v104 = v316;
      v96 = len;
      v105 = v322;
      v106 = *(_QWORD *)(v322 + 24);
      if ( !v106 )
        goto LABEL_177;
      goto LABEL_152;
    }
    if ( v94 != 2 )
      break;
    v95 = v87 | (unsigned __int64)(v90 << 32);
    v96 = v91 | (v92 << 32);
    if ( v318[0] != (void *)v319 )
    {
      v73 = *(__int8 **)(v319 - 8);
      v97 = *((unsigned int *)v73 + 10);
      v98 = (void *)*((unsigned int *)v73 + 11);
      v315[0] = 0LL;
      v325 = v97;
      v99 = (_DWORD)v97 != 0;
      LODWORD(v323) = 0;
      addr = v98;
      v100 = (_DWORD)v98 != 0;
      if ( !*(_QWORD *)v73 || *(_DWORD *)v324 == 47 )
        goto LABEL_173;
      *(_QWORD *)&v326 = *((_QWORD *)v73 + 1);
      if ( *(_QWORD *)(v313[0] + 432) )
      {
        v101 = (__int64 *)v328;
        if ( !*(_QWORD *)v328 )
          goto LABEL_137;
        goto LABEL_171;
      }
      <gimli::read::line::LineProgramHeader<R,Offset> as core::clone::Clone>::clone(
        (__int64)data,
        (__int64 *)v324,
        *(double *)a5.m128_u64,
        (__m128)a6);
      addr2line::Lines::parse(dest[0].m128i_i64, v313[0], data, v329);
      if ( *(_QWORD *)(v313[0] + 432) )
      {
        core::ptr::drop_in_place<core::result::Result<addr2line::Lines,gimli::read::Error>>(dest[0].m128i_i64);
        v101 = (__int64 *)v328;
        if ( *(_QWORD *)v328 )
          goto LABEL_171;
      }
      else
      {
        *(_QWORD *)(v313[0] + 432) = 1LL;
        a5 = (__m128)dest[0];
        a6 = _mm_loadu_si128(&dest[1]);
        v118 = (__m128 *)v328;
        *(__m128i *)(v328 + 16) = a6;
        *v118 = a5;
        v101 = (__int64 *)v328;
        if ( *(_QWORD *)v328 )
          goto LABEL_171;
      }
LABEL_137:
      LODWORD(v6) = v313[0];
      if ( *(_BYTE *)(v313[0] + 448) != 75 )
      {
        v89 = (unsigned __int64)v309;
        if ( !v317[0] )
          goto LABEL_182;
LABEL_181:
        LODWORD(v6) = _rust_dealloc(v321, v330, 8LL);
        goto LABEL_182;
      }
      v101 = *(__int64 **)(v313[0] + 456);
      if ( v101 )
      {
LABEL_171:
        if ( (unsigned __int64)v326 >= v101[1] )
          goto LABEL_173;
        v119 = *v101;
        v120 = *(_QWORD *)(*v101 + 24 * v326 + 8);
        v97 = *(_QWORD *)(v119 + 24 * v326 + 16);
      }
      else
      {
LABEL_173:
        v120 = 0LL;
      }
      *(_QWORD *)&v319 = v319 - 8;
      v121 = v315[0];
      LOBYTE(v121) = v99;
      v315[0] = v121;
      LODWORD(v121) = v323;
      LOBYTE(v121) = v100;
      LODWORD(v323) = v121;
      v103 = (const __m128i *)*((_QWORD *)v73 + 3);
      if ( v103 )
      {
        v73 = (__int8 *)*((_QWORD *)v73 + 4);
        v102 = v316;
        v104 = len;
        len = v120;
        *(_QWORD *)&v316 = v97;
        goto LABEL_178;
      }
      v102 = v316;
      v104 = len;
      len = v120;
      *(_QWORD *)&v316 = v97;
      v105 = v322;
      v106 = *(_QWORD *)(v322 + 24);
      if ( !v106 )
        goto LABEL_177;
      goto LABEL_152;
    }
    addr = (void *)v92;
    v325 = v90;
    v103 = *(const __m128i **)(v327 + 40);
    if ( v103 )
      v73 = *(__int8 **)(v327 + 48);
    LODWORD(v323) = v91;
    if ( v317[0] )
      _rust_dealloc(v321, v330, 8LL);
    v315[0] = 3LL;
    v102 = v316;
    v104 = len;
    if ( !v103 )
    {
      v105 = v322;
      v106 = *(_QWORD *)(v322 + 24);
      if ( !v106 )
      {
LABEL_177:
        v103 = 0LL;
        goto LABEL_178;
      }
LABEL_152:
      v107 = *(_QWORD *)(v105 + 16);
      v108 = v106;
      v109 = 0LL;
      v110 = v106;
      while ( 1 )
      {
        v111 = v109 + (v108 >> 1);
        v112 = *(__int8 **)(v107 + 24 * v111);
        if ( v112 == v309 )
          break;
        if ( v112 > v309 )
          v110 = v111;
        if ( v112 < v309 )
          v109 = v111 + 1;
        v108 = v110 - v109;
        if ( v110 <= v109 )
        {
          if ( !v109 )
            goto LABEL_177;
          v111 = v109 - 1;
          break;
        }
      }
      if ( v111 < v106 )
      {
        v113 = v107 + 24 * v111;
        if ( *(_QWORD *)v113 <= (unsigned __int64)v309
          && *(_QWORD *)(v113 + 8) + *(_QWORD *)v113 >= (unsigned __int64)v309 )
        {
          v114 = *(_QWORD *)(v322 + 96);
          if ( v114 )
          {
            v115 = *(unsigned int *)(v113 + 16);
            v139 = __CFADD__(*(_QWORD *)(v322 + 112), v115);
            v116 = *(_QWORD *)(v322 + 112) + v115;
            if ( !v139 )
            {
              v103 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at_until(
                       v114,
                       *(_QWORD *)(v322 + 104),
                       v116,
                       *(_QWORD *)(v322 + 120),
                       0);
              v73 = v117;
              goto LABEL_178;
            }
          }
        }
      }
      goto LABEL_177;
    }
LABEL_178:
    data[0].m128i_i64[0] = v95;
    data[0].m128i_i64[1] = v96;
    data[1].m128i_i64[0] = v104;
    data[1].m128i_i64[1] = v102;
    data[2].m128i_i64[0] = (__int64)v309;
    data[2].m128i_i64[1] = (__int64)v103;
    data[3].m128i_i64[0] = (__int64)v73;
    (*(void (__fastcall **)(__int64, __m128i *))(v337 + 32))(v336, data);
    v93 = 1;
    v89 = (unsigned __int64)v309;
    v87 = v315[0];
    v90 = v325;
    v92 = (unsigned __int64)addr;
    v91 = v323;
  }
  if ( (unsigned int)v6 >= 2 && v317[0] )
    goto LABEL_181;
LABEL_182:
  if ( (v93 & 1) == 0 )
  {
LABEL_187:
    LODWORD(v6) = v322;
    v122 = *(_QWORD *)(v322 + 24);
    if ( v122 )
    {
      v6 = *(const __m128i **)(v322 + 16);
      v123 = 0LL;
      v124 = *(_QWORD *)(v322 + 24);
      v125 = v124;
      while ( 1 )
      {
        v126 = v123 + (v124 >> 1);
        v127 = v6->m128i_u64[3 * v126];
        if ( v127 == v89 )
          break;
        if ( v127 > v89 )
          v125 = v126;
        if ( v127 < v89 )
          v123 = v126 + 1;
        v124 = v125 - v123;
        if ( v125 <= v123 )
        {
          if ( !v123 )
            return (int)v6;
          v126 = v123 - 1;
          break;
        }
      }
      if ( v126 < v122 )
      {
        v6 = (const __m128i *)((char *)v6 + 24 * v126);
        if ( v6->m128i_i64[0] <= v89 && v6->m128i_i64[1] + v6->m128i_i64[0] >= v89 )
        {
          v128 = *(_QWORD *)(v322 + 96);
          if ( v128 )
          {
            v129 = v6[1].m128i_u32[0];
            LODWORD(v6) = v322;
            v139 = __CFADD__(*(_QWORD *)(v322 + 112), v129);
            v130 = *(_QWORD *)(v322 + 112) + v129;
            if ( !v139 )
            {
              v6 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at_until(
                     v128,
                     *(_QWORD *)(v322 + 104),
                     v130,
                     *(_QWORD *)(v322 + 120),
                     0);
              if ( v6 )
              {
                data[0].m128i_i32[0] = 3;
                data[0].m128i_i64[1] = (__int64)v6;
                data[1].m128i_i64[0] = v131;
                data[1].m128i_i64[1] = v89;
                LODWORD(v6) = (*(__int64 (__fastcall **)(__int64, __m128i *))(v337 + 32))(v336, data);
              }
            }
          }
        }
      }
    }
  }
  return (int)v6;
}
// 2E470: variable 'v6' is possibly undefined
// 2E86F: variable 'v36' is possibly undefined
// 2EC99: variable 'v48' is possibly undefined
// 2ECFC: variable 'v50' is possibly undefined
// 2FA99: variable 'v117' is possibly undefined
// 2FBB5: variable 'v97' is possibly undefined
// 2FE52: variable 'v131' is possibly undefined
// 305E7: variable 'v196' is possibly undefined
// 30631: variable 'v201' is possibly undefined
// 30684: variable 'v206' is possibly undefined
// 306CE: variable 'v211' is possibly undefined
// 30718: variable 'v216' is possibly undefined
// 30763: variable 'v221' is possibly undefined
// 307B1: variable 'v226' is possibly undefined
// 307E7: variable 'v229' is possibly undefined
// 30901: variable 'v231' is possibly undefined
// 3143B: variable 'v274' is possibly undefined
// 31921: variable 'v299' is possibly undefined
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 49706: using guessed type char asc_49706;
// 585F8: using guessed type __int64 (__fastcall *off_585F8)();
// 58710: using guessed type char *off_58710;
// 58868: using guessed type char *off_58868;
// 58880: using guessed type char *off_58880;
// 59420: using guessed type char *off_59420;
// 59438: using guessed type char *off_59438;
// 59450: using guessed type char *off_59450;
// 59480: using guessed type char *off_59480;
// 5B030: using guessed type __int128 std::backtrace_rs::symbolize::gimli::Cache::with_global::MAPPINGS_CACHE;
// 5B040: using guessed type __int64 qword_5B040;
// 5B048: using guessed type __int64 qword_5B048;
// 5B058: using guessed type __int64 qword_5B058;

//----- (0000000000031F20) ----------------------------------------------------
int __fastcall std::backtrace_rs::symbolize::gimli::elf::<impl std::backtrace_rs::symbolize::gimli::Mapping>::new_debug(
        _QWORD *a1,
        _BYTE *a2,
        __int64 a3,
        __int64 a4)
{
  const __m128i *(__fastcall *v4)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char); // r12
  _QWORD *v6; // r14
  const void *v7; // r15
  size_t v8; // r13
  void *v9; // rbx
  size_t v10; // rbp
  __int128 v11; // kr10_16
  unsigned __int64 v12; // rbp
  __int64 v13; // rbp
  __int64 v14; // rbx
  __int64 v15; // rdx
  bool v16; // cf
  unsigned __int64 v17; // rdx
  const __m128i *bytes_at_until; // rax
  __int64 v19; // rdx
  _BYTE *bytes_at; // rax
  const __m128i *(__fastcall *v21)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char); // rdx
  _BYTE *v22; // rbx
  __int64 v23; // rbp
  int result; // eax
  __int64 v25; // rsi
  const void *v26; // rdi
  bool v27; // cl
  void *v28; // rax
  const void *v29; // r15
  size_t v30; // rdx
  const void *v31; // rbx
  __int64 v32; // rcx
  __int64 v33; // rsi
  _BYTE *v34; // rax
  __int64 v35; // rdx
  __int64 v36; // r15
  void *v37; // rax
  __int64 v38; // r13
  __int64 v39; // rcx
  bool v40; // al
  __int64 v41; // r13
  __int64 v42; // r13
  char *v43; // r15
  __m128i v44; // xmm1
  __m128i *v45; // r13
  __m128i v46; // xmm1
  __int128 v47; // xmm2
  __int64 v48; // r13
  unsigned __int64 v49; // r15
  __int128 v50; // kr20_16
  __int64 v51; // rdx
  const __m128i *(__fastcall *v52)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char); // r13
  unsigned __int64 v53; // r15
  const char *v54; // rax
  __int64 v55; // rdx
  __m128i v56; // xmm0
  __m128i v57; // xmm1
  __int64 v58; // [rsp+0h] [rbp-6A8h]
  __int64 v59; // [rsp+0h] [rbp-6A8h]
  const __m128i *(__fastcall *v60)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char); // [rsp+8h] [rbp-6A0h]
  const __m128i *(__fastcall *v61)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char); // [rsp+10h] [rbp-698h]
  __int64 v62; // [rsp+18h] [rbp-690h]
  void *v63; // [rsp+20h] [rbp-688h]
  size_t v64; // [rsp+28h] [rbp-680h]
  __int64 v65; // [rsp+30h] [rbp-678h]
  _BYTE *s2; // [rsp+38h] [rbp-670h]
  size_t n; // [rsp+40h] [rbp-668h]
  __int64 v68; // [rsp+48h] [rbp-660h]
  __int64 v69; // [rsp+58h] [rbp-650h]
  __int64 v70; // [rsp+60h] [rbp-648h]
  unsigned __int64 v71; // [rsp+68h] [rbp-640h]
  __int128 v72; // [rsp+70h] [rbp-638h]
  __m128i v73; // [rsp+80h] [rbp-628h] BYREF
  __m128i v74; // [rsp+90h] [rbp-618h] BYREF
  __int128 v75; // [rsp+A0h] [rbp-608h]
  __m128i v76; // [rsp+B0h] [rbp-5F8h] BYREF
  __m128i v77; // [rsp+C0h] [rbp-5E8h] BYREF
  __int128 v78; // [rsp+D0h] [rbp-5D8h]
  __int128 v79; // [rsp+E0h] [rbp-5C8h]
  __int128 v80; // [rsp+F0h] [rbp-5B8h]
  __m128i v81; // [rsp+100h] [rbp-5A8h] BYREF
  __int64 v82; // [rsp+110h] [rbp-598h]
  __m128i v83; // [rsp+120h] [rbp-588h] BYREF
  size_t v84; // [rsp+130h] [rbp-578h]
  void *src; // [rsp+140h] [rbp-568h]
  unsigned __int64 v86; // [rsp+148h] [rbp-560h]
  void *v87; // [rsp+150h] [rbp-558h]
  _BYTE *v88; // [rsp+158h] [rbp-550h]
  __int64 v89; // [rsp+160h] [rbp-548h]
  __int64 v90; // [rsp+168h] [rbp-540h] BYREF
  __int64 v91; // [rsp+170h] [rbp-538h] BYREF
  unsigned __int64 v92; // [rsp+178h] [rbp-530h]
  __int64 v93; // [rsp+180h] [rbp-528h]
  __int128 v94; // [rsp+188h] [rbp-520h]
  __int64 v95; // [rsp+198h] [rbp-510h]
  __int64 v96; // [rsp+1A0h] [rbp-508h]
  __int128 v97; // [rsp+1A8h] [rbp-500h]
  unsigned __int64 v98; // [rsp+1B8h] [rbp-4F0h]
  __int128 v99; // [rsp+1C0h] [rbp-4E8h]
  __m128i v100; // [rsp+1D0h] [rbp-4D8h]
  __int128 v101; // [rsp+1E0h] [rbp-4C8h]
  __m128i v102; // [rsp+1F0h] [rbp-4B8h]
  _OWORD dest[32]; // [rsp+200h] [rbp-4A8h] BYREF
  _QWORD v104[15]; // [rsp+400h] [rbp-2A8h] BYREF
  __int64 v105[70]; // [rsp+478h] [rbp-230h] BYREF

  v4 = (const __m128i *(__fastcall *)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char))a4;
  v6 = a1;
  v7 = *(const void **)(a4 + 8);
  v8 = *(_QWORD *)(a4 + 16);
  std::backtrace_rs::symbolize::gimli::mmap(v105, v7, v8);
  if ( !v105[0] )
  {
    result = 0;
    *a1 = 0x8000000000000000LL;
    v25 = *(_QWORD *)v4;
    if ( *(_QWORD *)v4 )
    {
      v26 = v7;
      return _rust_dealloc(v26, v25, 1LL);
    }
    return result;
  }
  v88 = a2;
  v89 = a3;
  v9 = (void *)v105[1];
  v10 = v105[2];
  v73.m128i_i64[0] = 0LL;
  v73.m128i_i64[1] = 8LL;
  v74 = 0LL;
  v75 = 8uLL;
  std::backtrace_rs::symbolize::gimli::elf::Object::parse((__int64 *)dest, v105[1], v105[2]);
  if ( *(_QWORD *)&dest[0] == 0x8000000000000000LL )
    goto LABEL_67;
  v87 = a1;
  v62 = *(_QWORD *)&dest[0];
  v63 = v9;
  v64 = v10;
  v61 = v4;
  v68 = *((_QWORD *)&dest[0] + 1);
  v69 = *((_QWORD *)&dest[1] + 1);
  v86 = *(_QWORD *)&dest[1];
  v11 = dest[2];
  v65 = *((_QWORD *)&dest[3] + 1);
  v72 = dest[4];
  v71 = *(_QWORD *)&dest[5];
  v101 = *(_OWORD *)((char *)&dest[5] + 8);
  v102 = _mm_loadu_si128((const __m128i *)((char *)&dest[6] + 8));
  v12 = 0x8000000000000000LL;
  v70 = *(_QWORD *)&dest[3];
  if ( *(_QWORD *)&dest[3] )
  {
    v12 = 0x8000000000000000LL;
    if ( *((_QWORD *)&dest[3] + 1) )
    {
      v13 = *(_QWORD *)&dest[3] << 6;
      v14 = 0LL;
      v4 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at_until;
      while ( 1 )
      {
        v15 = *(unsigned int *)(*((_QWORD *)&v11 + 1) + v14);
        v16 = __CFADD__(*((_QWORD *)&v72 + 1), v15);
        v17 = *((_QWORD *)&v72 + 1) + v15;
        if ( !v16 )
        {
          bytes_at_until = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at_until(v65, v72, v17, v71, 0);
          if ( bytes_at_until )
          {
            if ( v19 == 17
              && _mm_movemask_epi8(
                   _mm_and_si128(
                     _mm_cmpeq_epi8(_mm_cvtsi32_si128(bytes_at_until[1].m128i_u8[0]), (__m128i)xmmword_483A0),
                     _mm_cmpeq_epi8(_mm_loadu_si128(bytes_at_until), (__m128i)xmmword_48390))) == 0xFFFF )
            {
              break;
            }
          }
        }
        v14 += 64LL;
        if ( v13 == v14 )
          goto LABEL_65;
      }
      v12 = 0x8000000000000000LL;
      if ( *(_DWORD *)(*((_QWORD *)&v11 + 1) + v14 + 4) == 8 )
        goto LABEL_66;
      bytes_at = (_BYTE *)<&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
                            v69,
                            v11,
                            *(_QWORD *)(*((_QWORD *)&v11 + 1) + v14 + 24),
                            *(_QWORD *)(*((_QWORD *)&v11 + 1) + v14 + 32));
      if ( !bytes_at || (v4 = v21) == 0LL )
      {
LABEL_65:
        v12 = 0x8000000000000000LL;
        goto LABEL_66;
      }
      v22 = bytes_at;
      v23 = 0LL;
      while ( bytes_at[v23] )
      {
        if ( v21 == (const __m128i *(__fastcall *)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char))++v23 )
          goto LABEL_65;
      }
      n = (size_t)v21 + ~v23;
      s2 = &bytes_at[v23 + 1];
      if ( v23 && *bytes_at == 47 )
      {
        std::sys::pal::unix::fs::stat(dest, bytes_at, v23);
        if ( LODWORD(dest[0]) == 2 )
        {
          v91 = *((_QWORD *)&dest[0] + 1);
          LOBYTE(v90) = 1;
          core::ptr::drop_in_place<std::io::error::Error>(&v91);
        }
        else if ( (WORD4(dest[3]) & 0xF000) == 0x8000 )
        {
          if ( v23 < 0 )
            alloc::raw_vec::capacity_overflow();
          v28 = (void *)_rust_alloc(v23, 1LL);
          if ( !v28 )
            alloc::alloc::handle_alloc_error(1LL, v23);
          v29 = v28;
          memcpy(v28, v22, v23);
          v30 = v23;
          v31 = v29;
          v32 = v23;
LABEL_73:
          v59 = v32;
          std::backtrace_rs::symbolize::gimli::mmap(&v90, v31, v30);
          if ( v90 )
          {
            v48 = v91;
            v49 = v92;
            alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v74.m128i_i64[1], 0LL);
            v50 = v75;
            v51 = 16LL * *((_QWORD *)&v75 + 1);
            *(_QWORD *)(v75 + v51) = v48;
            *(_QWORD *)(v50 + v51 + 8) = v49;
            *((_QWORD *)&v75 + 1) = *((_QWORD *)&v50 + 1) + 1LL;
            if ( *((_QWORD *)&v50 + 1) == -1LL )
              core::option::unwrap_failed((__int64)&off_59420);
            std::backtrace_rs::symbolize::gimli::elf::Object::parse((__int64 *)dest, v48, v49);
            v52 = (const __m128i *(__fastcall *)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char))v23;
            v53 = *(_QWORD *)&dest[0];
            v12 = 0x8000000000000000LL;
            if ( *(_QWORD *)&dest[0] != 0x8000000000000000LL )
            {
              v60 = (const __m128i *(__fastcall *)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char))*((_QWORD *)&dest[0] + 1);
              v54 = std::backtrace_rs::symbolize::gimli::elf::Object::build_id(dest);
              if ( v54
                && (const __m128i *(__fastcall *)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char))((char *)v4 + ~v55) == v52
                && !bcmp(v54, s2, n) )
              {
                v82 = *(_QWORD *)&dest[7];
                v81 = (__m128i)dest[6];
                v80 = dest[5];
                v56 = _mm_loadu_si128((const __m128i *)&dest[1]);
                v57 = _mm_loadu_si128((const __m128i *)&dest[2]);
                v79 = dest[4];
                v78 = dest[3];
                v77 = v57;
                v76 = v56;
                v12 = v53;
              }
              else
              {
                if ( v53 )
                  _rust_dealloc(v60, 24 * v53, 8LL);
                v12 = 0x8000000000000000LL;
              }
            }
            v4 = v60;
          }
          else
          {
            v12 = 0x8000000000000000LL;
          }
          if ( v59 )
            _rust_dealloc(v31, v59, 1LL);
          goto LABEL_66;
        }
        goto LABEL_63;
      }
      std::sys::pal::unix::fs::canonicalize((size_t *)dest, v7, v8);
      v58 = *(_QWORD *)&dest[0];
      if ( *(_QWORD *)&dest[0] == 0x8000000000000000LL )
      {
        core::ptr::drop_in_place<std::io::error::Error>((__int64 *)dest + 1);
        goto LABEL_65;
      }
      if ( *(_QWORD *)&dest[1] )
        v27 = **((_BYTE **)&dest[0] + 1) == 47;
      else
        v27 = 0;
      v60 = (const __m128i *(__fastcall *)(__int64, unsigned __int64, unsigned __int64, unsigned __int64, char))*((_QWORD *)&dest[0] + 1);
      dest[0] = *(_OWORD *)((char *)dest + 8);
      LOBYTE(dest[1]) = 6;
      BYTE10(dest[3]) = v27;
      WORD4(dest[3]) = 512;
      <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(
        (__int64)&v90,
        (__int64)dest);
      if ( (_BYTE)v90 == 10
        || (unsigned __int8)(v90 - 6) > 3u
        || (unsigned __int64)(unsigned __int8)(v90 - 6) - 1 > 2
        || (v34 = std::path::Components::as_path((__int64)dest)) == 0LL )
      {
        v83.m128i_i64[0] = 0x8000000000000000LL;
        v33 = v58;
        if ( !v58 )
        {
LABEL_64:
          v32 = v83.m128i_i64[0];
          if ( v83.m128i_i64[0] == 0x8000000000000000LL )
            goto LABEL_65;
          v31 = (const void *)v83.m128i_i64[1];
          v30 = v84;
          goto LABEL_73;
        }
LABEL_35:
        _rust_dealloc(v60, v33, 1LL);
        goto LABEL_64;
      }
      v36 = v35;
      if ( v35 )
      {
        src = v34;
        if ( v35 < 0 )
          alloc::raw_vec::capacity_overflow();
        v37 = (void *)_rust_alloc(v35, 1LL);
        if ( !v37 )
          alloc::alloc::handle_alloc_error(1LL, v36);
        v38 = (__int64)v37;
        memcpy(v37, src, v36);
        v76.m128i_i64[0] = v36;
        v76.m128i_i64[1] = v38;
        v77.m128i_i64[0] = v36;
        v39 = v38;
        v40 = *(_BYTE *)(v36 + v38 - 1) == 47;
      }
      else
      {
        v76.m128i_i64[0] = 0LL;
        v76.m128i_i64[1] = 1LL;
        v77.m128i_i64[0] = 0LL;
        v40 = 1;
        v39 = 1LL;
      }
      if ( v23 && *v22 == 47 )
      {
        v41 = 0LL;
      }
      else
      {
        if ( v40 )
        {
          v41 = v36;
LABEL_51:
          if ( v36 - v41 >= (unsigned __int64)v23 )
          {
            v43 = (char *)v39;
          }
          else
          {
            alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(v76.m128i_i64, v41, v23);
            v43 = (char *)v76.m128i_i64[1];
            v41 = v77.m128i_i64[0];
          }
          memcpy(&v43[v41], v22, v23);
          v77.m128i_i64[0] = v23 + v41;
          std::sys::pal::unix::fs::stat(dest, v43, v23 + v41);
          if ( LODWORD(dest[0]) == 2 )
          {
            v91 = *((_QWORD *)&dest[0] + 1);
            LOBYTE(v90) = 1;
            core::ptr::drop_in_place<std::io::error::Error>(&v91);
LABEL_59:
            if ( v76.m128i_i64[0] )
              _rust_dealloc(v43, v76.m128i_i64[0], 1LL);
            if ( v58 )
              _rust_dealloc(v60, v58, 1LL);
LABEL_63:
            std::backtrace_rs::symbolize::gimli::elf::locate_build_id(&v83, s2, n);
            goto LABEL_64;
          }
          if ( (WORD4(dest[3]) & 0xF000) != 0x8000 )
            goto LABEL_59;
          v84 = v77.m128i_i64[0];
          v83 = _mm_loadu_si128(&v76);
          v33 = v58;
          if ( !v58 )
            goto LABEL_64;
          goto LABEL_35;
        }
        alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(v76.m128i_i64, v36, 1LL);
        v42 = v77.m128i_i64[0];
        v39 = v76.m128i_i64[1];
        *(_BYTE *)(v76.m128i_i64[1] + v77.m128i_i64[0]) = 47;
        v41 = v42 + 1;
        v36 = v76.m128i_i64[0];
      }
      v77.m128i_i64[0] = v41;
      goto LABEL_51;
    }
  }
LABEL_66:
  std::backtrace_rs::symbolize::gimli::elf::<impl std::backtrace_rs::symbolize::gimli::Mapping>::load_dwarf_package(
    (__int64)v104,
    v88,
    v89,
    v73.m128i_i64);
  v90 = v62;
  v91 = v68;
  v92 = v86;
  v93 = v69;
  v94 = v11;
  v95 = v70;
  v96 = v65;
  v97 = v72;
  v98 = v71;
  v99 = v101;
  v100 = v102;
  *(_QWORD *)&dest[0] = v12;
  *((_QWORD *)&dest[0] + 1) = v4;
  v44 = _mm_load_si128(&v77);
  dest[1] = v76;
  dest[2] = v44;
  dest[3] = v78;
  dest[4] = v79;
  dest[5] = v80;
  dest[6] = _mm_load_si128(&v81);
  *(_QWORD *)&dest[7] = v82;
  v4 = v61;
  v10 = v64;
  v9 = v63;
  std::backtrace_rs::symbolize::gimli::Context::new(v105, v73.m128i_i64, &v90, (__int64 *)dest, v104);
  v6 = v87;
  if ( v105[0] != 0x8000000000000000LL )
  {
    v45 = (__m128i *)v87;
    memcpy(dest, v105, sizeof(dest));
    result = (unsigned int)memcpy(v87, dest, 0x200uLL);
    v45[32].m128i_i64[0] = (__int64)v63;
    v45[32].m128i_i64[1] = v64;
    v46 = _mm_loadu_si128(&v74);
    v47 = v75;
    v45[33] = _mm_loadu_si128(&v73);
    v45[34] = v46;
    v45[35] = (__m128i)v47;
    v25 = *(_QWORD *)v61;
    if ( *(_QWORD *)v61 )
      goto LABEL_68;
    return result;
  }
LABEL_67:
  *v6 = 0x8000000000000000LL;
  core::ptr::drop_in_place<std::backtrace_rs::symbolize::gimli::stash::Stash>(v73.m128i_i64);
  result = munmap(v9, v10);
  v25 = *(_QWORD *)v4;
  if ( *(_QWORD *)v4 )
  {
LABEL_68:
    v26 = (const void *)*((_QWORD *)v4 + 1);
    return _rust_dealloc(v26, v25, 1LL);
  }
  return result;
}
// 32126: variable 'v19' is possibly undefined
// 3218C: variable 'v21' is possibly undefined
// 323B4: variable 'v35' is possibly undefined
// 3294E: variable 'v55' is possibly undefined
// 32997: variable 'v60' is possibly undefined
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 48390: using guessed type __int128 xmmword_48390;
// 483A0: using guessed type __int128 xmmword_483A0;
// 59420: using guessed type char *off_59420;
// 31F20: using guessed type _QWORD var_2A8[15];

//----- (0000000000032BC0) ----------------------------------------------------
int __fastcall std::backtrace_rs::symbolize::gimli::elf::<impl std::backtrace_rs::symbolize::gimli::Mapping>::load_dwarf_package(
        __int64 a1,
        _BYTE *a2,
        __int64 a3,
        __int64 *a4)
{
  void *v6; // rax
  const void *v7; // r13
  bool v8; // al
  _WORD *v9; // r13
  __int64 v10; // rcx
  __int64 v11; // rbp
  char *v13; // r12
  __int64 v14; // r15
  __int64 v15; // rax
  void *v16; // r12
  __int64 v17; // rdx
  size_t v18; // rdx
  __int64 v19; // r15
  __int64 v20; // rax
  const void *v21; // r15
  int result; // eax
  __int64 v23; // r13
  __int64 v24; // r12
  __int64 v25; // rsi
  __int64 v26; // rcx
  __int64 v27; // rax
  __int64 v28; // rsi
  __int64 v29; // rsi
  __int128 v30; // xmm0
  __int128 v31; // xmm1
  __int128 v32; // xmm2
  __int64 v33; // [rsp+0h] [rbp-138h] BYREF
  const void *v34; // [rsp+8h] [rbp-130h]
  __int64 v35; // [rsp+10h] [rbp-128h]
  _BYTE *v36; // [rsp+18h] [rbp-120h] BYREF
  char *v37; // [rsp+20h] [rbp-118h]
  __int64 v38; // [rsp+28h] [rbp-110h]
  __int16 v39; // [rsp+50h] [rbp-E8h]
  bool v40; // [rsp+52h] [rbp-E6h]
  __int128 v41[7]; // [rsp+58h] [rbp-E0h] BYREF
  __int64 v42; // [rsp+C8h] [rbp-70h]
  char v43[8]; // [rsp+D0h] [rbp-68h] BYREF
  _WORD *v44; // [rsp+D8h] [rbp-60h]
  __int64 v45; // [rsp+E0h] [rbp-58h]

  if ( a3 )
  {
    if ( a3 < 0 )
      alloc::raw_vec::capacity_overflow();
    v6 = (void *)_rust_alloc(a3, 1LL);
    if ( !v6 )
      alloc::alloc::handle_alloc_error(1LL, a3);
    v7 = v6;
    memcpy(v6, a2, a3);
    v33 = a3;
    v34 = v7;
    v35 = a3;
    v8 = *a2 == 47;
  }
  else
  {
    v33 = 0LL;
    v34 = &dword_0 + 1;
    v35 = 0LL;
    v8 = 0;
  }
  v36 = a2;
  v37 = (char *)a3;
  LOBYTE(v38) = 6;
  v40 = v8;
  v39 = 512;
  <std::path::Components as core::iter::traits::double_ended::DoubleEndedIterator>::next_back(
    (__int64)v43,
    (__int64)&v36);
  if ( v43[0] == 9 )
  {
    v9 = v44;
    if ( v45 != 2 || *v44 != 11822 )
    {
      v10 = v45;
      do
      {
        if ( (_WORD *)((char *)v44 + v10) == v44 )
          goto LABEL_18;
        v11 = v10 - 1;
      }
      while ( *((_BYTE *)v44 + --v10) != 46 );
      if ( v11 )
      {
        v13 = (char *)&dword_0 + 1;
        v14 = v45 - 1 - v11;
        if ( !v14 )
        {
LABEL_17:
          memcpy(v13, (char *)v9 + v11 + 1, v14);
          v36 = (_BYTE *)v14;
          v37 = v13;
          v38 = v14;
          alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v36, v14, 4LL);
          v16 = v37;
          v17 = v38;
          *(_DWORD *)&v37[v38] = 1886872622;
          v18 = v17 + 4;
          v19 = (__int64)v36;
          goto LABEL_20;
        }
        if ( v14 < 0 )
          alloc::raw_vec::capacity_overflow();
        v15 = _rust_alloc(v14, 1LL);
        if ( v15 )
        {
          v13 = (char *)v15;
          goto LABEL_17;
        }
LABEL_32:
        alloc::alloc::handle_alloc_error(1LL, v14);
      }
    }
  }
LABEL_18:
  v14 = 3LL;
  v20 = _rust_alloc(3LL, 1LL);
  if ( !v20 )
    goto LABEL_32;
  v16 = (void *)v20;
  *(_BYTE *)(v20 + 2) = 112;
  *(_WORD *)v20 = 30564;
  v18 = 3LL;
  v19 = 3LL;
LABEL_20:
  std::path::PathBuf::_set_extension(&v33, v16, v18);
  if ( v19 )
    _rust_dealloc(v16, v19, 1LL);
  v21 = v34;
  result = std::backtrace_rs::symbolize::gimli::mmap((__int64 *)&v36, v34, v35);
  if ( !v36 )
    goto LABEL_27;
  v23 = (__int64)v37;
  v24 = v38;
  v25 = a4[5];
  if ( v25 == a4[3] )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(a4 + 3, v25);
    v25 = a4[5];
  }
  v26 = a4[4];
  v27 = 16 * v25;
  *(_QWORD *)(v26 + v27) = v23;
  *(_QWORD *)(v26 + v27 + 8) = v24;
  v28 = v25 + 1;
  a4[5] = v28;
  if ( !v28 )
    core::option::unwrap_failed((__int64)&off_59420);
  result = std::backtrace_rs::symbolize::gimli::elf::Object::parse(
             (__int64 *)v41,
             *(_QWORD *)(a4[4] + v27),
             *(_QWORD *)(a4[4] + v27 + 8));
  if ( *(_QWORD *)&v41[0] == 0x8000000000000000LL )
  {
LABEL_27:
    *(_QWORD *)a1 = 0x8000000000000000LL;
    v29 = v33;
    if ( !v33 )
      return result;
    return _rust_dealloc(v21, v29, 1LL);
  }
  result = v42;
  *(_QWORD *)(a1 + 112) = v42;
  *(_OWORD *)(a1 + 96) = v41[6];
  *(_OWORD *)(a1 + 80) = v41[5];
  *(_OWORD *)(a1 + 64) = v41[4];
  v30 = v41[0];
  v31 = v41[1];
  v32 = v41[2];
  *(_OWORD *)(a1 + 48) = v41[3];
  *(_OWORD *)(a1 + 32) = v32;
  *(_OWORD *)(a1 + 16) = v31;
  *(_OWORD *)a1 = v30;
  v29 = v33;
  if ( v33 )
    return _rust_dealloc(v21, v29, 1LL);
  return result;
}
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 59420: using guessed type char *off_59420;
// 32BC0: using guessed type char var_68[8];

//----- (0000000000032FA0) ----------------------------------------------------
unsigned __int64 __fastcall std::backtrace_rs::symbolize::gimli::elf::Object::parse(
        __int64 *a1,
        __int64 a2,
        unsigned __int64 a3)
{
  __int64 bytes_at; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 result; // rax
  unsigned __int64 v10; // r8
  const char *v11; // r13
  unsigned __int64 v12; // r12
  unsigned __int64 v13; // r12
  __int64 v14; // rax
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // r8
  unsigned int v18; // eax
  __int64 v19; // rax
  unsigned __int64 v20; // rdx
  const char *v21; // rcx
  const char *v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rdi
  __int64 v25; // rsi
  __int64 v26; // rdi
  bool v27; // cf
  __int64 v28; // r12
  __int64 v29; // rbp
  __int64 v30; // r12
  __int64 v31; // rbp
  unsigned __int64 v32; // r12
  __int64 v33; // rax
  unsigned __int64 v34; // rdx
  unsigned __int64 v35; // rdi
  __int64 v36; // rax
  const char *v37; // rbp
  const char *v38; // rcx
  int v39; // r12d
  __int64 v40; // rax
  __int64 v41; // r12
  const char *v42; // rcx
  __int64 v43; // rcx
  __int64 v44; // r13
  __int64 v45; // rbp
  unsigned __int64 v46; // rax
  int v47; // eax
  __int64 v48; // rax
  unsigned __int64 v49; // rdx
  const char *v50; // r9
  unsigned __int64 v51; // r10
  unsigned __int64 v52; // rax
  unsigned __int64 v53; // rax
  const char *v54; // rax
  __int64 v55; // rsi
  __int64 v56; // r12
  __int64 v57; // rax
  __int64 v58; // rax
  unsigned __int64 v59; // rdx
  unsigned __int64 v60; // rax
  unsigned __int64 v61; // rax
  __int64 v62; // rsi
  const char *v63; // rcx
  __int64 v64; // r12
  __int64 v65; // rax
  const char *v66; // [rsp+0h] [rbp-A8h]
  __int64 v67; // [rsp+8h] [rbp-A0h]
  unsigned __int64 v68; // [rsp+8h] [rbp-A0h]
  unsigned __int64 v69; // [rsp+8h] [rbp-A0h]
  unsigned __int64 v70; // [rsp+10h] [rbp-98h]
  unsigned __int64 v71; // [rsp+18h] [rbp-90h]
  __int64 v72; // [rsp+20h] [rbp-88h]
  unsigned __int64 v73; // [rsp+28h] [rbp-80h]
  __int64 v74; // [rsp+28h] [rbp-80h]
  __int128 v75; // [rsp+30h] [rbp-78h]
  __int128 v76; // [rsp+30h] [rbp-78h]
  unsigned __int64 v77; // [rsp+30h] [rbp-78h]
  unsigned __int64 v78; // [rsp+30h] [rbp-78h]
  int v79; // [rsp+40h] [rbp-68h]
  const char *v80; // [rsp+40h] [rbp-68h]
  __int64 v81; // [rsp+48h] [rbp-60h]
  __int64 v82; // [rsp+50h] [rbp-58h]
  __int64 v83; // [rsp+58h] [rbp-50h] BYREF
  __int64 v84; // [rsp+60h] [rbp-48h]
  __int64 v85; // [rsp+68h] [rbp-40h]
  unsigned __int64 v86; // [rsp+70h] [rbp-38h]

  bytes_at = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(a2, a3, 0LL, 0x40uLL);
  if ( !bytes_at )
    goto LABEL_8;
  if ( v7 < 0x40 )
    goto LABEL_8;
  if ( *(_DWORD *)bytes_at != 1179403647 )
    goto LABEL_8;
  if ( *(_BYTE *)(bytes_at + 4) != 2 )
    goto LABEL_8;
  if ( (unsigned __int8)(*(_BYTE *)(bytes_at + 5) - 1) > 1u )
    goto LABEL_8;
  if ( *(_BYTE *)(bytes_at + 6) != 1 )
    goto LABEL_8;
  v8 = bytes_at;
  if ( *(_BYTE *)(bytes_at + 5) == 2 )
    goto LABEL_8;
  v10 = *(_QWORD *)(bytes_at + 40);
  v11 = aRustc9b00956e5;
  if ( v10 )
  {
    v12 = *(unsigned __int16 *)(bytes_at + 60);
    if ( *(_WORD *)(bytes_at + 60) )
    {
      if ( *(_WORD *)(bytes_at + 58) != 64 )
        goto LABEL_8;
      goto LABEL_12;
    }
    if ( *(_WORD *)(bytes_at + 58) != 64 )
      goto LABEL_8;
    v32 = *(_QWORD *)(bytes_at + 40);
    v33 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(a2, a3, v32, 0x40uLL);
    if ( !v33 || v34 < 0x40 )
      goto LABEL_8;
    v10 = v32;
    v12 = *(_QWORD *)(v33 + 32);
    if ( v12 )
    {
      if ( v12 >> 58 )
        goto LABEL_8;
LABEL_12:
      v73 = v10;
      v70 = v12;
      v13 = v12 << 6;
      v14 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(a2, a3, v10, v13);
      v16 = v70;
      v66 = (const char *)v14;
      if ( !v14 )
        goto LABEL_8;
      v17 = v13;
      if ( v13 > v15 )
        goto LABEL_8;
      v18 = *(unsigned __int16 *)(v8 + 62);
      if ( v18 == 0xFFFF )
      {
        v19 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(a2, a3, v73, 0x40uLL);
        v16 = v70;
        if ( !v19 || v20 < 0x40 )
          goto LABEL_8;
        v17 = v13;
        v18 = *(_DWORD *)(v19 + 40);
      }
      if ( v18 && v16 > v18 )
      {
        v21 = v66;
        v22 = &v66[64 * (unsigned __int64)v18];
        v23 = 0LL;
        v24 = 0LL;
        v25 = 0LL;
        if ( *((_DWORD *)v22 + 1) == 8 )
          goto LABEL_23;
        v25 = *((_QWORD *)v22 + 3);
        v26 = *((_QWORD *)v22 + 4);
        v27 = __CFADD__(v25, v26);
        v24 = v25 + v26;
        if ( !v27 )
        {
          v23 = a2;
          v21 = v66;
LABEL_23:
          v81 = v24;
          v82 = v25;
          v74 = v23;
          v28 = 0LL;
          v29 = 0LL;
          while ( *(_DWORD *)&v21[v28 + 4] != 2 )
          {
            ++v29;
            v28 += 64LL;
            if ( v17 == v28 )
            {
LABEL_26:
              v30 = 0LL;
              v31 = 0LL;
              while ( *(_DWORD *)&v21[v30 + 4] != 11 )
              {
                ++v31;
                v30 += 64LL;
                if ( v17 == v30 )
                  goto LABEL_37;
              }
              v69 = v17;
              v58 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
                      a2,
                      a3,
                      *(_QWORD *)&v21[v30 + 24],
                      *(_QWORD *)&v66[v30 + 32]);
              if ( v58 )
              {
                v11 = (const char *)v58;
                v78 = v59 / 0x18;
                if ( 24 * (v59 / 0x18) <= v59 )
                {
                  v60 = *(unsigned int *)&v66[v30 + 40];
                  if ( v70 > v60 )
                  {
                    v61 = v60 << 6;
                    if ( *(_DWORD *)&v66[v61 + 4] == 3 )
                    {
                      v62 = *(_QWORD *)&v66[v61 + 32];
                      v63 = v66;
                      v72 = *(_QWORD *)&v66[v61 + 24];
                      v71 = v72 + v62;
                      if ( !__CFADD__(v72, v62) )
                      {
                        v64 = 0LL;
                        while ( 1 )
                        {
                          if ( *(_DWORD *)&v63[v64 + 4] == 18 && *(_DWORD *)&v63[v64 + 40] == v31 )
                          {
                            v65 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
                                    a2,
                                    a3,
                                    *(_QWORD *)&v63[v64 + 24],
                                    *(_QWORD *)&v66[v64 + 32]);
                            v63 = v66;
                            if ( !v65 )
                              break;
                          }
                          v64 += 64LL;
                          if ( v69 == v64 )
                          {
                            v67 = a2;
                            v35 = v78;
                            goto LABEL_38;
                          }
                        }
                      }
                    }
                  }
                }
              }
              goto LABEL_8;
            }
          }
          v68 = v17;
          v48 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
                  a2,
                  a3,
                  *(_QWORD *)&v21[v28 + 24],
                  *(_QWORD *)&v66[v28 + 32]);
          v17 = v68;
          if ( v48 )
          {
            v50 = (const char *)v48;
            v51 = v49;
            v21 = v66;
            v35 = v49 / 0x18;
            if ( 24 * (v49 / 0x18) <= v49 )
            {
              v52 = *(unsigned int *)&v66[v28 + 40];
              if ( v70 > v52 )
              {
                v53 = v52 << 6;
                if ( *(_DWORD *)&v66[v53 + 4] == 3 )
                {
                  v54 = &v66[v53];
                  v55 = *((_QWORD *)v54 + 4);
                  v72 = *((_QWORD *)v54 + 3);
                  v71 = v72 + v55;
                  if ( !__CFADD__(v72, v55) )
                  {
                    v56 = 0LL;
                    v77 = v49 / 0x18;
                    v80 = v50;
                    v86 = v49;
                    while ( 1 )
                    {
                      if ( *(_DWORD *)&v21[v56 + 4] == 18 && *(_DWORD *)&v21[v56 + 40] == v29 )
                      {
                        v57 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
                                a2,
                                a3,
                                *(_QWORD *)&v21[v56 + 24],
                                *(_QWORD *)&v66[v56 + 32]);
                        v51 = v86;
                        v50 = v80;
                        v35 = v77;
                        v17 = v68;
                        v21 = v66;
                        if ( !v57 )
                          break;
                      }
                      v56 += 64LL;
                      if ( v17 == v56 )
                      {
                        if ( v51 <= 0x17 )
                          goto LABEL_26;
                        v67 = a2;
                        v11 = v50;
                        goto LABEL_38;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
LABEL_8:
      result = 0x8000000000000000LL;
      *a1 = 0x8000000000000000LL;
      return result;
    }
  }
  v74 = 0LL;
  v82 = 0LL;
  v81 = 0LL;
  v70 = 0LL;
  v66 = aRustc9b00956e5;
LABEL_37:
  v67 = 0LL;
  v72 = 0LL;
  v71 = 0LL;
  v35 = 0LL;
LABEL_38:
  v36 = 24 * v35;
  v37 = &v11[24 * v35];
  do
  {
    if ( !v36 )
    {
      v44 = 8LL;
      v41 = 0LL;
      v45 = 0LL;
      goto LABEL_52;
    }
    v38 = v11;
    v11 += 24;
    v36 -= 24LL;
  }
  while ( (unsigned __int8)((v38[4] & 0xF) - 3) < 0xFEu || !*((_WORD *)v38 + 3) );
  v75 = *((_OWORD *)v11 - 1);
  v39 = *((_DWORD *)v11 - 6);
  v40 = _rust_alloc(96LL, 8LL);
  if ( !v40 )
    alloc::alloc::handle_alloc_error(8LL, 96LL);
  *(_OWORD *)v40 = v75;
  *(_DWORD *)(v40 + 16) = v39;
  v83 = 4LL;
  v84 = v40;
  v85 = 1LL;
  v41 = 1LL;
  while ( v11 != v37 )
  {
    v42 = v11;
    v11 += 24;
    if ( (unsigned __int8)((v42[4] & 0xF) - 3) >= 0xFEu && *((_WORD *)v42 + 3) )
    {
      v76 = *((_OWORD *)v11 - 1);
      v79 = *((_DWORD *)v11 - 6);
      if ( v41 == v83 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(&v83, v41, 1LL);
        v40 = v84;
      }
      v43 = 3 * v41;
      *(_OWORD *)(v40 + 8 * v43) = v76;
      *(_DWORD *)(v40 + 8 * v43 + 16) = v79;
      v85 = ++v41;
    }
  }
  v45 = v83;
  v44 = v84;
LABEL_52:
  if ( v41 )
  {
    _BitScanReverse64(&v46, v41);
    v47 = v46 ^ 0x3F;
  }
  else
  {
    v47 = 64;
  }
  core::slice::sort::recurse(v44, v41, 0LL, 64 - v47);
  *a1 = v45;
  a1[1] = v44;
  a1[2] = v41;
  a1[3] = a2;
  a1[4] = a3;
  a1[5] = (__int64)v66;
  a1[6] = v70;
  a1[7] = v74;
  a1[8] = a3;
  a1[9] = v82;
  a1[10] = v81;
  a1[11] = v67;
  a1[12] = a3;
  a1[13] = v72;
  result = v71;
  a1[14] = v71;
  return result;
}
// 32FD3: variable 'v7' is possibly undefined
// 33081: variable 'v15' is possibly undefined
// 330B7: variable 'v20' is possibly undefined
// 33185: variable 'v34' is possibly undefined
// 333C0: variable 'v49' is possibly undefined
// 334E8: variable 'v59' is possibly undefined
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);

//----- (0000000000033620) ----------------------------------------------------
const char *__fastcall std::backtrace_rs::symbolize::gimli::elf::Object::section(
        _QWORD *a1,
        __int64 *a2,
        _DWORD *a3,
        size_t a4)
{
  __int64 v4; // r8
  __int64 v5; // rbx
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // rbp
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // rdx
  bool v11; // cf
  unsigned __int64 v12; // rdx
  const __m128i *bytes_at_until; // rax
  __int64 v14; // rdx
  int v15; // eax
  const char *v16; // r13
  __int64 v17; // rax
  __int64 v19; // rbp
  __int64 v20; // r12
  unsigned __int64 v21; // r14
  __int64 v22; // rbx
  __int64 v23; // rdx
  unsigned __int64 v24; // rdx
  const __m128i *v25; // rax
  unsigned __int64 v26; // rdx
  int v27; // ecx
  int v28; // eax
  __int64 v29; // rax
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // rdx
  size_t v32; // rbx
  unsigned __int64 v33; // r14
  __int64 v34; // r12
  unsigned __int64 v35; // rdx
  __int64 v36; // r15
  __int64 bytes_at; // rax
  unsigned __int64 v38; // rdx
  unsigned __int64 v39; // r15
  size_t v40; // r14
  __int64 v41; // rbp
  unsigned __int64 v42; // rdx
  unsigned __int64 v43; // rbx
  void *s2a; // [rsp+18h] [rbp-2B60h]
  __int64 v47; // [rsp+20h] [rbp-2B58h]
  __int64 v48; // [rsp+28h] [rbp-2B50h]
  unsigned __int64 v49; // [rsp+38h] [rbp-2B40h]
  __int64 v50; // [rsp+40h] [rbp-2B38h] BYREF
  char v51; // [rsp+48h] [rbp-2B30h]
  __int64 v52; // [rsp+50h] [rbp-2B28h]
  __int64 s[1380]; // [rsp+58h] [rbp-2B20h] BYREF

  s[862] = 0LL;
  s[350] = 0LL;
  v4 = a1[5];
  v48 = a1[6];
  v47 = v4;
  if ( v48 )
  {
    v5 = a1[7];
    if ( v5 )
    {
      v6 = a1[8];
      v7 = a1[10];
      v8 = a1[9];
      v9 = 0LL;
      while ( 1 )
      {
        v10 = *(unsigned int *)(v4 + v9);
        v11 = __CFADD__(v8, v10);
        v12 = v8 + v10;
        if ( !v11 )
        {
          bytes_at_until = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at_until(v5, v6, v12, v7, 0);
          v4 = v47;
          if ( bytes_at_until )
          {
            if ( v14 == a4 )
            {
              v15 = bcmp(bytes_at_until, a3, a4);
              v4 = v47;
              if ( !v15 )
                break;
            }
          }
        }
        v9 += 64LL;
        if ( v48 << 6 == v9 )
          goto LABEL_15;
      }
      if ( *(_DWORD *)(v47 + v9 + 4) == 8 )
      {
        v16 = aRustc9b00956e5;
        if ( (*(_BYTE *)(v47 + v9 + 9) & 8) != 0 )
          return 0LL;
        return v16;
      }
      bytes_at = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
                   a1[3],
                   a1[4],
                   *(_QWORD *)(v47 + v9 + 24),
                   *(_QWORD *)(v47 + v9 + 32));
      if ( bytes_at )
      {
        v16 = (const char *)bytes_at;
        if ( (*(_BYTE *)(v47 + v9 + 9) & 8) == 0 )
          return v16;
        if ( v38 >= 0x18 && *(_DWORD *)bytes_at == 1 )
        {
          v39 = v38 - 24;
          v40 = bytes_at + 24;
          v41 = std::backtrace_rs::symbolize::gimli::stash::Stash::allocate(a2, *(_QWORD *)(bytes_at + 8));
          v43 = v42;
          memset(s, 0, 0x2AEAuLL);
          miniz_oxide::inflate::core::decompress((__int64)&v50, (__int64)s, v40, v39, v41, v43, 0LL, 5);
          if ( v50 ^ v39 | v52 ^ v43 )
            v41 = 0LL;
          if ( v51 )
            return 0LL;
          return (const char *)v41;
        }
      }
      return 0LL;
    }
    v17 = v48 << 6;
    do
      v17 -= 64LL;
    while ( v17 );
  }
LABEL_15:
  if ( a4 < 7 || *a3 ^ 0x6265642E | *(_DWORD *)((char *)a3 + 3) ^ 0x5F677562 )
    return 0LL;
  if ( a4 != 7 && *((char *)a3 + 7) <= -65 )
    core::str::slice_error_fail(a3, a4, 7uLL, a4, (__int64)&off_59468);
  if ( !v48 )
    return 0LL;
  v19 = a1[7];
  if ( !v19 )
  {
    v36 = v48 << 6;
    v16 = 0LL;
    do
      v36 -= 64LL;
    while ( v36 );
    return v16;
  }
  s2a = (char *)a3 + 7;
  v49 = a1[8];
  v20 = a1[9];
  v21 = a1[10];
  v16 = 0LL;
  v22 = 0LL;
  while ( 1 )
  {
    v23 = *(unsigned int *)(v4 + v22);
    v11 = __CFADD__(v20, v23);
    v24 = v20 + v23;
    if ( !v11 )
    {
      v25 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at_until(v19, v49, v24, v21, 0);
      v4 = v47;
      if ( v25 )
      {
        if ( v26 >= 8 )
        {
          v27 = 0;
          if ( v26 - 1 == a4 )
          {
            LOBYTE(v27) = v25->m128i_i64[0] != 0x5F67756265647A2ELL;
            if ( !v27 )
            {
              v28 = bcmp(&v25->m128i_u64[1], s2a, v26 - 8);
              v4 = v47;
              if ( !v28 )
                break;
            }
          }
        }
      }
    }
    v22 += 64LL;
    if ( v48 << 6 == v22 )
      return v16;
  }
  if ( *(_DWORD *)(v47 + v22 + 4) == 8 )
    return 0LL;
  v29 = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
          a1[3],
          a1[4],
          *(_QWORD *)(v47 + v22 + 24),
          *(_QWORD *)(v47 + v22 + 32));
  if ( !v29 )
    return 0LL;
  v16 = 0LL;
  v11 = v30 < 8;
  v31 = v30 - 8;
  if ( !v11 )
  {
    v16 = 0LL;
    if ( v31 >= 4 && *(_QWORD *)v29 == 1112099930LL )
    {
      v32 = v29 + 12;
      v33 = v31 - 4;
      v34 = std::backtrace_rs::symbolize::gimli::stash::Stash::allocate(a2, _byteswap_ulong(*(_DWORD *)(v29 + 8)));
      v16 = 0LL;
      if ( std::backtrace_rs::symbolize::gimli::elf::decompress_zlib(v32, v33, v34, v35) )
        return (const char *)v34;
    }
  }
  return v16;
}
// 336E3: variable 'v14' is possibly undefined
// 33804: variable 'v26' is possibly undefined
// 3387F: variable 'v30' is possibly undefined
// 338D6: variable 'v35' is possibly undefined
// 3393A: variable 'v38' is possibly undefined
// 33967: variable 'v42' is possibly undefined
// 59468: using guessed type char *off_59468;

//----- (00000000000339F0) ----------------------------------------------------
const char *__fastcall std::backtrace_rs::symbolize::gimli::elf::Object::build_id(_QWORD *a1)
{
  __int64 v1; // r15
  __int64 v2; // r12
  __int64 v3; // r15
  __int64 bytes_at; // rax
  unsigned __int64 v5; // rdx
  const char *v6; // rcx
  unsigned __int64 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdi
  unsigned __int64 v12; // r10
  const char *v13; // rax
  unsigned __int64 v14; // rbp
  unsigned __int64 v15; // r11
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // r14
  bool v20; // zf
  unsigned __int64 v22; // [rsp+8h] [rbp-40h]
  __int64 v23; // [rsp+10h] [rbp-38h]

  v1 = a1[6];
  if ( !v1 )
    return 0LL;
  v2 = a1[5];
  v3 = v2 + (v1 << 6);
  v23 = a1[3];
  v22 = a1[4];
  do
  {
    if ( *(_DWORD *)(v2 + 4) == 7 )
    {
      bytes_at = <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
                   v23,
                   v22,
                   *(_QWORD *)(v2 + 24),
                   *(_QWORD *)(v2 + 32));
      if ( bytes_at )
      {
        v6 = (const char *)bytes_at;
        v7 = *(_QWORD *)(v2 + 48);
        v8 = 4LL;
        if ( v7 < 5 || (v8 = 8LL, v7 == 8) )
        {
          if ( v5 )
          {
            v9 = v8 + 11;
            v10 = -v8;
            v11 = v8 - 1;
            do
            {
              if ( v5 < 0xC )
                break;
              v12 = v5;
              v13 = v6;
              v14 = *(unsigned int *)v6;
              if ( v5 - 12 < v14 )
                break;
              v15 = v10 & (v9 + v14);
              if ( v5 < v15 )
                break;
              v16 = *((unsigned int *)v6 + 1);
              if ( v5 - v15 < v16 )
                break;
              v17 = v10 & (v16 + v11 + v15);
              v5 -= v17;
              if ( v12 < v17 )
                v5 = 0LL;
              v6 += v17;
              if ( v12 < v17 )
                v6 = aRustc9b00956e5;
              v18 = v14;
              while ( v18-- != 0 )
              {
                v20 = v13[v14 + 11] == 0;
                v14 = v18;
                if ( !v20 )
                {
                  if ( v18 == 2
                    && !(*((_WORD *)v13 + 6) ^ 0x4E47 | *((unsigned __int8 *)v13 + 14) ^ 0x55)
                    && *((_DWORD *)v13 + 2) == 3 )
                  {
                    return &v13[v15];
                  }
                  break;
                }
              }
            }
            while ( v12 > v17 );
          }
        }
      }
    }
    v2 += 64LL;
  }
  while ( v2 != v3 );
  return 0LL;
}
// 33A95: variable 'v5' is possibly undefined

//----- (0000000000033B80) ----------------------------------------------------
bool __fastcall std::backtrace_rs::symbolize::gimli::elf::decompress_zlib(
        size_t a1,
        unsigned __int64 a2,
        __int64 a3,
        unsigned __int64 a4)
{
  __int64 v7; // [rsp+0h] [rbp-2B38h] BYREF
  char v8; // [rsp+8h] [rbp-2B30h]
  __int64 v9; // [rsp+10h] [rbp-2B28h]
  __int64 s[1315]; // [rsp+18h] [rbp-2B20h] BYREF
  int v11; // [rsp+2930h] [rbp-208h]
  char v12[462]; // [rsp+2934h] [rbp-204h] BYREF

  v11 = 0;
  memset(s, 0, sizeof(s));
  memset(v12, 0, sizeof(v12));
  miniz_oxide::inflate::core::decompress((__int64)&v7, (__int64)s, a1, a2, a3, a4, 0LL, 5);
  return v8 == 0 && v7 == a2 && v9 == a4;
}

//----- (0000000000033C50) ----------------------------------------------------
bool std::backtrace_rs::symbolize::gimli::elf::debug_path_exists()
{
  char *v1; // rax
  char v2; // al
  char *v3; // rbx
  __int16 st_mode; // ax
  char *v5; // [rsp+8h] [rbp-2E8h] BYREF
  __int64 v6; // [rsp+10h] [rbp-2E0h] BYREF
  char *file; // [rsp+18h] [rbp-2D8h]
  struct stat64 buf; // [rsp+28h] [rbp-2C8h] BYREF
  __int64 v9[7]; // [rsp+B8h] [rbp-238h] BYREF
  int v10; // [rsp+F0h] [rbp-200h]
  char v11[392]; // [rsp+168h] [rbp-188h] BYREF

  if ( std::backtrace_rs::symbolize::gimli::elf::debug_path_exists::DEBUG_PATH_EXISTS )
    return std::backtrace_rs::symbolize::gimli::elf::debug_path_exists::DEBUG_PATH_EXISTS == 1;
  strcpy(v11, "/usr/lib/debug");
  core::ffi::c_str::CStr::from_bytes_with_nul(&v6, (__int64)v11, 0xFuLL);
  if ( !v6 )
  {
    v3 = file;
    std::sys::pal::unix::fs::try_statx((__int64)v9, 4294967196LL, (__int64)file, 0LL);
    if ( v9[0] == 3 )
    {
      memset(&buf, 0, sizeof(buf));
      if ( stat64(v3, &buf) == -1 )
      {
        v1 = (char *)(((unsigned __int64)(unsigned int)*_errno_location() << 32) | 2);
        goto LABEL_5;
      }
      st_mode = buf.st_mode;
    }
    else
    {
      if ( LODWORD(v9[0]) == 2 )
      {
        v1 = (char *)v9[1];
        goto LABEL_5;
      }
      st_mode = v10;
    }
    v2 = 2 - ((st_mode & 0xF000) == 0x4000);
    goto LABEL_13;
  }
  v1 = ptr;
LABEL_5:
  v5 = v1;
  core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v5);
  v2 = 2;
LABEL_13:
  std::backtrace_rs::symbolize::gimli::elf::debug_path_exists::DEBUG_PATH_EXISTS = v2;
  return v2 == 1;
}
// 5B16A: using guessed type char std::backtrace_rs::symbolize::gimli::elf::debug_path_exists::DEBUG_PATH_EXISTS;

//----- (0000000000033DB0) ----------------------------------------------------
unsigned __int64 __fastcall std::backtrace_rs::symbolize::gimli::elf::locate_build_id(
        _QWORD *a1,
        char *a2,
        unsigned __int64 a3)
{
  __int64 v5; // rax
  __int64 v6; // rsi
  unsigned __int64 result; // rax
  __int64 v8; // rsi
  char v9; // r12
  char v10; // cl
  char v11; // bp
  __int64 v12; // rsi
  unsigned __int8 v13; // r12
  char v14; // bp
  __int64 v15; // rsi
  __int64 v16; // rsi
  __int64 v17; // r13
  unsigned __int8 v18; // bp
  char v19; // bl
  __int64 v20; // rsi
  unsigned __int8 v21; // bp
  char v22; // bl
  __int64 v23; // rcx
  __int128 v24; // [rsp+8h] [rbp-50h] BYREF
  __int64 v25; // [rsp+18h] [rbp-40h]
  _QWORD *v26; // [rsp+20h] [rbp-38h]

  if ( a3 < 2 || !std::backtrace_rs::symbolize::gimli::elf::debug_path_exists() )
  {
    result = 0x8000000000000000LL;
    *a1 = 0x8000000000000000LL;
    return result;
  }
  if ( 2 * a3 == -32LL )
  {
    *(_QWORD *)&v24 = 0LL;
    *((_QWORD *)&v24 + 1) = 1LL;
    v25 = 0LL;
LABEL_10:
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v24, 0LL, 25LL);
    v5 = *((_QWORD *)&v24 + 1);
    v6 = v25;
    goto LABEL_11;
  }
  if ( (__int64)(2 * a3 + 32) < 0 )
    alloc::raw_vec::capacity_overflow();
  v5 = _rust_alloc(2 * a3 + 32, 1LL);
  if ( !v5 )
    alloc::alloc::handle_alloc_error(1LL, 2 * a3 + 32);
  *(_QWORD *)&v24 = 2 * a3 + 32;
  *((_QWORD *)&v24 + 1) = v5;
  v25 = 0LL;
  if ( (unsigned __int64)v24 <= 0x18 )
    goto LABEL_10;
  v6 = 0LL;
LABEL_11:
  qmemcpy((void *)(v5 + v6), "/usr/lib/debug/.build-id/", 25);
  v8 = v6 + 25;
  v25 = v8;
  v9 = *a2;
  v10 = (unsigned __int8)*a2 >> 4;
  v11 = v10 + 87;
  if ( (unsigned __int8)*a2 < 0xA0u )
    v11 = v10 + 48;
  if ( v8 == (_QWORD)v24 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v24, v8);
    v5 = *((_QWORD *)&v24 + 1);
    v8 = v25;
  }
  *(_BYTE *)(v5 + v8) = v11;
  v12 = v8 + 1;
  v25 = v12;
  v13 = v9 & 0xF;
  v14 = v13 + 87;
  if ( v13 < 0xAu )
    v14 = v13 + 48;
  if ( v12 == (_QWORD)v24 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v24, v12);
    v12 = v25;
  }
  *(_BYTE *)(*((_QWORD *)&v24 + 1) + v12) = v14;
  v15 = v12 + 1;
  v25 = v15;
  v26 = a1;
  if ( v15 == (_QWORD)v24 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v24, v15);
    v15 = v25;
  }
  *(_BYTE *)(*((_QWORD *)&v24 + 1) + v15) = 47;
  v16 = v15 + 1;
  v25 = v16;
  v17 = 1LL;
  do
  {
    v18 = a2[v17];
    v19 = (v18 >> 4) + 87;
    if ( v18 < 0xA0u )
      v19 = (v18 >> 4) + 48;
    if ( v16 == (_QWORD)v24 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v24, v16);
      v16 = v25;
    }
    *(_BYTE *)(*((_QWORD *)&v24 + 1) + v16) = v19;
    v20 = v16 + 1;
    v25 = v20;
    v21 = v18 & 0xF;
    v22 = v21 + 87;
    if ( v21 < 0xAu )
      v22 = v21 + 48;
    if ( v20 == (_QWORD)v24 )
    {
      alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v24, v20);
      v20 = v25;
    }
    *(_BYTE *)(*((_QWORD *)&v24 + 1) + v20) = v22;
    v16 = v20 + 1;
    v25 = v16;
    ++v17;
  }
  while ( a3 != v17 );
  if ( (unsigned __int64)(v24 - v16) > 5 )
  {
    v23 = (__int64)v26;
  }
  else
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v24, v16, 6LL);
    v23 = (__int64)v26;
    v16 = v25;
  }
  result = *((_QWORD *)&v24 + 1);
  *(_WORD *)(*((_QWORD *)&v24 + 1) + v16 + 4) = 26485;
  *(_DWORD *)(result + v16) = 1650811950;
  v25 = v16 + 6;
  *(_QWORD *)(v23 + 16) = v16 + 6;
  *(_OWORD *)v23 = v24;
  return result;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);

//----- (0000000000034080) ----------------------------------------------------
__int64 __fastcall std::backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::callback(
        struct dl_phdr_info *a1,
        size_t a2,
        __int64 *a3)
{
  __int64 *v3; // rbp
  struct dl_phdr_info *v4; // r12
  const char *dlpi_name; // r15
  signed __int64 v6; // rax
  size_t v7; // r14
  __int64 v9; // r12
  __int64 v10; // rax
  char *v11; // rdi
  Elf64_Addr dlpi_addr; // r14
  unsigned __int64 v13; // rbx
  char *v14; // rax
  size_t v15; // r13
  __int64 v16; // r12
  __int64 dlpi_phnum; // rbx
  struct dl_phdr_info *v18; // r14
  const Elf64_Phdr *dlpi_phdr; // rbp
  __int64 v20; // r15
  __int64 v21; // rax
  __int64 v22; // rcx
  Elf64_Xword *p_p_memsz; // rsi
  Elf64_Xword *v24; // rdi
  Elf64_Xword v25; // r9
  Elf64_Xword v26; // r9
  Elf64_Addr p_vaddr; // rsi
  Elf64_Xword p_memsz; // rdx
  __int64 v29; // rcx
  Elf64_Addr v30; // rcx
  __int64 v31; // rsi
  __int64 v32; // rax
  __int64 v33; // rcx
  __int128 v34; // xmm0
  __int128 v35; // xmm1
  __int64 v37; // rdx
  __int64 v38; // r15
  __int64 v39; // rsi
  unsigned __int64 v40; // r13
  _QWORD *v41; // rbx
  __int64 v42; // rsi
  __int64 v43; // r12
  __int64 v44; // rax
  __int128 v45; // xmm1
  __int128 v46; // xmm2
  __int128 v47; // xmm3
  __int64 v48; // rbp
  __int64 v49; // rax
  unsigned __int8 *v50; // rbp
  unsigned __int8 *v51; // rdx
  __int64 v52; // rbp
  unsigned __int64 v53; // r14
  __int64 v54; // r13
  __int64 v55; // rbx
  __int64 v56; // r12
  unsigned __int64 v57; // r13
  __int64 v58; // rax
  __int64 v59; // rbx
  __int64 v60; // rdx
  void *v61; // rax
  _QWORD *v62; // rbx
  __int64 v63; // rsi
  _QWORD *v64; // rbx
  __int64 v65; // rsi
  int fd; // [rsp+4h] [rbp-2B4h] BYREF
  unsigned __int64 v67; // [rsp+8h] [rbp-2B0h]
  __int64 v68; // [rsp+10h] [rbp-2A8h]
  __int64 *v69; // [rsp+18h] [rbp-2A0h]
  __int64 v70; // [rsp+20h] [rbp-298h] BYREF
  char *v71; // [rsp+28h] [rbp-290h]
  __int64 v72; // [rsp+30h] [rbp-288h]
  __int64 v73; // [rsp+38h] [rbp-280h] BYREF
  __int64 v74; // [rsp+40h] [rbp-278h]
  __int64 v75; // [rsp+48h] [rbp-270h]
  __int128 v76; // [rsp+50h] [rbp-268h] BYREF
  __int64 v77[5]; // [rsp+60h] [rbp-258h] BYREF
  char v78; // [rsp+88h] [rbp-230h]
  __int16 v79; // [rsp+90h] [rbp-228h]
  struct dl_phdr_info *v80; // [rsp+A0h] [rbp-218h]
  __int64 v81; // [rsp+A8h] [rbp-210h] BYREF
  int v82; // [rsp+B0h] [rbp-208h]
  __int16 v83; // [rsp+B4h] [rbp-204h]
  void *src; // [rsp+B8h] [rbp-200h]
  __int128 v85; // [rsp+C0h] [rbp-1F8h]
  __int128 v86; // [rsp+D0h] [rbp-1E8h]
  __int128 v87; // [rsp+E0h] [rbp-1D8h]
  __int128 v88; // [rsp+F0h] [rbp-1C8h]
  __int128 v89; // [rsp+108h] [rbp-1B0h] BYREF
  _BYTE v90[40]; // [rsp+118h] [rbp-1A0h]
  __int128 v91; // [rsp+140h] [rbp-178h]
  __int128 v92; // [rsp+150h] [rbp-168h]

  v3 = a3;
  v4 = a1;
  dlpi_name = a1->dlpi_name;
  if ( !dlpi_name || !*dlpi_name )
  {
    if ( a3[2] )
    {
LABEL_20:
      v67 = 1LL;
      v7 = 0LL;
      v15 = 0LL;
      goto LABEL_21;
    }
    dlpi_addr = a1->dlpi_addr;
    v73 = 0LL;
    v74 = 8LL;
    v75 = 0LL;
    v81 = 0x1B600000000LL;
    v82 = 1;
    v83 = 0;
    strcpy((char *)&v89, "/proc/self/maps");
    core::ffi::c_str::CStr::from_bytes_with_nul(&v76, (__int64)&v89, 0x10uLL);
    v13 = 0x8000000000000000LL;
    v80 = a1;
    if ( (_QWORD)v76 )
    {
      v14 = ptr;
LABEL_14:
      *(_QWORD *)&v89 = v14;
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v89);
      v16 = 8LL;
LABEL_15:
      if ( v73 )
        _rust_dealloc(v16, 88 * v73, 8LL);
LABEL_17:
      std::env::current_exe(&v89);
      v4 = v80;
      if ( (_QWORD)v89 != v13 )
      {
        v76 = v89;
        v77[0] = *(_QWORD *)v90;
        v67 = *((_QWORD *)&v89 + 1);
        v15 = v89;
        v7 = *(_QWORD *)v90;
        goto LABEL_21;
      }
      *((_QWORD *)&v76 + 1) = *((_QWORD *)&v89 + 1);
      *(_QWORD *)&v76 = v13;
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v76 + 1);
      goto LABEL_20;
    }
    std::sys::pal::unix::fs::File::open_c((__int64)&v70, *((const char **)&v76 + 1), (__int64)&v81);
    if ( (_DWORD)v70 )
    {
      v14 = v71;
      goto LABEL_14;
    }
    fd = HIDWORD(v70);
    v70 = 0LL;
    v71 = (_BYTE *)(&dword_0 + 1);
    v72 = 0LL;
    *(_QWORD *)&v89 = &fd;
    if ( <&std::fs::File as std::io::Read>::read_to_string((int **)&v89, &v70) )
    {
      *(_QWORD *)&v89 = v37;
      core::ptr::drop_in_place<std::io::error::Error>((__int64 *)&v89);
      v38 = 0LL;
      v39 = v70;
      if ( v70 )
LABEL_36:
        _rust_dealloc(v71, v39, 1LL);
LABEL_37:
      close(fd);
      v16 = v74;
      if ( v38 )
      {
        v40 = v13;
        v41 = (_QWORD *)(v74 + 8);
        do
        {
          v42 = *(v41 - 1);
          if ( v42 )
            _rust_dealloc(*v41, v42, 1LL);
          v41 += 11;
          --v38;
        }
        while ( v38 );
        v13 = v40;
      }
      goto LABEL_15;
    }
    v67 = dlpi_addr;
    v69 = v3;
    *(_QWORD *)&v76 = 0LL;
    *((_QWORD *)&v76 + 1) = v72;
    v77[0] = (__int64)v71;
    v77[1] = v72;
    v77[2] = 0LL;
    v77[3] = v72;
    v77[4] = 0xA0000000ALL;
    v78 = 1;
    v79 = 0;
    v43 = 8LL;
    v38 = 0LL;
    while ( 1 )
    {
      v48 = v77[0];
      <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match((__int64 *)&v89, v77);
      if ( (_QWORD)v89 )
      {
        v49 = v76;
        v50 = (unsigned __int8 *)(v76 + v48);
        *(_QWORD *)&v76 = *(_QWORD *)v90;
        v51 = (unsigned __int8 *)(*(_QWORD *)v90 - v49);
        if ( *(_QWORD *)v90 == v49 )
          goto LABEL_56;
      }
      else
      {
        if ( HIBYTE(v79) )
          goto LABEL_61;
        HIBYTE(v79) = 1;
        if ( !(_BYTE)v79 && *((_QWORD *)&v76 + 1) == (_QWORD)v76 )
          goto LABEL_61;
        v51 = (unsigned __int8 *)(*((_QWORD *)&v76 + 1) - v76);
        v50 = (unsigned __int8 *)(v77[0] + v76);
        if ( *((_QWORD *)&v76 + 1) == (_QWORD)v76 )
          goto LABEL_56;
      }
      if ( v51[(_QWORD)v50 - 1] != 10 )
        goto LABEL_57;
      if ( v51 == (_BYTE *)&dword_0 + 1 )
      {
LABEL_56:
        v51 = 0LL;
        goto LABEL_57;
      }
      if ( v51[(_QWORD)v50 - 2] == 13 )
        v51 -= 2;
      else
        --v51;
LABEL_57:
      <std::backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::str::traits::FromStr>::from_str(
        &v89,
        v50,
        v51);
      v52 = v89;
      if ( (_QWORD)v89 == v13 )
      {
        v3 = v69;
        v39 = v70;
        if ( v70 )
          goto LABEL_36;
        goto LABEL_37;
      }
      v53 = v13;
      v54 = *((_QWORD *)&v89 + 1);
      v55 = *(_QWORD *)v90;
      v85 = *(_OWORD *)&v90[8];
      v86 = *(_OWORD *)&v90[24];
      v87 = v91;
      v88 = v92;
      if ( v38 == v73 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve_for_push(&v73, v38);
        v43 = v74;
        v38 = v75;
      }
      v44 = 88 * v38;
      *(_QWORD *)(v43 + v44) = v52;
      *(_QWORD *)(v43 + v44 + 8) = v54;
      *(_QWORD *)(v43 + v44 + 16) = v55;
      v45 = v86;
      v46 = v87;
      v47 = v88;
      *(_OWORD *)(v43 + v44 + 24) = v85;
      *(_OWORD *)(v43 + v44 + 40) = v45;
      *(_OWORD *)(v43 + v44 + 56) = v46;
      *(_OWORD *)(v43 + v44 + 72) = v47;
      v75 = ++v38;
      v13 = v53;
      if ( HIBYTE(v79) )
      {
LABEL_61:
        v56 = v73;
        v68 = v74;
        if ( v70 )
          _rust_dealloc(v71, v70, 1LL);
        close(fd);
        v3 = v69;
        if ( v56 != v13 )
        {
          v57 = v13;
          *(_QWORD *)&v89 = v56;
          *((_QWORD *)&v89 + 1) = v68;
          *(_QWORD *)v90 = v38;
          if ( v38 )
          {
            v58 = 0LL;
            v59 = v68;
            do
            {
              if ( *(_QWORD *)(v68 + v58 + 40) <= v67 && *(_QWORD *)(v68 + v58 + 48) > v67 )
              {
                v60 = *(_QWORD *)(v68 + v58 + 16);
                if ( v60 )
                {
                  if ( v60 < 0 )
                    alloc::raw_vec::capacity_overflow();
                  v15 = *(_QWORD *)(v68 + v58 + 16);
                  src = *(void **)(v68 + v58 + 8);
                  v61 = (void *)_rust_alloc(v60, 1LL);
                  if ( !v61 )
                    alloc::alloc::handle_alloc_error(1LL, v15);
                  v67 = (unsigned __int64)v61;
                  memcpy(v61, src, v15);
                  v62 = (_QWORD *)(v59 + 8);
                  v7 = v15;
                  do
                  {
                    v63 = *(v62 - 1);
                    if ( v63 )
                      _rust_dealloc(*v62, v63, 1LL);
                    v62 += 11;
                    --v38;
                  }
                  while ( v38 );
                  if ( v56 )
                    _rust_dealloc(v68, 88 * v56, 8LL);
                  v4 = v80;
                  goto LABEL_21;
                }
              }
              v58 += 88LL;
            }
            while ( 88 * v38 != v58 );
            v64 = (_QWORD *)(v68 + 8);
            do
            {
              v65 = *(v64 - 1);
              if ( v65 )
                _rust_dealloc(*v64, v65, 1LL);
              v64 += 11;
              --v38;
            }
            while ( v38 );
          }
          if ( v56 )
            _rust_dealloc(v68, 88 * v56, 8LL);
          v13 = v57;
        }
        goto LABEL_17;
      }
    }
  }
  v6 = strlen(a1->dlpi_name);
  v7 = v6;
  if ( v6 )
  {
    if ( v6 < 0 )
      alloc::raw_vec::capacity_overflow();
    v9 = 1LL;
    v10 = _rust_alloc(v6, 1LL);
    if ( !v10 )
    {
      v20 = v7;
      goto LABEL_90;
    }
    v11 = (char *)v10;
    v4 = a1;
  }
  else
  {
    v11 = (char *)&dword_0 + 1;
  }
  v67 = (unsigned __int64)v11;
  memcpy(v11, dlpi_name, v7);
  v15 = v7;
LABEL_21:
  dlpi_phnum = v4->dlpi_phnum;
  if ( !v4->dlpi_phnum )
  {
    v21 = 8LL;
    goto LABEL_31;
  }
  v68 = v7;
  v69 = v3;
  v18 = v4;
  dlpi_phdr = v4->dlpi_phdr;
  v20 = (unsigned int)(16 * dlpi_phnum);
  v9 = 8LL;
  v21 = _rust_alloc(v20, 8LL);
  if ( !v21 )
LABEL_90:
    alloc::alloc::handle_alloc_error(v9, v20);
  if ( (_DWORD)dlpi_phnum == 1 )
  {
    v22 = 0LL;
    v4 = v18;
  }
  else
  {
    p_p_memsz = &dlpi_phdr[1].p_memsz;
    v24 = (Elf64_Xword *)(v21 + 24);
    v22 = 0LL;
    v4 = v18;
    do
    {
      v25 = *(p_p_memsz - 7);
      *(v24 - 3) = *(p_p_memsz - 10);
      *(v24 - 2) = v25;
      v26 = *p_p_memsz;
      *(v24 - 1) = *(p_p_memsz - 3);
      *v24 = v26;
      v22 += 2LL;
      p_p_memsz += 14;
      v24 += 4;
    }
    while ( (dlpi_phnum & 0xFFFFFFFE) != v22 );
  }
  v7 = v68;
  if ( (dlpi_phnum & 1) != 0 )
  {
    p_vaddr = dlpi_phdr[v22].p_vaddr;
    p_memsz = dlpi_phdr[v22].p_memsz;
    v29 = 16 * v22;
    *(_QWORD *)(v21 + v29) = p_vaddr;
    *(_QWORD *)(v21 + v29 + 8) = p_memsz;
  }
  v3 = v69;
LABEL_31:
  v30 = v4->dlpi_addr;
  *(_QWORD *)&v89 = v15;
  *((_QWORD *)&v89 + 1) = v67;
  *(_QWORD *)v90 = v7;
  *(_QWORD *)&v90[8] = dlpi_phnum;
  *(_QWORD *)&v90[16] = v21;
  *(_QWORD *)&v90[24] = dlpi_phnum;
  *(_QWORD *)&v90[32] = v30;
  v31 = v3[2];
  if ( v31 == *v3 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(v3, v31);
    v31 = v3[2];
  }
  v32 = v3[1];
  v33 = 56 * v31;
  *(_QWORD *)(v32 + v33 + 48) = *(_QWORD *)&v90[32];
  v34 = v89;
  v35 = *(_OWORD *)v90;
  *(_OWORD *)(v32 + v33 + 32) = *(_OWORD *)&v90[16];
  *(_OWORD *)(v32 + v33 + 16) = v35;
  *(_OWORD *)(v32 + v33) = v34;
  v3[2] = v31 + 1;
  return 0LL;
}
// 34486: variable 'v37' is possibly undefined
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (00000000000349A0) ----------------------------------------------------
_QWORD *__fastcall <std::backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::str::traits::FromStr>::from_str(
        _QWORD *a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3)
{
  unsigned __int64 v3; // r15
  unsigned __int8 *v4; // r13
  _QWORD *v5; // rbx
  unsigned __int8 *started; // r12
  __int64 v7; // rdx
  __int64 v8; // r14
  unsigned __int8 *v9; // rbp
  unsigned __int8 *v10; // r14
  unsigned __int8 *v11; // r12
  __int64 v12; // rdx
  __int64 v13; // r13
  unsigned __int8 *v14; // r13
  unsigned __int8 *v15; // rdi
  const char *v16; // rax
  unsigned __int8 *v17; // rsi
  __int64 v18; // r13
  unsigned __int8 *v19; // rbp
  unsigned __int8 *v20; // r12
  __int64 v21; // rdx
  __int64 v22; // r15
  unsigned __int64 v23; // rcx
  unsigned __int8 *v24; // rsi
  unsigned __int8 *v25; // rdi
  unsigned __int8 *v26; // r15
  __int64 v27; // rbp
  unsigned __int8 *v28; // r12
  __int64 v29; // rdx
  __int64 v30; // r13
  unsigned __int8 *v31; // rcx
  unsigned __int8 *v32; // rsi
  unsigned __int8 *v33; // rdi
  unsigned __int8 *v34; // r15
  unsigned __int8 *v35; // r13
  unsigned __int64 v36; // rbp
  unsigned __int8 *v37; // rbx
  __int64 v38; // rdx
  __int64 v39; // r12
  unsigned __int8 *v40; // r12
  unsigned __int8 *v41; // rdi
  __int64 v42; // rdx
  unsigned __int8 *v43; // r12
  __int64 v44; // rbx
  unsigned __int64 v45; // rdx
  unsigned __int8 *v46; // r12
  unsigned __int64 v47; // rbx
  __int64 v48; // rax
  void *v49; // rcx
  unsigned __int64 v51; // r12
  int v52; // eax
  __int64 v53; // r14
  void *v54; // rbx
  int v55; // eax
  int v56; // eax
  int v57; // eax
  unsigned __int64 v58; // r15
  unsigned __int8 *v59; // rbx
  unsigned __int64 v60; // r14
  unsigned __int64 v61; // rbx
  unsigned __int64 v62; // r13
  unsigned __int8 *v63; // [rsp+0h] [rbp-E8h]
  _QWORD *v64; // [rsp+0h] [rbp-E8h]
  unsigned __int8 *v65; // [rsp+8h] [rbp-E0h] BYREF
  unsigned __int8 *v66; // [rsp+10h] [rbp-D8h]
  unsigned __int8 *v67; // [rsp+18h] [rbp-D0h]
  unsigned __int8 *v68; // [rsp+20h] [rbp-C8h]
  __int64 v69; // [rsp+28h] [rbp-C0h]
  char v70; // [rsp+30h] [rbp-B8h]
  __int64 v71; // [rsp+38h] [rbp-B0h] BYREF
  unsigned __int8 *v72; // [rsp+40h] [rbp-A8h]
  __int64 v73; // [rsp+48h] [rbp-A0h]
  __int64 v74; // [rsp+50h] [rbp-98h]
  unsigned __int8 *v75; // [rsp+58h] [rbp-90h]
  unsigned __int8 *v76; // [rsp+60h] [rbp-88h]
  int v77; // [rsp+6Ch] [rbp-7Ch]
  int v78; // [rsp+70h] [rbp-78h]
  int v79; // [rsp+74h] [rbp-74h]
  __int64 v80; // [rsp+78h] [rbp-70h]
  unsigned __int8 *v81; // [rsp+80h] [rbp-68h]
  unsigned __int8 *v82; // [rsp+88h] [rbp-60h]
  __int64 v83; // [rsp+90h] [rbp-58h]
  unsigned __int8 *v84; // [rsp+98h] [rbp-50h]
  __int128 v85; // [rsp+A0h] [rbp-48h] BYREF
  __int64 v86; // [rsp+B0h] [rbp-38h]

  v3 = (unsigned __int64)a3;
  v4 = a2;
  v5 = a1;
  started = core::str::<impl str>::trim_start_matches(a2, a3);
  v8 = v7;
  v65 = started;
  v66 = (unsigned __int8 *)v7;
  v67 = 0LL;
  v68 = (unsigned __int8 *)v7;
  v70 = 1;
  v69 = 0x2000000020LL;
  <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(&v71, (__int64 *)&v65);
  v9 = aRustc9b00956e5;
  if ( !v71 || !started )
  {
    v10 = 0LL;
    if ( !v3 )
      goto LABEL_4;
LABEL_6:
    v76 = v4;
    v11 = core::str::<impl str>::trim_start_matches(v9, v10);
    v13 = v12;
    v65 = v11;
    v66 = (unsigned __int8 *)v12;
    v67 = 0LL;
    v68 = (unsigned __int8 *)v12;
    v70 = 1;
    v69 = 0x2000000020LL;
    <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(&v71, (__int64 *)&v65);
    if ( v71 && v11 )
    {
      v10 = v72;
      v14 = (unsigned __int8 *)(v13 - v73);
      v15 = &v11[v73];
      v9 = v11;
      if ( !v72 )
      {
LABEL_9:
        v16 = aCouldnTFindPer;
LABEL_10:
        v5[1] = v16;
        v5[2] = 25LL;
        goto LABEL_36;
      }
    }
    else
    {
      v15 = aRustc9b00956e5;
      v14 = 0LL;
      if ( !v10 )
        goto LABEL_9;
    }
    v17 = v14;
    v18 = v3;
    v63 = v9;
    v19 = v15;
    v74 = (__int64)v17;
    v20 = core::str::<impl str>::trim_start_matches(v15, v17);
    v65 = v20;
    v66 = (unsigned __int8 *)v21;
    v67 = 0LL;
    v22 = v21;
    v68 = (unsigned __int8 *)v21;
    v70 = 1;
    v69 = 0x2000000020LL;
    <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(&v71, (__int64 *)&v65);
    if ( v71 && v20 )
    {
      v23 = (unsigned __int64)v72;
      v24 = (unsigned __int8 *)(v22 - v73);
      v25 = &v20[v73];
      v19 = v20;
      if ( !v72 )
      {
LABEL_15:
        v5[1] = aCouldnTFindOff;
        v5[2] = 20LL;
        goto LABEL_36;
      }
    }
    else
    {
      v25 = aRustc9b00956e5;
      v24 = 0LL;
      v23 = v74;
      if ( !v74 )
        goto LABEL_15;
    }
    v75 = (unsigned __int8 *)v18;
    v74 = v23;
    v84 = v19;
    v26 = v25;
    v27 = (__int64)v24;
    v28 = core::str::<impl str>::trim_start_matches(v25, v24);
    v65 = v28;
    v66 = (unsigned __int8 *)v29;
    v67 = 0LL;
    v30 = v29;
    v68 = (unsigned __int8 *)v29;
    v70 = 1;
    v69 = 0x2000000020LL;
    <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(&v71, (__int64 *)&v65);
    if ( v71 )
    {
      v31 = v63;
      if ( v28 )
      {
        v27 = (__int64)v72;
        v32 = (unsigned __int8 *)(v30 - v73);
        v33 = &v28[v73];
        if ( v72 )
        {
LABEL_20:
          v34 = v31;
          v82 = v28;
          v83 = v27;
          v64 = v5;
          v35 = v33;
          v36 = (unsigned __int64)v32;
          v37 = core::str::<impl str>::trim_start_matches(v33, v32);
          v39 = v38;
          v65 = v37;
          v66 = (unsigned __int8 *)v38;
          v67 = 0LL;
          v68 = (unsigned __int8 *)v38;
          v70 = 1;
          v69 = 0x2000000020LL;
          <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(&v71, (__int64 *)&v65);
          if ( v71 && v37 )
          {
            v36 = (unsigned __int64)v72;
            v40 = (unsigned __int8 *)(v39 - v73);
            v41 = &v37[v73];
            v35 = v37;
            v5 = v64;
            if ( !v72 )
            {
LABEL_23:
              v5[1] = aCouldnTFindIno;
              v5[2] = 19LL;
              goto LABEL_36;
            }
          }
          else
          {
            v41 = aRustc9b00956e5;
            v40 = 0LL;
            v5 = v64;
            if ( !v32 )
              goto LABEL_23;
          }
          v81 = core::str::<impl str>::trim_start_matches(v41, v40);
          v80 = v42;
          v43 = v76;
          v65 = v76;
          v66 = v75;
          v67 = 0LL;
          v68 = v75;
          v70 = 1;
          v69 = 0x2D0000002DLL;
          <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(&v71, (__int64 *)&v65);
          if ( !v71 )
          {
            v48 = 28LL;
            v49 = &unk_4A643;
            goto LABEL_35;
          }
          v44 = v73;
          core::num::<impl usize>::from_str_radix((__int64)&v65, v43, (unsigned __int64)v72, 0x10u);
          if ( (_BYTE)v65 )
            goto LABEL_28;
          v45 = (unsigned __int64)&v75[-v44];
          v46 = &v43[v44];
          v47 = (unsigned __int64)v66;
          core::num::<impl usize>::from_str_radix((__int64)&v65, v46, v45, 0x10u);
          if ( (_BYTE)v65 )
            goto LABEL_28;
          v51 = v47;
          v76 = v66;
          v65 = v34;
          v66 = &v10[(_QWORD)v34];
          v52 = <core::str::iter::Chars as core::iter::traits::iterator::Iterator>::next(&v65);
          v53 = 18LL;
          v54 = &unk_4A5F8;
          if ( v52 != 1114112 )
          {
            LODWORD(v75) = v52;
            v55 = <core::str::iter::Chars as core::iter::traits::iterator::Iterator>::next(&v65);
            if ( v55 != 1114112 )
            {
              v79 = v55;
              v56 = <core::str::iter::Chars as core::iter::traits::iterator::Iterator>::next(&v65);
              if ( v56 != 1114112 )
              {
                v78 = v56;
                v57 = <core::str::iter::Chars as core::iter::traits::iterator::Iterator>::next(&v65);
                if ( v57 != 1114112 )
                {
                  v77 = v57;
                  if ( (unsigned int)<core::str::iter::Chars as core::iter::traits::iterator::Iterator>::next(&v65) == 1114112 )
                  {
                    core::num::<impl usize>::from_str_radix((__int64)&v65, v84, v74, 0x10u);
                    if ( !(_BYTE)v65 )
                    {
                      v58 = (unsigned __int64)v66;
                      core::str::<impl str>::split_once((__int64 *)&v65, (__int64)v82, v83, 0x3Au);
                      if ( !v65 )
                      {
                        v48 = 18LL;
                        v49 = &unk_4A631;
                        goto LABEL_29;
                      }
                      v59 = v67;
                      v74 = (__int64)v68;
                      core::num::<impl usize>::from_str_radix((__int64)&v71, v65, (unsigned __int64)v66, 0x10u);
                      if ( (_BYTE)v71
                        || (v60 = (unsigned __int64)v72,
                            core::num::<impl usize>::from_str_radix((__int64)&v71, v59, v74, 0x10u),
                            (_BYTE)v71) )
                      {
LABEL_28:
                        v48 = 25LL;
                        v49 = &unk_4A618;
LABEL_29:
                        v5 = v64;
LABEL_35:
                        v5[1] = v49;
                        v5[2] = v48;
                        goto LABEL_36;
                      }
                      v61 = (unsigned __int64)v72;
                      core::num::<impl usize>::from_str_radix((__int64)&v65, v35, v36, 0x10u);
                      if ( !(_BYTE)v65 )
                      {
                        v62 = (unsigned __int64)v66;
                        <std::ffi::os_str::OsString as core::convert::From<&T>>::from((__int64 *)&v85, v81, v80);
                        v64[2] = v86;
                        *(_OWORD *)v64 = v85;
                        *((_DWORD *)v64 + 6) = (_DWORD)v75;
                        *((_DWORD *)v64 + 7) = v79;
                        *((_DWORD *)v64 + 8) = v78;
                        *((_DWORD *)v64 + 9) = v77;
                        v64[5] = v51;
                        v64[6] = v76;
                        v64[7] = v58;
                        v64[8] = v60;
                        v64[9] = v61;
                        v5 = v64;
                        v64[10] = v62;
                        return v5;
                      }
                    }
                    v16 = (const char *)&unk_4A618;
                    v5 = v64;
                    goto LABEL_10;
                  }
                  v53 = 14LL;
                  v54 = &unk_4A60A;
                }
              }
            }
          }
          v64[1] = v54;
          v5 = v64;
          v64[2] = v53;
          goto LABEL_36;
        }
      }
      else
      {
        v33 = aRustc9b00956e5;
        v32 = 0LL;
        v28 = v26;
        if ( v27 )
          goto LABEL_20;
      }
    }
    else
    {
      v33 = aRustc9b00956e5;
      v32 = 0LL;
      v31 = v63;
      v28 = v26;
      if ( v27 )
        goto LABEL_20;
    }
    v5[1] = aCouldnTFindDev;
    v5[2] = 17LL;
    goto LABEL_36;
  }
  v3 = (unsigned __int64)v72;
  v10 = (unsigned __int8 *)(v8 - v73);
  v9 = &started[v73];
  v4 = started;
  if ( v72 )
    goto LABEL_6;
LABEL_4:
  a1[1] = aCouldnTFindAdd;
  a1[2] = 21LL;
LABEL_36:
  *v5 = 0x8000000000000000LL;
  return v5;
}
// 349C8: variable 'v7' is possibly undefined
// 34A68: variable 'v12' is possibly undefined
// 34B14: variable 'v21' is possibly undefined
// 34BC8: variable 'v29' is possibly undefined
// 34C5E: variable 'v38' is possibly undefined
// 34D03: variable 'v42' is possibly undefined

//----- (0000000000035060) ----------------------------------------------------
volatile signed __int64 *__fastcall std::sys_common::thread_info::THREAD_INFO::__getit::destroy(__int64 a1)
{
  volatile signed __int64 *result; // rax

  *(_BYTE *)(__readfsqword(0) - 32) = 2;
  result = *(volatile signed __int64 **)(a1 + 24);
  if ( result )
  {
    if ( !_InterlockedDecrement64(result) )
      return (volatile signed __int64 *)alloc::sync::Arc<T,A>::drop_slow((__int64 *)(a1 + 24));
  }
  return result;
}

//----- (00000000000350A0) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<panic_unwind::real_imp::Exception>(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v4; // rsi

  result = (*(__int64 (**)(void))a2)();
  v4 = *(_QWORD *)(a2 + 8);
  if ( v4 )
    return _rust_dealloc(a1, v4, *(_QWORD *)(a2 + 16));
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (00000000000350F0) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<alloc::boxed::Box<panic_unwind::real_imp::Exception>>(__int64 a1)
{
  __int64 v1; // r14
  __int64 v2; // r12
  __int64 v3; // rsi

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 48);
  (*(void (__fastcall **)(__int64))v2)(v1);
  v3 = *(_QWORD *)(v2 + 8);
  if ( v3 )
    _rust_dealloc(v1, v3, *(_QWORD *)(v2 + 16));
  return _rust_dealloc(a1, 56LL, 8LL);
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (0000000000035180) ----------------------------------------------------
__int64 __fastcall _rust_panic_cleanup(__int64 a1)
{
  __int64 v1; // rbx

  if ( *(_QWORD *)a1 != 0x4D4F5A0052555354LL )
  {
    Unwind_DeleteException((struct _Unwind_Exception *)a1);
LABEL_5:
    _rust_foreign_exception();
  }
  if ( *(_UNKNOWN **)(a1 + 32) != &panic_unwind::real_imp::CANARY )
    goto LABEL_5;
  v1 = *(_QWORD *)(a1 + 40);
  _rust_dealloc(a1, 56LL, 8LL);
  return v1;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (00000000000351E0) ----------------------------------------------------
_Unwind_Reason_Code __fastcall _rust_start_panic(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rdx
  __int64 v4; // rbx
  __int64 v5; // rax

  v2 = (*(__int64 (**)(void))(a2 + 24))();
  v4 = v3;
  v5 = _rust_alloc(56LL, 8LL);
  if ( !v5 )
    alloc::alloc::handle_alloc_error(8LL, 56LL);
  *(_QWORD *)v5 = 0x4D4F5A0052555354LL;
  *(_QWORD *)(v5 + 8) = panic_unwind::real_imp::panic::exception_cleanup;
  *(_OWORD *)(v5 + 16) = 0LL;
  *(_QWORD *)(v5 + 32) = &panic_unwind::real_imp::CANARY;
  *(_QWORD *)(v5 + 40) = v2;
  *(_QWORD *)(v5 + 48) = v4;
  return Unwind_RaiseException((struct _Unwind_Exception *)v5);
}
// 351EB: variable 'v3' is possibly undefined
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);

//----- (0000000000035280) ----------------------------------------------------
void __fastcall __noreturn panic_unwind::real_imp::panic::exception_cleanup(__int64 a1, __int64 a2)
{
  core::ptr::drop_in_place<alloc::boxed::Box<panic_unwind::real_imp::Exception>>(a2);
  _rust_drop_panic();
}

//----- (00000000000352A0) ----------------------------------------------------
__int64 __fastcall <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4)
{
  __int64 result; // rax

  result = a1 + a3;
  if ( a2 - a3 < a4 )
    result = 0LL;
  if ( a2 < a3 )
    return 0LL;
  return result;
}

//----- (00000000000352C0) ----------------------------------------------------
const __m128i *__fastcall <&[u8] as object::read::read_ref::ReadRef>::read_bytes_at_until(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        char a5)
{
  unsigned __int64 v5; // r14
  const __m128i *v6; // rbx
  const __m128i *result; // rax
  unsigned __int64 v8; // rdx

  v5 = a4 - a3;
  v6 = (const __m128i *)(a3 + a1);
  result = 0LL;
  if ( a4 >= a3 && a4 <= a2 && v5 )
  {
    if ( memchr::memchr::x86::sse2::memchr(a5, v6, v5) )
    {
      if ( v8 > v5 )
        return 0LL;
      return v6;
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}
// 35304: variable 'v8' is possibly undefined

//----- (0000000000035320) ----------------------------------------------------
_BOOL8 __fastcall memchr::memchr::x86::sse2::memchr(char a1, const __m128i *a2, unsigned __int64 a3)
{
  const __m128i *v3; // rcx
  _BOOL8 result; // rax
  __int64 v5; // rdx
  unsigned __int64 v6; // r8
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  const __m128i *v11; // rdi
  __int64 v12; // rdi
  __m128i v13; // xmm4
  __m128i v14; // xmm3
  __m128i v15; // xmm2
  __m128i v16; // xmm1
  __int64 v17; // r8
  signed __int64 v18; // r9

  v3 = (const __m128i *)((char *)a2 + a3);
  if ( a3 > 0xF )
  {
    v7 = _mm_cvtsi32_si128(a1);
    v8 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v7, v7), 0), 0);
    _EDI = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a2), v8));
    result = 1LL;
    if ( _EDI )
    {
      __asm { tzcnt   edx, edi }
    }
    else
    {
      v11 = (const __m128i *)(((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL) + 16);
      if ( a3 < 0x40 || v11 > &v3[-4] )
      {
LABEL_15:
        if ( v11 > &v3[-1] )
        {
LABEL_19:
          if ( v11 >= v3 )
          {
            return 0LL;
          }
          else
          {
            _ECX = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(v3 - 1), v8));
            result = _ECX != 0;
            __asm { tzcnt   edx, ecx }
          }
        }
        else
        {
          v18 = (char *)v11 - (char *)a2;
          while ( !_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(v11), v8)) )
          {
            ++v11;
            v18 += 16LL;
            if ( v11 > &v3[-1] )
              goto LABEL_19;
          }
          __asm { tzcnt   edx, edx }
        }
      }
      else
      {
        v12 = 32LL - ((unsigned __int8)a2 & 0xF);
        while ( 1 )
        {
          v13 = _mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a2 + v12 - 16)), v8);
          v14 = _mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a2 + v12)), v8);
          v15 = _mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a2 + v12 + 16)), v8);
          v16 = _mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a2 + v12 + 32)), v8);
          if ( _mm_movemask_epi8(_mm_or_si128(_mm_or_si128(v15, v16), _mm_or_si128(v14, v13))) )
            break;
          v17 = (__int64)a2[-1].m128i_i64 + v12;
          v12 += 64LL;
          if ( v17 + 64 > (unsigned __int64)&v3[-4] )
          {
            v11 = (const __m128i *)((char *)a2 + v12 - 16);
            goto LABEL_15;
          }
        }
        if ( _mm_movemask_epi8(v13) )
        {
          __asm { tzcnt   ecx, ecx }
        }
        else if ( _mm_movemask_epi8(v14) )
        {
          __asm { tzcnt   edx, ecx }
        }
        else if ( _mm_movemask_epi8(v15) )
        {
          __asm { tzcnt   ecx, ecx }
        }
        else if ( _mm_movemask_epi8(_mm_slli_epi16(v16, 7u)) )
        {
          __asm { tzcnt   ecx, ecx }
        }
      }
    }
  }
  else
  {
    result = 0LL;
    if ( a3 )
    {
      v5 = 0LL;
      while ( a2->m128i_i8[v5] != a1 )
      {
        v6 = (unsigned __int64)a2->m128i_u64 + ++v5;
        if ( v6 >= (unsigned __int64)v3 )
          return result;
      }
      return 1LL;
    }
  }
  return result;
}

//----- (00000000000354E0) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 result; // rax

  v4 = 1LL;
  if ( !a2 )
  {
    result = 1LL;
    v5 = 0LL;
    goto LABEL_12;
  }
  v5 = a3;
  if ( a4[1] )
  {
    v6 = a4[2];
    if ( v6 )
    {
      v7 = _rust_realloc(*a4, v6, 1LL, a3);
      if ( !v7 )
        goto LABEL_8;
      goto LABEL_11;
    }
  }
  if ( !a3 )
  {
    v7 = 1LL;
    goto LABEL_11;
  }
  v7 = _rust_alloc(a3, 1LL);
  if ( v7 )
  {
LABEL_11:
    a1[1] = v7;
    result = 2LL;
    v4 = 0LL;
    goto LABEL_12;
  }
LABEL_8:
  a1[1] = 1LL;
  result = 2LL;
LABEL_12:
  a1[result] = v5;
  *a1 = v4;
  return result * 8;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000035580) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v4; // r14
  __int64 v5; // rax
  __int64 result; // rax
  __int64 v7; // [rsp+8h] [rbp-40h] BYREF
  __int64 v8; // [rsp+10h] [rbp-38h]
  __int64 v9; // [rsp+18h] [rbp-30h]
  __int64 v10[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( !v2 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 8LL;
  if ( v2 >= 9 )
    v4 = v2;
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = v3;
    v5 = 1LL;
  }
  else
  {
    v5 = 0LL;
  }
  v10[1] = v5;
  alloc::raw_vec::finish_grow(&v7, v4 >= 0, v4, v10);
  if ( v7 )
  {
    if ( v8 )
      alloc::alloc::handle_alloc_error(v8, v9);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v8;
  a1[1] = v8;
  *a1 = v4;
  return result;
}

//----- (0000000000035630) ----------------------------------------------------
__int64 __fastcall <addr2line::LocationRangeUnitIter as core::iter::traits::iterator::Iterator>::next(
        __int64 a1,
        __int64 **a2)
{
  __int64 result; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // r9
  __int64 *v5; // r11
  __int64 v6; // rbx
  unsigned __int64 v7; // rdi
  __int64 *v8; // rdx
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r10
  __int64 v11; // r11
  unsigned __int64 v12; // r8
  __int64 v13; // rbx
  __int64 *v14; // rdi
  unsigned __int64 v15; // r9
  __int64 v16; // r14
  __int64 v17; // r9
  __int64 v18; // rdi
  unsigned __int64 v19; // r10
  unsigned __int64 v20; // r9
  __int64 v21; // r11
  __int64 v22; // r10
  unsigned __int64 v23; // rcx
  _QWORD *v24; // rdx
  bool v25; // cf
  _QWORD *v26; // r10
  unsigned __int64 v27; // rdx
  int v28; // r10d
  int v29; // r11d

  result = a1;
  v3 = (unsigned __int64)a2[2];
  v4 = (unsigned __int64)a2[3];
  if ( v4 >= v3 )
    goto LABEL_16;
  v5 = a2[1];
  v6 = 4 * v4;
  v7 = (unsigned __int64)a2[5];
  if ( v5[4 * v4 + 2] >= v7 )
    goto LABEL_16;
  v8 = &v5[v6];
  v9 = (unsigned __int64)a2[4];
  v10 = v5[v6 + 1];
  if ( v9 >= v10 )
  {
    v19 = v4 + 1;
    a2[3] = (__int64 *)(v4 + 1);
    a2[4] = 0LL;
    if ( v4 + 1 != v3 )
    {
      v8 = &v5[4 * v19];
      v9 = 0LL;
      if ( v19 >= v3 )
        v8 = 0LL;
      v20 = v4 + 2;
      v21 = (__int64)&v5[v6 + 8];
      do
      {
        if ( v8[2] >= v7 )
          break;
        v10 = v8[1];
        if ( v10 )
          goto LABEL_4;
        a2[3] = (__int64 *)v20;
        a2[4] = 0LL;
        v8 = 0LL;
        if ( v20 < v3 )
          v8 = (__int64 *)v21;
        v22 = 1 - v3 + v20++ + 1;
        v21 += 32LL;
      }
      while ( v22 != 2 );
    }
    goto LABEL_16;
  }
LABEL_4:
  v11 = *v8;
  v12 = *(_QWORD *)(*v8 + 24 * v9);
  if ( v12 >= v7 )
  {
LABEL_16:
    *(_DWORD *)(result + 16) = 2;
    return result;
  }
  v13 = v11 + 24 * v9;
  v14 = *a2;
  v15 = *(_QWORD *)(v13 + 8);
  if ( v15 >= (*a2)[1] )
  {
    v18 = 0LL;
  }
  else
  {
    v16 = *v14;
    v17 = 3 * v15;
    v18 = *(_QWORD *)(*v14 + 8 * v17 + 8);
    v15 = *(_QWORD *)(v16 + 8 * v17 + 16);
  }
  v23 = v9 + 1;
  v24 = v8 + 3;
  v25 = v23 < v10;
  v26 = (_QWORD *)(v11 + 24 * v23);
  if ( !v25 )
    v26 = v24;
  v27 = *v26 - v12;
  v28 = *(_DWORD *)(v13 + 16);
  v29 = *(_DWORD *)(v13 + 20);
  a2[4] = (__int64 *)v23;
  *(_QWORD *)result = v12;
  *(_QWORD *)(result + 8) = v27;
  *(_DWORD *)(result + 16) = v28 != 0;
  *(_DWORD *)(result + 20) = v28;
  *(_DWORD *)(result + 24) = v29 != 0;
  *(_DWORD *)(result + 28) = v29;
  *(_QWORD *)(result + 32) = v18;
  *(_QWORD *)(result + 40) = v15;
  return result;
}

//----- (00000000000357A0) ----------------------------------------------------
void *__fastcall addr2line::path_push(__int64 *a1, unsigned __int8 *a2, __int64 a3)
{
  int v5; // eax
  void *v6; // rax
  __int64 v7; // r15
  void *result; // rax
  __int64 v9; // rdi
  unsigned __int64 v10; // r15
  char v11; // bp

  if ( a3 )
  {
    v5 = *a2;
    if ( v5 == 47 || v5 == 92 )
      goto LABEL_4;
    if ( a3 != 1 && (char)a2[1] >= -64 )
    {
      if ( (unsigned __int64)a3 <= 3 )
      {
        if ( a3 != 3 )
          goto LABEL_16;
      }
      else if ( (char)a2[3] < -64 )
      {
        goto LABEL_16;
      }
      if ( *(_WORD *)(a2 + 1) == 23610 )
      {
LABEL_4:
        if ( a3 < 0 )
          alloc::raw_vec::capacity_overflow();
        v6 = (void *)_rust_alloc(a3, 1LL);
        if ( !v6 )
          alloc::alloc::handle_alloc_error(1LL, a3);
        v7 = (__int64)v6;
        result = memcpy(v6, a2, a3);
        if ( *a1 )
          result = (void *)_rust_dealloc(a1[1], *a1, 1LL);
        *a1 = a3;
        a1[1] = v7;
        a1[2] = a3;
        return result;
      }
    }
  }
LABEL_16:
  v9 = a1[1];
  v10 = a1[2];
  if ( v10 )
  {
    if ( *(_BYTE *)v9 == 92 )
    {
LABEL_18:
      v11 = 92;
      goto LABEL_27;
    }
    v11 = 47;
    if ( v10 != 1 && *(char *)(v9 + 1) >= -64 )
    {
      if ( v10 <= 3 )
      {
        if ( v10 != 3 )
          goto LABEL_27;
      }
      else if ( *(char *)(v9 + 3) < -64 )
      {
        goto LABEL_27;
      }
      if ( *(_WORD *)(v9 + 1) == 23610 )
        goto LABEL_18;
    }
LABEL_27:
    if ( v11 != *(_BYTE *)(v9 + v10 - 1) )
    {
      if ( v10 == *a1 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve_for_push(a1, a1[2]);
        v9 = a1[1];
        v10 = a1[2];
      }
      *(_BYTE *)(v9 + v10++) = v11;
      a1[2] = v10;
    }
    goto LABEL_31;
  }
  v10 = 0LL;
LABEL_31:
  if ( *a1 - v10 < a3 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle(a1, v10, a3);
    v9 = a1[1];
    v10 = a1[2];
  }
  result = memcpy((void *)(v10 + v9), a2, a3);
  a1[2] = a3 + v10;
  return result;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (0000000000035930) ----------------------------------------------------
__int64 __fastcall <&T as core::fmt::Debug>::fmt(unsigned __int64 **a1, __int64 a2)
{
  unsigned __int64 *v2; // rdi
  int v3; // eax

  v2 = *a1;
  v3 = *(_DWORD *)(a2 + 52);
  if ( (v3 & 0x10) != 0 )
    return core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt(v2, a2);
  if ( (v3 & 0x20) != 0 )
    return core::fmt::num::<impl core::fmt::UpperHex for usize>::fmt(v2, a2);
  return core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt(v2, a2);
}

//----- (0000000000035960) ----------------------------------------------------
__int64 __fastcall core::ptr::drop_in_place<gimli::read::abbrev::Attributes>(_QWORD *a1)
{
  __int64 v1; // rsi
  __int64 result; // rax

  if ( *a1 )
  {
    v1 = a1[1];
    if ( v1 )
      return _rust_dealloc(a1[2], 16 * v1, 8LL);
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);

//----- (0000000000035990) ----------------------------------------------------
__int64 __fastcall alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::KV>::split(
        __int64 a1,
        _QWORD *a2)
{
  __int64 v3; // rax
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // rdi
  unsigned __int64 v7; // rbp
  __int64 v8; // rsi
  __int64 v9; // r13
  void *v10; // rbx
  __int64 v11; // rax
  __int64 result; // rax
  __int64 v13; // [rsp+8h] [rbp-110h]
  __int64 v14; // [rsp+10h] [rbp-108h]
  __int64 v15; // [rsp+18h] [rbp-100h]
  __int128 v17; // [rsp+90h] [rbp-88h]
  __int128 v18; // [rsp+A0h] [rbp-78h]
  __int128 v19; // [rsp+B0h] [rbp-68h]
  __int128 v20; // [rsp+C0h] [rbp-58h]
  __int128 v21; // [rsp+D0h] [rbp-48h]
  __int64 v22; // [rsp+E0h] [rbp-38h]

  v3 = _rust_alloc(1336LL, 8LL);
  if ( !v3 )
    alloc::alloc::handle_alloc_error(8LL, 1336LL);
  *(_QWORD *)(v3 + 1232) = 0LL;
  v4 = *a2;
  v5 = a2[2];
  v6 = *(unsigned __int16 *)(*a2 + 1330LL);
  v7 = v6 + ~v5;
  *(_WORD *)(v3 + 1330) = v7;
  v15 = *(_QWORD *)(v4 + 112 * v5);
  v13 = *(_QWORD *)(v4 + 112 * v5 + 8);
  v14 = *(_QWORD *)(v4 + 112 * v5 + 16);
  v22 = *(_QWORD *)(v4 + 112 * v5 + 104);
  v21 = *(_OWORD *)(v4 + 112 * v5 + 88);
  v20 = *(_OWORD *)(v4 + 112 * v5 + 72);
  v19 = *(_OWORD *)(v4 + 112 * v5 + 56);
  v18 = *(_OWORD *)(v4 + 112 * v5 + 40);
  v17 = *(_OWORD *)(v4 + 112 * v5 + 24);
  if ( v7 > 0xB )
    core::slice::index::slice_end_index_len_fail(v6 + ~v5, 11LL, (__int64)&off_59630);
  v8 = *(_QWORD *)(v4 + 8 * v5 + 1240);
  v9 = v5 + 1;
  if ( v6 - (v5 + 1) != v7 )
    core::panicking::panic((__int64)aAssertionFaile_5, 40LL, (__int64)&off_59618);
  v10 = (void *)v3;
  memcpy((void *)(v3 + 1240), (const void *)(v4 + 1240 + 8 * v9), 8 * v7);
  memcpy(v10, (const void *)(v4 + 112 * v9), 112 * v7);
  *(_WORD *)(v4 + 1330) = v5;
  v11 = a2[1];
  *(_QWORD *)(a1 + 120) = v4;
  *(_QWORD *)(a1 + 128) = v11;
  *(_QWORD *)a1 = v8;
  *(_QWORD *)(a1 + 8) = v15;
  *(_QWORD *)(a1 + 16) = v13;
  *(_QWORD *)(a1 + 24) = v14;
  *(_OWORD *)(a1 + 32) = v17;
  *(_OWORD *)(a1 + 48) = v18;
  *(_OWORD *)(a1 + 64) = v19;
  *(_OWORD *)(a1 + 80) = v20;
  *(_OWORD *)(a1 + 96) = v21;
  result = v22;
  *(_QWORD *)(a1 + 112) = v22;
  *(_QWORD *)(a1 + 136) = v10;
  *(_QWORD *)(a1 + 144) = 0LL;
  return result;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 59618: using guessed type char *off_59618;
// 59630: using guessed type char *off_59630;

//----- (0000000000035C60) ----------------------------------------------------
__int64 __fastcall alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Internal>,alloc::collections::btree::node::marker::KV>::split(
        __int64 a1,
        _QWORD *a2)
{
  __int64 v3; // r15
  __int64 v4; // rax
  _WORD *v5; // rbx
  __int64 v6; // r13
  __int64 v7; // rax
  unsigned __int64 v8; // r14
  __int64 v9; // rbp
  unsigned __int64 v10; // r14
  __int64 v11; // rdi
  __int64 result; // rax
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdx
  __int64 v15; // rsi
  __int64 v16; // [rsp+0h] [rbp-118h]
  __int64 v17; // [rsp+8h] [rbp-110h]
  __int64 v18; // [rsp+10h] [rbp-108h]
  __int64 v19; // [rsp+18h] [rbp-100h]
  __int64 v20; // [rsp+28h] [rbp-F0h]
  __int128 v21; // [rsp+90h] [rbp-88h]
  __int128 v22; // [rsp+A0h] [rbp-78h]
  __int128 v23; // [rsp+B0h] [rbp-68h]
  __int128 v24; // [rsp+C0h] [rbp-58h]
  __int128 v25; // [rsp+D0h] [rbp-48h]
  __int64 v26; // [rsp+E0h] [rbp-38h]

  v3 = *a2;
  v20 = *(unsigned __int16 *)(*a2 + 1330LL);
  v4 = _rust_alloc(1432LL, 8LL);
  if ( !v4 )
    alloc::alloc::handle_alloc_error(8LL, 1432LL);
  v5 = (_WORD *)v4;
  *(_QWORD *)(v4 + 1232) = 0LL;
  v6 = a2[2];
  v7 = *(unsigned __int16 *)(v3 + 1330);
  v8 = v7 + ~v6;
  v5[665] = v8;
  v17 = *(_QWORD *)(v3 + 112 * v6);
  v16 = *(_QWORD *)(v3 + 112 * v6 + 8);
  v18 = *(_QWORD *)(v3 + 112 * v6 + 16);
  v26 = *(_QWORD *)(v3 + 112 * v6 + 104);
  v25 = *(_OWORD *)(v3 + 112 * v6 + 88);
  v24 = *(_OWORD *)(v3 + 112 * v6 + 72);
  v23 = *(_OWORD *)(v3 + 112 * v6 + 56);
  v22 = *(_OWORD *)(v3 + 112 * v6 + 40);
  v21 = *(_OWORD *)(v3 + 112 * v6 + 24);
  if ( v8 > 0xB )
    core::slice::index::slice_end_index_len_fail(v8, 11LL, (__int64)&off_59630);
  v19 = *(_QWORD *)(v3 + 8 * v6 + 1240);
  v9 = v6 + 1;
  if ( v7 - (v6 + 1) != v8 )
    core::panicking::panic((__int64)aAssertionFaile_5, 40LL, (__int64)&off_59618);
  memcpy(v5 + 620, (const void *)(v3 + 1240 + 8 * v9), 8 * v8);
  memcpy(v5, (const void *)(v3 + 112 * v9), 112 * v8);
  *(_WORD *)(v3 + 1330) = v6;
  v10 = (unsigned __int16)v5[665];
  v11 = v10 + 1;
  if ( v10 >= 0xC )
    core::slice::index::slice_end_index_len_fail(v11, 12LL, (__int64)&off_59648);
  if ( v20 - v6 != v11 )
    core::panicking::panic((__int64)aAssertionFaile_5, 40LL, (__int64)&off_59618);
  memcpy(v5 + 668, (const void *)(v3 + 8 * v9 + 1336), 8 * (v20 - v6));
  result = a2[1];
  v13 = 0LL;
  do
  {
    v14 = v13;
    v13 += v13 < v10;
    v15 = *(_QWORD *)&v5[4 * v14 + 668];
    *(_QWORD *)(v15 + 1232) = v5;
    *(_WORD *)(v15 + 1328) = v14;
  }
  while ( v14 < v10 && v13 <= v10 );
  *(_QWORD *)(a1 + 120) = v3;
  *(_QWORD *)(a1 + 128) = result;
  *(_QWORD *)a1 = v19;
  *(_QWORD *)(a1 + 8) = v17;
  *(_QWORD *)(a1 + 16) = v16;
  *(_QWORD *)(a1 + 24) = v18;
  *(_OWORD *)(a1 + 32) = v21;
  *(_OWORD *)(a1 + 48) = v22;
  *(_OWORD *)(a1 + 64) = v23;
  *(_OWORD *)(a1 + 80) = v24;
  *(_OWORD *)(a1 + 96) = v25;
  *(_QWORD *)(a1 + 112) = v26;
  *(_QWORD *)(a1 + 136) = v5;
  *(_QWORD *)(a1 + 144) = result;
  return result;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 59618: using guessed type char *off_59618;
// 59630: using guessed type char *off_59630;
// 59648: using guessed type char *off_59648;

//----- (0000000000035FE0) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 result; // rax

  if ( !a2 )
  {
    a1[1] = 0LL;
    goto LABEL_10;
  }
  if ( a4[1] )
  {
    v6 = a4[2];
    if ( v6 )
    {
      v7 = _rust_realloc(*a4, v6, a2, a3);
      if ( v7 )
        goto LABEL_5;
      goto LABEL_8;
    }
  }
  if ( !a3 )
  {
    v7 = a2;
    goto LABEL_5;
  }
  v7 = _rust_alloc(a3, a2);
  if ( !v7 )
  {
LABEL_8:
    a1[1] = a2;
    a1[2] = a3;
LABEL_10:
    result = 1LL;
    goto LABEL_11;
  }
LABEL_5:
  a1[1] = v7;
  a1[2] = a3;
  result = 0LL;
LABEL_11:
  *a1 = result;
  return result;
}
// 36069: conditional instruction was optimized away because r15.8!=0
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000036070) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 >> 59 == 0);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 16 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 16 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (0000000000036130) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+8h] [rbp-40h] BYREF
  __int64 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+18h] [rbp-30h]
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( a2 == -1 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 4LL;
  if ( v2 >= 5 )
    v4 = v2;
  v5 = 8 * (unsigned int)(v2 < 0x124924924924925LL);
  if ( v3 )
  {
    v11[0] = a1[1];
    v11[2] = 112 * v3;
    v6 = 8LL;
  }
  else
  {
    v6 = 0LL;
  }
  v11[1] = v6;
  alloc::raw_vec::finish_grow(&v8, v5, 112 * v4, v11);
  if ( v8 )
  {
    if ( v9 )
      alloc::alloc::handle_alloc_error(v9, v10);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v9;
  a1[1] = v9;
  *a1 = v4;
  return result;
}

//----- (00000000000361F0) ----------------------------------------------------
__int64 __fastcall gimli::read::abbrev::Abbreviations::insert(__int64 *a1, __int64 *a2)
{
  unsigned __int64 v3; // rbp
  __int64 v4; // rsi
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // r10
  __int64 v9; // r8
  char v10; // r11
  bool v11; // cf
  __int64 v12; // r15
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 i; // r12
  __int64 v16; // rax
  unsigned __int64 v17; // r14
  __int64 v18; // rsi
  unsigned __int64 v19; // r13
  char v20; // r8
  __int64 v21; // r13
  __int64 v22; // r14
  __int64 v23; // r15
  __int64 *v24; // rbx
  __int64 v25; // rax
  __int64 v26; // rcx
  __int128 v27; // xmm1
  __int128 v28; // xmm2
  __int128 v29; // xmm3
  __int64 v30; // r13
  __int64 v31; // r14
  __int64 v32; // r15
  __int64 v33; // rax
  __int128 v34; // xmm1
  __int128 v35; // xmm2
  __int128 v36; // xmm3
  __int64 v38; // r10
  __int64 v39; // r8
  __int64 v40; // rdx
  __int64 *v41; // rbx
  __int64 v42; // rax
  __int64 v43; // r14
  unsigned __int64 *v44; // rsi
  __int64 v45; // r15
  __int128 v46; // xmm0
  __int128 v47; // xmm1
  __int128 v48; // xmm2
  __int64 v49; // r12
  unsigned __int16 v50; // r8
  unsigned __int64 *v51; // rsi
  unsigned __int64 v52; // r14
  __int128 v53; // xmm0
  __int128 v54; // xmm1
  __int128 v55; // xmm2
  __int128 v56; // xmm0
  __int128 v57; // xmm1
  __int128 v58; // xmm2
  __int64 v59; // rcx
  __int128 v60; // xmm1
  __int128 v61; // xmm2
  __int128 v62; // xmm3
  __int128 v63; // xmm0
  __int128 v64; // xmm1
  __int128 v65; // xmm2
  __int64 v66; // rax
  __int128 v67; // xmm1
  __int128 v68; // xmm2
  __int128 v69; // xmm3
  __int64 v70; // r9
  __int64 v71; // rbp
  size_t v72; // r12
  __int64 v73; // rcx
  __int64 v74; // rax
  void *v75; // r8
  __int64 v76; // r14
  __int64 v77; // rbx
  _QWORD *v78; // r13
  __int64 v79; // rax
  __int64 v80; // rdx
  __int64 v81; // rcx
  __int128 v82; // xmm1
  __int128 v83; // xmm2
  __int128 v84; // xmm3
  unsigned __int64 v85; // r14
  unsigned __int64 v86; // r13
  __int64 v87; // rbx
  __int128 v88; // xmm1
  __int128 v89; // xmm2
  __int128 v90; // xmm3
  __int64 v91; // rbx
  __int64 v92; // rbx
  unsigned __int64 v93; // r12
  unsigned __int64 v94; // rbp
  unsigned __int64 v95; // r9
  __int64 v96; // r13
  __int128 v97; // xmm1
  __int128 v98; // xmm2
  __int128 v99; // xmm3
  __int64 v100; // rax
  __int128 v101; // xmm1
  __int128 v102; // xmm2
  __int128 v103; // xmm3
  unsigned __int64 v104; // rax
  int v105; // r12d
  __int64 k; // rdx
  __int64 v107; // rsi
  __int64 v108; // rcx
  __int64 v109; // rcx
  __int64 v110; // rcx
  __int64 v111; // rcx
  __int128 v112; // xmm1
  __int128 v113; // xmm2
  __int128 v114; // xmm3
  unsigned __int16 v115; // cx
  int v116; // ebx
  __int64 v117; // rax
  __int64 *v118; // rdx
  __int64 v119; // rsi
  __int64 v120; // rax
  __int64 v121; // rax
  __int64 v122; // rax
  __int64 v123; // r8
  __int64 v124; // rbx
  __int64 v125; // rcx
  __int16 v126; // dx
  unsigned __int64 v127; // r15
  _QWORD *v128; // rsi
  __int64 v129; // rbp
  __int64 v130; // rax
  unsigned __int64 v131; // r12
  __int128 v132; // xmm1
  __int128 v133; // xmm2
  __int128 v134; // xmm3
  void *v135; // rbp
  char v136; // al
  unsigned __int64 v137; // r13
  int v138; // eax
  __int64 j; // rcx
  __int64 v140; // rsi
  __int64 v141; // rax
  __int64 v142; // rax
  __int64 v143; // rax
  __int64 v144; // rax
  __int64 v145; // [rsp+0h] [rbp-228h]
  __int64 v146; // [rsp+0h] [rbp-228h]
  __int64 v147; // [rsp+0h] [rbp-228h]
  __int64 v148; // [rsp+8h] [rbp-220h]
  __int64 v149; // [rsp+8h] [rbp-220h]
  __int64 v150; // [rsp+8h] [rbp-220h]
  __int64 v151; // [rsp+8h] [rbp-220h]
  __int64 v152; // [rsp+10h] [rbp-218h]
  __int64 v153; // [rsp+10h] [rbp-218h]
  void *v154; // [rsp+10h] [rbp-218h]
  __int64 *v155; // [rsp+18h] [rbp-210h]
  unsigned __int16 nb; // [rsp+20h] [rbp-208h]
  size_t n; // [rsp+20h] [rbp-208h]
  size_t na; // [rsp+20h] [rbp-208h]
  __int128 v159; // [rsp+30h] [rbp-1F8h] BYREF
  __int128 v160; // [rsp+40h] [rbp-1E8h]
  __int128 v161; // [rsp+50h] [rbp-1D8h]
  __int128 v162; // [rsp+60h] [rbp-1C8h]
  __int128 v163; // [rsp+70h] [rbp-1B8h]
  __int64 v164; // [rsp+80h] [rbp-1A8h]
  __int64 v165; // [rsp+88h] [rbp-1A0h]
  __int128 v166; // [rsp+90h] [rbp-198h]
  __int128 v167; // [rsp+A0h] [rbp-188h]
  __int128 v168; // [rsp+B0h] [rbp-178h]
  __int128 v169; // [rsp+C0h] [rbp-168h]
  __int128 v170; // [rsp+D0h] [rbp-158h]
  __int64 v171; // [rsp+E0h] [rbp-148h]
  __int128 v172; // [rsp+F0h] [rbp-138h] BYREF
  __int128 v173; // [rsp+100h] [rbp-128h]
  __int128 v174; // [rsp+110h] [rbp-118h]
  __int128 v175; // [rsp+120h] [rbp-108h]
  __int128 v176; // [rsp+130h] [rbp-F8h]
  __int128 v177; // [rsp+140h] [rbp-E8h]
  __int128 v178; // [rsp+150h] [rbp-D8h]
  __int64 v179; // [rsp+160h] [rbp-C8h]
  __int64 v180; // [rsp+168h] [rbp-C0h]
  __int64 v181; // [rsp+170h] [rbp-B8h]
  void *src; // [rsp+178h] [rbp-B0h]
  __int64 v183; // [rsp+180h] [rbp-A8h]
  __int64 v184; // [rsp+190h] [rbp-98h]
  size_t v185; // [rsp+198h] [rbp-90h]
  __int128 v186; // [rsp+1A0h] [rbp-88h] BYREF
  __int128 v187; // [rsp+1B0h] [rbp-78h]
  __int128 v188; // [rsp+1C0h] [rbp-68h]
  __int128 v189; // [rsp+1D0h] [rbp-58h]
  __int128 v190; // [rsp+1E0h] [rbp-48h]
  __int64 v191; // [rsp+1F0h] [rbp-38h]

  v3 = a2[12];
  v4 = v3 - 1;
  if ( v3 - 1 >= a1[2] )
  {
    if ( v3 - 1 == a1[2] )
    {
      if ( a1[5] )
      {
        v6 = a1[3];
        if ( v6 )
        {
          v7 = a1[4];
          while ( 1 )
          {
            v8 = 8 * (unsigned int)*(unsigned __int16 *)(v6 + 1330);
            v9 = -1LL;
            do
            {
              if ( !v8 )
              {
                v9 = *(unsigned __int16 *)(v6 + 1330);
                goto LABEL_17;
              }
              v10 = *(_QWORD *)(v6 + 8 * v9 + 1248) != v3;
              if ( *(_QWORD *)(v6 + 8 * v9 + 1248) > v3 )
                v10 = -1;
              ++v9;
              v8 -= 8LL;
            }
            while ( v10 == 1 );
            if ( !v10 )
              goto LABEL_2;
LABEL_17:
            v11 = v7-- == 0;
            if ( v11 )
              break;
            v6 = *(_QWORD *)(v6 + 8 * v9 + 1336);
          }
        }
      }
      v21 = *a2;
      v22 = a2[1];
      v23 = a2[2];
      if ( v4 == *a1 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve_for_push(a1, v4);
        v4 = a1[2];
      }
      v24 = a2 + 3;
      v25 = a1[1];
      v26 = 112 * v4;
      *(_QWORD *)(v25 + v26) = v21;
      *(_QWORD *)(v25 + v26 + 8) = v22;
      *(_QWORD *)(v25 + v26 + 16) = v23;
      v27 = *((_OWORD *)v24 + 1);
      v28 = *((_OWORD *)v24 + 2);
      v29 = *((_OWORD *)v24 + 3);
      *(_OWORD *)(v25 + v26 + 24) = *(_OWORD *)v24;
      *(_OWORD *)(v25 + v26 + 40) = v27;
      *(_OWORD *)(v25 + v26 + 56) = v28;
      *(_OWORD *)(v25 + v26 + 72) = v29;
      *(_OWORD *)(v25 + v26 + 88) = *((_OWORD *)v24 + 4);
      *(_QWORD *)(v25 + v26 + 104) = v24[10];
      a1[2] = v4 + 1;
      goto LABEL_36;
    }
    v12 = a1[3];
    if ( !v12 )
    {
      v30 = *a2;
      v31 = a2[1];
      v32 = a2[2];
      v33 = _rust_alloc(1336LL, 8LL);
      if ( !v33 )
        alloc::alloc::handle_alloc_error(8LL, 1336LL);
      *(_QWORD *)(v33 + 1232) = 0LL;
      v34 = *(_OWORD *)(a2 + 5);
      v35 = *(_OWORD *)(a2 + 7);
      v36 = *(_OWORD *)(a2 + 9);
      *(_OWORD *)(v33 + 24) = *(_OWORD *)(a2 + 3);
      *(_OWORD *)(v33 + 40) = v34;
      *(_OWORD *)(v33 + 56) = v35;
      *(_OWORD *)(v33 + 72) = v36;
      *(_OWORD *)(v33 + 88) = *(_OWORD *)(a2 + 11);
      *(_QWORD *)(v33 + 104) = a2[13];
      *(_WORD *)(v33 + 1330) = 1;
      *(_QWORD *)(v33 + 1240) = v3;
      *(_QWORD *)v33 = v30;
      *(_QWORD *)(v33 + 8) = v31;
      *(_QWORD *)(v33 + 16) = v32;
      a1[3] = v33;
      a1[4] = 0LL;
      a1[5] = 1LL;
      goto LABEL_36;
    }
    v13 = a1[4];
    v14 = v13;
    for ( i = a1[3]; ; i = *(_QWORD *)(i + 8 * v19 + 1336) )
    {
      v16 = i + 1240;
      v17 = *(unsigned __int16 *)(i + 1330);
      v18 = 8 * (unsigned int)*(unsigned __int16 *)(i + 1330);
      v19 = -1LL;
      do
      {
        if ( !v18 )
        {
          v19 = *(unsigned __int16 *)(i + 1330);
          goto LABEL_29;
        }
        v20 = *(_QWORD *)(i + 8 * v19 + 1248) != v3;
        if ( *(_QWORD *)(i + 8 * v19 + 1248) > v3 )
          v20 = -1;
        ++v19;
        v18 -= 8LL;
      }
      while ( v20 == 1 );
      if ( !v20 )
        goto LABEL_2;
LABEL_29:
      v11 = v14-- == 0;
      if ( v11 )
        break;
    }
    v38 = *a2;
    v39 = a2[1];
    v40 = a2[2];
    v41 = a2 + 3;
    if ( (unsigned __int16)v17 <= 0xAu )
    {
      v44 = (unsigned __int64 *)(v16 + 8 * v19);
      v45 = v17 - v19;
      if ( v17 <= v19 )
      {
        *v44 = v3;
        v171 = v41[10];
        v170 = *((_OWORD *)v41 + 4);
        v56 = *(_OWORD *)v41;
        v57 = *((_OWORD *)v41 + 1);
        v58 = *((_OWORD *)v41 + 2);
        v169 = *((_OWORD *)v41 + 3);
        v168 = v58;
        v167 = v57;
        v166 = v56;
      }
      else
      {
        v153 = v40;
        v146 = v39;
        v149 = v38;
        memmove((void *)(v16 + 8 * v19 + 8), v44, 8 * v45);
        *(_QWORD *)(i + 8 * v19 + 1240) = v3;
        v171 = v41[10];
        v170 = *((_OWORD *)v41 + 4);
        v46 = *(_OWORD *)v41;
        v47 = *((_OWORD *)v41 + 1);
        v48 = *((_OWORD *)v41 + 2);
        v169 = *((_OWORD *)v41 + 3);
        v168 = v48;
        v167 = v47;
        v166 = v46;
        memmove((void *)(i + 112 * v19 + 112), (const void *)(i + 112 * v19), 112 * v45);
        v38 = v149;
        v40 = v153;
        v39 = v146;
      }
      v59 = 112 * v19;
      *(_QWORD *)(i + v59) = v38;
      *(_QWORD *)(i + v59 + 8) = v39;
      *(_QWORD *)(i + v59 + 16) = v40;
      v60 = v167;
      v61 = v168;
      v62 = v169;
      *(_OWORD *)(i + v59 + 24) = v166;
      *(_OWORD *)(i + v59 + 40) = v60;
      *(_OWORD *)(i + v59 + 56) = v61;
      *(_OWORD *)(i + v59 + 72) = v62;
      *(_OWORD *)(i + v59 + 88) = v170;
      *(_QWORD *)(i + v59 + 104) = v171;
      *(_WORD *)(i + 1330) = v17 + 1;
      goto LABEL_57;
    }
    v159 = (unsigned __int64)i;
    v42 = 4LL;
    v155 = a1;
    v145 = v39;
    v152 = v40;
    v148 = v38;
    if ( v19 < 5 || (v42 = v19, v19 == 5) )
    {
      v184 = v13;
      *(_QWORD *)&v160 = v42;
      v43 = 120LL;
      alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::KV>::split(
        (__int64)&v172,
        &v159);
    }
    else
    {
      v184 = v13;
      if ( v19 == 6 )
      {
        *(_QWORD *)&v160 = 5LL;
        alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::KV>::split(
          (__int64)&v172,
          &v159);
        v43 = 136LL;
        v19 = 0LL;
      }
      else
      {
        *(_QWORD *)&v160 = 6LL;
        alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::KV>::split(
          (__int64)&v172,
          &v159);
        v19 -= 7LL;
        v43 = 136LL;
      }
    }
    v49 = *(_QWORD *)((char *)&v172 + v43);
    v50 = *(_WORD *)(v49 + 1330);
    v51 = (unsigned __int64 *)(v49 + 8 * v19 + 1240);
    v52 = v50 - v19;
    if ( v50 <= v19 )
    {
      *v51 = v3;
      v171 = v41[10];
      v170 = *((_OWORD *)v41 + 4);
      v63 = *(_OWORD *)v41;
      v64 = *((_OWORD *)v41 + 1);
      v65 = *((_OWORD *)v41 + 2);
      v169 = *((_OWORD *)v41 + 3);
      v168 = v65;
      v167 = v64;
      v166 = v63;
    }
    else
    {
      nb = *(_WORD *)(v49 + 1330);
      memmove((void *)(v49 + 1240 + 8 * v19 + 8), v51, 8 * v52);
      *(_QWORD *)(v49 + 8 * v19 + 1240) = v3;
      v171 = v41[10];
      v170 = *((_OWORD *)v41 + 4);
      v53 = *(_OWORD *)v41;
      v54 = *((_OWORD *)v41 + 1);
      v55 = *((_OWORD *)v41 + 2);
      v169 = *((_OWORD *)v41 + 3);
      v168 = v55;
      v167 = v54;
      v166 = v53;
      memmove((void *)(v49 + 112 * v19 + 112), (const void *)(v49 + 112 * v19), 112 * v52);
      v50 = nb;
    }
    v66 = 112 * v19;
    *(_QWORD *)(v49 + v66) = v148;
    *(_QWORD *)(v49 + v66 + 8) = v145;
    *(_QWORD *)(v49 + v66 + 16) = v152;
    v67 = v167;
    v68 = v168;
    v69 = v169;
    *(_OWORD *)(v49 + v66 + 24) = v166;
    *(_OWORD *)(v49 + v66 + 40) = v67;
    *(_OWORD *)(v49 + v66 + 56) = v68;
    *(_OWORD *)(v49 + v66 + 72) = v69;
    *(_OWORD *)(v49 + v66 + 88) = v170;
    *(_QWORD *)(v49 + v66 + 104) = v171;
    *(_WORD *)(v49 + 1330) = v50 + 1;
    v70 = v172;
    v71 = *((_QWORD *)&v173 + 1);
    v72 = v173;
    v186 = v174;
    v187 = v175;
    v188 = v176;
    v189 = v177;
    v190 = v178;
    v191 = v179;
    if ( *((_QWORD *)&v172 + 1) == 2LL )
    {
LABEL_57:
      ++a1[5];
LABEL_36:
      LODWORD(v3) = 0;
      return (unsigned int)v3;
    }
    v147 = *((_QWORD *)&v172 + 1);
    v73 = v180;
    v74 = v181;
    v75 = src;
    v76 = v183;
    v164 = v191;
    v163 = v190;
    v162 = v189;
    v161 = v188;
    v160 = v187;
    v159 = v186;
    v77 = *(_QWORD *)(v180 + 1232);
    if ( !v77 )
    {
      v78 = src;
LABEL_54:
      v150 = v70;
      v79 = _rust_alloc(1432LL, 8LL);
      if ( !v79 )
        alloc::alloc::handle_alloc_error(8LL, 1432LL);
      *(_QWORD *)(v79 + 1232) = 0LL;
      *(_WORD *)(v79 + 1330) = 0;
      *(_QWORD *)(v79 + 1336) = v12;
      v80 = v184;
      v81 = v184 + 1;
      *(_QWORD *)(v12 + 1232) = v79;
      *(_WORD *)(v12 + 1328) = 0;
      a1[3] = v79;
      a1[4] = v81;
      if ( v80 != v76 )
        core::panicking::panic((__int64)aAssertionFaile_4, 48LL, (__int64)&off_59600);
      *(_WORD *)(v79 + 1330) = 1;
      *(_QWORD *)(v79 + 1240) = v150;
      *(_QWORD *)v79 = v147;
      *(_QWORD *)(v79 + 8) = v72;
      *(_QWORD *)(v79 + 16) = v71;
      v82 = v160;
      v83 = v161;
      v84 = v162;
      *(_OWORD *)(v79 + 24) = v159;
      *(_OWORD *)(v79 + 40) = v82;
      *(_OWORD *)(v79 + 56) = v83;
      *(_OWORD *)(v79 + 72) = v84;
      *(_OWORD *)(v79 + 88) = v163;
      *(_QWORD *)(v79 + 104) = v164;
      *(_QWORD *)(v79 + 1344) = v78;
      v78[154] = v79;
      *((_WORD *)v78 + 664) = 1;
      goto LABEL_57;
    }
    while ( 1 )
    {
      if ( v74 != v76 )
        core::panicking::panic((__int64)aAssertionFaile_6, 53LL, (__int64)&off_59660);
      v85 = *(unsigned __int16 *)(v73 + 1328);
      v86 = *(unsigned __int16 *)(v77 + 1330);
      v154 = v75;
      if ( v86 < 0xB )
      {
        v165 = v71;
        na = v72;
        v126 = v86 + 1;
        v127 = v85 + 1;
        v128 = (_QWORD *)(v77 + 8 * v85 + 1240);
        if ( (unsigned __int16)v85 >= (unsigned __int16)v86 )
        {
          *v128 = v70;
          *(_QWORD *)&v177 = v164;
          v176 = v163;
          v175 = v162;
          v174 = v161;
          v173 = v160;
          v172 = v159;
        }
        else
        {
          v129 = v70;
          memmove((void *)(v77 + 1240 + 8 * v127), v128, 8 * (v86 - v85));
          *(_QWORD *)(v77 + 8 * v85 + 1240) = v129;
          *(_QWORD *)&v177 = v164;
          v176 = v163;
          v175 = v162;
          v174 = v161;
          v173 = v160;
          v172 = v159;
          memmove((void *)(v77 + 112 * v127), (const void *)(v77 + 112 * v85), 112 * (v86 - v85));
          v126 = v86 + 1;
          v75 = v154;
        }
        v130 = 112 * v85;
        v131 = v86 + 2;
        *(_QWORD *)(v77 + v130) = v147;
        *(_QWORD *)(v77 + v130 + 8) = na;
        *(_QWORD *)(v77 + v130 + 16) = v165;
        v132 = v173;
        v133 = v174;
        v134 = v175;
        *(_OWORD *)(v77 + v130 + 24) = v172;
        *(_OWORD *)(v77 + v130 + 40) = v132;
        *(_OWORD *)(v77 + v130 + 56) = v133;
        *(_OWORD *)(v77 + v130 + 72) = v134;
        *(_OWORD *)(v77 + v130 + 88) = v176;
        *(_QWORD *)(v77 + v130 + 104) = v177;
        if ( (unsigned __int16)v85 < (unsigned __int16)v86 )
        {
          v135 = v75;
          memmove((void *)(v77 + 1336 + 8 * v85 + 16), (const void *)(v77 + 1336 + 8 * v127), 8 * (v86 - v85));
          v126 = v86 + 1;
          v75 = v135;
        }
        *(_QWORD *)(v77 + 8 * v85 + 1344) = v75;
        *(_WORD *)(v77 + 1330) = v126;
        a1 = v155;
        if ( v127 < v131 )
        {
          v136 = v86 - v85 + 1;
          v137 = v86 - v85;
          v138 = v136 & 3;
          if ( v138 )
          {
            for ( j = 0LL; j != v138; *(_WORD *)(v140 + 1328) = v127 + j++ )
            {
              v140 = *(_QWORD *)(v77 + 8 * v85 + 1344 + 8 * j);
              *(_QWORD *)(v140 + 1232) = v77;
            }
            v127 += j;
          }
          if ( v137 >= 3 )
          {
            do
            {
              v141 = *(_QWORD *)(v77 + 8 * v127 + 1336);
              *(_QWORD *)(v141 + 1232) = v77;
              *(_WORD *)(v141 + 1328) = v127;
              v142 = *(_QWORD *)(v77 + 8 * v127 + 1344);
              *(_QWORD *)(v142 + 1232) = v77;
              *(_WORD *)(v142 + 1328) = v127 + 1;
              v143 = *(_QWORD *)(v77 + 8 * v127 + 1352);
              *(_QWORD *)(v143 + 1232) = v77;
              *(_WORD *)(v143 + 1328) = v127 + 2;
              v144 = *(_QWORD *)(v77 + 8 * v127 + 1360);
              *(_QWORD *)(v144 + 1232) = v77;
              *(_WORD *)(v144 + 1328) = v127 + 3;
              v127 += 4LL;
            }
            while ( v127 != v131 );
          }
        }
        goto LABEL_57;
      }
      *(_QWORD *)&v186 = v77;
      *((_QWORD *)&v186 + 1) = v74 + 1;
      v151 = v70;
      if ( (unsigned __int16)v85 < 5u )
        break;
      if ( v85 == 5 )
      {
        *(_QWORD *)&v187 = 5LL;
        goto LABEL_69;
      }
      if ( (_DWORD)v85 != 6 )
      {
        *(_QWORD *)&v187 = 6LL;
        alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Internal>,alloc::collections::btree::node::marker::KV>::split(
          (__int64)&v172,
          &v186);
        v85 -= 7LL;
        v91 = 136LL;
LABEL_70:
        v165 = v71;
        n = v72;
        v92 = *(_QWORD *)((char *)&v172 + v91);
        v93 = *(unsigned __int16 *)(v92 + 1330);
        v94 = v85 + 1;
        v95 = v93 - v85;
        if ( v93 <= v85 )
        {
          *(_QWORD *)(v92 + 8 * v85 + 1240) = v151;
          v100 = 112 * v85;
          *(_QWORD *)(v92 + v100) = v147;
          *(_QWORD *)(v92 + v100 + 8) = n;
          *(_QWORD *)(v92 + v100 + 16) = v165;
          v101 = v160;
          v102 = v161;
          v103 = v162;
          *(_OWORD *)(v92 + v100 + 24) = v159;
          *(_OWORD *)(v92 + v100 + 40) = v101;
          *(_OWORD *)(v92 + v100 + 56) = v102;
          *(_OWORD *)(v92 + v100 + 72) = v103;
          *(_OWORD *)(v92 + v100 + 88) = v163;
          *(_QWORD *)(v92 + v100 + 104) = v164;
        }
        else
        {
          v185 = 8 * v95;
          memmove((void *)(v92 + 1240 + 8 * v94), (const void *)(v92 + 8 * v85 + 1240), 8 * v95);
          *(_QWORD *)(v92 + 8 * v85 + 1240) = v151;
          v96 = 112 * v85;
          memmove((void *)(v92 + 112 * v94), (const void *)(v92 + 112 * v85), 112 * (v93 - v85));
          *(_QWORD *)(v92 + 112 * v85) = v147;
          *(_QWORD *)(v92 + v96 + 8) = n;
          *(_QWORD *)(v92 + v96 + 16) = v165;
          v97 = v160;
          v98 = v161;
          v99 = v162;
          *(_OWORD *)(v92 + v96 + 24) = v159;
          *(_OWORD *)(v92 + v96 + 40) = v97;
          *(_OWORD *)(v92 + v96 + 56) = v98;
          *(_OWORD *)(v92 + v96 + 72) = v99;
          *(_OWORD *)(v92 + v96 + 88) = v163;
          *(_QWORD *)(v92 + v96 + 104) = v164;
          memmove((void *)(v92 + 8 * v85 + 1352), (const void *)(v92 + 8 * v94 + 1336), v185);
          v95 = v93 - v85;
        }
        a1 = v155;
        v104 = v93 + 2;
        *(_QWORD *)(v92 + 8 * v85 + 1344) = v154;
        *(_WORD *)(v92 + 1330) = v93 + 1;
        if ( v94 < v93 + 2 )
        {
          v105 = ((_BYTE)v93 - (_BYTE)v85 + 1) & 3;
          if ( v105 )
          {
            for ( k = 0LL; k != v105; *(_WORD *)(v107 + 1328) = k++ + v94 )
            {
              v107 = *(_QWORD *)(v92 + 8 * v85 + 1344 + 8 * k);
              *(_QWORD *)(v107 + 1232) = v92;
            }
            v94 += k;
          }
          if ( v95 >= 3 )
          {
            do
            {
              v108 = *(_QWORD *)(v92 + 8 * v94 + 1336);
              *(_QWORD *)(v108 + 1232) = v92;
              *(_WORD *)(v108 + 1328) = v94;
              v109 = *(_QWORD *)(v92 + 8 * v94 + 1344);
              *(_QWORD *)(v109 + 1232) = v92;
              *(_WORD *)(v109 + 1328) = v94 + 1;
              v110 = *(_QWORD *)(v92 + 8 * v94 + 1352);
              *(_QWORD *)(v110 + 1232) = v92;
              *(_WORD *)(v110 + 1328) = v94 + 2;
              v111 = *(_QWORD *)(v92 + 8 * v94 + 1360);
              *(_QWORD *)(v111 + 1232) = v92;
              *(_WORD *)(v111 + 1328) = v94 + 3;
              v94 += 4LL;
            }
            while ( v94 != v104 );
          }
        }
        v70 = v172;
        v71 = *((_QWORD *)&v173 + 1);
        v72 = v173;
        v166 = v174;
        v167 = v175;
        v168 = v176;
        v169 = v177;
        v170 = v178;
        v171 = v179;
        v73 = v180;
        v74 = v181;
        v78 = src;
        v76 = v183;
        v147 = *((_QWORD *)&v172 + 1);
        if ( *((_QWORD *)&v172 + 1) == 2LL )
          goto LABEL_57;
        goto LABEL_59;
      }
      *(_QWORD *)&v187 = 5LL;
      alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Internal>,alloc::collections::btree::node::marker::KV>::split(
        (__int64)&v172,
        &v186);
      v78 = src;
      v87 = *((unsigned __int16 *)src + 665);
      if ( *((_WORD *)src + 665) )
      {
        memmove((char *)src + 1248, (char *)src + 1240, (unsigned int)(8 * v87));
        v78[155] = v151;
        memmove(v78 + 14, v78, 112 * v87);
        v88 = v160;
        v89 = v161;
        v90 = v162;
        *(_OWORD *)(v78 + 3) = v159;
        *(_OWORD *)(v78 + 5) = v88;
        *(_OWORD *)(v78 + 7) = v89;
        *(_OWORD *)(v78 + 9) = v90;
        *(_OWORD *)(v78 + 11) = v163;
        v78[13] = v164;
        memmove(v78 + 169, v78 + 168, (unsigned int)(8 * v87));
      }
      else
      {
        *((_QWORD *)src + 155) = v151;
        v112 = v160;
        v113 = v161;
        v114 = v162;
        *(_OWORD *)(v78 + 3) = v159;
        *(_OWORD *)(v78 + 5) = v112;
        *(_OWORD *)(v78 + 7) = v113;
        *(_OWORD *)(v78 + 9) = v114;
        *(_OWORD *)(v78 + 11) = v163;
        v78[13] = v164;
      }
      a1 = v155;
      v115 = v87;
      *v78 = v147;
      v78[1] = v72;
      v78[2] = v71;
      v78[168] = v154;
      *((_WORD *)v78 + 665) = v87 + 1;
      v116 = v87 + 1;
      v117 = 1LL;
      if ( v115 >= 3u )
      {
        v118 = v78 + 171;
        do
        {
          v119 = v117;
          v120 = *(v118 - 3);
          *(_QWORD *)(v120 + 1232) = v78;
          *(_WORD *)(v120 + 1328) = v119;
          v121 = *(v118 - 2);
          *(_QWORD *)(v121 + 1232) = v78;
          *(_WORD *)(v121 + 1328) = v119 + 1;
          v122 = *(v118 - 1);
          *(_QWORD *)(v122 + 1232) = v78;
          *(_WORD *)(v122 + 1328) = v119 + 2;
          v117 = v119 + 4;
          v123 = *v118;
          *(_QWORD *)(v123 + 1232) = v78;
          v119 += 3LL;
          *(_WORD *)(v123 + 1328) = v119;
          v118 += 4;
        }
        while ( v119 != (v116 & 0xFFFFFFFC) );
      }
      v124 = v116 & 3;
      if ( (_DWORD)v124 )
      {
        do
        {
          v125 = v78[v117 + 167];
          *(_QWORD *)(v125 + 1232) = v78;
          *(_WORD *)(v125 + 1328) = v117++;
          --v124;
        }
        while ( v124 );
      }
      v70 = v172;
      v71 = *((_QWORD *)&v173 + 1);
      v72 = v173;
      v166 = v174;
      v167 = v175;
      v168 = v176;
      v169 = v177;
      v170 = v178;
      v171 = v179;
      v73 = v180;
      v74 = v181;
      v76 = v183;
      v147 = *((_QWORD *)&v172 + 1);
      if ( *((_QWORD *)&v172 + 1) == 2LL )
        goto LABEL_57;
LABEL_59:
      v164 = v171;
      v163 = v170;
      v162 = v169;
      v161 = v168;
      v160 = v167;
      v159 = v166;
      v77 = *(_QWORD *)(v73 + 1232);
      v75 = v78;
      if ( !v77 )
        goto LABEL_54;
    }
    *(_QWORD *)&v187 = 4LL;
LABEL_69:
    v91 = 120LL;
    alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Internal>,alloc::collections::btree::node::marker::KV>::split(
      (__int64)&v172,
      &v186);
    goto LABEL_70;
  }
LABEL_2:
  LOBYTE(v3) = 1;
  if ( *a2 )
  {
    v5 = a2[1];
    if ( v5 )
      _rust_dealloc(a2[2], 16 * v5, 8LL);
  }
  return (unsigned int)v3;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 59600: using guessed type char *off_59600;
// 59660: using guessed type char *off_59660;

//----- (00000000000374E0) ----------------------------------------------------
__int64 __fastcall gimli::read::abbrev::Abbreviation::new(__int64 a1, __int64 a2, __int16 a3, char a4, _OWORD *a5)
{
  __int128 v5; // xmm1
  __int128 v6; // xmm2
  __int128 v7; // xmm3
  __int64 v9; // [rsp+0h] [rbp-48h] BYREF
  __int128 v10[4]; // [rsp+8h] [rbp-40h] BYREF

  v9 = a2;
  if ( !a2 )
  {
    *(_QWORD *)&v10[0] = 0LL;
    core::panicking::assert_failed((__int64)&v9, v10);
  }
  *(_QWORD *)(a1 + 96) = a2;
  *(_WORD *)(a1 + 104) = a3;
  *(_BYTE *)(a1 + 106) = a4;
  v5 = a5[1];
  v6 = a5[2];
  v7 = a5[3];
  *(_OWORD *)a1 = *a5;
  *(_OWORD *)(a1 + 16) = v5;
  *(_OWORD *)(a1 + 32) = v6;
  *(_OWORD *)(a1 + 48) = v7;
  *(_OWORD *)(a1 + 64) = a5[4];
  *(_OWORD *)(a1 + 80) = a5[5];
  return a1;
}
// 374E0: using guessed type __int128 var_40[4];

//----- (0000000000037570) ----------------------------------------------------
void __fastcall gimli::read::abbrev::Attributes::push(__int64 a1, _OWORD *a2)
{
  __int64 *v4; // r15
  __int64 v5; // rsi
  __int64 v6; // rdi
  _OWORD *v7; // rax
  __int128 v8; // xmm0
  __int128 v9; // xmm1
  __int128 v10; // xmm2
  __int64 v11; // rcx
  __int128 v12; // [rsp+8h] [rbp-30h] BYREF
  __int64 v13; // [rsp+18h] [rbp-20h]

  v4 = (__int64 *)(a1 + 8);
  if ( *(_QWORD *)a1 )
  {
    v5 = *(_QWORD *)(a1 + 24);
    if ( v5 == *(_QWORD *)(a1 + 8) )
    {
      alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)(a1 + 8), v5);
      v5 = *(_QWORD *)(a1 + 24);
    }
    *(_OWORD *)(*(_QWORD *)(a1 + 16) + 16 * v5) = *a2;
    *(_QWORD *)(a1 + 24) = v5 + 1;
  }
  else
  {
    v6 = *v4;
    if ( *v4 == 5 )
    {
      v7 = (_OWORD *)_rust_alloc(80LL, 8LL);
      if ( !v7 )
        alloc::alloc::handle_alloc_error(8LL, 80LL);
      v7[4] = *(_OWORD *)(a1 + 80);
      v8 = *(_OWORD *)(a1 + 16);
      v9 = *(_OWORD *)(a1 + 32);
      v10 = *(_OWORD *)(a1 + 48);
      v7[3] = *(_OWORD *)(a1 + 64);
      v7[2] = v10;
      v7[1] = v9;
      *v7 = v8;
      *(_QWORD *)&v12 = 5LL;
      *((_QWORD *)&v12 + 1) = v7;
      v13 = 5LL;
      alloc::raw_vec::RawVec<T,A>::reserve_for_push((__int64 *)&v12, 5LL);
      v11 = v13;
      *(_OWORD *)(*((_QWORD *)&v12 + 1) + 16 * v13) = *a2;
      v13 = v11 + 1;
      *(_QWORD *)a1 = 1LL;
      v4[2] = v13;
      *(_OWORD *)v4 = v12;
    }
    else
    {
      if ( (unsigned __int64)*v4 >= 5 )
        core::panicking::panic_bounds_check(v6, 5LL, (__int64)&off_59690);
      *(_OWORD *)(a1 + 16 * v6 + 16) = *a2;
      ++*(_QWORD *)(a1 + 8);
    }
  }
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 59690: using guessed type char *off_59690;

//----- (00000000000376E0) ----------------------------------------------------
_QWORD *__fastcall <gimli::read::abbrev::Attributes as core::ops::deref::Deref>::deref(_QWORD *a1)
{
  unsigned __int64 v2; // rdx

  if ( *a1 )
    return (_QWORD *)a1[2];
  v2 = a1[1];
  if ( v2 >= 6 )
    core::slice::index::slice_end_index_len_fail(v2, 5LL, (__int64)&off_596A8);
  return a1 + 2;
}
// 596A8: using guessed type char *off_596A8;

//----- (0000000000037720) ----------------------------------------------------
__int64 __fastcall <core::iter::sources::from_fn::FromFn<F> as core::iter::traits::iterator::Iterator>::next(
        unsigned __int8 **a1)
{
  unsigned __int8 *v1; // rcx
  unsigned __int8 *v2; // rdx
  __int64 result; // rax
  bool v4; // cf
  unsigned __int64 v5; // rcx
  unsigned __int8 *v6; // rax
  unsigned __int8 *v7; // rsi
  int v8; // r8d
  int v9; // edx
  int v10; // r8d
  int v11; // r8d
  unsigned int v12; // r8d
  int v13; // edx
  unsigned int v14; // edx
  char v15; // r8
  unsigned __int64 v16; // rdx
  char v17; // al
  __int64 v18; // rsi
  char v19; // dl
  char (__fastcall *v20)(__int64 *, __int64); // rcx
  int v21; // ebx
  int v22; // r11d
  unsigned int v23; // r10d
  int v24; // ebx
  unsigned int v25; // ebx
  unsigned int v26; // ebx
  int v27; // r11d
  unsigned int v28; // r11d
  int v29; // r11d
  int v30; // r10d
  unsigned int v31; // r9d
  int v32; // r11d
  unsigned int v33; // r11d
  unsigned int v34; // r11d
  int v35; // r10d
  unsigned int v36; // r10d
  int v37; // edi
  int v38; // ecx
  unsigned int v39; // eax
  int v40; // edi
  unsigned int v41; // edi
  unsigned int v42; // esi
  int v43; // ecx
  unsigned int v44; // ecx
  int v45; // eax
  int v46; // r9d
  int v47; // r8d
  char v48; // dl
  bool v49; // cl
  char v50; // [rsp+4h] [rbp-94h] BYREF
  __int16 v51; // [rsp+5h] [rbp-93h]
  char v52; // [rsp+7h] [rbp-91h]
  char *v53; // [rsp+8h] [rbp-90h] BYREF
  unsigned __int64 v54; // [rsp+10h] [rbp-88h]
  unsigned __int64 v55; // [rsp+18h] [rbp-80h] BYREF
  __int64 *v56; // [rsp+20h] [rbp-78h] BYREF
  char (__fastcall *v57)(__int64 *, __int64); // [rsp+28h] [rbp-70h]
  __int64 *v58; // [rsp+30h] [rbp-68h]
  char (__fastcall *v59)(__int64, __int64); // [rsp+38h] [rbp-60h]
  unsigned __int64 *v60; // [rsp+40h] [rbp-58h]
  __int64 (__fastcall *v61)(unsigned __int64 *, __int64); // [rsp+48h] [rbp-50h]
  __int64 v62[2]; // [rsp+50h] [rbp-48h] BYREF
  __int64 v63[7]; // [rsp+60h] [rbp-38h] BYREF

  v1 = a1[1];
  v2 = a1[4];
  result = 1114113LL;
  v4 = v1 < v2;
  v5 = v1 - v2;
  if ( v4 )
    return result;
  v6 = *a1;
  v7 = &v2[(_QWORD)*a1];
  *a1 = v7;
  a1[1] = (unsigned __int8 *)v5;
  if ( v2 != (_BYTE *)&dword_0 + 2 )
    core::panicking::panic((__int64)aInternalErrorE_1, 40LL, (__int64)&off_59AE0);
  v8 = *v6;
  v9 = v6[1];
  LOBYTE(v6) = v8 - 48;
  if ( (unsigned int)(v8 - 48) >= 0xA )
  {
    v10 = (v8 | 0x20) - 97;
    v4 = __CFADD__(v10, 10);
    v11 = v10 + 10;
    LODWORD(v6) = -1;
    if ( !v4 )
      LODWORD(v6) = v11;
    if ( (unsigned int)v6 >= 0x10 )
      goto LABEL_70;
  }
  LOBYTE(v12) = v9 - 48;
  if ( (unsigned int)(v9 - 48) >= 0xA )
  {
    v13 = (v9 | 0x20) - 97;
    v4 = __CFADD__(v13, 10);
    v14 = v13 + 10;
    v12 = -1;
    if ( !v4 )
      v12 = v14;
    if ( v12 >= 0x10 )
      goto LABEL_70;
  }
  v15 = (16 * (_BYTE)v6) | v12;
  if ( v15 < 0 )
  {
    result = 1114112LL;
    if ( (unsigned __int8)v15 < 0xC0u )
      return result;
    if ( (unsigned __int8)v15 >= 0xE0u )
    {
      if ( (unsigned __int8)v15 < 0xF0u )
      {
        v16 = 3LL;
        v17 = 1;
LABEL_25:
        v50 = v15;
        v51 = 0;
        v52 = 0;
        v53 = &v50;
        v54 = v16;
        if ( v5 < 2 )
          return 1114112LL;
        *a1 = v7 + 2;
        a1[1] = (unsigned __int8 *)(v5 - 2);
        v21 = *v7;
        v22 = v7[1];
        LOBYTE(v23) = v21 - 48;
        if ( (unsigned int)(v21 - 48) < 0xA )
          goto LABEL_33;
        v24 = (v21 | 0x20) - 97;
        v4 = __CFADD__(v24, 10);
        v25 = v24 + 10;
        v23 = -1;
        if ( !v4 )
          v23 = v25;
        if ( v23 <= 0xF )
        {
LABEL_33:
          LOBYTE(v26) = v22 - 48;
          if ( (unsigned int)(v22 - 48) < 0xA )
            goto LABEL_34;
          v27 = (v22 | 0x20) - 97;
          v4 = __CFADD__(v27, 10);
          v28 = v27 + 10;
          v26 = -1;
          if ( !v4 )
            v26 = v28;
          if ( v26 <= 0xF )
          {
LABEL_34:
            LOBYTE(v51) = (16 * v23) | v26;
            if ( (unsigned __int8)v15 < 0xE0u )
              goto LABEL_13;
            if ( v5 - 2 < 2 )
              return 1114112LL;
            *a1 = v7 + 4;
            a1[1] = (unsigned __int8 *)(v5 - 4);
            v29 = v7[2];
            v30 = v7[3];
            LOBYTE(v31) = v29 - 48;
            if ( (unsigned int)(v29 - 48) < 0xA )
              goto LABEL_43;
            v32 = (v29 | 0x20) - 97;
            v4 = __CFADD__(v32, 10);
            v33 = v32 + 10;
            v31 = -1;
            if ( !v4 )
              v31 = v33;
            if ( v31 <= 0xF )
            {
LABEL_43:
              LOBYTE(v34) = v30 - 48;
              if ( (unsigned int)(v30 - 48) < 0xA )
                goto LABEL_44;
              v35 = (v30 | 0x20) - 97;
              v4 = __CFADD__(v35, 10);
              v36 = v35 + 10;
              v34 = -1;
              if ( !v4 )
                v34 = v36;
              if ( v34 <= 0xF )
              {
LABEL_44:
                HIBYTE(v51) = (16 * v31) | v34;
                if ( v17 )
                  goto LABEL_13;
                if ( v5 - 4 < 2 )
                  return 1114112LL;
                *a1 = v7 + 6;
                a1[1] = (unsigned __int8 *)(v5 - 6);
                v37 = v7[4];
                v38 = v7[5];
                LOBYTE(v39) = v37 - 48;
                if ( (unsigned int)(v37 - 48) < 0xA )
                  goto LABEL_53;
                v40 = (v37 | 0x20) - 97;
                v4 = __CFADD__(v40, 10);
                v41 = v40 + 10;
                v39 = -1;
                if ( !v4 )
                  v39 = v41;
                if ( v39 <= 0xF )
                {
LABEL_53:
                  LOBYTE(v42) = v38 - 48;
                  if ( (unsigned int)(v38 - 48) < 0xA )
                    goto LABEL_54;
                  v43 = (v38 | 0x20) - 97;
                  v4 = __CFADD__(v43, 10);
                  v44 = v43 + 10;
                  v42 = -1;
                  if ( !v4 )
                    v42 = v44;
                  if ( v42 <= 0xF )
                  {
LABEL_54:
                    v52 = (16 * v39) | v42;
                    goto LABEL_13;
                  }
                }
              }
            }
          }
        }
LABEL_70:
        core::option::unwrap_failed((__int64)&off_59AF8);
      }
      if ( (unsigned __int8)v15 >= 0xF8u )
        return result;
      v16 = 4LL;
    }
    else
    {
      v16 = 2LL;
    }
    v17 = 0;
    goto LABEL_25;
  }
  v50 = v15;
  v51 = 0;
  v52 = 0;
  v53 = &v50;
  v54 = 1LL;
  v16 = 1LL;
LABEL_13:
  core::str::converts::from_utf8((__int64)&v56, (__int64)&v50, v16);
  if ( v56 )
    return 1114112LL;
  v62[0] = (__int64)v57;
  v62[1] = (__int64)v58;
  v18 = (__int64)v58 + (_QWORD)v57;
  if ( v58 )
  {
    v19 = *(_BYTE *)v57;
    if ( *(char *)v57 < 0 )
    {
      v45 = v19 & 0x1F;
      v46 = *((_BYTE *)v57 + 1) & 0x3F;
      if ( (unsigned __int8)v19 <= 0xDFu )
      {
        v20 = (char (__fastcall *)(__int64 *, __int64))((char *)v57 + 2);
        result = v46 | (unsigned int)(v45 << 6);
      }
      else
      {
        v47 = (v46 << 6) | *((_BYTE *)v57 + 2) & 0x3F;
        if ( (unsigned __int8)v19 < 0xF0u )
        {
          v20 = (char (__fastcall *)(__int64 *, __int64))((char *)v57 + 3);
          result = v47 | (unsigned int)(v45 << 12);
        }
        else
        {
          v20 = (char (__fastcall *)(__int64 *, __int64))((char *)v57 + 4);
          result = (v47 << 6) | *((_BYTE *)v57 + 3) & 0x3F | ((unsigned __int8)(v19 & 7) << 18);
        }
      }
    }
    else
    {
      v20 = (char (__fastcall *)(__int64 *, __int64))((char *)v57 + 1);
      result = *(unsigned __int8 *)v57;
    }
  }
  else
  {
    result = 1114112LL;
    v20 = v57;
  }
  if ( v20 == (char (__fastcall *)(__int64 *, __int64))v18 )
  {
    v49 = 1;
    if ( (_DWORD)result == 1114112 )
      goto LABEL_72;
  }
  else
  {
    v48 = *(_BYTE *)v20;
    if ( *(char *)v20 >= 0
      || (unsigned __int8)v48 < 0xF0u
      || (v49 = (((v48 & 7) << 18) | ((*((_BYTE *)v20 + 1) & 0x3F) << 12) | ((*((_BYTE *)v20 + 2) & 0x3F) << 6) | *((_BYTE *)v20 + 3) & 0x3F) == 1114112,
          (_DWORD)result == 1114112) )
    {
LABEL_72:
      v55 = <core::str::iter::Chars as core::iter::traits::iterator::Iterator>::count((__int64)v57, v18);
      v56 = (__int64 *)&v53;
      v57 = <&mut T as core::fmt::Debug>::fmt;
      v58 = v62;
      v59 = <&T as core::fmt::Debug>::fmt;
      v60 = &v55;
      v61 = core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
      v63[0] = (__int64)&off_59B10;
      v63[1] = 4LL;
      v63[4] = 0LL;
      v63[2] = (__int64)&v56;
      v63[3] = 3LL;
      core::panicking::panic_fmt((__int64)v63, (__int64)&off_59B50);
    }
  }
  if ( !v49 )
    goto LABEL_72;
  return result;
}
// 0: using guessed type int dword_0;
// 59AE0: using guessed type char *off_59AE0;
// 59AF8: using guessed type char *off_59AF8;
// 59B10: using guessed type char *off_59B10;
// 59B50: using guessed type char *off_59B50;

//----- (0000000000037BB0) ----------------------------------------------------
char __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return <str as core::fmt::Debug>::fmt(*(unsigned __int8 **)a1, *(_QWORD *)(a1 + 8), a2);
}

//----- (0000000000037BD0) ----------------------------------------------------
__int64 __fastcall <&T as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
}

//----- (0000000000037C00) ----------------------------------------------------
__int64 __fastcall <&T as core::fmt::Debug>::fmt(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rdi
  int v3; // eax

  v2 = *a1;
  v3 = *(_DWORD *)(a2 + 52);
  if ( (v3 & 0x10) != 0 )
    return core::fmt::num::<impl core::fmt::LowerHex for u8>::fmt(v2, a2);
  if ( (v3 & 0x20) != 0 )
    return core::fmt::num::<impl core::fmt::UpperHex for u8>::fmt(v2, a2);
  return core::fmt::num::imp::<impl core::fmt::Display for u8>::fmt(v2, a2);
}

//----- (0000000000037C20) ----------------------------------------------------
char __fastcall <&T as core::fmt::Display>::fmt(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int128 v4; // [rsp+0h] [rbp-30h] BYREF
  __int64 v5; // [rsp+10h] [rbp-20h]
  int v6; // [rsp+18h] [rbp-18h]
  __int64 v7; // [rsp+20h] [rbp-10h]
  int v8; // [rsp+28h] [rbp-8h]

  v2 = *a1;
  if ( *(_QWORD *)v2 )
    return <rustc_demangle::legacy::Demangle as core::fmt::Display>::fmt(v2, a2);
  v4 = *(_OWORD *)(v2 + 8);
  v5 = 0LL;
  v6 = 0;
  v7 = a2;
  v8 = 0;
  return rustc_demangle::v0::Printer::print_path((__int64)&v4, 1u);
}

//----- (0000000000037C70) ----------------------------------------------------
char __fastcall <() as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return core::fmt::Formatter::pad(a2, (__int64)asc_4ADD0, 2uLL);
}

//----- (0000000000037C90) ----------------------------------------------------
char __fastcall core::fmt::Write::write_char(_QWORD *a1, unsigned int a2)
{
  unsigned __int64 v2; // rdx
  bool v3; // al
  bool v4; // cf
  __int64 v5; // rcx
  char result; // al

  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
        v2 = 4LL;
      else
        v2 = 3LL;
    }
    else
    {
      v2 = 2LL;
    }
  }
  else
  {
    v2 = 1LL;
  }
  v3 = *a1 != 0LL;
  v4 = a1[1] < v2;
  a1[1] -= v2;
  v5 = v3 | (unsigned __int8)v4;
  *a1 = v5;
  result = 1;
  if ( !(_BYTE)v5 )
    return <core::fmt::Formatter as core::fmt::Write>::write_str(a1[2]);
  return result;
}

//----- (0000000000037D70) ----------------------------------------------------
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2)
{
  return core::fmt::write(a1, (__int64)off_597F8, a2);
}
// 597F8: using guessed type __int64 (__fastcall *off_597F8[2])();

//----- (0000000000037DB0) ----------------------------------------------------
_BYTE *__fastcall core::str::traits::<impl core::slice::index::SliceIndex<str> for core::ops::range::RangeTo<usize>>::index(
        unsigned __int64 a1,
        _BYTE *a2,
        unsigned __int64 a3,
        __int64 a4)
{
  if ( a1 )
  {
    if ( a1 >= a3 )
    {
      if ( a1 != a3 )
LABEL_4:
        core::str::slice_error_fail(a2, a3, 0LL, a1, a4);
    }
    else if ( (char)a2[a1] <= -65 )
    {
      goto LABEL_4;
    }
  }
  return a2;
}

//----- (0000000000037DE0) ----------------------------------------------------
char __fastcall core::char::methods::<impl char>::escape_debug_ext(__int64 a1, unsigned int a2)
{
  char result; // al
  __int64 v3; // [rsp+0h] [rbp-1Ch] BYREF
  int v4; // [rsp+8h] [rbp-14h]

  switch ( a2 )
  {
    case 0u:
      result = core::char::EscapeDebug::backslash(a1, 48);
      break;
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 0xBu:
    case 0xCu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x23u:
    case 0x24u:
    case 0x25u:
    case 0x26u:
      goto LABEL_5;
    case 9u:
      result = core::char::EscapeDebug::backslash(a1, 116);
      break;
    case 0xAu:
      result = core::char::EscapeDebug::backslash(a1, 110);
      break;
    case 0xDu:
      result = core::char::EscapeDebug::backslash(a1, 114);
      break;
    case 0x22u:
      result = core::char::EscapeDebug::backslash(a1, 34);
      break;
    case 0x27u:
      result = core::char::EscapeDebug::backslash(a1, 39);
      break;
    default:
      if ( a2 == 92 )
      {
        result = core::char::EscapeDebug::backslash(a1, 92);
      }
      else
      {
LABEL_5:
        if ( a2 > 0x7F && core::unicode::unicode_data::grapheme_extend::lookup(a2)
          || (result = core::unicode::printable::is_printable(a2)) == 0 )
        {
          core::char::EscapeUnicode::new((__int64)&v3, a2);
          *(_DWORD *)(a1 + 8) = v4;
          result = v3;
          *(_QWORD *)a1 = v3;
        }
        else
        {
          *(_BYTE *)a1 = 0x80;
          *(_DWORD *)(a1 + 4) = a2;
        }
      }
      break;
  }
  return result;
}

//----- (0000000000037EC0) ----------------------------------------------------
char __fastcall <&mut T as core::fmt::Debug>::fmt(__int64 *a1, __int64 a2)
{
  __int64 v2; // r12
  __int64 v3; // r13
  __int64 v5; // [rsp+0h] [rbp-48h] BYREF
  char v6[64]; // [rsp+8h] [rbp-40h] BYREF

  v2 = *a1;
  v3 = a1[1];
  core::fmt::Formatter::debug_list((__int64)v6, a2);
  for ( ; v3; --v3 )
  {
    v5 = v2++;
    core::fmt::builders::DebugList::entry(v6, (__int64)&v5, (__int64)&off_596C0);
  }
  return core::fmt::builders::DebugList::finish(v6);
}
// 596C0: using guessed type __int64 (__fastcall *off_596C0)();

//----- (0000000000037F40) ----------------------------------------------------
__int64 __fastcall <core::fmt::Error as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
}

//----- (0000000000037F60) ----------------------------------------------------
char __fastcall <core::num::error::ParseIntError as core::fmt::Debug>::fmt(
        __int64 a1,
        __int64 a2,
        double a3,
        double a4)
{
  __int64 v5; // [rsp+10h] [rbp-8h] BYREF

  v5 = a1;
  return core::fmt::Formatter::debug_struct_field1_finish(
           a2,
           a3,
           a4,
           (__int64)aParseinterror,
           13LL,
           (__int64)&unk_4AF1C,
           4uLL,
           (__int64)&v5,
           (__int64)&off_597D8);
}
// 597D8: using guessed type __int64 (__fastcall *off_597D8)();

//----- (0000000000037FB0) ----------------------------------------------------
void __fastcall <core::str::pattern::StrSearcher as core::str::pattern::Searcher>::next(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v2; // rdx
  unsigned __int64 v3; // rax
  __int64 v4; // r10
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // rbp
  __int64 v9; // r14
  __int64 v10; // rdi
  unsigned __int64 v11; // r13
  __int64 v12; // r9
  unsigned __int64 v13; // r12
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // r11
  unsigned __int64 v17; // r9
  bool v18; // zf
  unsigned __int64 v19; // r11
  unsigned __int64 v20; // r9
  __int64 v21; // r8
  char v22; // r8
  __int64 v23; // rax
  unsigned __int64 v24; // rcx
  char v25; // r9
  unsigned int v26; // ecx
  int v27; // ecx
  int v28; // r11d
  int v29; // r10d
  unsigned __int64 v30; // rcx
  __int64 v31; // rax
  unsigned __int64 v32; // r8
  unsigned __int64 v33; // [rsp+8h] [rbp-60h]
  _QWORD *v34; // [rsp+10h] [rbp-58h]
  unsigned __int64 v35; // [rsp+18h] [rbp-50h]
  unsigned __int64 v36; // [rsp+20h] [rbp-48h]
  unsigned __int64 v37; // [rsp+30h] [rbp-38h]

  if ( *(_QWORD *)a2 )
  {
    v2 = *(_QWORD *)(a2 + 40);
    v3 = *(_QWORD *)(a2 + 80);
    if ( v2 != v3 )
    {
      v34 = a1;
      v4 = *(_QWORD *)(a2 + 72);
      v5 = *(_QWORD *)(a2 + 96);
      v6 = v2 + v5 - 1;
      v7 = *(_QWORD *)(a2 + 80);
      if ( v6 < v3 )
      {
        v8 = *(_QWORD *)(a2 + 56);
        v9 = *(_QWORD *)(a2 + 88);
        v37 = v5 - 1;
        v10 = *(_QWORD *)(a2 + 32);
        v11 = *(_QWORD *)(a2 + 8);
        v12 = *(_QWORD *)(a2 + 24);
        v35 = v5 - v12;
        v36 = v2 + v12;
        v33 = v2 + v5;
        v13 = v8;
        v7 = *(_QWORD *)(a2 + 40);
        while ( 1 )
        {
          if ( v2 != v7 )
            goto LABEL_49;
          if ( _bittest64(&v10, *(unsigned __int8 *)(v4 + v6)) )
            break;
          v7 = v2 + v5;
          *(_QWORD *)(a2 + 40) = v33;
          if ( v8 != -1LL )
          {
            v14 = 0LL;
            v7 = v2 + v5;
LABEL_9:
            *(_QWORD *)(a2 + 56) = v14;
            v13 = v14;
          }
LABEL_10:
          v6 = v7 + v37;
          if ( v7 + v37 >= v3 )
          {
            v7 = v3;
            goto LABEL_49;
          }
        }
        v15 = v13;
        if ( v11 > v13 )
          v15 = v11;
        if ( v8 == -1LL )
          v15 = v11;
        v16 = v15;
        do
        {
          if ( v16 >= v5 )
          {
            v19 = v13;
            if ( v8 == -1LL )
              v19 = 0LL;
            v20 = v11;
            do
            {
              if ( v19 >= v20 )
              {
                *(_QWORD *)(a2 + 40) = v33;
                if ( v8 != -1LL )
                  *(_QWORD *)(a2 + 56) = 0LL;
                *v34 = 0LL;
                v34[1] = v2;
                v34[2] = v33;
                return;
              }
              if ( --v20 >= v5 )
                core::panicking::panic_bounds_check(v20, v5, (__int64)&off_596F8);
              v21 = v20 + v2;
              if ( v20 + v2 >= v3 )
                core::panicking::panic_bounds_check(v21, v3, (__int64)&off_59710);
            }
            while ( *(_BYTE *)(v9 + v20) == *(_BYTE *)(v4 + v21) );
            v7 = v36;
            *(_QWORD *)(a2 + 40) = v36;
            v14 = v35;
            if ( v8 != -1LL )
              goto LABEL_9;
            goto LABEL_10;
          }
          if ( v2 + v16 >= v3 )
          {
            v32 = v2 + v15;
            if ( v3 > v32 )
              v32 = v3;
            core::panicking::panic_bounds_check(v32, v3, (__int64)&off_59728);
          }
          v17 = v16 + 1;
          v18 = *(_BYTE *)(v9 + v16) == *(_BYTE *)(v4 + v2 + v16);
          ++v16;
        }
        while ( v18 );
        v7 = v2 - v11 + v17;
        *(_QWORD *)(a2 + 40) = v7;
        if ( v8 == -1LL )
          goto LABEL_10;
        v14 = 0LL;
        goto LABEL_9;
      }
LABEL_49:
      if ( v7 )
      {
        v30 = v7;
        a1 = v34;
        do
        {
          if ( v30 >= v3 )
          {
            if ( v30 == v3 )
              goto LABEL_58;
          }
          else if ( *(char *)(v4 + v30) > -65 )
          {
            v3 = v30;
            goto LABEL_58;
          }
          ++v30;
        }
        while ( v30 );
        v3 = 0LL;
      }
      else
      {
        v3 = 0LL;
        a1 = v34;
      }
LABEL_58:
      if ( v3 > v7 )
        v7 = v3;
      *(_QWORD *)(a2 + 40) = v7;
      goto LABEL_61;
    }
LABEL_6:
    *a1 = 2LL;
    return;
  }
  if ( *(_BYTE *)(a2 + 26) )
    goto LABEL_6;
  v22 = *(_BYTE *)(a2 + 24);
  *(_BYTE *)(a2 + 24) = v22 ^ 1;
  v2 = *(_QWORD *)(a2 + 8);
  v23 = *(_QWORD *)(a2 + 72);
  v24 = *(_QWORD *)(a2 + 80);
  if ( v2 )
  {
    if ( v2 >= v24 )
    {
      if ( v2 != v24 )
LABEL_35:
        core::str::slice_error_fail(*(_BYTE **)(a2 + 72), *(_QWORD *)(a2 + 80), v2, v24, (__int64)&off_59828);
    }
    else if ( *(char *)(v23 + v2) <= -65 )
    {
      goto LABEL_35;
    }
  }
  if ( v2 == v24 )
  {
    if ( !v22 )
    {
LABEL_67:
      *(_BYTE *)(a2 + 26) = 1;
      goto LABEL_6;
    }
  }
  else
  {
    v25 = *(_BYTE *)(v23 + v2);
    if ( v25 < 0 )
    {
      v27 = v25 & 0x1F;
      v28 = *(_BYTE *)(v23 + v2 + 1) & 0x3F;
      if ( (unsigned __int8)v25 <= 0xDFu )
      {
        v26 = v28 | (v27 << 6);
      }
      else
      {
        v29 = (v28 << 6) | *(_BYTE *)(v23 + v2 + 2) & 0x3F;
        if ( (unsigned __int8)v25 < 0xF0u )
          v26 = v29 | (v27 << 12);
        else
          v26 = (v29 << 6) | *(_BYTE *)(v23 + v2 + 3) & 0x3F | ((v25 & 7) << 18);
      }
    }
    else
    {
      v26 = *(unsigned __int8 *)(v23 + v2);
    }
    if ( !v22 )
    {
      if ( v26 != 1114112 )
      {
        v31 = 1LL;
        if ( v26 >= 0x80 )
        {
          v31 = 2LL;
          if ( v26 >= 0x800 )
            v31 = 4LL - (v26 < 0x10000);
        }
        v3 = v2 + v31;
        *(_QWORD *)(a2 + 8) = v3;
LABEL_61:
        a1[1] = v2;
        a1[2] = v3;
        *a1 = 1LL;
        return;
      }
      goto LABEL_67;
    }
  }
  a1[1] = v2;
  a1[2] = v2;
  *a1 = 0LL;
}
// 596F8: using guessed type char *off_596F8;
// 59710: using guessed type char *off_59710;
// 59728: using guessed type char *off_59728;
// 59828: using guessed type char *off_59828;

//----- (0000000000038360) ----------------------------------------------------
unsigned __int64 __fastcall <core::str::iter::Chars as core::iter::traits::iterator::Iterator>::count(
        __int64 a1,
        __int64 a2)
{
  unsigned __int64 v2; // rsi

  v2 = a2 - a1;
  if ( v2 >= 0x20 )
    return core::str::count::do_count_chars(a1, v2);
  else
    return core::str::count::char_count_general_case(a1, v2);
}

//----- (0000000000038380) ----------------------------------------------------
__int64 __fastcall <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(
        __int64 *a1,
        __int64 *a2)
{
  unsigned __int64 v2; // r13
  size_t v3; // r12
  __int64 result; // rax
  unsigned __int64 v5; // rdx
  __int64 v7; // rsi
  size_t v8; // r15
  unsigned __int8 v9; // bl
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  size_t v14; // rbp
  __int64 v15; // [rsp+10h] [rbp-48h]
  size_t v16; // [rsp+18h] [rbp-40h]

  v2 = a2[3];
  v3 = a2[2];
  result = 0LL;
  v5 = v2 - v3;
  if ( v2 >= v3 )
  {
    v16 = a2[1];
    if ( v2 <= v16 )
    {
      v15 = *a2;
      v7 = *a2 + v3;
      v8 = *((unsigned __int8 *)a2 + 40);
      v9 = *((_BYTE *)a2 + v8 + 31);
      if ( v8 > 4 )
      {
        while ( 1 )
        {
          if ( v5 >= 0x10 )
          {
            result = core::slice::memchr::memchr_aligned(v9, v7, v5);
            v10 = v11;
            if ( result != 1 )
              goto LABEL_27;
          }
          else
          {
            v10 = 0LL;
            if ( v2 == v3 )
            {
LABEL_10:
              result = 0LL;
              goto LABEL_27;
            }
            while ( *(_BYTE *)(v7 + v10) != v9 )
            {
              if ( v5 == ++v10 )
                goto LABEL_10;
            }
          }
          v3 += v10 + 1;
          a2[2] = v3;
          if ( v3 >= v8 && v3 <= v16 )
            core::slice::index::slice_end_index_len_fail(v8, 4LL, (__int64)&off_59840);
          v7 = v15 + v3;
          v5 = v2 - v3;
          if ( v2 < v3 )
            goto LABEL_28;
        }
      }
      do
      {
        if ( v5 >= 0x10 )
        {
          result = core::slice::memchr::memchr_aligned(v9, v7, v5);
          v12 = v13;
          if ( result != 1 )
            goto LABEL_27;
        }
        else
        {
          v12 = 0LL;
          if ( v2 == v3 )
          {
LABEL_21:
            result = 0LL;
LABEL_27:
            a2[2] = v2;
            goto LABEL_29;
          }
          while ( *(_BYTE *)(v7 + v12) != v9 )
          {
            if ( v5 == ++v12 )
              goto LABEL_21;
          }
        }
        v3 += v12 + 1;
        a2[2] = v3;
        v14 = v3 - v8;
        if ( v3 >= v8 && v3 <= v16 && !bcmp((const void *)(v15 + v14), a2 + 4, v8) )
        {
          a1[1] = v14;
          a1[2] = v3;
          result = 1LL;
          goto LABEL_29;
        }
        v7 = v15 + v3;
        v5 = v2 - v3;
      }
      while ( v2 >= v3 );
LABEL_28:
      result = 0LL;
    }
  }
LABEL_29:
  *a1 = result;
  return result;
}
// 38445: variable 'v11' is possibly undefined
// 38509: variable 'v13' is possibly undefined
// 59840: using guessed type char *off_59840;

//----- (00000000000385A0) ----------------------------------------------------
__int64 __fastcall <rustc_demangle::legacy::Demangle as core::fmt::Display>::fmt(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbp
  char *v3; // r15
  __int64 v4; // rbx
  char v5; // cl
  unsigned __int64 v6; // r13
  int v7; // edx
  int v8; // edi
  int v9; // esi
  int v10; // ecx
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  char *v13; // rax
  int v14; // ecx
  int v15; // edx
  int v16; // edi
  int v17; // esi
  unsigned __int64 v18; // r13
  unsigned __int64 v19; // r15
  int v20; // eax
  unsigned int v21; // eax
  unsigned __int64 v22; // rsi
  unsigned __int8 *v23; // rcx
  unsigned __int64 v24; // rbx
  int v25; // edx
  unsigned __int8 *v26; // rdi
  int v27; // esi
  int v28; // r9d
  int v29; // r8d
  char *v30; // rbx
  unsigned __int64 v31; // rcx
  int v32; // ecx
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // r13
  unsigned __int64 v35; // r15
  int v36; // eax
  int v37; // esi
  int v38; // edx
  unsigned __int8 *v39; // rbx
  unsigned __int8 *v40; // rax
  char v41; // r12
  int v42; // ecx
  int v43; // edx
  int v44; // r9d
  int v45; // r8d
  unsigned __int64 v46; // rax
  unsigned __int64 v47; // rax
  char **v49; // r8
  char *v50; // r15
  char **v51; // r8
  unsigned int v52; // [rsp+4h] [rbp-A4h]
  unsigned __int64 v54; // [rsp+10h] [rbp-98h]
  __int64 v55; // [rsp+18h] [rbp-90h]
  char *v56; // [rsp+20h] [rbp-88h]
  __int64 v57; // [rsp+28h] [rbp-80h]
  unsigned __int64 v58; // [rsp+30h] [rbp-78h] BYREF
  unsigned __int64 v59; // [rsp+38h] [rbp-70h]
  __int64 v60; // [rsp+40h] [rbp-68h]
  unsigned __int64 v61; // [rsp+48h] [rbp-60h]
  __int64 v62; // [rsp+50h] [rbp-58h]
  char v63; // [rsp+58h] [rbp-50h]
  __int64 v64; // [rsp+60h] [rbp-48h] BYREF
  unsigned __int64 v65; // [rsp+68h] [rbp-40h]

  v56 = *(char **)a1;
  v54 = *(_QWORD *)(a1 + 8);
  v57 = *(_QWORD *)(a1 + 16);
  v55 = 0LL;
  while ( 2 )
  {
    v3 = v56;
    v4 = v55;
    LOBYTE(v2) = v55 != v57;
    if ( v55 == v57 )
      return 0;
    if ( !v54 )
LABEL_164:
      core::option::unwrap_failed((__int64)&off_598B8);
    ++v55;
    v5 = *v56;
    v6 = 0LL;
    if ( *v56 < 0 )
      goto LABEL_8;
LABEL_6:
    if ( (unsigned int)(unsigned __int8)v5 - 48 <= 9 )
    {
      do
      {
        while ( 1 )
        {
          if ( v54 - 1 == v6 )
            goto LABEL_164;
          v5 = v56[v6 + 1];
          if ( v5 <= -65 )
            core::str::slice_error_fail(&v56[v6], v54 - v6, 1uLL, v54 - v6, (__int64)&off_598D0);
          ++v6;
          if ( v5 >= 0 )
            goto LABEL_6;
LABEL_8:
          v7 = v5 & 0x1F;
          v8 = v56[v6 + 1] & 0x3F;
          if ( (unsigned __int8)v5 > 0xDFu )
            break;
          v10 = v8 | (v7 << 6);
LABEL_13:
          if ( (unsigned int)(v10 - 48) > 9 )
            goto LABEL_19;
        }
        v9 = (v8 << 6) | v56[v6 + 2] & 0x3F;
        if ( (unsigned __int8)v5 >= 0xF0u )
        {
          v10 = ((v5 & 7) << 18) | (v9 << 6) | v56[v6 + 3] & 0x3F;
          if ( v10 == 1114112 )
            goto LABEL_164;
          goto LABEL_13;
        }
      }
      while ( ((v7 << 12) | (unsigned int)v9) - 48 <= 9 );
    }
LABEL_19:
    if ( v6 && v56[v6] <= -65 )
      core::str::slice_error_fail(v56, v54, 0LL, v6, (__int64)&off_598E8);
    core::num::<impl core::str::traits::FromStr for usize>::from_str((__int64)&v58, (unsigned __int8 *)v56, v6);
    if ( (_BYTE)v58 )
    {
      LOBYTE(v64) = BYTE1(v58);
      core::result::unwrap_failed(
        (__int64)aCalledResultUn_3,
        43LL,
        (__int64)&v64,
        (__int64)&off_597B8,
        (__int64)&off_59900);
    }
    v11 = v59;
    v12 = v54 - v59;
    if ( !v59 )
      goto LABEL_27;
    if ( v59 >= v54 - v6 )
    {
      if ( v12 == v6 )
        goto LABEL_27;
LABEL_171:
      core::str::slice_error_fail(&v56[v6], v54 - v6, v59, v54 - v6, (__int64)&off_59918);
    }
    if ( v56[v59 + v6] <= -65 )
      goto LABEL_171;
LABEL_27:
    v52 = v2;
    v2 = (unsigned __int64)&v56[v6];
    v56 += v6 + v59;
    if ( v59 && v55 == v57 && (*(_DWORD *)(a2 + 52) & 4) != 0 && *(_BYTE *)v2 == 104 )
    {
      if ( v59 == 1 || v3[v6 + 1] > -65 )
      {
        v13 = &v3[v6 + 1];
        while ( 1 )
        {
          while ( 1 )
          {
            if ( v56 == v13 )
              return 0;
            v14 = (unsigned __int8)*v13;
            if ( (v14 & 0x80u) == 0 )
              break;
            v15 = v14 & 0x1F;
            v16 = v13[1] & 0x3F;
            if ( (unsigned __int8)v14 <= 0xDFu )
            {
              v13 += 2;
              v14 = v16 | (v15 << 6);
              if ( (unsigned int)(v14 - 48) >= 0xA )
                goto LABEL_46;
            }
            else
            {
              v17 = (v16 << 6) | v13[2] & 0x3F;
              if ( (unsigned __int8)v14 < 0xF0u )
              {
                v13 += 3;
                v14 = (v15 << 12) | v17;
                if ( (unsigned int)(v14 - 48) >= 0xA )
                  goto LABEL_46;
              }
              else
              {
                v14 = ((v14 & 7) << 18) | (v17 << 6) | v13[3] & 0x3F;
                if ( v14 == 1114112 )
                  return 0;
                v13 += 4;
                if ( (unsigned int)(v14 - 48) >= 0xA )
                  goto LABEL_46;
              }
            }
          }
          ++v13;
          if ( (unsigned int)(v14 - 48) >= 0xA )
          {
LABEL_46:
            if ( (v14 | 0x20u) - 97 >= 6 )
              goto LABEL_47;
          }
        }
      }
      v50 = &v3[v6];
      v51 = &off_598A0;
LABEL_180:
      core::str::slice_error_fail(v50, v11, 1uLL, v11, (__int64)v51);
    }
LABEL_47:
    if ( v4 && (unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str(a2) )
      return v52;
    if ( v11 >= 2 && *(_WORD *)v2 == 9311 )
    {
      if ( v3[v6 + 1] <= -65 )
      {
        v50 = &v3[v6];
        v51 = &off_59948;
        goto LABEL_180;
      }
      v2 = (unsigned __int64)&v3[v6 + 1];
      --v11;
    }
    v54 = v12 - v6;
LABEL_54:
    while ( 2 )
    {
      while ( 2 )
      {
        v18 = v2;
        v19 = v11;
        if ( !v11 )
          goto LABEL_60;
        v20 = *(unsigned __int8 *)v2;
        if ( v20 != 36 )
        {
          if ( v20 == 46 )
          {
            if ( v11 == 1 )
            {
              v21 = <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
              if ( (_BYTE)v21 )
                goto LABEL_162;
LABEL_159:
              v34 = v2 + 1;
              v35 = v11 - 1;
              goto LABEL_160;
            }
            if ( *(char *)(v2 + 1) <= -65 )
            {
              v49 = &off_599F0;
              goto LABEL_177;
            }
            v32 = *(unsigned __int8 *)(v2 + 1);
            if ( (v32 & 0x80u) == 0 )
            {
              if ( v32 != 46 )
                goto LABEL_157;
LABEL_152:
              v21 = <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
              if ( !(_BYTE)v21 )
              {
                if ( v11 >= 3 && *(char *)(v2 + 2) < -64 )
                  core::str::slice_error_fail((_BYTE *)v2, v11, 2uLL, v11, (__int64)&off_59A08);
                v34 = v2 + 2;
                v35 = v11 - 2;
                goto LABEL_160;
              }
              goto LABEL_162;
            }
            v36 = v32 & 0x1F;
            v37 = *(_BYTE *)(v2 + 2) & 0x3F;
            if ( (unsigned __int8)v32 <= 0xDFu )
            {
              if ( (v37 | (v36 << 6)) == 46 )
                goto LABEL_152;
            }
            else
            {
              v38 = (v37 << 6) | *(_BYTE *)(v2 + 3) & 0x3F;
              if ( (unsigned __int8)v32 >= 0xF0u )
              {
                if ( ((v38 << 6) | *(_BYTE *)(v2 + 4) & 0x3F | ((v32 & 7) << 18)) != 46 )
                  goto LABEL_157;
                goto LABEL_152;
              }
              if ( (v38 | (v36 << 12)) == 46 )
                goto LABEL_152;
            }
LABEL_157:
            v21 = <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
            if ( (_BYTE)v21 )
              goto LABEL_162;
            if ( *(char *)(v2 + 1) >= -64 )
              goto LABEL_159;
            v49 = &off_59A20;
LABEL_177:
            core::str::slice_error_fail((_BYTE *)v2, v11, 1uLL, v11, (__int64)v49);
          }
LABEL_60:
          v22 = 0LL;
          v23 = (unsigned __int8 *)v2;
          while ( 1 )
          {
            if ( v23 == (unsigned __int8 *)(v11 + v2) )
              goto LABEL_2;
            v24 = v22;
            v25 = *v23;
            if ( (v25 & 0x80u) != 0 )
            {
              v27 = v25 & 0x1F;
              v28 = v23[1] & 0x3F;
              if ( (unsigned __int8)v25 <= 0xDFu )
              {
                v26 = v23 + 2;
                v25 = v28 | (v27 << 6);
                if ( v25 == 36 )
                  goto LABEL_74;
              }
              else
              {
                v29 = (v28 << 6) | v23[2] & 0x3F;
                if ( (unsigned __int8)v25 < 0xF0u )
                {
                  v26 = v23 + 3;
                  v25 = (v27 << 12) | v29;
                  if ( v25 == 36 )
                    goto LABEL_74;
                }
                else
                {
                  v25 = ((v25 & 7) << 18) | (v29 << 6) | v23[3] & 0x3F;
                  if ( v25 == 1114112 )
                    goto LABEL_2;
                  v26 = v23 + 4;
                  if ( v25 == 36 )
                  {
LABEL_74:
                    if ( v24 )
                    {
                      if ( v11 <= v24 )
                      {
                        if ( v11 != v24 )
                          goto LABEL_168;
                      }
                      else if ( *(char *)(v2 + v24) <= -65 )
                      {
LABEL_168:
                        core::str::slice_error_fail((_BYTE *)v2, v11, 0LL, v24, (__int64)&off_59960);
                      }
                      v21 = <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
                      if ( (_BYTE)v21 )
                        goto LABEL_162;
                      if ( v11 <= v24 )
                      {
                        if ( v11 != v24 )
                          goto LABEL_173;
                      }
                      else if ( *(char *)(v2 + v24) < -64 )
                      {
LABEL_173:
                        core::str::slice_error_fail((_BYTE *)v2, v11, v24, v11, (__int64)&off_59978);
                      }
LABEL_111:
                      v34 = v24 + v2;
                      v35 = v11 - v24;
LABEL_160:
                      v11 = v35;
                      v2 = v34;
                      goto LABEL_54;
                    }
                    v21 = <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
                    if ( !(_BYTE)v21 )
                      goto LABEL_111;
LABEL_162:
                    LOBYTE(v21) = 1;
                    return v21;
                  }
                }
              }
            }
            else
            {
              v26 = v23 + 1;
              if ( v25 == 36 )
                goto LABEL_74;
            }
            v22 = (unsigned __int64)&v26[v24 - (_QWORD)v23];
            v23 = v26;
            if ( v25 == 46 )
              goto LABEL_74;
          }
        }
        if ( v11 != 1 && *(char *)(v2 + 1) <= -65 )
        {
          v49 = &off_59990;
          goto LABEL_177;
        }
        v30 = (char *)(v2 + 1);
        v58 = v2 + 1;
        v59 = v11 - 1;
        v60 = 0LL;
        v61 = v11 - 1;
        v63 = 1;
        v62 = 0x2400000024LL;
        <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(&v64, (__int64 *)&v58);
        if ( !v64 )
          goto LABEL_2;
        if ( v65 == -1LL )
          core::str::traits::str_index_overflow_fail((__int64)&off_599A8);
        v31 = v65 + 1;
        if ( v11 != 1 && *v30 < -64 )
LABEL_167:
          core::str::slice_error_fail((_BYTE *)v2, v11, 1uLL, v31, (__int64)&off_599A8);
        if ( v31 >= v11 )
        {
          if ( v31 != v11 )
            goto LABEL_167;
          v33 = v2;
          v2 = v65 + 2;
          if ( v65 == -2LL )
            goto LABEL_107;
        }
        else
        {
          if ( *(char *)(v2 + v31) < -64 )
            goto LABEL_167;
          v2 = v65 + 2;
        }
        v11 -= v2;
        if ( v19 <= v2 )
        {
          if ( v19 != v2 )
LABEL_172:
            core::str::slice_error_fail((_BYTE *)v18, v19, v2, v19, (__int64)&off_599C0);
        }
        else if ( *(char *)(v18 + v2) < -64 )
        {
          goto LABEL_172;
        }
        v2 += v18;
        if ( v65 == 1 )
        {
          if ( *v30 != 67 )
          {
            if ( *v30 != 117 )
              goto LABEL_2;
            goto LABEL_129;
          }
          goto LABEL_122;
        }
        if ( v65 == 2 )
        {
          if ( *(_WORD *)v30 != 20563
            && *(_WORD *)v30 != 20546
            && *(_WORD *)v30 != 18002
            && *(_WORD *)v30 != 21580
            && *(_WORD *)v30 != 21575
            && *(_WORD *)v30 != 20556
            && *(_WORD *)v30 != 20562 )
          {
            v33 = v2;
            if ( *(_BYTE *)(v18 + 1) != 117 )
              goto LABEL_2;
            goto LABEL_108;
          }
LABEL_122:
          v21 = <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
          if ( (_BYTE)v21 )
            goto LABEL_162;
          continue;
        }
        break;
      }
      v33 = v2;
      if ( !v65 )
        break;
LABEL_107:
      if ( *(_BYTE *)(v18 + 1) != 117 )
        break;
LABEL_108:
      v2 = v33;
      if ( *(char *)(v18 + 2) <= -65 )
        core::str::slice_error_fail((_BYTE *)(v18 + 1), v65, 1uLL, v65, (__int64)&off_599D8);
LABEL_129:
      v39 = (unsigned __int8 *)&v30[v65];
      v40 = (unsigned __int8 *)(v18 + 2);
      while ( 1 )
      {
        v41 = 1;
        if ( v40 == v39 )
          break;
        v42 = *v40;
        if ( (v42 & 0x80u) != 0 )
        {
          v43 = v42 & 0x1F;
          v44 = v40[1] & 0x3F;
          if ( (unsigned __int8)v42 <= 0xDFu )
          {
            v40 += 2;
            v42 = v44 | (v43 << 6);
            if ( (unsigned int)(v42 - 48) >= 0xA )
              goto LABEL_142;
          }
          else
          {
            v45 = (v44 << 6) | v40[2] & 0x3F;
            if ( (unsigned __int8)v42 < 0xF0u )
            {
              v40 += 3;
              v42 = (v43 << 12) | v45;
              if ( (unsigned int)(v42 - 48) >= 0xA )
                goto LABEL_142;
            }
            else
            {
              v42 = ((v42 & 7) << 18) | (v45 << 6) | v40[3] & 0x3F;
              if ( v42 == 1114112 )
                break;
              v40 += 4;
              if ( (unsigned int)(v42 - 48) >= 0xA )
                goto LABEL_142;
            }
          }
        }
        else
        {
          ++v40;
          if ( (unsigned int)(v42 - 48) >= 0xA )
          {
LABEL_142:
            if ( (unsigned int)(v42 - 97) >= 6 )
            {
              v41 = 0;
              break;
            }
          }
        }
      }
      v46 = core::num::<impl u32>::from_str_radix(v18 + 2, v65 - 1, 16LL);
      if ( (v46 & 1) == 0 )
      {
        v47 = HIDWORD(v46);
        if ( ((unsigned int)v47 ^ 0xD800) - 1114112 < 0xFFEF0800 )
          LODWORD(v47) = 1114112;
        if ( !(((_DWORD)v47 == 1114112) | (unsigned __int8)v41 ^ 1) )
        {
          LODWORD(v58) = v47;
          if ( !core::unicode::unicode_data::cc::lookup(v47) )
          {
            if ( <char as core::fmt::Display>::fmt((unsigned int *)&v58, (_QWORD *)a2) )
              goto LABEL_162;
            continue;
          }
        }
      }
      break;
    }
LABEL_2:
    if ( !(unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str(a2) )
      continue;
    return v52;
  }
}
// 38B20: conditional instruction was optimized away because rbx.8!=0
// 38BC6: conditional instruction was optimized away because %var_40.8 is in (2..FFFFFFFFFFFFFFFE)
// 38769: variable 'v2' is possibly undefined
// 38F05: variable 'v21' is possibly undefined
// 45F60: using guessed type __int64 __fastcall core::num::<impl u32>::from_str_radix(_QWORD, _QWORD, _QWORD);
// 597B8: using guessed type __int64 (__fastcall *off_597B8)();
// 598A0: using guessed type char *off_598A0;
// 598B8: using guessed type char *off_598B8;
// 598D0: using guessed type char *off_598D0;
// 598E8: using guessed type char *off_598E8;
// 59900: using guessed type char *off_59900;
// 59918: using guessed type char *off_59918;
// 59948: using guessed type char *off_59948;
// 59960: using guessed type char *off_59960;
// 59978: using guessed type char *off_59978;
// 59990: using guessed type char *off_59990;
// 599A8: using guessed type char *off_599A8;
// 599C0: using guessed type char *off_599C0;
// 599D8: using guessed type char *off_599D8;
// 599F0: using guessed type char *off_599F0;
// 59A08: using guessed type char *off_59A08;
// 59A20: using guessed type char *off_59A20;

//----- (00000000000390C0) ----------------------------------------------------
__int64 __fastcall <rustc_demangle::v0::Ident as core::fmt::Display>::fmt(unsigned __int8 **a1, __int64 a2)
{
  __int64 v2; // rbx
  char *v3; // r13
  unsigned __int8 v4; // r8
  unsigned __int8 *v5; // rcx
  __int64 v6; // rax
  unsigned __int8 *v7; // rax
  unsigned __int64 v8; // r10
  int v9; // edx
  int v10; // esi
  int v11; // r9d
  int v12; // edi
  unsigned __int8 *v14; // r15
  unsigned __int64 v15; // rbp
  unsigned __int64 v16; // r11
  unsigned __int64 i; // rsi
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rcx
  bool v21; // cf
  unsigned __int64 v22; // rsi
  unsigned __int64 v23; // r14
  unsigned __int64 v24; // rdi
  unsigned __int64 v25; // r9
  unsigned __int64 v26; // r9
  unsigned __int64 v27; // rdi
  unsigned __int64 v28; // r14
  unsigned __int64 v29; // r12
  unsigned __int8 v30; // al
  unsigned __int8 v31; // dl
  unsigned __int64 v32; // rax
  unsigned __int64 v33; // r12
  __int64 v34; // rax
  unsigned __int64 v35; // r8
  unsigned __int64 v36; // rdx
  unsigned __int64 v37; // rax
  __int64 v38; // r10
  __int64 v39; // rax
  __int128 v40; // xmm0
  unsigned __int64 v41; // rcx
  unsigned __int64 v42; // rdx
  __int64 v43; // rsi
  unsigned __int64 v44; // rcx
  bool v45; // cc
  _QWORD *v46; // r15
  unsigned int *v47; // r12
  int v48; // eax
  unsigned __int64 v49; // [rsp+0h] [rbp-288h]
  unsigned __int64 v50; // [rsp+8h] [rbp-280h]
  unsigned __int8 *v51; // [rsp+10h] [rbp-278h]
  unsigned int v52; // [rsp+1Ch] [rbp-26Ch] BYREF
  unsigned __int64 v53; // [rsp+20h] [rbp-268h]
  unsigned __int64 v54; // [rsp+28h] [rbp-260h]
  unsigned __int8 *v55; // [rsp+30h] [rbp-258h]
  _QWORD *v56; // [rsp+38h] [rbp-250h]
  unsigned __int8 *v57; // [rsp+40h] [rbp-248h]
  unsigned __int8 *v58; // [rsp+48h] [rbp-240h] BYREF
  __int64 v59; // [rsp+50h] [rbp-238h]
  int s[140]; // [rsp+58h] [rbp-230h] BYREF

  v2 = a2;
  LODWORD(v3) = (_DWORD)a1;
  memset(s, 0, 0x200uLL);
  v57 = a1[3];
  if ( !v57 )
    return <core::fmt::Formatter as core::fmt::Write>::write_str(v2);
  v56 = (_QWORD *)a2;
  v55 = a1[2];
  v4 = *v55;
  v5 = *a1;
  v6 = (__int64)a1[1];
  v58 = *a1;
  v59 = v6;
  if ( v6 )
  {
    v7 = &v5[v6];
    v8 = 0LL;
    do
    {
      v9 = *v5;
      if ( (v9 & 0x80u) != 0 )
      {
        v10 = v9 & 0x1F;
        v11 = v5[1] & 0x3F;
        if ( (unsigned __int8)v9 <= 0xDFu )
        {
          v5 += 2;
          v9 = v11 | (v10 << 6);
          if ( v8 == 128 )
            goto LABEL_80;
        }
        else
        {
          v12 = (v11 << 6) | v5[2] & 0x3F;
          if ( (unsigned __int8)v9 < 0xF0u )
          {
            v5 += 3;
            v9 = (v10 << 12) | v12;
            if ( v8 == 128 )
              goto LABEL_80;
          }
          else
          {
            v9 = ((v9 & 7) << 18) | (v12 << 6) | v5[3] & 0x3F;
            if ( v9 == 1114112 )
              break;
            v5 += 4;
            if ( v8 == 128 )
              goto LABEL_80;
          }
        }
      }
      else
      {
        ++v5;
        if ( v8 == 128 )
          goto LABEL_80;
      }
      s[v8++] = v9;
    }
    while ( v5 != v7 );
  }
  else
  {
    v8 = 0LL;
  }
  v14 = v55;
  v51 = &v57[(_QWORD)v55];
  v54 = 4 * v8 + 4;
  v53 = ~v8;
  v50 = v8 + 1;
  v3 = (char *)&v58 + 4 * v8 + 4;
  v49 = 700LL;
  v15 = 72LL;
  v16 = 128LL;
  for ( i = 0LL; ; i = v24 + 1 )
  {
    v18 = 0LL;
    if ( v15 <= 0x24 )
      v18 = 36 - v15;
    v19 = (v18 == 0) + v18;
    if ( v19 >= 0x1A )
      v19 = 26LL;
    LOBYTE(v20) = v4 - 97;
    if ( (unsigned __int8)(v4 - 97) >= 0x1Au )
    {
      if ( (unsigned __int8)(v4 - 48) > 9u )
        goto LABEL_80;
      LOBYTE(v20) = v4 - 22;
    }
    ++v14;
    v20 = (unsigned __int8)v20;
    if ( v19 <= (unsigned __int8)v20 )
      break;
    v21 = __CFADD__((unsigned __int8)v20, i);
    v22 = (unsigned __int8)v20 + i;
    if ( v21 )
      goto LABEL_80;
LABEL_29:
    v23 = v8 + 1;
    if ( ((v8 + 1) | v22) >> 32 )
    {
      v24 = v22 % v23;
      v21 = __CFADD__(v22 / v23, v16);
      v16 += v22 / v23;
      if ( v21 )
        goto LABEL_80;
    }
    else
    {
      v34 = (unsigned int)v22 / (unsigned int)v23;
      v24 = (unsigned int)v22 % (unsigned int)v23;
      v21 = __CFADD__(v34, v16);
      v16 += v34;
      if ( v21 )
        goto LABEL_80;
    }
    if ( HIDWORD(v16) || ((unsigned int)v16 ^ 0xD800) - 1114112 < 0xFFEF0800 || v8 > 0x7F )
      goto LABEL_80;
    v35 = v8 - v24;
    if ( v8 <= v24 )
    {
      if ( v24 >= 0x80 )
        core::panicking::panic_bounds_check(v24, 128LL, (__int64)&off_59AB0);
    }
    else
    {
      if ( v35 < 8 )
      {
        v36 = v8;
        do
        {
LABEL_68:
          s[v36] = s[v36 - 1];
          --v36;
        }
        while ( v36 > v24 );
        goto LABEL_69;
      }
      if ( (v50 | v22) >> 32 )
        v37 = v22 / v50;
      else
        v37 = (unsigned int)v22 / (unsigned int)v50;
      v36 = v8 - (v35 & 0xFFFFFFFFFFFFFFF8LL);
      v38 = -(__int64)((v8 - (v53 * v37 + v22)) & 0xFFFFFFFFFFFFFFF8LL);
      v39 = 0LL;
      do
      {
        v40 = *(_OWORD *)&v3[4 * v39 - 20];
        *(_OWORD *)&v3[4 * v39] = *(_OWORD *)&v3[4 * v39 - 4];
        *(_OWORD *)&v3[4 * v39 - 16] = v40;
        v39 -= 8LL;
      }
      while ( v38 != v39 );
      if ( v35 != (v35 & 0xFFFFFFFFFFFFFFF8LL) )
        goto LABEL_68;
    }
LABEL_69:
    s[v24] = v16;
    if ( v14 == v51 )
    {
      v46 = v56;
      v47 = (unsigned int *)s;
      do
      {
        v52 = *v47;
        LOBYTE(v48) = <char as core::fmt::Display>::fmt(&v52, v46);
        LODWORD(v3) = v48;
        if ( (_BYTE)v48 )
          break;
        ++v47;
        v54 -= 4LL;
      }
      while ( v54 );
      return (unsigned int)v3;
    }
    v4 = *v14;
    if ( HIDWORD(v20) )
      v41 = v20 / v49;
    else
      v41 = (unsigned int)v20 / (unsigned int)v49;
    if ( (v23 | v41) >> 32 )
    {
      v42 = v41 + v41 / v23;
      v43 = 0LL;
      if ( v42 < 0x1C8 )
        goto LABEL_79;
    }
    else
    {
      v42 = v41 + (unsigned int)v41 / (unsigned int)v23;
      v43 = 0LL;
      if ( v42 < 0x1C8 )
        goto LABEL_79;
    }
    v44 = v42;
    do
    {
      v42 = v44 / 0x23;
      v43 += 36LL;
      v45 = v44 <= 0x3E57;
      v44 /= 0x23uLL;
    }
    while ( !v45 );
LABEL_79:
    v15 = v43 + (unsigned __int16)((unsigned __int16)(36 * v42) / (unsigned __int16)(v42 + 38));
    v54 += 4LL;
    --v53;
    ++v50;
    v3 += 4;
    v49 = 2LL;
    v8 = v23;
  }
  if ( v14 != v51 )
  {
    v25 = 0LL;
    if ( v15 <= 0x48 )
      v25 = 72 - v15;
    v26 = (v25 == 0) + v25;
    if ( v26 >= 0x1A )
      v26 = 26LL;
    v27 = 36 - v19;
    v28 = 108LL;
    while ( 1 )
    {
      v29 = 0LL;
      if ( v28 >= v15 )
        v29 = v28 - v15;
      v30 = *v14;
      v31 = *v14 - 97;
      if ( v31 >= 0x1Au )
      {
        if ( (unsigned __int8)(v30 - 48) > 9u )
          break;
        v31 = v30 - 22;
      }
      v32 = v27 * v31;
      if ( !is_mul_ok(v27, v31) )
        break;
      v21 = __CFADD__(v32, v20);
      v20 += v32;
      if ( v21 )
        break;
      if ( v26 > v31 )
      {
        ++v14;
        v21 = __CFADD__(v20, i);
        v22 = v20 + i;
        if ( !v21 )
          goto LABEL_29;
        break;
      }
      if ( is_mul_ok(36 - v26, v27) )
      {
        v27 *= 36 - v26;
        ++v14;
        v33 = (v29 == 0) + v29;
        if ( v33 >= 0x1A )
          v33 = 26LL;
        v28 += 36LL;
        v26 = v33;
        if ( v14 != v51 )
          continue;
      }
      break;
    }
  }
LABEL_80:
  v2 = (__int64)v56;
  LOBYTE(v3) = 1;
  if ( !(unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str((__int64)v56)
    && (!v59
     || !(unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str((__int64)v56)
     && !(unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str((__int64)v56))
    && !(unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str((__int64)v56) )
  {
    return <core::fmt::Formatter as core::fmt::Write>::write_str(v2);
  }
  return (unsigned int)v3;
}
// 396A0: variable 'v48' is possibly undefined
// 59AB0: using guessed type char *off_59AB0;
// 390C0: using guessed type int s[140];

//----- (00000000000396D0) ----------------------------------------------------
__int64 __fastcall rustc_demangle::v0::HexNibbles::try_parse_uint(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 result; // rax
  unsigned __int8 *v4; // rbx
  unsigned __int8 *v5; // rcx
  __int64 v6; // rdx
  int v7; // edi
  unsigned int v8; // r8d
  int v9; // r8d
  int v10; // r10d
  int v11; // r9d
  int v12; // edi
  bool v13; // cf
  unsigned int v14; // edi
  __int64 v15; // [rsp+8h] [rbp-A0h] BYREF
  __int64 v16; // [rsp+10h] [rbp-98h]
  char v17[136]; // [rsp+20h] [rbp-88h] BYREF

  core::str::pattern::StrSearcher::new((__int64)v17, a1, a2, a0, 1uLL);
  do
    <core::str::pattern::StrSearcher as core::str::pattern::Searcher>::next(&v15, (__int64)v17);
  while ( !v15 );
  if ( (_DWORD)v15 != 1 )
  {
    v2 = a2;
    goto LABEL_5;
  }
  v2 = v16;
  if ( (unsigned __int64)(a2 - v16) <= 0x10 )
  {
LABEL_5:
    result = 1LL;
    if ( a2 == v2 )
      return result;
    v4 = (unsigned __int8 *)(a1 + a2);
    v5 = (unsigned __int8 *)(a1 + v2);
    v6 = 0LL;
    while ( 1 )
    {
      v7 = *v5;
      if ( (v7 & 0x80u) != 0 )
      {
        v9 = v7 & 0x1F;
        v10 = v5[1] & 0x3F;
        if ( (unsigned __int8)v7 <= 0xDFu )
        {
          v5 += 2;
          v7 = v10 | (v9 << 6);
          v8 = v7 - 48;
          if ( (unsigned int)(v7 - 48) >= 0xA )
            goto LABEL_23;
        }
        else
        {
          v11 = (v10 << 6) | v5[2] & 0x3F;
          if ( (unsigned __int8)v7 < 0xF0u )
          {
            v5 += 3;
            v7 = (v9 << 12) | v11;
            v8 = v7 - 48;
            if ( (unsigned int)(v7 - 48) >= 0xA )
              goto LABEL_23;
          }
          else
          {
            v7 = ((v7 & 7) << 18) | (v11 << 6) | v5[3] & 0x3F;
            if ( v7 == 1114112 )
              return result;
            v5 += 4;
            v8 = v7 - 48;
            if ( (unsigned int)(v7 - 48) >= 0xA )
            {
LABEL_23:
              v12 = (v7 | 0x20) - 97;
              v13 = __CFADD__(v12, 10);
              v14 = v12 + 10;
              if ( v13 )
                v14 = -1;
              v8 = v14;
              if ( v14 >= 0x10 )
                core::option::unwrap_failed((__int64)&off_59AC8);
            }
          }
        }
      }
      else
      {
        ++v5;
        v8 = v7 - 48;
        if ( (unsigned int)(v7 - 48) >= 0xA )
          goto LABEL_23;
      }
      v6 = (16 * v6) | v8;
      if ( v5 == v4 )
        return result;
    }
  }
  return 0LL;
}
// 4B00D: using guessed type char a0;
// 59AC8: using guessed type char *off_59AC8;

//----- (0000000000039880) ----------------------------------------------------
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm4,xmm5> rustc_demangle::v0::Parser::hex_nibbles(
        _QWORD *a1,
        __int64 a2)
{
  unsigned __int64 v3; // rdx
  _BYTE *v4; // rax
  unsigned __int64 v5; // rsi
  __int64 v6; // r9
  unsigned __int64 v7; // rcx
  char v8; // r10
  unsigned __int64 v9; // rcx

  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_BYTE **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v6 = -1LL;
  v7 = v3;
  do
  {
    if ( v7 >= v5 )
      goto LABEL_11;
    v8 = v4[v7++];
    *(_QWORD *)(a2 + 16) = v7;
    ++v6;
  }
  while ( (unsigned __int8)(v8 - 48) < 0xAu || (unsigned __int8)(v8 - 97) < 6u );
  if ( v8 == 95 )
  {
    v9 = v7 - 1;
    if ( v3 > v9 )
      goto LABEL_10;
    if ( v3 )
    {
      if ( v3 >= v5 )
      {
        if ( v3 != v5 )
LABEL_10:
          core::str::slice_error_fail(v4, v5, v3, v9, (__int64)&off_59B68);
      }
      else if ( (char)v4[v3] <= -65 )
      {
        goto LABEL_10;
      }
    }
    *a1 = &v4[v3];
    a1[1] = v6;
  }
  else
  {
LABEL_11:
    *((_BYTE *)a1 + 8) = 0;
    *a1 = 0LL;
  }
}
// 59B68: using guessed type char *off_59B68;

//----- (0000000000039920) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Parser::integer_62(__int64 a1, __int64 *a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // rcx
  char result; // al
  unsigned __int64 v6; // rax
  char v7; // dl
  unsigned __int8 v8; // r11
  unsigned __int8 v9; // dl
  __int64 v10; // rax
  unsigned __int64 v11; // kr00_8
  bool v12; // cf
  unsigned __int64 v13; // rax

  v2 = *a2;
  v3 = a2[1];
  v4 = a2[2];
  if ( v4 < v3 && *(_BYTE *)(v2 + v4) == 95 )
  {
    a2[2] = v4 + 1;
    *(_QWORD *)(a1 + 8) = 0LL;
    result = 0;
    *(_BYTE *)a1 = 0;
  }
  else
  {
    if ( v4 >= v3 )
      goto LABEL_18;
    v6 = 0LL;
    while ( *(_BYTE *)(v2 + v4) != 95 )
    {
      v7 = *(_BYTE *)(v2 + v4);
      v8 = v7 - 48;
      if ( (unsigned __int8)(v7 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v7 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v7 - 65) >= 0x1Au )
            goto LABEL_18;
          v9 = v7 - 29;
        }
        else
        {
          v9 = v7 - 87;
        }
        v8 = v9;
      }
      a2[2] = ++v4;
      v11 = v6;
      v10 = 62 * v6;
      if ( is_mul_ok(0x3EuLL, v11) )
      {
        v12 = __CFADD__(v8, v10);
        v6 = v8 + v10;
        if ( !v12 && v4 < v3 )
          continue;
      }
      goto LABEL_18;
    }
    a2[2] = v4 + 1;
    v13 = v6 + 1;
    if ( v13 )
    {
      *(_QWORD *)(a1 + 8) = v13;
      result = 0;
      *(_BYTE *)a1 = 0;
    }
    else
    {
LABEL_18:
      *(_BYTE *)(a1 + 1) = 0;
      result = 1;
      *(_BYTE *)a1 = 1;
    }
  }
  return result;
}

//----- (00000000000399E0) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Parser::disambiguator(__int64 a1, __int64 *a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rcx
  __int64 v4; // r9
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rax
  char result; // al
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rax
  char v10; // dl
  unsigned __int8 v11; // r11
  unsigned __int8 v12; // dl
  __int64 v13; // rax
  unsigned __int64 v14; // kr00_8
  bool v15; // cf

  v2 = a2[1];
  v3 = a2[2];
  if ( v3 >= v2 || (v4 = *a2, *(_BYTE *)(*a2 + v3) != 115) )
  {
    *(_QWORD *)(a1 + 8) = 0LL;
    result = 0;
    *(_BYTE *)a1 = 0;
    return result;
  }
  a2[2] = v3 + 1;
  if ( v3 + 1 < v2 )
  {
    if ( *(_BYTE *)(v4 + v3 + 1) == 95 )
    {
      a2[2] = v3 + 2;
      v5 = 0LL;
      goto LABEL_6;
    }
    v8 = v3 + 2;
    v9 = 0LL;
    while ( 1 )
    {
      v10 = *(_BYTE *)(v4 + v8 - 1);
      if ( v10 == 95 )
        break;
      v11 = v10 - 48;
      if ( (unsigned __int8)(v10 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v10 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v10 - 65) >= 0x1Au )
            goto LABEL_22;
          v12 = v10 - 29;
        }
        else
        {
          v12 = v10 - 87;
        }
        v11 = v12;
      }
      a2[2] = v8;
      v14 = v9;
      v13 = 62 * v9;
      if ( is_mul_ok(0x3EuLL, v14) )
      {
        v15 = __CFADD__(v11, v13);
        v9 = v11 + v13;
        if ( !v15 )
        {
          v15 = v8++ < v2;
          if ( v15 )
            continue;
        }
      }
      goto LABEL_22;
    }
    a2[2] = v8;
    v5 = v9 + 1;
    if ( v5 )
    {
LABEL_6:
      v6 = v5 + 1;
      if ( v6 )
      {
        *(_QWORD *)(a1 + 8) = v6;
        result = 0;
        *(_BYTE *)a1 = 0;
        return result;
      }
    }
  }
LABEL_22:
  *(_BYTE *)(a1 + 1) = 0;
  result = 1;
  *(_BYTE *)a1 = 1;
  return result;
}

//----- (0000000000039AC0) ----------------------------------------------------
__int64 __fastcall rustc_demangle::v0::Parser::namespace(_QWORD *a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // rcx
  bool v4; // cf
  __int64 v5; // rcx

  v1 = a1[2];
  if ( v1 >= a1[1] )
    return 1LL;
  v2 = *(unsigned __int8 *)(*a1 + v1);
  a1[2] = v1 + 1;
  if ( (unsigned __int8)(v2 - 65) < 0x1Au )
    return v2 << 32;
  v4 = (unsigned __int8)(v2 - 123) < 0xE6u;
  v5 = 0x11000000000000LL;
  if ( v4 )
    v5 = 0LL;
  return v5 | v4;
}

//----- (0000000000039B20) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Parser::ident(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v4; // rsi
  unsigned __int64 v5; // rcx
  char v6; // r9
  _BYTE *v7; // rbx
  unsigned __int64 v8; // rcx
  unsigned __int8 v9; // r11
  unsigned __int64 v10; // kr00_8
  bool v11; // cf
  unsigned __int64 v12; // r14
  _BYTE *v13; // r15
  unsigned __int64 v14; // r12
  __int64 v15; // rdx
  const char *v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r13
  __int64 v20; // rbp
  unsigned __int64 v21; // rbp

  v4 = a2[1];
  v5 = a2[2];
  if ( v5 < v4 && (v2 = *a2, *(_BYTE *)(*a2 + v5) == 117) )
  {
    a2[2] = ++v5;
    v6 = 1;
    if ( v5 >= v4 )
      goto LABEL_20;
  }
  else
  {
    v6 = 0;
    if ( v5 >= v4 )
    {
LABEL_20:
      *(_BYTE *)(a1 + 8) = 0;
      *(_QWORD *)a1 = 0LL;
      return v2;
    }
  }
  v7 = (_BYTE *)*a2;
  LOBYTE(v2) = *(_BYTE *)(*a2 + v5) - 48;
  if ( (unsigned __int8)v2 > 9u )
    goto LABEL_20;
  v8 = v5 + 1;
  a2[2] = v8;
  if ( (_BYTE)v2 )
  {
    v2 = (unsigned __int8)v2;
    if ( v8 < v4 )
    {
      while ( 1 )
      {
        v9 = v7[v8] - 48;
        if ( v9 > 9u )
          break;
        a2[2] = ++v8;
        v10 = v2;
        v2 *= 10LL;
        if ( !is_mul_ok(0xAuLL, v10) )
          goto LABEL_20;
        v11 = __CFADD__(v9, v2);
        v2 += v9;
        if ( v11 )
          goto LABEL_20;
        if ( v4 == v8 )
        {
          v8 = v4;
          goto LABEL_18;
        }
      }
    }
  }
  else
  {
    v2 = 0LL;
  }
  if ( v8 < v4 && v7[v8] == 95 )
    a2[2] = ++v8;
LABEL_18:
  v12 = v2 + v8;
  if ( __CFADD__(v2, v8) )
    goto LABEL_20;
  a2[2] = v12;
  if ( v12 > v4 )
    goto LABEL_20;
  if ( v8 )
  {
    if ( v8 >= v4 )
    {
      if ( v8 != v4 )
        goto LABEL_43;
    }
    else if ( (char)v7[v8] < -64 )
    {
      goto LABEL_43;
    }
  }
  if ( v12 && v12 < v4 && (char)v7[v12] <= -65 )
LABEL_43:
    core::str::slice_error_fail(v7, v4, v8, v2 + v8, (__int64)&off_59B80);
  v13 = &v7[v8];
  v14 = v2;
  if ( v6 )
  {
    v15 = 0LL;
    v16 = aRustc9b00956e5_0;
    v17 = 0LL;
    do
    {
      if ( !(v17 + v2) )
        goto LABEL_41;
      v18 = v17 - 1;
    }
    while ( v7[v12 - 1 + v17--] != 95 );
    v20 = v18 + v2;
    v2 = (unsigned __int64)core::str::traits::<impl core::slice::index::SliceIndex<str> for core::ops::range::RangeTo<usize>>::index(
                             v18 + v2,
                             v13,
                             v2,
                             (__int64)&off_59B98);
    v16 = (const char *)v2;
    v21 = v20 + 1;
    if ( v21 )
    {
      if ( v21 >= v14 )
      {
        if ( v18 != -1 )
LABEL_37:
          core::str::slice_error_fail(v13, v14, v21, v14, (__int64)&off_59BB0);
      }
      else if ( (char)v7[v12 + 1 + v18] <= -65 )
      {
        goto LABEL_37;
      }
    }
    v13 = &v7[v12 + 1 + v18];
    v14 = ~v18;
LABEL_41:
    if ( !v14 )
      goto LABEL_20;
    *(_QWORD *)a1 = v16;
    *(_QWORD *)(a1 + 8) = v15;
    *(_QWORD *)(a1 + 16) = v13;
    *(_QWORD *)(a1 + 24) = v14;
  }
  else
  {
    *(_QWORD *)a1 = v13;
    *(_QWORD *)(a1 + 8) = v2;
    v2 = (unsigned __int64)aRustc9b00956e5_0;
    *(_QWORD *)(a1 + 16) = aRustc9b00956e5_0;
    *(_QWORD *)(a1 + 24) = 0LL;
  }
  return v2;
}
// 39D11: variable 'v15' is possibly undefined
// 39BF2: variable 'v2' is possibly undefined
// 59B80: using guessed type char *off_59B80;
// 59B98: using guessed type char *off_59B98;
// 59BB0: using guessed type char *off_59BB0;

//----- (0000000000039D40) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::skipping_printing(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // r14
  char result; // al
  char v4[17]; // [rsp+1h] [rbp-11h] BYREF

  v4[0] = HIBYTE(v1);
  v2 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0LL;
  result = rustc_demangle::v0::Printer::print_path(a1, 0);
  if ( result )
    core::result::unwrap_failed((__int64)aFmtErrorSShoul, 61LL, (__int64)v4, (__int64)&off_59778, (__int64)&off_59BC8);
  *(_QWORD *)(a1 + 32) = v2;
  return result;
}
// 39D43: variable 'v1' is possibly undefined
// 59778: using guessed type __int64 (__fastcall *off_59778)();
// 59BC8: using guessed type char *off_59BC8;
// 39D40: using guessed type char var_11[17];

//----- (0000000000039D90) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_backref(__int64 *a1, char a2)
{
  __int64 v3; // r8
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rdi
  char v6; // cl
  unsigned __int64 v7; // rax
  unsigned int v8; // ecx
  char v9; // bp
  __int64 v10; // rdx
  char result; // al
  unsigned __int64 v12; // r10
  unsigned __int64 v13; // rax
  char v14; // dl
  unsigned __int8 v15; // bp
  unsigned __int8 v16; // dl
  __int64 v17; // rax
  unsigned __int64 v18; // kr00_8
  __int64 v19; // rdx
  bool v20; // cf
  __int64 v21; // rdx
  const char *v22; // rdi
  char v23; // cl
  __int128 v24; // [rsp+0h] [rbp-38h]
  __int128 v25; // [rsp+10h] [rbp-28h]

  v3 = *a1;
  if ( !*a1 )
  {
    v10 = a1[4];
    if ( v10 )
      return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v10);
    return 0;
  }
  v4 = a1[1];
  v5 = a1[2];
  v6 = 1;
  if ( v5 >= v4 )
    goto LABEL_23;
  if ( *(_BYTE *)(v3 + v5) == 95 )
  {
    a1[2] = v5 + 1;
    v7 = 0LL;
  }
  else
  {
    v12 = v5 + 1;
    v13 = 0LL;
    while ( 1 )
    {
      v14 = *(_BYTE *)(v3 + v12 - 1);
      if ( v14 == 95 )
        break;
      v15 = v14 - 48;
      if ( (unsigned __int8)(v14 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v14 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v14 - 65) >= 0x1Au )
            goto LABEL_23;
          v16 = v14 - 29;
        }
        else
        {
          v16 = v14 - 87;
        }
        v15 = v16;
      }
      a1[2] = v12;
      v18 = v13;
      v17 = 62 * v13;
      if ( !is_mul_ok(0x3EuLL, v18) )
        goto LABEL_23;
      v19 = v15;
      v9 = 0;
      v20 = __CFADD__(v19, v17);
      v13 = v19 + v17;
      if ( !v20 )
      {
        v20 = v12++ < v4;
        if ( v20 )
          continue;
      }
      goto LABEL_24;
    }
    a1[2] = v12;
    v7 = v13 + 1;
    if ( !v7 )
      goto LABEL_23;
  }
  if ( v7 >= v5 - 1 )
  {
LABEL_23:
    v9 = 0;
    goto LABEL_24;
  }
  v8 = *((_DWORD *)a1 + 6) + 1;
  if ( v8 <= 0x1F4 )
  {
    if ( a1[4] )
    {
      v25 = *((_OWORD *)a1 + 1);
      v24 = *(_OWORD *)a1;
      a1[2] = v7;
      *((_DWORD *)a1 + 6) = v8;
      result = rustc_demangle::v0::Printer::print_path((__int64)a1, a2 != 0);
      *(_OWORD *)a1 = v24;
      *((_OWORD *)a1 + 1) = v25;
      return result;
    }
    return 0;
  }
  v9 = 1;
  v6 = 0;
LABEL_24:
  v21 = a1[4];
  if ( !v21 )
    goto LABEL_28;
  v22 = aRecursionLimit;
  if ( v6 )
    v22 = aInvalidSyntax;
  v23 = <str as core::fmt::Display>::fmt((__int64)v22, 9LL * ((unsigned __int8)v6 ^ 1u) + 16, v21);
  result = 1;
  if ( !v23 )
  {
LABEL_28:
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v9;
    return 0;
  }
  return result;
}
// 4B0F9: using guessed type char asc_4B0F9;

//----- (0000000000039F30) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_backref(__int64 *a1, char a2)
{
  __int64 v3; // r8
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rdi
  char v6; // cl
  unsigned __int64 v7; // rax
  unsigned int v8; // ecx
  char v9; // bp
  __int64 v10; // rdx
  char result; // al
  unsigned __int64 v12; // r10
  unsigned __int64 v13; // rax
  char v14; // dl
  unsigned __int8 v15; // bp
  unsigned __int8 v16; // dl
  __int64 v17; // rax
  unsigned __int64 v18; // kr00_8
  __int64 v19; // rdx
  bool v20; // cf
  __int64 v21; // rdx
  const char *v22; // rdi
  char v23; // cl
  __int128 v24; // [rsp+0h] [rbp-38h]
  __int128 v25; // [rsp+10h] [rbp-28h]

  v3 = *a1;
  if ( !*a1 )
  {
    v10 = a1[4];
    if ( v10 )
      return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v10);
    return 0;
  }
  v4 = a1[1];
  v5 = a1[2];
  v6 = 1;
  if ( v5 >= v4 )
    goto LABEL_23;
  if ( *(_BYTE *)(v3 + v5) == 95 )
  {
    a1[2] = v5 + 1;
    v7 = 0LL;
  }
  else
  {
    v12 = v5 + 1;
    v13 = 0LL;
    while ( 1 )
    {
      v14 = *(_BYTE *)(v3 + v12 - 1);
      if ( v14 == 95 )
        break;
      v15 = v14 - 48;
      if ( (unsigned __int8)(v14 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v14 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v14 - 65) >= 0x1Au )
            goto LABEL_23;
          v16 = v14 - 29;
        }
        else
        {
          v16 = v14 - 87;
        }
        v15 = v16;
      }
      a1[2] = v12;
      v18 = v13;
      v17 = 62 * v13;
      if ( !is_mul_ok(0x3EuLL, v18) )
        goto LABEL_23;
      v19 = v15;
      v9 = 0;
      v20 = __CFADD__(v19, v17);
      v13 = v19 + v17;
      if ( !v20 )
      {
        v20 = v12++ < v4;
        if ( v20 )
          continue;
      }
      goto LABEL_24;
    }
    a1[2] = v12;
    v7 = v13 + 1;
    if ( !v7 )
      goto LABEL_23;
  }
  if ( v7 >= v5 - 1 )
  {
LABEL_23:
    v9 = 0;
    goto LABEL_24;
  }
  v8 = *((_DWORD *)a1 + 6) + 1;
  if ( v8 <= 0x1F4 )
  {
    if ( a1[4] )
    {
      v25 = *((_OWORD *)a1 + 1);
      v24 = *(_OWORD *)a1;
      a1[2] = v7;
      *((_DWORD *)a1 + 6) = v8;
      result = rustc_demangle::v0::Printer::print_const((__int64)a1, a2 != 0);
      *(_OWORD *)a1 = v24;
      *((_OWORD *)a1 + 1) = v25;
      return result;
    }
    return 0;
  }
  v9 = 1;
  v6 = 0;
LABEL_24:
  v21 = a1[4];
  if ( !v21 )
    goto LABEL_28;
  v22 = aRecursionLimit;
  if ( v6 )
    v22 = aInvalidSyntax;
  v23 = <str as core::fmt::Display>::fmt((__int64)v22, 9LL * ((unsigned __int8)v6 ^ 1u) + 16, v21);
  result = 1;
  if ( !v23 )
  {
LABEL_28:
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v9;
    return 0;
  }
  return result;
}
// 4B0F9: using guessed type char asc_4B0F9;

//----- (000000000003A0D0) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_backref(__int64 *a1)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rsi
  char v5; // cl
  unsigned __int64 v6; // rax
  unsigned int v7; // ecx
  char v8; // bp
  __int64 v9; // rdx
  char result; // al
  unsigned __int64 v11; // r9
  unsigned __int64 v12; // rax
  char v13; // dl
  unsigned __int8 v14; // r11
  unsigned __int8 v15; // dl
  __int64 v16; // rax
  unsigned __int64 v17; // kr00_8
  bool v18; // cf
  __int64 v19; // rdx
  const char *v20; // rdi
  char v21; // cl
  __int128 v22; // [rsp+0h] [rbp-38h]
  __int128 v23; // [rsp+10h] [rbp-28h]

  v2 = *a1;
  if ( !v2 )
  {
    v9 = a1[4];
    if ( v9 )
      return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v9);
    return 0;
  }
  v3 = a1[1];
  v4 = a1[2];
  v5 = 1;
  if ( v4 >= v3 )
    goto LABEL_23;
  if ( *(_BYTE *)(v2 + v4) == 95 )
  {
    a1[2] = v4 + 1;
    v6 = 0LL;
  }
  else
  {
    v11 = v4 + 1;
    v12 = 0LL;
    v8 = 0;
    while ( 1 )
    {
      v13 = *(_BYTE *)(v2 + v11 - 1);
      if ( v13 == 95 )
        break;
      v14 = v13 - 48;
      if ( (unsigned __int8)(v13 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v13 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v13 - 65) >= 0x1Au )
            goto LABEL_23;
          v15 = v13 - 29;
        }
        else
        {
          v15 = v13 - 87;
        }
        v14 = v15;
      }
      a1[2] = v11;
      v17 = v12;
      v16 = 62 * v12;
      if ( !is_mul_ok(0x3EuLL, v17) )
        goto LABEL_23;
      v18 = __CFADD__(v14, v16);
      v12 = v14 + v16;
      if ( !v18 )
      {
        v18 = v11++ < v3;
        if ( v18 )
          continue;
      }
      goto LABEL_24;
    }
    a1[2] = v11;
    v6 = v12 + 1;
    if ( !v6 )
      goto LABEL_23;
  }
  if ( v6 >= v4 - 1 )
  {
LABEL_23:
    v8 = 0;
    goto LABEL_24;
  }
  v7 = *((_DWORD *)a1 + 6) + 1;
  if ( v7 <= 0x1F4 )
  {
    if ( a1[4] )
    {
      v23 = *((_OWORD *)a1 + 1);
      v22 = *(_OWORD *)a1;
      a1[2] = v6;
      *((_DWORD *)a1 + 6) = v7;
      result = rustc_demangle::v0::Printer::print_type((__int64)a1);
      *(_OWORD *)a1 = v22;
      *((_OWORD *)a1 + 1) = v23;
      return result;
    }
    return 0;
  }
  v8 = 1;
  v5 = 0;
LABEL_24:
  v19 = a1[4];
  if ( !v19 )
    goto LABEL_28;
  v20 = aRecursionLimit;
  if ( v5 )
    v20 = aInvalidSyntax;
  v21 = <str as core::fmt::Display>::fmt((__int64)v20, 9LL * ((unsigned __int8)v5 ^ 1u) + 16, v19);
  result = 1;
  if ( !v21 )
  {
LABEL_28:
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v8;
    return 0;
  }
  return result;
}
// 4B0F9: using guessed type char asc_4B0F9;

//----- (000000000003A260) ----------------------------------------------------
__int64 __fastcall rustc_demangle::v0::Printer::print_quoted_escaped_chars(__int64 a1, unsigned int a2)
{
  unsigned int v2; // ebx
  __int64 v4; // rdi
  __int64 v6; // [rsp+0h] [rbp-48h] BYREF
  int v7; // [rsp+8h] [rbp-40h]
  __int64 v8; // [rsp+Ch] [rbp-3Ch] BYREF
  int v9; // [rsp+14h] [rbp-34h]

  if ( a1 )
  {
    LOBYTE(v2) = 1;
    if ( !(unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_char(a1) )
    {
      if ( a2 != 34 || (a2 = 1114112, !(unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_char(a1)) )
      {
LABEL_5:
        if ( a2 != 1114112 )
        {
          core::char::methods::<impl char>::escape_debug_ext((__int64)&v8, a2);
          v7 = v9;
          v6 = v8;
          while ( 1 )
          {
            if ( (_BYTE)v6 == 0x80 )
            {
              core::char::EscapeDebug::clear((__int64)&v6);
            }
            else
            {
              v4 = BYTE2(v7);
              if ( BYTE2(v7) >= HIBYTE(v7) )
              {
                a2 = 1114112;
                goto LABEL_5;
              }
              ++BYTE2(v7);
              if ( (unsigned __int8)v4 >= 0xAu )
                core::panicking::panic_bounds_check(v4, 10LL, (__int64)&off_59740);
            }
            if ( (unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_char(a1) )
              return v2;
          }
        }
        return (unsigned int)<core::fmt::Formatter as core::fmt::Write>::write_char(a1);
      }
    }
  }
  else
  {
    return 0;
  }
  return v2;
}
// 3A33C: variable 'v2' is possibly undefined
// 59740: using guessed type char *off_59740;

//----- (000000000003A380) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_lifetime_from_index(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // rbx
  char v3; // bp
  unsigned __int64 v4; // r12
  bool v5; // cf
  unsigned __int64 v6; // r12
  unsigned int v8; // [rsp+4h] [rbp-34h] BYREF
  unsigned __int64 v9[6]; // [rsp+8h] [rbp-30h] BYREF

  v2 = *(_QWORD **)(a1 + 32);
  if ( !v2 )
    return 0;
  v3 = 1;
  if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0FA, 1uLL, (__int64)v2) )
    return v3;
  if ( a2 )
  {
    v4 = *(unsigned int *)(a1 + 40);
    v5 = v4 < a2;
    v6 = v4 - a2;
    if ( !v5 )
    {
      if ( v6 >= 0x1A )
      {
        if ( !<str as core::fmt::Display>::fmt((__int64)asc_4B0CC, 1uLL, (__int64)v2) )
        {
          v9[0] = v6;
          return core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt(v9, (__int64)v2);
        }
      }
      else
      {
        v8 = v6 + 97;
        return <char as core::fmt::Display>::fmt(&v8, v2);
      }
      return v3;
    }
    if ( !<str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, (__int64)v2) )
    {
      *(_QWORD *)a1 = 0LL;
      *(_BYTE *)(a1 + 8) = 0;
      return 0;
    }
    return v3;
  }
  return <str as core::fmt::Display>::fmt((__int64)asc_4B0CC, 1uLL, (__int64)v2);
}
// 4B0CC: using guessed type char asc_4B0CC;
// 4B0FA: using guessed type char asc_4B0FA;
// 3A380: using guessed type unsigned __int64 var_30[6];

//----- (000000000003A470) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::in_binder(__int64 a1)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rdi
  unsigned __int64 v4; // rsi
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // r14
  __int64 v7; // rdx
  char v8; // bp
  __int64 v9; // r12
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v13; // r15
  unsigned __int64 v14; // rax
  bool v15; // cf
  __int64 v16; // rdx
  unsigned __int64 v17; // rsi
  unsigned __int64 v18; // r14
  char v19; // al
  unsigned __int8 v20; // r9
  unsigned __int8 v21; // al
  __int64 v22; // rax
  __int64 v23; // rdx
  unsigned __int64 v24; // rax
  __int64 v25; // r12
  unsigned __int64 v26; // rcx
  __int64 v27; // rdx
  __int64 v28; // rdx

  v2 = *(_QWORD *)a1;
  if ( !*(_QWORD *)a1 )
  {
    v11 = *(_QWORD *)(a1 + 32);
    if ( v11 )
      return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v11);
    return 0;
  }
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if ( v4 >= v3 || *(_BYTE *)(v2 + v4) != 71 )
  {
    v6 = 0LL;
    goto LABEL_10;
  }
  *(_QWORD *)(a1 + 16) = v4 + 1;
  if ( v4 + 1 < v3 )
  {
    if ( *(_BYTE *)(v2 + v4 + 1) == 95 )
    {
      *(_QWORD *)(a1 + 16) = v4 + 2;
      v5 = 0LL;
    }
    else
    {
      v17 = v4 + 2;
      v18 = 0LL;
      while ( 1 )
      {
        v19 = *(_BYTE *)(v2 + v17 - 1);
        if ( v19 == 95 )
          break;
        v20 = v19 - 48;
        if ( (unsigned __int8)(v19 - 48) >= 0xAu )
        {
          if ( (unsigned __int8)(v19 - 97) >= 0x1Au )
          {
            if ( (unsigned __int8)(v19 - 65) >= 0x1Au )
              goto LABEL_61;
            v21 = v19 - 29;
          }
          else
          {
            v21 = v19 - 87;
          }
          v20 = v21;
        }
        *(_QWORD *)(a1 + 16) = v17;
        v22 = 62 * v18;
        if ( is_mul_ok(0x3EuLL, v18) )
        {
          v18 = v20 + v22;
          if ( !__CFADD__(v20, v22) )
          {
            v15 = v17++ < v3;
            if ( v15 )
              continue;
          }
        }
        goto LABEL_61;
      }
      *(_QWORD *)(a1 + 16) = v17;
      v5 = v18 + 1;
      if ( !v5 )
        goto LABEL_61;
    }
    v6 = v5 + 1;
    if ( v6 )
    {
LABEL_10:
      v7 = *(_QWORD *)(a1 + 32);
      if ( v7 )
      {
        if ( !v6 )
          goto LABEL_48;
        v8 = 1;
        if ( !<str as core::fmt::Display>::fmt((__int64)aFor, 4uLL, v7) )
        {
          ++*(_DWORD *)(a1 + 40);
          v9 = 1LL;
          if ( !rustc_demangle::v0::Printer::print_lifetime_from_index(a1, 1uLL) )
          {
            while ( v6 != v9 )
            {
              if ( !v9
                || (v10 = *(_QWORD *)(a1 + 32)) == 0
                || !<str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v10) )
              {
                ++*(_DWORD *)(a1 + 40);
                ++v9;
                if ( !rustc_demangle::v0::Printer::print_lifetime_from_index(a1, 1uLL) )
                  continue;
              }
              return v8;
            }
            v23 = *(_QWORD *)(a1 + 32);
            if ( !v23 || !<str as core::fmt::Display>::fmt((__int64)asc_4B0FB, 2uLL, v23) )
            {
LABEL_48:
              v24 = *(_QWORD *)a1;
              if ( *(_QWORD *)a1 )
              {
                v25 = 0LL;
                while ( 1 )
                {
                  v26 = *(_QWORD *)(a1 + 16);
                  if ( v26 < *(_QWORD *)(a1 + 8) && *(_BYTE *)(v24 + v26) == 69 )
                    break;
                  v15 = v25-- == 0;
                  if ( !v15
                    && (v27 = *(_QWORD *)(a1 + 32)) != 0
                    && <str as core::fmt::Display>::fmt((__int64)asc_4B116, 3uLL, v27)
                    || rustc_demangle::v0::Printer::print_dyn_trait((unsigned __int64 *)a1) )
                  {
                    v8 = 1;
                    *(_DWORD *)(a1 + 40) -= v6;
                    return v8;
                  }
                  v24 = *(_QWORD *)a1;
                  if ( !*(_QWORD *)a1 )
                    goto LABEL_57;
                }
                *(_QWORD *)(a1 + 16) = v26 + 1;
                v8 = 0;
                *(_DWORD *)(a1 + 40) -= v6;
              }
              else
              {
LABEL_57:
                v8 = 0;
                *(_DWORD *)(a1 + 40) -= v6;
              }
            }
          }
        }
        return v8;
      }
      v13 = 0LL;
      while ( 1 )
      {
        v14 = *(_QWORD *)(a1 + 16);
        if ( v14 < *(_QWORD *)(a1 + 8) && *(_BYTE *)(v2 + v14) == 69 )
          break;
        v15 = v13-- == 0;
        if ( !v15 )
        {
          v16 = *(_QWORD *)(a1 + 32);
          if ( v16 )
          {
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B116, 3uLL, v16) )
              return 1;
          }
        }
        if ( rustc_demangle::v0::Printer::print_dyn_trait((unsigned __int64 *)a1) )
          return 1;
        v2 = *(_QWORD *)a1;
        if ( !*(_QWORD *)a1 )
          return 0;
      }
      *(_QWORD *)(a1 + 16) = v14 + 1;
      return 0;
    }
  }
LABEL_61:
  v28 = *(_QWORD *)(a1 + 32);
  if ( v28 )
  {
    v8 = 1;
    if ( <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v28) )
      return v8;
  }
  *(_QWORD *)a1 = 0LL;
  *(_BYTE *)(a1 + 8) = 0;
  return 0;
}
// 4B0F9: using guessed type char asc_4B0F9;

//----- (000000000003A790) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::in_binder(__int64 a1)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rdi
  unsigned __int64 v4; // rsi
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // r14
  __int64 v7; // rdx
  char v8; // bp
  __int64 v9; // r12
  __int64 v10; // rdx
  __int64 v11; // rdx
  char result; // al
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // r14
  char v15; // al
  unsigned __int8 v16; // r9
  unsigned __int8 v17; // al
  __int64 v18; // rax
  __int64 v20; // rdx
  __int64 v21; // rdx

  v2 = *(_QWORD *)a1;
  if ( !*(_QWORD *)a1 )
  {
    v11 = *(_QWORD *)(a1 + 32);
    if ( v11 )
      return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v11);
    return 0;
  }
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if ( v4 < v3 && *(_BYTE *)(v2 + v4) == 71 )
  {
    *(_QWORD *)(a1 + 16) = v4 + 1;
    if ( v4 + 1 >= v3 )
      goto LABEL_40;
    if ( *(_BYTE *)(v2 + v4 + 1) == 95 )
    {
      *(_QWORD *)(a1 + 16) = v4 + 2;
      v5 = 0LL;
    }
    else
    {
      v13 = v4 + 2;
      v14 = 0LL;
      while ( 1 )
      {
        v15 = *(_BYTE *)(v2 + v13 - 1);
        if ( v15 == 95 )
          break;
        v16 = v15 - 48;
        if ( (unsigned __int8)(v15 - 48) >= 0xAu )
        {
          if ( (unsigned __int8)(v15 - 97) >= 0x1Au )
          {
            if ( (unsigned __int8)(v15 - 65) >= 0x1Au )
              goto LABEL_40;
            v17 = v15 - 29;
          }
          else
          {
            v17 = v15 - 87;
          }
          v16 = v17;
        }
        *(_QWORD *)(a1 + 16) = v13;
        v18 = 62 * v14;
        if ( is_mul_ok(0x3EuLL, v14) )
        {
          v14 = v16 + v18;
          if ( !__CFADD__(v16, v18) && v13++ < v3 )
            continue;
        }
        goto LABEL_40;
      }
      *(_QWORD *)(a1 + 16) = v13;
      v5 = v14 + 1;
      if ( !v5 )
        goto LABEL_40;
    }
    v6 = v5 + 1;
    if ( !v6 )
    {
LABEL_40:
      v21 = *(_QWORD *)(a1 + 32);
      if ( v21 )
      {
        v8 = 1;
        if ( <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v21) )
          return v8;
      }
      *(_QWORD *)a1 = 0LL;
      *(_BYTE *)(a1 + 8) = 0;
      return 0;
    }
  }
  else
  {
    v6 = 0LL;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if ( !v7 )
    return rustc_demangle::v0::Printer::print_type::{{closure}}((unsigned __int64 *)a1);
  if ( !v6 )
    goto LABEL_38;
  v8 = 1;
  if ( !<str as core::fmt::Display>::fmt((__int64)aFor, 4uLL, v7) )
  {
    ++*(_DWORD *)(a1 + 40);
    v9 = 1LL;
    if ( !rustc_demangle::v0::Printer::print_lifetime_from_index(a1, 1uLL) )
    {
      while ( v6 != v9 )
      {
        if ( !v9
          || (v10 = *(_QWORD *)(a1 + 32)) == 0
          || !<str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v10) )
        {
          ++*(_DWORD *)(a1 + 40);
          ++v9;
          if ( !rustc_demangle::v0::Printer::print_lifetime_from_index(a1, 1uLL) )
            continue;
        }
        return v8;
      }
      v20 = *(_QWORD *)(a1 + 32);
      if ( !v20 || !<str as core::fmt::Display>::fmt((__int64)asc_4B0FB, 2uLL, v20) )
      {
LABEL_38:
        result = rustc_demangle::v0::Printer::print_type::{{closure}}((unsigned __int64 *)a1);
        *(_DWORD *)(a1 + 40) -= v6;
        return result;
      }
    }
  }
  return v8;
}
// 4B0F9: using guessed type char asc_4B0F9;

//----- (000000000003A9D0) ----------------------------------------------------
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v2; // r14
  __int64 i; // rbx
  unsigned __int64 v4; // rcx
  __int64 v5; // rdx

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  v2 = 0LL;
  for ( i = 0LL; ; ++i )
  {
    v4 = a1[2];
    if ( v4 < a1[1] && *(_BYTE *)(v1 + v4) == 69 )
      break;
    if ( i )
    {
      v5 = a1[4];
      if ( v5 )
      {
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v5) )
          return 1LL;
      }
    }
    if ( rustc_demangle::v0::Printer::print_type((__int64)a1) )
      return 1LL;
    v1 = *a1;
    if ( !*a1 )
      return v2;
  }
  a1[2] = v4 + 1;
  return 0LL;
}

//----- (000000000003AA70) ----------------------------------------------------
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v2; // r14
  __int64 i; // rbx
  unsigned __int64 v4; // rcx
  __int64 v5; // rdx

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  v2 = 0LL;
  for ( i = 0LL; ; ++i )
  {
    v4 = a1[2];
    if ( v4 < a1[1] && *(_BYTE *)(v1 + v4) == 69 )
      break;
    if ( i )
    {
      v5 = a1[4];
      if ( v5 )
      {
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v5) )
          return 1LL;
      }
    }
    if ( rustc_demangle::v0::Printer::print_const((__int64)a1, 1) )
      return 1LL;
    v1 = *a1;
    if ( !*a1 )
      return v2;
  }
  a1[2] = v4 + 1;
  return 0LL;
}

//----- (000000000003AB20) ----------------------------------------------------
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // r13
  unsigned __int64 v4; // rcx
  __int64 v6; // rdx

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  v2 = 0LL;
  v3 = 0LL;
  while ( 1 )
  {
    v4 = a1[2];
    if ( v4 < a1[1] && *(_BYTE *)(v1 + v4) == 69 )
      break;
    if ( v3-- != 0 )
    {
      v6 = a1[4];
      if ( v6 )
      {
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v6) )
          return 1LL;
      }
    }
    if ( rustc_demangle::v0::Printer::print_generic_arg(a1) )
      return 1LL;
    v1 = *a1;
    if ( !*a1 )
      return v2;
  }
  a1[2] = v4 + 1;
  return 0LL;
}

//----- (000000000003ABC0) ----------------------------------------------------
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(unsigned __int64 *a1)
{
  unsigned __int64 v1; // rcx
  __int64 i; // r15
  unsigned __int64 v4; // rax
  __int64 v5; // rdx
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // r12
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // rax
  char v12; // dl
  unsigned __int8 v13; // r8
  unsigned __int8 v14; // dl
  __int64 v15; // rax
  unsigned __int64 v16; // kr00_8
  bool v17; // cf
  __int64 v18; // r12
  char v19; // r12
  __int64 v20; // rdx
  __int64 v21; // rdx
  __int128 v23[2]; // [rsp+0h] [rbp-78h] BYREF
  __int128 v24[5]; // [rsp+20h] [rbp-58h] BYREF

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  for ( i = 0LL; ; ++i )
  {
    v4 = a1[2];
    if ( v4 < a1[1] && *(_BYTE *)(v1 + v4) == 69 )
    {
      a1[2] = v4 + 1;
      return 0LL;
    }
    if ( i )
    {
      v5 = a1[4];
      if ( v5 )
      {
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v5) )
          return 1LL;
        v1 = *a1;
        if ( !*a1 )
        {
          v8 = a1[4];
          if ( !v8 )
            return 0LL;
          v9 = 1LL;
          if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v8) )
            return v9;
          goto LABEL_4;
        }
      }
    }
    v6 = a1[1];
    v7 = a1[2];
    if ( v7 < v6 && *(_BYTE *)(v1 + v7) == 115 )
    {
      a1[2] = v7 + 1;
      if ( v7 + 1 >= v6 )
        break;
      if ( *(_BYTE *)(v1 + v7 + 1) == 95 )
      {
        a1[2] = v7 + 2;
        goto LABEL_32;
      }
      v10 = v7 + 2;
      v11 = 0LL;
      while ( 1 )
      {
        v12 = *(_BYTE *)(v1 + v10 - 1);
        if ( v12 == 95 )
          break;
        v13 = v12 - 48;
        if ( (unsigned __int8)(v12 - 48) >= 0xAu )
        {
          if ( (unsigned __int8)(v12 - 97) >= 0x1Au )
          {
            if ( (unsigned __int8)(v12 - 65) >= 0x1Au )
              goto LABEL_45;
            v14 = v12 - 29;
          }
          else
          {
            v14 = v12 - 87;
          }
          v13 = v14;
        }
        a1[2] = v10;
        v16 = v11;
        v15 = 62 * v11;
        if ( is_mul_ok(0x3EuLL, v16) )
        {
          v17 = __CFADD__(v13, v15);
          v11 = v13 + v15;
          if ( !v17 )
          {
            v17 = v10++ < v6;
            if ( v17 )
              continue;
          }
        }
        goto LABEL_45;
      }
      a1[2] = v10;
      if ( v11 > 0xFFFFFFFFFFFFFFFDLL )
        break;
    }
LABEL_32:
    rustc_demangle::v0::Parser::ident((__int64)v23, a1);
    if ( *(_QWORD *)&v23[0] )
    {
      v24[1] = v23[1];
      v24[0] = v23[0];
      v18 = a1[4];
      if ( v18
        && ((unsigned __int8)<rustc_demangle::v0::Ident as core::fmt::Display>::fmt((unsigned __int8 **)v24, a1[4])
         || <str as core::fmt::Display>::fmt((__int64)asc_4B13B, 2uLL, v18))
        || rustc_demangle::v0::Printer::print_const((__int64)a1, 1) )
      {
        return 1LL;
      }
    }
    else
    {
      v19 = BYTE8(v23[0]);
      v20 = a1[4];
      if ( BYTE8(v23[0]) )
      {
        if ( v20 && <str as core::fmt::Display>::fmt((__int64)aRecursionLimit, 0x19uLL, v20) )
          return 1LL;
      }
      else if ( v20 && <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v20) )
      {
        return 1LL;
      }
      *a1 = 0LL;
      *((_BYTE *)a1 + 8) = v19;
    }
LABEL_4:
    v1 = *a1;
    if ( !*a1 )
      return 0LL;
  }
LABEL_45:
  v21 = a1[4];
  if ( v21 && <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v21) )
    return 1LL;
  *a1 = 0LL;
  *((_BYTE *)a1 + 8) = 0;
  return 0LL;
}
// 4B0F9: using guessed type char asc_4B0F9;

//----- (000000000003AE80) ----------------------------------------------------
__int64 __fastcall rustc_demangle::v0::Printer::print_sep_list(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // r13
  unsigned __int64 v4; // rcx
  __int64 v6; // rdx

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  v2 = 0LL;
  v3 = 0LL;
  while ( 1 )
  {
    v4 = a1[2];
    if ( v4 < a1[1] && *(_BYTE *)(v1 + v4) == 69 )
      break;
    if ( v3-- != 0 )
    {
      v6 = a1[4];
      if ( v6 )
      {
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v6) )
          return 1LL;
      }
    }
    if ( rustc_demangle::v0::Printer::print_const((__int64)a1, 1) )
      return 1LL;
    v1 = *a1;
    if ( !*a1 )
      return v2;
  }
  a1[2] = v4 + 1;
  return 0LL;
}

//----- (000000000003AF20) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_path(__int64 a1, unsigned __int8 a2)
{
  __int64 v3; // rcx
  unsigned int v4; // eax
  __int64 v5; // rdx
  char v6; // bp
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rdi
  int v9; // r14d
  unsigned __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rdx
  char v13; // r14
  __int64 v14; // rdx
  const char *v15; // rdi
  unsigned __int64 v16; // rsi
  char v17; // al
  __int64 v18; // rax
  unsigned __int64 v19; // r14
  __int64 v20; // r15
  unsigned __int64 v21; // r14
  __int64 v22; // rdx
  __int64 v23; // rsi
  __int64 v24; // rdx
  __int64 v25; // rdx
  __int64 v26; // rdx
  const char *v27; // rdi
  __int64 v28; // rdx
  const char *v29; // rdi
  unsigned __int64 v30; // rsi
  __int64 v31; // rsi
  __int64 v32; // rdi
  __int64 v33; // rdx
  unsigned __int64 v34; // rdi
  unsigned __int64 v35; // rax
  char v36; // dl
  unsigned __int8 v37; // r9
  unsigned __int8 v38; // dl
  __int64 v39; // rax
  unsigned __int64 v40; // kr00_8
  bool v41; // cf
  __int64 v42; // rdx
  __int64 v43; // rdx
  __int64 v45; // rdx
  __int64 v46; // rdx
  _QWORD *v47; // rdx
  const char *v48; // rdi
  unsigned __int64 v49; // rsi
  char v50; // al
  __int64 v51; // rdx
  __int64 v52; // rsi
  __int64 v53; // rsi
  __int128 v54; // [rsp+0h] [rbp-98h] BYREF
  __int128 v55; // [rsp+10h] [rbp-88h]
  __int128 v56; // [rsp+20h] [rbp-78h] BYREF
  __int128 v57; // [rsp+30h] [rbp-68h]
  unsigned __int64 v58; // [rsp+48h] [rbp-50h] BYREF
  __int128 v59[4]; // [rsp+50h] [rbp-48h] BYREF

  v3 = *(_QWORD *)a1;
  if ( !*(_QWORD *)a1 )
    goto LABEL_91;
  v4 = *(_DWORD *)(a1 + 24) + 1;
  *(_DWORD *)(a1 + 24) = v4;
  if ( v4 > 0x1F4 )
  {
    v5 = *(_QWORD *)(a1 + 32);
    if ( v5 )
    {
      v6 = 1;
      if ( <str as core::fmt::Display>::fmt((__int64)aRecursionLimit, 0x19uLL, v5) )
        return v6;
    }
    *(_QWORD *)a1 = 0LL;
    *(_BYTE *)(a1 + 8) = 1;
    return 0;
  }
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 16);
  if ( v8 >= v7 )
  {
LABEL_94:
    v45 = *(_QWORD *)(a1 + 32);
    if ( v45 )
    {
      v6 = 1;
      if ( <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v45) )
        return v6;
    }
    *(_QWORD *)a1 = 0LL;
    *(_BYTE *)(a1 + 8) = 0;
    return 0;
  }
  v9 = *(unsigned __int8 *)(v3 + v8);
  v10 = v8 + 1;
  *(_QWORD *)(a1 + 16) = v8 + 1;
  switch ( v9 )
  {
    case 'B':
      v17 = rustc_demangle::v0::Printer::print_backref((__int64 *)a1, a2);
      v6 = 1;
      goto LABEL_49;
    case 'C':
      rustc_demangle::v0::Parser::disambiguator((__int64)&v54, (__int64 *)a1);
      if ( (_BYTE)v54 )
        goto LABEL_23;
      v58 = *((_QWORD *)&v54 + 1);
      if ( *(_QWORD *)a1 )
      {
        rustc_demangle::v0::Parser::ident((__int64)&v54, (unsigned __int64 *)a1);
        if ( !(_QWORD)v54 )
          goto LABEL_83;
        v59[1] = v55;
        v59[0] = v54;
        v31 = *(_QWORD *)(a1 + 32);
        if ( v31 )
        {
          v6 = 1;
          if ( (unsigned __int8)<rustc_demangle::v0::Ident as core::fmt::Display>::fmt((unsigned __int8 **)v59, v31) )
            return v6;
          v32 = *(_QWORD *)(a1 + 32);
          if ( v32 )
          {
            if ( (*(_BYTE *)(v32 + 52) & 4) == 0
              && ((unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str(v32)
               || (unsigned __int8)core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt(&v58, *(_QWORD *)(a1 + 32))
               || (unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str(*(_QWORD *)(a1 + 32))) )
            {
              return 1;
            }
          }
        }
        goto LABEL_50;
      }
      v33 = *(_QWORD *)(a1 + 32);
      if ( !v33 )
        return 0;
      return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v33);
    case 'I':
      v6 = 1;
      if ( rustc_demangle::v0::Printer::print_path(a1, a2) )
        return v6;
      if ( a2 )
      {
        v24 = *(_QWORD *)(a1 + 32);
        if ( v24 )
        {
          if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF8F, 2uLL, v24) )
            return v6;
        }
      }
      v25 = *(_QWORD *)(a1 + 32);
      if ( v25 )
      {
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF96, 1uLL, v25) )
          return v6;
      }
      if ( rustc_demangle::v0::Printer::print_sep_list((__int64 *)a1) )
        return v6;
      goto LABEL_46;
    case 'M':
    case 'X':
      if ( v10 >= v7 || *(_BYTE *)(v3 + v10) != 115 )
        goto LABEL_13;
      *(_QWORD *)(a1 + 16) = v8 + 2;
      if ( v8 + 2 >= v7 )
        goto LABEL_94;
      if ( *(_BYTE *)(v3 + v8 + 2) == 95 )
      {
        *(_QWORD *)(a1 + 16) = v8 + 3;
      }
      else
      {
        v34 = v8 + 3;
        v35 = 0LL;
        while ( 1 )
        {
          v36 = *(_BYTE *)(v3 + v34 - 1);
          if ( v36 == 95 )
            break;
          v37 = v36 - 48;
          if ( (unsigned __int8)(v36 - 48) >= 0xAu )
          {
            if ( (unsigned __int8)(v36 - 97) >= 0x1Au )
            {
              if ( (unsigned __int8)(v36 - 65) >= 0x1Au )
                goto LABEL_94;
              v38 = v36 - 29;
            }
            else
            {
              v38 = v36 - 87;
            }
            v37 = v38;
          }
          *(_QWORD *)(a1 + 16) = v34;
          v40 = v35;
          v39 = 62 * v35;
          if ( is_mul_ok(0x3EuLL, v40) )
          {
            v41 = __CFADD__(v37, v39);
            v35 = v37 + v39;
            if ( !v41 )
            {
              v41 = v34++ < v7;
              if ( v41 )
                continue;
            }
          }
          goto LABEL_94;
        }
        *(_QWORD *)(a1 + 16) = v34;
        if ( v35 > 0xFFFFFFFFFFFFFFFDLL )
          goto LABEL_94;
      }
LABEL_13:
      rustc_demangle::v0::Printer::skipping_printing(a1);
LABEL_14:
      v11 = *(_QWORD *)(a1 + 32);
      if ( v11 )
      {
        v6 = 1;
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF96, 1uLL, v11) )
          return v6;
      }
      v6 = 1;
      if ( rustc_demangle::v0::Printer::print_type(a1) )
        return v6;
      if ( (_BYTE)v9 != 77 )
      {
        v12 = *(_QWORD *)(a1 + 32);
        if ( v12 )
        {
          if ( <str as core::fmt::Display>::fmt((__int64)aAs, 4uLL, v12) )
            return v6;
        }
        if ( rustc_demangle::v0::Printer::print_path(a1, 0) )
          return v6;
      }
LABEL_46:
      v26 = *(_QWORD *)(a1 + 32);
      if ( !v26 )
        goto LABEL_50;
      v27 = asc_4AF95;
      goto LABEL_48;
    case 'N':
      v18 = rustc_demangle::v0::Parser::namespace((_QWORD *)a1);
      v19 = v18;
      if ( (v18 & 1) != 0 )
      {
        v28 = *(_QWORD *)(a1 + 32);
        if ( (v18 & 0x100) != 0 )
        {
          if ( v28 )
          {
            v29 = aRecursionLimit;
            v30 = 25LL;
LABEL_67:
            v6 = 1;
            if ( <str as core::fmt::Display>::fmt((__int64)v29, v30, v28) )
              return v6;
          }
        }
        else if ( v28 )
        {
          v29 = aInvalidSyntax;
          v30 = 16LL;
          goto LABEL_67;
        }
        *(_QWORD *)a1 = 0LL;
        *(_BYTE *)(a1 + 8) = BYTE1(v19) & 1;
        return 0;
      }
      v6 = 1;
      if ( rustc_demangle::v0::Printer::print_path(a1, a2) )
        return v6;
      if ( !*(_QWORD *)a1 )
      {
        v42 = *(_QWORD *)(a1 + 32);
        if ( !v42 )
          return 0;
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF8F, 2uLL, v42) )
          return v6;
        if ( !*(_QWORD *)a1 )
        {
LABEL_91:
          v43 = *(_QWORD *)(a1 + 32);
          if ( v43 )
            return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v43);
          return 0;
        }
      }
      rustc_demangle::v0::Parser::disambiguator((__int64)&v54, (__int64 *)a1);
      if ( (_BYTE)v54 )
      {
LABEL_23:
        v13 = BYTE1(v54);
        v14 = *(_QWORD *)(a1 + 32);
        if ( !BYTE1(v54) )
          goto LABEL_84;
LABEL_24:
        if ( v14 )
        {
          v15 = aRecursionLimit;
          v16 = 25LL;
          goto LABEL_86;
        }
LABEL_87:
        *(_QWORD *)a1 = 0LL;
        *(_BYTE *)(a1 + 8) = v13;
        return 0;
      }
      if ( !*(_QWORD *)a1 )
        goto LABEL_91;
      v20 = *((_QWORD *)&v54 + 1);
      rustc_demangle::v0::Parser::ident((__int64)&v54, (unsigned __int64 *)a1);
      if ( (_QWORD)v54 )
      {
        v21 = HIDWORD(v19);
        v57 = v55;
        v56 = v54;
        if ( (_DWORD)v21 == 1114112 )
        {
          if ( *((_QWORD *)&v57 + 1) | *((_QWORD *)&v56 + 1) )
          {
            v22 = *(_QWORD *)(a1 + 32);
            if ( v22 )
            {
              if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF8F, 2uLL, v22) )
                return v6;
              v23 = *(_QWORD *)(a1 + 32);
              if ( v23 )
              {
                v17 = <rustc_demangle::v0::Ident as core::fmt::Display>::fmt((unsigned __int8 **)&v56, v23);
LABEL_49:
                if ( v17 )
                  return v6;
              }
            }
          }
LABEL_50:
          if ( *(_QWORD *)a1 )
            --*(_DWORD *)(a1 + 24);
          return 0;
        }
        v46 = *(_QWORD *)(a1 + 32);
        if ( v46 )
        {
          if ( <str as core::fmt::Display>::fmt((__int64)asc_4B101, 3uLL, v46) )
            return v6;
          v47 = *(_QWORD **)(a1 + 32);
        }
        else
        {
          v47 = 0LL;
        }
        if ( (_DWORD)v21 == 67 )
        {
          if ( !v47 )
            goto LABEL_113;
          v48 = aClosure;
          v49 = 7LL;
        }
        else
        {
          if ( (_DWORD)v21 != 83 )
          {
            LODWORD(v54) = v21;
            if ( !v47 )
              goto LABEL_113;
            v50 = <char as core::fmt::Display>::fmt((unsigned int *)&v54, v47);
LABEL_112:
            if ( v50 )
              return v6;
LABEL_113:
            v51 = *(_QWORD *)(a1 + 32);
            if ( *((_QWORD *)&v57 + 1) | *((_QWORD *)&v56 + 1) )
            {
              if ( !v51 )
                goto LABEL_50;
              if ( <str as core::fmt::Display>::fmt((__int64)asc_4B10B, 1uLL, v51) )
                return v6;
              v53 = *(_QWORD *)(a1 + 32);
              if ( !v53 )
                goto LABEL_50;
              if ( (unsigned __int8)<rustc_demangle::v0::Ident as core::fmt::Display>::fmt(
                                      (unsigned __int8 **)&v56,
                                      v53) )
                return v6;
              v51 = *(_QWORD *)(a1 + 32);
              if ( !v51 )
                goto LABEL_50;
            }
            else if ( !v51 )
            {
              goto LABEL_50;
            }
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B10C, 1uLL, v51) )
              return v6;
            v52 = *(_QWORD *)(a1 + 32);
            *(_QWORD *)&v54 = v20;
            if ( !v52 )
              goto LABEL_50;
            if ( (unsigned __int8)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt(
                                    (unsigned __int64 *)&v54,
                                    v52) )
              return v6;
            v26 = *(_QWORD *)(a1 + 32);
            if ( !v26 )
              goto LABEL_50;
            v27 = asc_4B00C;
LABEL_48:
            v17 = <str as core::fmt::Display>::fmt((__int64)v27, 1uLL, v26);
            goto LABEL_49;
          }
          if ( !v47 )
            goto LABEL_113;
          v48 = aShim;
          v49 = 4LL;
        }
        v50 = <str as core::fmt::Display>::fmt((__int64)v48, v49, (__int64)v47);
        goto LABEL_112;
      }
LABEL_83:
      v13 = BYTE8(v54);
      v14 = *(_QWORD *)(a1 + 32);
      if ( BYTE8(v54) )
        goto LABEL_24;
LABEL_84:
      if ( !v14 )
        goto LABEL_87;
      v15 = aInvalidSyntax;
      v16 = 16LL;
LABEL_86:
      v6 = 1;
      if ( !<str as core::fmt::Display>::fmt((__int64)v15, v16, v14) )
        goto LABEL_87;
      return v6;
    case 'Y':
      goto LABEL_14;
    default:
      goto LABEL_94;
  }
}
// 4AF95: using guessed type char asc_4AF95;
// 4AF96: using guessed type char asc_4AF96;
// 4B00C: using guessed type char asc_4B00C;
// 4B0F9: using guessed type char asc_4B0F9;
// 4B10B: using guessed type char asc_4B10B;
// 4B10C: using guessed type char asc_4B10C;

//----- (000000000003B640) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_generic_arg(_QWORD *a1)
{
  __int64 v1; // rsi
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  char result; // al
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  char v8; // dl
  unsigned __int8 v9; // r10
  unsigned __int8 v10; // dl
  __int64 v11; // rax
  unsigned __int64 v12; // kr00_8
  bool v13; // cf
  __int64 v14; // rdx
  char v15; // cl

  v1 = *a1;
  if ( !*a1 )
    return rustc_demangle::v0::Printer::print_type((__int64)a1);
  v2 = a1[1];
  v3 = a1[2];
  if ( v3 >= v2 )
    return rustc_demangle::v0::Printer::print_type((__int64)a1);
  if ( *(_BYTE *)(v1 + v3) != 76 )
  {
    if ( *(_BYTE *)(v1 + v3) == 75 )
    {
      a1[2] = v3 + 1;
      return rustc_demangle::v0::Printer::print_const((__int64)a1, 0);
    }
    return rustc_demangle::v0::Printer::print_type((__int64)a1);
  }
  a1[2] = v3 + 1;
  if ( v3 + 1 < v2 )
  {
    if ( *(_BYTE *)(v1 + v3 + 1) == 95 )
    {
      a1[2] = v3 + 2;
      v4 = 0LL;
      return rustc_demangle::v0::Printer::print_lifetime_from_index((__int64)a1, v4);
    }
    v6 = v3 + 2;
    v7 = 0LL;
    while ( 1 )
    {
      v8 = *(_BYTE *)(v1 + v6 - 1);
      if ( v8 == 95 )
        break;
      v9 = v8 - 48;
      if ( (unsigned __int8)(v8 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v8 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v8 - 65) >= 0x1Au )
            goto LABEL_24;
          v10 = v8 - 29;
        }
        else
        {
          v10 = v8 - 87;
        }
        v9 = v10;
      }
      a1[2] = v6;
      v12 = v7;
      v11 = 62 * v7;
      if ( is_mul_ok(0x3EuLL, v12) )
      {
        v13 = __CFADD__(v9, v11);
        v7 = v9 + v11;
        if ( !v13 )
        {
          v13 = v6++ < v2;
          if ( v13 )
            continue;
        }
      }
      goto LABEL_24;
    }
    a1[2] = v6;
    v4 = v7 + 1;
    if ( v4 )
      return rustc_demangle::v0::Printer::print_lifetime_from_index((__int64)a1, v4);
  }
LABEL_24:
  v14 = a1[4];
  if ( !v14 || (v15 = <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v14), result = 1, !v15) )
  {
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = 0;
    return 0;
  }
  return result;
}

//----- (000000000003B750) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_type(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int64 v3; // rcx
  int v4; // r14d
  __int64 v5; // rsi
  int v6; // edx
  unsigned int v7; // edx
  __int64 v8; // rdx
  char v9; // bp
  __int64 v10; // rdx
  const char *v11; // rdi
  unsigned __int64 v12; // rsi
  __int64 v14; // rdx
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v17; // rdx
  const char *v18; // rdi
  __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  char v21; // r14
  __int64 v22; // rdx
  const char *v23; // rdi
  unsigned __int64 v24; // rsi
  __int64 v25; // rdx
  __int64 v26; // rdx
  const char *v27; // rdi
  unsigned __int64 v28; // rsi
  char v29; // al
  __int64 v30; // rdx
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // r14
  __int64 v33; // rdx
  __int64 v34; // rdx
  __int64 v35; // rdx
  __int64 v36; // rdx
  __int64 v37; // rdx
  __int64 v38; // rdx
  char v39; // [rsp+0h] [rbp-28h] BYREF
  char v40; // [rsp+1h] [rbp-27h]
  unsigned __int64 v41; // [rsp+8h] [rbp-20h]

  v2 = *(_QWORD *)a1;
  if ( !*(_QWORD *)a1 )
  {
    v10 = *(_QWORD *)(a1 + 32);
    if ( !v10 )
      return 0;
    v11 = asc_4B0F9;
    v12 = 1LL;
    return <str as core::fmt::Display>::fmt((__int64)v11, v12, v10);
  }
  v3 = *(_QWORD *)(a1 + 16);
  if ( v3 >= *(_QWORD *)(a1 + 8) )
  {
    v14 = *(_QWORD *)(a1 + 32);
    if ( v14 )
    {
      v9 = 1;
      if ( <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v14) )
        return v9;
    }
    goto LABEL_14;
  }
  v4 = *(unsigned __int8 *)(v2 + v3);
  *(_QWORD *)(a1 + 16) = v3 + 1;
  if ( (unsigned __int8)(v4 - 97) <= 0x19u )
  {
    v5 = (unsigned __int8)(v4 - 97);
    v6 = 62716863;
    if ( _bittest(&v6, v5) )
    {
      v10 = *(_QWORD *)(a1 + 32);
      if ( !v10 )
        return 0;
      v11 = (const char *)*(&off_59C68 + v5);
      v12 = qword_4B210[v5];
      return <str as core::fmt::Display>::fmt((__int64)v11, v12, v10);
    }
  }
  v7 = *(_DWORD *)(a1 + 24) + 1;
  *(_DWORD *)(a1 + 24) = v7;
  if ( v7 <= 0x1F4 )
  {
    switch ( v4 )
    {
      case 'A':
      case 'S':
        v15 = *(_QWORD *)(a1 + 32);
        if ( !v15 || (v9 = 1, !<str as core::fmt::Display>::fmt((__int64)asc_4B0FF, 1uLL, v15)) )
        {
          v9 = 1;
          if ( !rustc_demangle::v0::Printer::print_type(a1)
            && (v4 != 65
             || ((v16 = *(_QWORD *)(a1 + 32)) == 0 || !<str as core::fmt::Display>::fmt((__int64)asc_4B114, 2uLL, v16))
             && !rustc_demangle::v0::Printer::print_const(a1, 1)) )
          {
            v17 = *(_QWORD *)(a1 + 32);
            if ( !v17 )
              goto LABEL_81;
            v18 = asc_4B100;
            goto LABEL_64;
          }
        }
        return v9;
      case 'B':
        v29 = rustc_demangle::v0::Printer::print_backref((__int64 *)a1);
        goto LABEL_79;
      case 'D':
        v30 = *(_QWORD *)(a1 + 32);
        if ( v30 )
        {
          v9 = 1;
          if ( <str as core::fmt::Display>::fmt((__int64)aDyn, 4uLL, v30) )
            return v9;
        }
        v9 = 1;
        if ( rustc_demangle::v0::Printer::in_binder(a1) )
          return v9;
        if ( *(_QWORD *)a1 )
        {
          v31 = *(_QWORD *)(a1 + 16);
          if ( v31 < *(_QWORD *)(a1 + 8) && *(_BYTE *)(*(_QWORD *)a1 + v31) == 76 )
          {
            *(_QWORD *)(a1 + 16) = v31 + 1;
            rustc_demangle::v0::Parser::integer_62((__int64)&v39, (__int64 *)a1);
            if ( !v39 )
            {
              v32 = v41;
              if ( v41 )
              {
                v33 = *(_QWORD *)(a1 + 32);
                if ( v33 )
                {
                  if ( <str as core::fmt::Display>::fmt((__int64)asc_4B116, 3uLL, v33) )
                    return v9;
                }
                v29 = rustc_demangle::v0::Printer::print_lifetime_from_index(a1, v32);
LABEL_80:
                if ( v29 )
                  return v9;
              }
LABEL_81:
              if ( *(_QWORD *)a1 )
                --*(_DWORD *)(a1 + 24);
              return 0;
            }
LABEL_35:
            v21 = v40;
            v22 = *(_QWORD *)(a1 + 32);
            if ( v40 )
            {
              if ( v22 )
              {
                v23 = aRecursionLimit;
                v24 = 25LL;
                goto LABEL_85;
              }
            }
            else if ( v22 )
            {
              v23 = aInvalidSyntax;
              v24 = 16LL;
LABEL_85:
              v9 = 1;
              if ( <str as core::fmt::Display>::fmt((__int64)v23, v24, v22) )
                return v9;
            }
            *(_QWORD *)a1 = 0LL;
            *(_BYTE *)(a1 + 8) = v21;
            return 0;
          }
        }
        v37 = *(_QWORD *)(a1 + 32);
        if ( v37 && <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v37) )
          return v9;
        break;
      case 'F':
        v29 = rustc_demangle::v0::Printer::in_binder(a1);
        goto LABEL_79;
      case 'O':
      case 'P':
        v25 = *(_QWORD *)(a1 + 32);
        if ( v25 )
        {
          v9 = 1;
          if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF98, 1uLL, v25) )
            return v9;
        }
        v26 = *(_QWORD *)(a1 + 32);
        if ( v4 != 80 )
          goto LABEL_75;
        if ( !v26 )
          goto LABEL_78;
        v27 = aConst;
        v28 = 6LL;
        goto LABEL_77;
      case 'Q':
      case 'R':
        v19 = *(_QWORD *)(a1 + 32);
        if ( !v19 )
          goto LABEL_32;
        v9 = 1;
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF97, 1uLL, v19) )
          return v9;
        v2 = *(_QWORD *)a1;
        if ( !*(_QWORD *)a1 )
          goto LABEL_73;
LABEL_32:
        v20 = *(_QWORD *)(a1 + 16);
        if ( v20 >= *(_QWORD *)(a1 + 8) || *(_BYTE *)(v2 + v20) != 76 )
          goto LABEL_73;
        *(_QWORD *)(a1 + 16) = v20 + 1;
        rustc_demangle::v0::Parser::integer_62((__int64)&v39, (__int64 *)a1);
        if ( v39 )
          goto LABEL_35;
        if ( v41 )
        {
          v9 = 1;
          if ( rustc_demangle::v0::Printer::print_lifetime_from_index(a1, v41) )
            return v9;
          v38 = *(_QWORD *)(a1 + 32);
          if ( v38 )
          {
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B10D, 1uLL, v38) )
              return v9;
          }
        }
LABEL_73:
        if ( v4 != 82 )
        {
          v26 = *(_QWORD *)(a1 + 32);
LABEL_75:
          if ( v26 )
          {
            v27 = aMut;
            v28 = 4LL;
LABEL_77:
            v9 = 1;
            if ( <str as core::fmt::Display>::fmt((__int64)v27, v28, v26) )
              return v9;
          }
        }
LABEL_78:
        v29 = rustc_demangle::v0::Printer::print_type(a1);
LABEL_79:
        v9 = 1;
        goto LABEL_80;
      case 'T':
        v34 = *(_QWORD *)(a1 + 32);
        if ( v34 )
        {
          v9 = 1;
          if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF94, 1uLL, v34) )
            return v9;
        }
        v9 = 1;
        if ( rustc_demangle::v0::Printer::print_sep_list((__int64 *)a1) )
          return v9;
        if ( v35 != 1 )
          goto LABEL_62;
        v36 = *(_QWORD *)(a1 + 32);
        if ( !v36 )
          goto LABEL_81;
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF92, 1uLL, v36) )
          return v9;
LABEL_62:
        v17 = *(_QWORD *)(a1 + 32);
        if ( !v17 )
          goto LABEL_81;
        v18 = asc_4AF93;
LABEL_64:
        v29 = <str as core::fmt::Display>::fmt((__int64)v18, 1uLL, v17);
        goto LABEL_80;
      default:
        *(_QWORD *)(a1 + 16) = v3;
        v29 = rustc_demangle::v0::Printer::print_path(a1, 0);
        goto LABEL_79;
    }
LABEL_14:
    *(_QWORD *)a1 = 0LL;
    *(_BYTE *)(a1 + 8) = 0;
    return 0;
  }
  v8 = *(_QWORD *)(a1 + 32);
  if ( v8 )
  {
    v9 = 1;
    if ( <str as core::fmt::Display>::fmt((__int64)aRecursionLimit, 0x19uLL, v8) )
      return v9;
  }
  *(_QWORD *)a1 = 0LL;
  *(_BYTE *)(a1 + 8) = 1;
  return 0;
}
// 3BAFA: variable 'v35' is possibly undefined
// 4AF92: using guessed type char asc_4AF92;
// 4AF93: using guessed type char asc_4AF93;
// 4AF94: using guessed type char asc_4AF94;
// 4AF97: using guessed type char asc_4AF97;
// 4AF98: using guessed type char asc_4AF98;
// 4B0F9: using guessed type char asc_4B0F9;
// 4B0FF: using guessed type char asc_4B0FF;
// 4B100: using guessed type char asc_4B100;
// 4B10D: using guessed type char asc_4B10D;
// 4B210: using guessed type _QWORD qword_4B210[26];
// 59C68: using guessed type void *off_59C68;

//----- (000000000003BC50) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_type::{{closure}}(unsigned __int64 *a1)
{
  __int64 v1; // r12
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rax
  char v6; // bp
  void *v7; // r15
  __int64 v8; // rdx
  char v9; // cl
  char result; // al
  __int64 v11; // r14
  char v12; // cl
  __int64 v13; // r15
  unsigned __int64 v14; // rsi
  char v15; // bp
  __int64 v16; // rdx
  const char *v17; // rdi
  unsigned __int64 v18; // rsi
  __int64 v19; // rdx
  char v20; // cl
  unsigned __int64 v21; // rax
  __int64 v22; // r12
  unsigned __int64 v23; // rcx
  __int64 v25; // rdx
  __int64 v26; // rdx
  char v27; // cl
  unsigned __int64 v28; // rcx
  __int64 v29; // rdx
  char v30; // cl
  __int64 v31; // rdx
  char v32; // cl
  __int64 v33; // rbp
  __int64 v34; // r13
  __int64 v35; // r13
  unsigned __int64 v36; // r15
  char v37; // cl
  __int128 v38; // [rsp+0h] [rbp-D8h] BYREF
  __int128 v39[3]; // [rsp+10h] [rbp-C8h] BYREF
  __int64 v40; // [rsp+40h] [rbp-98h]
  __int128 v41; // [rsp+48h] [rbp-90h]
  __int128 v42; // [rsp+58h] [rbp-80h] BYREF
  __int128 v43; // [rsp+68h] [rbp-70h]
  __int128 v44; // [rsp+78h] [rbp-60h]
  __int64 v45; // [rsp+88h] [rbp-50h]
  __int64 v46[9]; // [rsp+90h] [rbp-48h] BYREF

  v3 = *a1;
  if ( !*a1 )
    goto LABEL_38;
  v4 = a1[1];
  v5 = a1[2];
  if ( v5 < v4 && *(_BYTE *)(v3 + v5) == 85 )
  {
    a1[2] = ++v5;
    v6 = 1;
    if ( v5 >= v4 )
      goto LABEL_11;
  }
  else
  {
    v6 = 0;
    if ( v5 >= v4 )
    {
LABEL_11:
      if ( !v6 )
        goto LABEL_38;
      v7 = 0LL;
LABEL_13:
      v8 = a1[4];
      if ( v8 )
      {
        v9 = <str as core::fmt::Display>::fmt((__int64)aUnsafe, 7uLL, v8);
        result = 1;
        if ( v9 )
          return result;
      }
      if ( !v7 )
      {
LABEL_38:
        v19 = a1[4];
        if ( v19 )
        {
          v20 = <str as core::fmt::Display>::fmt((__int64)aFn, 3uLL, v19);
          result = 1;
          if ( v20 )
            return result;
        }
        v21 = *a1;
        if ( *a1 )
        {
          v22 = 0LL;
          while ( 1 )
          {
            v23 = a1[2];
            if ( v23 < a1[1] && *(_BYTE *)(v21 + v23) == 69 )
              break;
            if ( v22-- != 0 )
            {
              v25 = a1[4];
              if ( v25 )
              {
                if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v25) )
                  return 1;
              }
            }
            if ( rustc_demangle::v0::Printer::print_type((__int64)a1) )
              return 1;
            v21 = *a1;
            if ( !*a1 )
              goto LABEL_49;
          }
          a1[2] = v23 + 1;
          v26 = a1[4];
          if ( !v26 )
          {
LABEL_54:
            if ( v21 )
              goto LABEL_55;
            goto LABEL_58;
          }
        }
        else
        {
LABEL_49:
          v21 = 0LL;
          v26 = a1[4];
          if ( !v26 )
            goto LABEL_54;
        }
        v27 = <str as core::fmt::Display>::fmt((__int64)asc_4AF93, 1uLL, v26);
        result = 1;
        if ( v27 )
          return result;
        v21 = *a1;
        if ( *a1 )
        {
LABEL_55:
          v28 = a1[2];
          if ( v28 < a1[1] && *(_BYTE *)(v21 + v28) == 117 )
          {
            a1[2] = v28 + 1;
            return 0;
          }
        }
LABEL_58:
        v29 = a1[4];
        if ( !v29 )
          return rustc_demangle::v0::Printer::print_type((__int64)a1);
        v30 = <str as core::fmt::Display>::fmt((__int64)asc_4AF4C, 4uLL, v29);
        result = 1;
        if ( !v30 )
          return rustc_demangle::v0::Printer::print_type((__int64)a1);
        return result;
      }
LABEL_21:
      v11 = a1[4];
      if ( v11 )
      {
        v12 = <str as core::fmt::Display>::fmt((__int64)aExtern, 8uLL, a1[4]);
        result = 1;
        if ( v12 )
          return result;
      }
      *(_QWORD *)&v41 = 0LL;
      *((_QWORD *)&v41 + 1) = v1;
      *(_QWORD *)&v42 = v7;
      *((_QWORD *)&v42 + 1) = v1;
      *(_QWORD *)&v43 = 0LL;
      *((_QWORD *)&v43 + 1) = v1;
      *(_QWORD *)&v44 = 0x5F0000005FLL;
      BYTE8(v44) = 1;
      LOWORD(v45) = 1;
      <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match((__int64 *)&v38, (__int64 *)&v42);
      if ( (_QWORD)v38 )
      {
        v13 = (__int64)v7 + v41;
        v14 = *((_QWORD *)&v38 + 1) - v41;
        *(_QWORD *)&v41 = *(_QWORD *)&v39[0];
        if ( !v11 )
        {
LABEL_34:
          v40 = v45;
          v39[2] = v44;
          v39[1] = v43;
          v39[0] = v42;
          v38 = v41;
          if ( BYTE1(v45) )
          {
LABEL_35:
            if ( !v11 || !<str as core::fmt::Display>::fmt((__int64)asc_4B128, 2uLL, v11) )
              goto LABEL_38;
            return 1;
          }
          v33 = v11;
          while ( 1 )
          {
            v34 = *(_QWORD *)&v39[0];
            <core::str::pattern::CharSearcher as core::str::pattern::Searcher>::next_match(v46, (__int64 *)v39);
            if ( v46[0] )
            {
              v35 = v38 + v34;
              v36 = v46[1] - v38;
              *(_QWORD *)&v38 = v46[2];
              if ( !v33 )
                goto LABEL_66;
            }
            else
            {
              if ( BYTE1(v40) )
                goto LABEL_35;
              BYTE1(v40) = 1;
              if ( !(_BYTE)v40 && *((_QWORD *)&v38 + 1) == (_QWORD)v38 )
                goto LABEL_35;
              v36 = *((_QWORD *)&v38 + 1) - v38;
              v35 = *(_QWORD *)&v39[0] + v38;
              if ( !v33 )
                goto LABEL_66;
            }
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B00B, 1uLL, v33) )
              return 1;
            v11 = a1[4];
            if ( !v11 )
            {
              v11 = 0LL;
LABEL_66:
              v33 = 0LL;
              goto LABEL_67;
            }
            v33 = a1[4];
            if ( <str as core::fmt::Display>::fmt(v35, v36, v33) )
              return 1;
LABEL_67:
            if ( BYTE1(v40) )
              goto LABEL_35;
          }
        }
      }
      else
      {
        if ( BYTE1(v45) || (BYTE1(v45) = 1, !(_BYTE)v45) && *((_QWORD *)&v41 + 1) == (_QWORD)v41 )
          core::option::unwrap_failed((__int64)&off_59BE0);
        v14 = *((_QWORD *)&v41 + 1) - v41;
        v13 = v42 + v41;
        if ( !v11 )
          goto LABEL_34;
      }
      if ( <str as core::fmt::Display>::fmt(v13, v14, v11) )
        return 1;
      goto LABEL_34;
    }
  }
  if ( *(_BYTE *)(v3 + v5) != 75 )
    goto LABEL_11;
  a1[2] = v5 + 1;
  if ( v5 + 1 < v4 && *(_BYTE *)(v3 + v5 + 1) == 67 )
  {
    a1[2] = v5 + 2;
    v1 = 1LL;
    v7 = &unk_4AF91;
    goto LABEL_20;
  }
  rustc_demangle::v0::Parser::ident((__int64)&v38, a1);
  v7 = (void *)v38;
  if ( !(_QWORD)v38 )
  {
    v15 = BYTE8(v38);
    v16 = a1[4];
    if ( BYTE8(v38) )
    {
      if ( v16 )
      {
        v17 = aRecursionLimit;
        v18 = 25LL;
        goto LABEL_81;
      }
    }
    else if ( v16 )
    {
      v17 = aInvalidSyntax;
      v18 = 16LL;
LABEL_81:
      v37 = <str as core::fmt::Display>::fmt((__int64)v17, v18, v16);
      result = 1;
      if ( v37 )
        return result;
    }
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v15;
    return 0;
  }
  v1 = *((_QWORD *)&v38 + 1);
  if ( *((_QWORD *)&v38 + 1) && !*((_QWORD *)&v39[0] + 1) )
  {
LABEL_20:
    if ( !v6 )
      goto LABEL_21;
    goto LABEL_13;
  }
  v31 = a1[4];
  if ( !v31 || (v32 = <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v31), result = 1, !v32) )
  {
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = 0;
    return 0;
  }
  return result;
}
// 3BD72: variable 'v1' is possibly undefined
// 4AF93: using guessed type char asc_4AF93;
// 4B00B: using guessed type char asc_4B00B;
// 59BE0: using guessed type char *off_59BE0;

//----- (000000000003C160) ----------------------------------------------------
__int64 __fastcall rustc_demangle::v0::Printer::print_path_maybe_open_generics(_QWORD *a1)
{
  unsigned int v1; // ebx
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // rsi
  _QWORD *v5; // r15
  char v6; // cl
  unsigned __int64 v7; // rax
  unsigned int v8; // ecx
  __int64 v9; // rdx
  __int64 v10; // rax
  __int64 v11; // r12
  unsigned __int64 v12; // rcx
  bool v13; // cf
  __int64 v14; // rdx
  unsigned int v15; // eax
  __int64 result; // rax
  unsigned __int64 v17; // r10
  unsigned __int64 v18; // rax
  char v19; // dl
  unsigned __int8 v20; // bl
  unsigned __int8 v21; // dl
  __int64 v22; // rax
  unsigned __int64 v23; // kr00_8
  __int64 v24; // rdx
  __int64 v25; // rdx
  const char *v26; // rdi
  char v27; // al
  __int128 v28; // [rsp+0h] [rbp-48h]
  __int128 v29; // [rsp+10h] [rbp-38h]

  v2 = *a1;
  if ( !*a1 )
    goto LABEL_24;
  v3 = a1[1];
  v4 = a1[2];
  if ( v4 >= v3 )
    goto LABEL_24;
  v5 = a1;
  if ( *(_BYTE *)(v2 + v4) != 66 )
  {
    if ( *(_BYTE *)(v2 + v4) == 73 )
    {
      a1[2] = v4 + 1;
      if ( !rustc_demangle::v0::Printer::print_path((__int64)a1, 0) )
      {
        v9 = a1[4];
        if ( !v9 || !<str as core::fmt::Display>::fmt((__int64)asc_4AF96, 1uLL, v9) )
        {
          v10 = *a1;
          LOBYTE(v1) = 1;
          if ( *a1 )
          {
            v11 = 0LL;
            while ( 1 )
            {
              v12 = a1[2];
              if ( v12 < a1[1] && *(_BYTE *)(v10 + v12) == 69 )
                break;
              v13 = v11-- == 0;
              if ( !v13 )
              {
                v14 = a1[4];
                if ( v14 )
                {
                  a1 = v5;
                  if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v14) )
                    goto LABEL_44;
                }
              }
              if ( rustc_demangle::v0::Printer::print_generic_arg(a1) )
                goto LABEL_44;
              a1 = v5;
              v10 = *v5;
              if ( !*v5 )
                return v1;
            }
            a1[2] = v12 + 1;
          }
          return v1;
        }
      }
      goto LABEL_44;
    }
LABEL_24:
    LOBYTE(v15) = rustc_demangle::v0::Printer::print_path((__int64)a1, 0);
    v1 = v15;
    LOBYTE(v1) = 2 * v15;
    return v1;
  }
  a1[2] = v4 + 1;
  v6 = 1;
  if ( v4 + 1 >= v3 )
    goto LABEL_39;
  if ( *(_BYTE *)(v2 + v4 + 1) == 95 )
  {
    a1[2] = v4 + 2;
    v7 = 0LL;
  }
  else
  {
    v17 = v4 + 2;
    v18 = 0LL;
    while ( 1 )
    {
      v19 = *(_BYTE *)(v2 + v17 - 1);
      if ( v19 == 95 )
        break;
      v20 = v19 - 48;
      if ( (unsigned __int8)(v19 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v19 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v19 - 65) >= 0x1Au )
            goto LABEL_39;
          v21 = v19 - 29;
        }
        else
        {
          v21 = v19 - 87;
        }
        v20 = v21;
      }
      a1[2] = v17;
      v23 = v18;
      v22 = 62 * v18;
      if ( !is_mul_ok(0x3EuLL, v23) )
        goto LABEL_39;
      v24 = v20;
      v1 = 0;
      v13 = __CFADD__(v24, v22);
      v18 = v24 + v22;
      if ( !v13 )
      {
        v13 = v17++ < v3;
        if ( v13 )
          continue;
      }
      goto LABEL_40;
    }
    a1[2] = v17;
    v7 = v18 + 1;
    if ( !v7 )
      goto LABEL_39;
  }
  if ( v7 >= v4 )
  {
LABEL_39:
    v1 = 0;
LABEL_40:
    v25 = a1[4];
    if ( v25 )
    {
      v26 = aRecursionLimit;
      if ( v6 )
        v26 = aInvalidSyntax;
      v27 = <str as core::fmt::Display>::fmt((__int64)v26, 9LL * ((unsigned __int8)v6 ^ 1u) + 16, v25);
      a1 = v5;
      if ( v27 )
      {
LABEL_44:
        LOBYTE(v1) = 2;
        return v1;
      }
    }
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v1;
    return 0;
  }
  v8 = *((_DWORD *)a1 + 6) + 1;
  if ( v8 > 0x1F4 )
  {
    LOBYTE(v1) = 1;
    v6 = 0;
    goto LABEL_40;
  }
  if ( !a1[4] )
    return 0;
  v29 = *((_OWORD *)a1 + 1);
  v28 = *(_OWORD *)a1;
  a1[2] = v7;
  *((_DWORD *)a1 + 6) = v8;
  result = rustc_demangle::v0::Printer::print_path_maybe_open_generics(a1);
  *(_OWORD *)a1 = v28;
  *((_OWORD *)a1 + 1) = v29;
  return result;
}
// 3C29E: variable 'v15' is possibly undefined
// 3C2A2: variable 'v1' is possibly undefined
// 4AF96: using guessed type char asc_4AF96;

//----- (000000000003C3C0) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_dyn_trait(unsigned __int64 *a1)
{
  char v2; // al
  char v3; // bl
  char v4; // r15
  unsigned __int64 v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v11; // rdx
  char v12; // bp
  __int64 v13; // rdx
  const char *v14; // rdi
  unsigned __int64 v15; // rsi
  __int128 v16[2]; // [rsp+0h] [rbp-78h] BYREF
  __int128 v17[5]; // [rsp+20h] [rbp-58h] BYREF

  v2 = rustc_demangle::v0::Printer::print_path_maybe_open_generics(a1);
  v3 = 1;
  if ( v2 == 2 )
    return v3;
  v4 = v2;
  while ( *a1 )
  {
    v5 = a1[2];
    if ( v5 >= a1[1] || *(_BYTE *)(*a1 + v5) != 112 )
      break;
    a1[2] = v5 + 1;
    v6 = a1[4];
    if ( (v4 & 1) != 0 )
    {
      if ( v6 && <str as core::fmt::Display>::fmt((__int64)asc_4B0FD, 2uLL, v6) )
        return v3;
LABEL_13:
      if ( !*a1 )
        goto LABEL_21;
      goto LABEL_14;
    }
    if ( v6 )
    {
      v4 = 1;
      if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF96, 1uLL, v6) )
        return 1;
      goto LABEL_13;
    }
    v4 = 1;
    if ( !*a1 )
    {
LABEL_21:
      v9 = a1[4];
      if ( v9 )
        return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v9);
      return 0;
    }
LABEL_14:
    rustc_demangle::v0::Parser::ident((__int64)v16, a1);
    if ( !*(_QWORD *)&v16[0] )
    {
      v12 = BYTE8(v16[0]);
      v13 = a1[4];
      if ( BYTE8(v16[0]) )
      {
        if ( v13 )
        {
          v14 = aRecursionLimit;
          v15 = 25LL;
LABEL_32:
          v3 = 1;
          if ( <str as core::fmt::Display>::fmt((__int64)v14, v15, v13) )
            return v3;
        }
      }
      else if ( v13 )
      {
        v14 = aInvalidSyntax;
        v15 = 16LL;
        goto LABEL_32;
      }
      *a1 = 0LL;
      *((_BYTE *)a1 + 8) = v12;
      return 0;
    }
    v17[1] = v16[1];
    v17[0] = v16[0];
    v7 = a1[4];
    if ( v7 )
    {
      if ( (unsigned __int8)<rustc_demangle::v0::Ident as core::fmt::Display>::fmt((unsigned __int8 **)v17, v7) )
        return v3;
      v8 = a1[4];
      if ( v8 )
      {
        if ( <str as core::fmt::Display>::fmt((__int64)asc_4B12D, 3uLL, v8) )
          return v3;
      }
    }
    if ( rustc_demangle::v0::Printer::print_type((__int64)a1) )
      return v3;
  }
  if ( (v4 & 1) == 0 )
    return 0;
  v11 = a1[4];
  if ( !v11 || !<str as core::fmt::Display>::fmt((__int64)asc_4AF95, 1uLL, v11) )
    return 0;
  return v3;
}
// 4AF95: using guessed type char asc_4AF95;
// 4AF96: using guessed type char asc_4AF96;
// 4B0F9: using guessed type char asc_4B0F9;

//----- (000000000003C5D0) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_const(__int64 a1, char a2)
{
  __int64 v3; // rcx
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rax
  int v6; // r14d
  unsigned __int64 v7; // rdx
  unsigned int v8; // r8d
  __int64 v9; // rdx
  char v10; // bp
  __int64 v11; // rdx
  char v12; // al
  __int64 v13; // rdx
  __int64 v14; // rdx
  const char *v15; // rdi
  unsigned __int64 v16; // rsi
  char v17; // r15
  unsigned __int64 v18; // rdx
  __int64 v19; // rdx
  __int64 v20; // rdx
  char v21; // r14
  __int64 v22; // rdx
  const char *v23; // rdi
  unsigned __int64 v24; // rsi
  __int64 v25; // rdx
  __int64 v26; // rdx
  __int64 v27; // rdx
  __int64 v28; // rdx
  __int64 v29; // rdx
  __int64 v30; // rdx
  unsigned __int64 v31; // rcx
  int v32; // eax
  __int64 v33; // rdx
  __int64 v34; // rdx
  __int64 v36; // rdx
  __int64 v37; // rdx
  const char *v38; // rdi
  __int64 v39; // rdx
  __int64 v40; // rdx
  __int64 v41; // rdx
  __int64 v42; // rdx
  __int64 v43; // rdx
  __int64 v44; // rdx
  __int64 v45; // rdx
  __int64 v46; // [rsp+8h] [rbp-30h] BYREF
  __int64 v47; // [rsp+10h] [rbp-28h]

  v3 = *(_QWORD *)a1;
  if ( !*(_QWORD *)a1 )
  {
LABEL_86:
    v34 = *(_QWORD *)(a1 + 32);
    if ( v34 )
      return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v34);
    return 0;
  }
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if ( v5 >= v4 )
  {
LABEL_30:
    v19 = *(_QWORD *)(a1 + 32);
    if ( v19 )
    {
      v10 = 1;
      if ( <str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v19) )
        return v10;
    }
LABEL_32:
    *(_QWORD *)a1 = 0LL;
    *(_BYTE *)(a1 + 8) = 0;
    return 0;
  }
  v6 = *(unsigned __int8 *)(v3 + v5);
  v7 = v5 + 1;
  *(_QWORD *)(a1 + 16) = v5 + 1;
  v8 = *(_DWORD *)(a1 + 24) + 1;
  *(_DWORD *)(a1 + 24) = v8;
  if ( v8 <= 0x1F4 )
  {
    switch ( v6 )
    {
      case 'A':
        if ( a2 )
        {
          v17 = 0;
        }
        else
        {
          v26 = *(_QWORD *)(a1 + 32);
          if ( v26 )
          {
            v17 = 1;
            v10 = 1;
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B135, 1uLL, v26) )
              return v10;
          }
          else
          {
            v17 = 1;
          }
        }
        v36 = *(_QWORD *)(a1 + 32);
        if ( v36 )
        {
          v10 = 1;
          if ( <str as core::fmt::Display>::fmt((__int64)asc_4B0FF, 1uLL, v36) )
            return v10;
        }
        v10 = 1;
        if ( rustc_demangle::v0::Printer::print_sep_list((__int64 *)a1) )
          return v10;
        v37 = *(_QWORD *)(a1 + 32);
        if ( !v37 )
          goto LABEL_111;
        v38 = asc_4B100;
        goto LABEL_105;
      case 'B':
        v12 = rustc_demangle::v0::Printer::print_backref((__int64 *)a1, a2);
        goto LABEL_13;
      case 'Q':
        goto LABEL_39;
      case 'R':
        if ( v7 < v4 && *(_BYTE *)(v3 + v7) == 101 )
        {
          *(_QWORD *)(a1 + 16) = v5 + 2;
          v12 = rustc_demangle::v0::Printer::print_const_str_literal(a1);
          goto LABEL_13;
        }
LABEL_39:
        if ( a2 )
        {
          v17 = 0;
        }
        else
        {
          v20 = *(_QWORD *)(a1 + 32);
          if ( v20 )
          {
            v17 = 1;
            v10 = 1;
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B135, 1uLL, v20) )
              return v10;
          }
          else
          {
            v17 = 1;
          }
        }
        v29 = *(_QWORD *)(a1 + 32);
        if ( !v29 || (v10 = 1, !<str as core::fmt::Display>::fmt((__int64)asc_4AF97, 1uLL, v29)) )
        {
          if ( v6 == 82
            || (v30 = *(_QWORD *)(a1 + 32)) == 0
            || (v10 = 1, !<str as core::fmt::Display>::fmt((__int64)aMut, 4uLL, v30)) )
          {
            v10 = 1;
            if ( !rustc_demangle::v0::Printer::print_const(a1, 1) )
              goto LABEL_111;
          }
        }
        return v10;
      case 'T':
        if ( a2 )
        {
          v17 = 0;
        }
        else
        {
          v27 = *(_QWORD *)(a1 + 32);
          if ( v27 )
          {
            v17 = 1;
            v10 = 1;
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B135, 1uLL, v27) )
              return v10;
          }
          else
          {
            v17 = 1;
          }
        }
        v39 = *(_QWORD *)(a1 + 32);
        if ( v39 )
        {
          v10 = 1;
          if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF94, 1uLL, v39) )
            return v10;
        }
        v10 = 1;
        if ( rustc_demangle::v0::Printer::print_sep_list((__int64 *)a1) )
          return v10;
        if ( v40 != 1 )
          goto LABEL_103;
        v41 = *(_QWORD *)(a1 + 32);
        if ( !v41 )
          goto LABEL_111;
        if ( !<str as core::fmt::Display>::fmt((__int64)asc_4AF92, 1uLL, v41) )
          goto LABEL_103;
        return v10;
      case 'V':
        if ( a2 )
        {
          v17 = 0;
        }
        else
        {
          v25 = *(_QWORD *)(a1 + 32);
          if ( v25 )
          {
            v17 = 1;
            v10 = 1;
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B135, 1uLL, v25) )
              return v10;
          }
          else
          {
            v17 = 1;
          }
        }
        v10 = 1;
        if ( rustc_demangle::v0::Printer::print_path(a1, 1u) )
          return v10;
        if ( !*(_QWORD *)a1 )
          goto LABEL_86;
        v31 = *(_QWORD *)(a1 + 16);
        if ( v31 >= *(_QWORD *)(a1 + 8) )
          goto LABEL_116;
        v32 = *(unsigned __int8 *)(*(_QWORD *)a1 + v31);
        *(_QWORD *)(a1 + 16) = v31 + 1;
        if ( v32 == 83 )
        {
          v44 = *(_QWORD *)(a1 + 32);
          if ( v44 && <str as core::fmt::Display>::fmt((__int64)asc_4B136, 3uLL, v44) )
            return v10;
          if ( rustc_demangle::v0::Printer::print_sep_list((unsigned __int64 *)a1) )
            return v10;
          v45 = *(_QWORD *)(a1 + 32);
          if ( v45 )
          {
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B139, 2uLL, v45) )
              return v10;
          }
          goto LABEL_111;
        }
        if ( v32 == 85 )
          goto LABEL_111;
        if ( v32 != 84 )
        {
LABEL_116:
          v43 = *(_QWORD *)(a1 + 32);
          if ( !v43 || !<str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v43) )
            goto LABEL_32;
          return v10;
        }
        v33 = *(_QWORD *)(a1 + 32);
        if ( v33 && <str as core::fmt::Display>::fmt((__int64)asc_4AF94, 1uLL, v33)
          || rustc_demangle::v0::Printer::print_sep_list((__int64 *)a1) )
        {
          return v10;
        }
LABEL_103:
        v37 = *(_QWORD *)(a1 + 32);
        if ( !v37 )
          goto LABEL_111;
        v38 = asc_4AF93;
LABEL_105:
        if ( !<str as core::fmt::Display>::fmt((__int64)v38, 1uLL, v37) )
          goto LABEL_111;
        return v10;
      case 'a':
      case 'i':
      case 'l':
      case 'n':
      case 's':
      case 'x':
        if ( v7 < v4 && *(_BYTE *)(v3 + v7) == 110 )
        {
          *(_QWORD *)(a1 + 16) = v5 + 2;
          v11 = *(_QWORD *)(a1 + 32);
          if ( v11 )
          {
            v10 = 1;
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B00B, 1uLL, v11) )
              return v10;
          }
        }
        goto LABEL_12;
      case 'b':
        rustc_demangle::v0::Parser::hex_nibbles(&v46, a1);
        if ( !v46 )
          goto LABEL_48;
        if ( rustc_demangle::v0::HexNibbles::try_parse_uint(v46, v47) != 1 )
          goto LABEL_30;
        if ( v13 != 1 )
        {
          if ( v13 )
            goto LABEL_30;
          v14 = *(_QWORD *)(a1 + 32);
          if ( v14 )
          {
            v15 = aFalse;
            v16 = 5LL;
            goto LABEL_115;
          }
          goto LABEL_14;
        }
        v14 = *(_QWORD *)(a1 + 32);
        if ( !v14 )
          goto LABEL_14;
        v15 = aTrue;
        v16 = 4LL;
        goto LABEL_115;
      case 'c':
        rustc_demangle::v0::Parser::hex_nibbles(&v46, a1);
        if ( v46 )
        {
          if ( rustc_demangle::v0::HexNibbles::try_parse_uint(v46, v47)
            && !HIDWORD(v18)
            && ((unsigned int)v18 ^ 0xD800) - 1114112 >= 0xFFEF0800 )
          {
            v12 = rustc_demangle::v0::Printer::print_quoted_escaped_chars(*(_QWORD *)(a1 + 32), v18);
LABEL_13:
            v10 = 1;
            if ( v12 )
              return v10;
LABEL_14:
            if ( *(_QWORD *)a1 )
              --*(_DWORD *)(a1 + 24);
            return 0;
          }
          goto LABEL_30;
        }
LABEL_48:
        v21 = v47;
        v22 = *(_QWORD *)(a1 + 32);
        if ( (_BYTE)v47 )
        {
          if ( v22 )
          {
            v23 = aRecursionLimit;
            v24 = 25LL;
            goto LABEL_73;
          }
        }
        else if ( v22 )
        {
          v23 = aInvalidSyntax;
          v24 = 16LL;
LABEL_73:
          v10 = 1;
          if ( <str as core::fmt::Display>::fmt((__int64)v23, v24, v22) )
            return v10;
        }
        *(_QWORD *)a1 = 0LL;
        *(_BYTE *)(a1 + 8) = v21;
        return 0;
      case 'e':
        if ( a2 )
        {
          v17 = 0;
        }
        else
        {
          v28 = *(_QWORD *)(a1 + 32);
          if ( v28 )
          {
            v17 = 1;
            v10 = 1;
            if ( <str as core::fmt::Display>::fmt((__int64)asc_4B135, 1uLL, v28) )
              return v10;
          }
          else
          {
            v17 = 1;
          }
        }
        v42 = *(_QWORD *)(a1 + 32);
        if ( v42 )
        {
          v10 = 1;
          if ( <str as core::fmt::Display>::fmt((__int64)asc_4AF98, 1uLL, v42) )
            return v10;
        }
        v10 = 1;
        if ( rustc_demangle::v0::Printer::print_const_str_literal(a1) )
          return v10;
LABEL_111:
        if ( !v17 )
          goto LABEL_14;
        v14 = *(_QWORD *)(a1 + 32);
        if ( !v14 )
          goto LABEL_14;
        v15 = asc_4B00C;
LABEL_114:
        v16 = 1LL;
LABEL_115:
        v12 = <str as core::fmt::Display>::fmt((__int64)v15, v16, v14);
        goto LABEL_13;
      case 'h':
      case 'j':
      case 'm':
      case 'o':
      case 't':
      case 'y':
LABEL_12:
        v12 = rustc_demangle::v0::Printer::print_const_uint(a1, v6);
        goto LABEL_13;
      case 'p':
        v14 = *(_QWORD *)(a1 + 32);
        if ( !v14 )
          goto LABEL_14;
        v15 = asc_4B0CC;
        goto LABEL_114;
      default:
        goto LABEL_30;
    }
  }
  v9 = *(_QWORD *)(a1 + 32);
  if ( v9 )
  {
    v10 = 1;
    if ( <str as core::fmt::Display>::fmt((__int64)aRecursionLimit, 0x19uLL, v9) )
      return v10;
  }
  *(_QWORD *)a1 = 0LL;
  *(_BYTE *)(a1 + 8) = 1;
  return 0;
}
// 3C704: variable 'v13' is possibly undefined
// 3C780: variable 'v18' is possibly undefined
// 3CB53: variable 'v40' is possibly undefined
// 4AF92: using guessed type char asc_4AF92;
// 4AF93: using guessed type char asc_4AF93;
// 4AF94: using guessed type char asc_4AF94;
// 4AF97: using guessed type char asc_4AF97;
// 4AF98: using guessed type char asc_4AF98;
// 4B00B: using guessed type char asc_4B00B;
// 4B00C: using guessed type char asc_4B00C;
// 4B0CC: using guessed type char asc_4B0CC;
// 4B0F9: using guessed type char asc_4B0F9;
// 4B0FF: using guessed type char asc_4B0FF;
// 4B100: using guessed type char asc_4B100;
// 4B135: using guessed type char asc_4B135;

//----- (000000000003CCC0) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_const_uint(__int64 a1, char a2)
{
  _BYTE *v3; // rdi
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rdx
  __int64 v7; // r14
  __int64 v8; // r15
  char v9; // r8
  unsigned __int64 v10; // rcx
  char v11; // r12
  unsigned __int64 v12; // r15
  unsigned __int64 v13; // rdx
  __int64 v14; // rbx
  char v15; // bp
  __int64 v16; // rdx
  __int64 v17; // rdx
  unsigned __int8 v19; // r12
  int v20; // ecx
  unsigned __int64 v21[6]; // [rsp+8h] [rbp-30h] BYREF

  v3 = *(_BYTE **)a1;
  if ( v3 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(_QWORD *)(a1 + 16);
    v7 = (__int64)&v3[v6];
    v8 = 0LL;
    do
    {
      if ( v6 + v8 >= v5 )
        goto LABEL_14;
      v9 = *(_BYTE *)(v7 + v8);
      *(_QWORD *)(a1 + 16) = v6 + 1 + v8++;
    }
    while ( (unsigned __int8)(v9 - 48) < 0xAu || (unsigned __int8)(v9 - 97) < 6u );
    if ( v9 != 95 )
    {
LABEL_14:
      v16 = *(_QWORD *)(a1 + 32);
      if ( !v16 || (v15 = 1, !<str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v16)) )
      {
        *(_QWORD *)a1 = 0LL;
        *(_BYTE *)(a1 + 8) = 0;
        return 0;
      }
      return v15;
    }
    v10 = v6 + v8 - 1;
    if ( v6 > v10 || (v11 = a2, v6) && (char)v3[v6] <= -65 )
      core::str::slice_error_fail(v3, v5, v6, v10, (__int64)&off_59B68);
    v12 = v8 - 1;
    if ( rustc_demangle::v0::HexNibbles::try_parse_uint((__int64)&v3[v6], v12) )
    {
      v14 = *(_QWORD *)(a1 + 32);
      v21[0] = v13;
      if ( !v14 )
        return 0;
      v15 = 1;
      if ( (unsigned __int8)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt(v21, v14) )
        return v15;
      goto LABEL_22;
    }
    v14 = *(_QWORD *)(a1 + 32);
    if ( !v14 )
      return 0;
    v15 = 1;
    if ( !<str as core::fmt::Display>::fmt((__int64)a0x, 2uLL, v14) && !<str as core::fmt::Display>::fmt(v7, v12, v14) )
    {
LABEL_22:
      if ( (*(_BYTE *)(v14 + 52) & 4) != 0 )
        return 0;
      v19 = v11 - 97;
      if ( v19 >= 0x1Au || (v20 = 62716863, !_bittest(&v20, v19)) )
        core::option::unwrap_failed((__int64)&off_59BF8);
      return <str as core::fmt::Display>::fmt((__int64)*(&off_59C68 + v19), qword_4B210[v19], v14);
    }
  }
  else
  {
    v17 = *(_QWORD *)(a1 + 32);
    if ( v17 )
      return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v17);
    return 0;
  }
  return v15;
}
// 3CD64: variable 'v13' is possibly undefined
// 4B0F9: using guessed type char asc_4B0F9;
// 4B210: using guessed type _QWORD qword_4B210[26];
// 59B68: using guessed type char *off_59B68;
// 59BF8: using guessed type char *off_59BF8;
// 59C68: using guessed type void *off_59C68;
// 3CCC0: using guessed type unsigned __int64 var_30[6];

//----- (000000000003CEA0) ----------------------------------------------------
char __fastcall rustc_demangle::v0::Printer::print_const_str_literal(__int64 a1)
{
  _BYTE *v2; // r15
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rdx
  __int64 v5; // r12
  __int64 v6; // rcx
  _BYTE *v7; // rax
  char v8; // di
  __int64 v9; // r13
  unsigned __int8 *v10; // r15
  unsigned int v11; // eax
  __int64 v12; // r14
  char v13; // bl
  unsigned int v14; // eax
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v18; // rdi
  __int64 v19; // [rsp+0h] [rbp-78h] BYREF
  int v20; // [rsp+8h] [rbp-70h]
  unsigned __int8 *v21; // [rsp+10h] [rbp-68h] BYREF
  __int64 v22; // [rsp+18h] [rbp-60h]
  __int64 v23; // [rsp+20h] [rbp-58h]
  __int64 v24; // [rsp+28h] [rbp-50h]
  __int64 v25; // [rsp+30h] [rbp-48h]
  __int64 v26; // [rsp+3Ch] [rbp-3Ch] BYREF
  int v27; // [rsp+44h] [rbp-34h]

  v2 = *(_BYTE **)a1;
  if ( *(_QWORD *)a1 )
  {
    v3 = *(_QWORD *)(a1 + 8);
    v4 = *(_QWORD *)(a1 + 16);
    v5 = -1LL;
    v6 = 0LL;
    v7 = *(_BYTE **)a1;
    while ( v4 + v6 < v3 )
    {
      v8 = v7[v4];
      *(_QWORD *)(a1 + 16) = v4 + v6 + 1;
      ++v7;
      ++v5;
      ++v6;
      if ( (unsigned __int8)(v8 - 48) >= 0xAu && (unsigned __int8)(v8 - 97) >= 6u )
      {
        if ( v8 == 95 )
        {
          if ( v4 > v4 + v5 || v4 && (char)v2[v4] <= -65 )
            core::str::slice_error_fail(v2, v3, v4, v4 + v5, (__int64)&off_59B68);
          if ( (v5 & 1) == 0 )
          {
            v9 = (__int64)&v7[v4 - 1];
            v10 = &v2[v4];
            v21 = v10;
            v22 = v5;
            v23 = v9;
            v24 = 0LL;
            v25 = 2LL;
            do
              v11 = <core::iter::sources::from_fn::FromFn<F> as core::iter::traits::iterator::Iterator>::next(&v21);
            while ( v11 < 0x110000 );
            if ( v11 == 1114113 )
            {
              v12 = *(_QWORD *)(a1 + 32);
              if ( !v12 )
                return 0;
              v13 = 1;
              if ( !(unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_char(v12) )
              {
                v21 = v10;
                v22 = v5;
                v23 = v9;
                v24 = 0LL;
                v25 = 2LL;
                v14 = <core::iter::sources::from_fn::FromFn<F> as core::iter::traits::iterator::Iterator>::next(&v21);
                if ( v14 == 1114113 )
                {
                  return <core::fmt::Formatter as core::fmt::Write>::write_char(v12);
                }
                else
                {
                  while ( 1 )
                  {
                    if ( v14 == 1114112 )
                      core::result::unwrap_failed(
                        (__int64)aCalledResultUn_3,
                        43LL,
                        (__int64)&v19,
                        (__int64)&off_59798,
                        (__int64)&off_596E0);
                    if ( v14 != 39 )
                    {
                      core::char::methods::<impl char>::escape_debug_ext((__int64)&v26, v14);
                      v20 = v27;
                      v19 = v26;
                      while ( 1 )
                      {
                        if ( (_BYTE)v19 == 0x80 )
                        {
                          core::char::EscapeDebug::clear((__int64)&v19);
                        }
                        else
                        {
                          v18 = BYTE2(v20);
                          if ( BYTE2(v20) >= HIBYTE(v20) )
                            goto LABEL_28;
                          ++BYTE2(v20);
                          if ( (unsigned __int8)v18 >= 0xAu )
                            core::panicking::panic_bounds_check(v18, 10LL, (__int64)&off_59740);
                        }
                        if ( (unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_char(v12) )
                          return v13;
                      }
                    }
                    if ( (unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_char(v12) )
                      break;
LABEL_28:
                    v14 = <core::iter::sources::from_fn::FromFn<F> as core::iter::traits::iterator::Iterator>::next(&v21);
                    if ( v14 == 1114113 )
                      return <core::fmt::Formatter as core::fmt::Write>::write_char(v12);
                  }
                }
              }
              return v13;
            }
          }
        }
        break;
      }
    }
    v15 = *(_QWORD *)(a1 + 32);
    if ( !v15 || (v13 = 1, !<str as core::fmt::Display>::fmt((__int64)aInvalidSyntax, 0x10uLL, v15)) )
    {
      *(_QWORD *)a1 = 0LL;
      *(_BYTE *)(a1 + 8) = 0;
      return 0;
    }
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 32);
    if ( v16 )
      return <str as core::fmt::Display>::fmt((__int64)asc_4B0F9, 1uLL, v16);
    return 0;
  }
  return v13;
}
// 4B0F9: using guessed type char asc_4B0F9;
// 596E0: using guessed type char *off_596E0;
// 59740: using guessed type char *off_59740;
// 59798: using guessed type __int64 (__fastcall *off_59798)();
// 59B68: using guessed type char *off_59B68;

//----- (000000000003D160) ----------------------------------------------------
__int64 *__fastcall rustc_demangle::demangle(__int64 *a1, __int64 a2, __int64 a3)
{
  _BYTE *v3; // rbx
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // rcx
  __int64 v8; // r12
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r10
  bool v12; // zf
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // rsi
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // r8
  __int64 v18; // r12
  unsigned __int64 v19; // r14
  unsigned __int64 v20; // r15
  __int64 v21; // r8
  char *v22; // r10
  unsigned __int64 v23; // rcx
  char v24; // r13
  char *v25; // rcx
  unsigned __int64 v26; // r10
  bool v27; // cf
  char v28; // r15
  __int64 v29; // r12
  unsigned __int64 v30; // rcx
  __int64 v31; // r15
  const char *v32; // r15
  __int64 v33; // r12
  const char *v34; // rcx
  __int64 v35; // rax
  bool v36; // sf
  int v37; // edi
  const char *v38; // rbp
  int v39; // edx
  int v40; // edx
  int v41; // r8d
  int v42; // eax
  char v43; // al
  __int64 v44; // r13
  unsigned __int64 v45; // r13
  __int64 v46; // rax
  unsigned __int64 v47; // rcx
  __int64 v48; // rdx
  __int64 *result; // rax
  _BYTE *v50; // rdi
  char v51; // al
  unsigned __int64 v52; // rdx
  unsigned __int64 v53; // rcx
  unsigned __int64 v54; // rax
  unsigned int v55; // r8d
  __int64 v56; // rax
  unsigned __int64 v57; // kr00_8
  int v58; // r9d
  int v59; // edx
  int v60; // r10d
  int v61; // r8d
  char v62; // r9
  int v63; // r8d
  int v64; // r10d
  int v65; // r9d
  unsigned __int64 v66; // rax
  int v67; // r10d
  __int64 v68; // r8
  const char *v69; // r9
  int v70; // r11d
  int v71; // r14d
  _BYTE *v72; // rsi
  int v73; // ebx
  unsigned __int64 v74; // r11
  unsigned __int64 v75; // rdi
  unsigned __int64 v76; // r14
  unsigned __int8 *v77; // rdx
  int v78; // r9d
  int v79; // edi
  int v80; // ecx
  int v81; // r8d
  _BYTE *v83; // [rsp+10h] [rbp-C8h] BYREF
  unsigned __int64 v84; // [rsp+18h] [rbp-C0h]
  unsigned __int64 v85; // [rsp+20h] [rbp-B8h]
  unsigned __int64 v86; // [rsp+28h] [rbp-B0h] BYREF
  __int64 v87; // [rsp+30h] [rbp-A8h]
  unsigned __int64 v88; // [rsp+38h] [rbp-A0h]
  unsigned __int64 v89; // [rsp+48h] [rbp-90h]
  __int64 v90; // [rsp+58h] [rbp-80h]
  unsigned __int64 v91; // [rsp+60h] [rbp-78h]
  __int64 v92; // [rsp+68h] [rbp-70h]
  unsigned __int64 v93; // [rsp+70h] [rbp-68h]
  _BYTE *v94; // [rsp+78h] [rbp-60h]
  unsigned __int64 v95; // [rsp+80h] [rbp-58h]
  __int64 *v96; // [rsp+88h] [rbp-50h]
  __int64 v97; // [rsp+90h] [rbp-48h] BYREF
  unsigned __int64 v98; // [rsp+98h] [rbp-40h]

  v3 = (_BYTE *)a2;
  core::str::pattern::StrSearcher::new((__int64)&v83, a2, a3, aLlvm, 6uLL);
  v96 = a1;
  if ( !v83 )
  {
    do
      <core::str::pattern::StrSearcher as core::str::pattern::Searcher>::next(&v97, (__int64)&v83);
    while ( v97 == 1 );
    if ( !v97 )
    {
      v6 = v98;
      v15 = a3;
      v16 = v98 + 6;
      if ( v98 != -6LL )
        goto LABEL_184;
      goto LABEL_188;
    }
LABEL_44:
    v15 = a3;
    goto LABEL_45;
  }
  v94 = (_BYTE *)a2;
  v4 = v89;
  v5 = v93 - 1;
  if ( v89 != -1LL )
  {
    v6 = v88;
    v7 = v88 + v5;
    if ( v88 + v5 < v91 )
    {
      v8 = v87;
      while ( 1 )
      {
        if ( !_bittest64(&v8, *(unsigned __int8 *)(v90 + v7)) )
        {
          v6 += v93;
          goto LABEL_6;
        }
        v9 = v4;
        if ( v84 > v4 )
          v9 = v84;
        v10 = v9;
        while ( 2 )
        {
          if ( v10 >= v93 )
          {
            v13 = v84;
            do
            {
              if ( v4 >= v13 )
                goto LABEL_183;
              if ( --v13 >= v93 )
                goto LABEL_209;
              v14 = v13 + v6;
              if ( v13 + v6 >= v91 )
                goto LABEL_177;
            }
            while ( *(_BYTE *)(v92 + v13) == *(_BYTE *)(v90 + v14) );
            v6 += v86;
            v4 = v93 - v86;
            v7 = v6 + v5;
            if ( v6 + v5 >= v91 )
              goto LABEL_43;
          }
          else
          {
            if ( v6 + v10 >= v91 )
            {
              v75 = v6 + v9;
              if ( v91 > v75 )
                v75 = v91;
              core::panicking::panic_bounds_check(v75, v91, (__int64)&off_59728);
            }
            v11 = v10 + 1;
            v12 = *(_BYTE *)(v92 + v10) == *(_BYTE *)(v90 + v6 + v10);
            ++v10;
            if ( v12 )
              continue;
            v6 = v11 + v6 - v84;
LABEL_6:
            v4 = 0LL;
            v7 = v6 + v5;
            if ( v6 + v5 >= v91 )
              goto LABEL_43;
          }
          break;
        }
      }
    }
    goto LABEL_43;
  }
  v6 = v88;
  v17 = v88 + v5;
  if ( v88 + v5 >= v91 )
  {
LABEL_43:
    v3 = v94;
    goto LABEL_44;
  }
  v18 = v87;
  v95 = v86;
  v13 = v84 - 1;
  while ( 1 )
  {
    if ( !_bittest64(&v18, *(unsigned __int8 *)(v90 + v17)) )
    {
      v19 = v93 + v6;
      goto LABEL_29;
    }
    v21 = 0LL;
    v22 = (char *)(v84 + v92);
    v23 = v6;
    while ( v84 + v21 < v93 )
    {
      if ( v84 + v23 >= v91 )
      {
        v76 = v84 + v6;
        if ( v91 > v76 )
          v76 = v91;
        core::panicking::panic_bounds_check(v76, v91, (__int64)&off_59728);
      }
      v24 = *v22;
      v20 = v23 + 1;
      ++v22;
      ++v21;
      v12 = v24 == *(_BYTE *)(v90 + v84 + v23++);
      if ( !v12 )
        goto LABEL_30;
    }
    if ( v13 >= v93 )
      break;
    v14 = v13 + v6;
    v25 = (char *)(v92 + v84 - 1);
    v26 = v84;
    do
    {
      v27 = v26-- == 0;
      if ( v27 )
        goto LABEL_183;
      if ( v14 >= v91 )
LABEL_177:
        core::panicking::panic_bounds_check(v14, v91, (__int64)&off_59710);
      v28 = *v25--;
      v12 = v28 == *(_BYTE *)(v90 + v14--);
    }
    while ( v12 );
    v19 = v95 + v6;
LABEL_29:
    v20 = v19;
LABEL_30:
    v17 = v20 + v5;
    v6 = v20;
    if ( v20 + v5 >= v91 )
      goto LABEL_43;
  }
  if ( v84 )
LABEL_209:
    core::panicking::panic_bounds_check(v13, v93, (__int64)&off_596F8);
LABEL_183:
  v3 = v94;
  v15 = a3;
  v16 = v6 + 6;
  if ( v6 != -6LL )
  {
LABEL_184:
    if ( v16 >= v15 )
    {
      if ( v16 != v15 )
LABEL_186:
        core::str::slice_error_fail(v3, v15, v16, v15, (__int64)&off_59C10);
    }
    else if ( (char)v3[v16] <= -65 )
    {
      goto LABEL_186;
    }
  }
LABEL_188:
  v77 = &v3[v16];
LABEL_191:
  while ( v77 != &v3[v15] )
  {
    v78 = *v77;
    if ( (v78 & 0x80u) == 0 )
    {
      ++v77;
      if ( (unsigned int)(v78 - 64) < 7 )
        goto LABEL_191;
      goto LABEL_190;
    }
    v79 = v78 & 0x1F;
    v80 = v77[1] & 0x3F;
    if ( (unsigned __int8)v78 <= 0xDFu )
    {
      v77 += 2;
      v78 = v80 | (v79 << 6);
      if ( (unsigned int)(v78 - 64) < 7 )
        goto LABEL_191;
LABEL_190:
      if ( (unsigned int)(v78 - 48) >= 0xA )
        goto LABEL_45;
      goto LABEL_191;
    }
    v81 = (v80 << 6) | v77[2] & 0x3F;
    if ( (unsigned __int8)v78 < 0xF0u )
    {
      v77 += 3;
      v78 = (v79 << 12) | v81;
      if ( (unsigned int)(v78 - 64) < 7 )
        goto LABEL_191;
      goto LABEL_190;
    }
    v78 = ((v78 & 7) << 18) | (v81 << 6) | v77[3] & 0x3F;
    if ( v78 == 1114112 )
      break;
    v77 += 4;
    if ( (unsigned int)(v78 - 64) >= 7 )
      goto LABEL_190;
  }
  if ( !v6 )
  {
    v38 = aRustc9b00956e5_0;
    v15 = 0LL;
    goto LABEL_87;
  }
  if ( v6 < v15 )
  {
    if ( (char)v3[v6] > -65 )
    {
      v15 = v6;
      goto LABEL_45;
    }
LABEL_208:
    core::str::slice_error_fail(v3, v15, 0LL, v6, (__int64)&off_59C28);
  }
  if ( v6 != v15 )
    goto LABEL_208;
LABEL_45:
  if ( v15 >= 3 )
  {
    if ( *(_WORD *)v3 ^ 0x5A5F | (unsigned __int8)v3[2] ^ 0x4E )
    {
      if ( *(_WORD *)v3 == 20058 )
      {
        if ( (char)v3[2] <= -65 )
          core::str::slice_error_fail(v3, v15, 2uLL, v15, (__int64)&off_59870);
        v29 = -2LL;
LABEL_60:
        v31 = 2LL;
      }
      else
      {
        v30 = 3LL;
        if ( v15 == 3 )
          goto LABEL_80;
        if ( *(_DWORD *)v3 != 1314545503 )
        {
LABEL_79:
          v30 = v15;
LABEL_80:
          if ( *(_WORD *)v3 == 21087 )
          {
            v43 = v3[2];
            if ( v43 <= -65 )
              core::str::slice_error_fail(v3, v30, 2uLL, v30, (__int64)&off_59A68);
            v33 = (__int64)(v3 + 2);
            v44 = -2LL;
          }
          else
          {
            if ( *v3 == 82 )
            {
              v15 = v30;
              goto LABEL_84;
            }
            v38 = aRustc9b00956e5_0;
            if ( v30 == 3 )
            {
              v15 = 3LL;
              goto LABEL_87;
            }
            v45 = 0LL;
            if ( *(_WORD *)v3 ^ 0x5F5F | (unsigned __int8)v3[2] ^ 0x52 )
            {
              v15 = v30;
              goto LABEL_88;
            }
            v43 = v3[3];
            if ( v43 <= -65 )
              core::str::slice_error_fail(v3, v30, 3uLL, v30, (__int64)&off_59A38);
            v33 = (__int64)(v3 + 3);
            v44 = -3LL;
          }
          v15 = v30;
          goto LABEL_92;
        }
        v29 = -4LL;
        v31 = 4LL;
        if ( v15 < 5 )
        {
          v15 = 4LL;
        }
        else if ( (char)v3[4] <= -65 )
        {
          core::str::slice_error_fail(v3, v15, 4uLL, v15, (__int64)&off_59858);
        }
      }
    }
    else
    {
      v29 = -3LL;
      v31 = 3LL;
      if ( v15 == 3 )
      {
        v15 = 3LL;
      }
      else if ( (char)v3[3] <= -65 )
      {
        core::str::slice_error_fail(v3, v15, 3uLL, v15, (__int64)&off_59888);
      }
    }
    v32 = &v3[v31];
    v33 = v15 + v29;
    v34 = &v32[v33];
    v35 = 0LL;
    while ( v33 != v35 )
    {
      v36 = v32[v35++] < 0;
      if ( v36 )
        goto LABEL_78;
    }
    if ( !v33 )
    {
LABEL_78:
      if ( v15 <= 2 )
        goto LABEL_83;
      goto LABEL_79;
    }
    v37 = *(unsigned __int8 *)v32;
    if ( (v37 & 0x80u) == 0 )
    {
      v38 = v32 + 1;
LABEL_69:
      v39 = v37;
      goto LABEL_76;
    }
    v40 = v37 & 0x1F;
    v41 = v32[1] & 0x3F;
    if ( (unsigned __int8)v37 <= 0xDFu )
    {
      v38 = v32 + 2;
      v39 = v41 | (v40 << 6);
    }
    else
    {
      v42 = (v41 << 6) | v32[2] & 0x3F;
      if ( (unsigned __int8)v37 >= 0xF0u )
      {
        v38 = v32 + 4;
        v37 = ((v37 & 7) << 18) | (v42 << 6) | v32[3] & 0x3F;
        goto LABEL_69;
      }
      v38 = v32 + 3;
      v39 = (v40 << 12) | v42;
    }
LABEL_76:
    if ( v39 == 69 )
    {
      v45 = 0LL;
      goto LABEL_116;
    }
    if ( v39 == 1114112 )
      goto LABEL_78;
    v45 = 0LL;
LABEL_119:
    if ( (unsigned int)(v39 - 48) > 9 )
      goto LABEL_78;
    v54 = 0LL;
    while ( 1 )
    {
      v55 = v39 - 48;
      if ( (unsigned int)(v39 - 48) >= 0xA )
      {
        if ( v54 )
        {
          while ( v38 != v34 )
          {
            v39 = *(unsigned __int8 *)v38;
            if ( (v39 & 0x80u) == 0 )
            {
              ++v38;
            }
            else
            {
              v63 = v39 & 0x1F;
              v64 = v38[1] & 0x3F;
              if ( (unsigned __int8)v39 <= 0xDFu )
              {
                v38 += 2;
                v39 = v64 | (v63 << 6);
              }
              else
              {
                v65 = (v64 << 6) | v38[2] & 0x3F;
                if ( (unsigned __int8)v39 < 0xF0u )
                {
                  v38 += 3;
                  v39 = (v63 << 12) | v65;
                }
                else
                {
                  v39 = ((v39 & 7) << 18) | (v65 << 6) | v38[3] & 0x3F;
                  if ( v39 == 1114112 )
                    goto LABEL_78;
                  v38 += 4;
                }
              }
            }
            if ( !--v54 )
              goto LABEL_135;
          }
          goto LABEL_78;
        }
LABEL_135:
        ++v45;
        if ( v39 == 69 )
        {
LABEL_116:
          v47 = v34 - v38;
          v48 = 1LL;
          if ( !v47 )
            goto LABEL_117;
LABEL_152:
          if ( *v38 == 46 )
          {
            v66 = v15;
            LOBYTE(v67) = 46;
            v68 = 0x7E0000007FLL;
            v69 = v38;
LABEL_163:
            ++v69;
            v67 = (unsigned __int8)v67;
            if ( (unsigned int)(unsigned __int8)v67 - 33 < 0x19 )
              goto LABEL_167;
LABEL_164:
            if ( (v67 & 0xFFFFFFDF) - 65 < 0x1A
              || (v74 = (unsigned int)(v67 - 58), (unsigned int)v74 <= 0x26) && _bittest64(&v68, v74)
              || (unsigned int)(v67 - 127) >= 0xFFFFFFFC )
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  while ( 1 )
                  {
LABEL_167:
                    if ( v69 == &v38[v47] )
                    {
                      v15 = v66;
                      goto LABEL_99;
                    }
                    LOBYTE(v67) = *v69;
                    if ( *v69 >= 0 )
                      goto LABEL_163;
                    v70 = v67 & 0x1F;
                    v71 = v69[1] & 0x3F;
                    if ( (unsigned __int8)v67 > 0xDFu )
                      break;
                    v69 += 2;
                    v67 = v71 | (v70 << 6);
                    if ( (unsigned int)(v67 - 33) >= 0x19 )
                      goto LABEL_164;
                  }
                  v72 = v3;
                  v73 = (v71 << 6) | v69[2] & 0x3F;
                  if ( (unsigned __int8)v67 >= 0xF0u )
                    break;
                  v69 += 3;
                  v67 = (v70 << 12) | v73;
                  v3 = v72;
                  if ( (unsigned int)(v67 - 33) >= 0x19 )
                    goto LABEL_164;
                }
                v67 = ((v67 & 7) << 18) | (v73 << 6) | v69[3] & 0x3F;
                if ( v67 == 1114112 )
                  break;
                v69 += 4;
                v3 = v72;
                if ( (unsigned int)(v67 - 33) >= 0x19 )
                  goto LABEL_164;
              }
              v3 = v72;
              v15 = v66;
            }
            else
            {
              v47 = 0LL;
              v38 = aRustc9b00956e5_0;
              v48 = 0LL;
              v15 = v66;
            }
            goto LABEL_99;
          }
          v47 = 0LL;
          v38 = aRustc9b00956e5_0;
LABEL_98:
          v48 = 0LL;
          goto LABEL_99;
        }
        goto LABEL_119;
      }
      v57 = v54;
      v56 = 10 * v54;
      if ( !is_mul_ok(0xAuLL, v57) )
        goto LABEL_78;
      v27 = __CFADD__(v55, v56);
      v54 = v55 + v56;
      if ( v27 || v38 == v34 )
        goto LABEL_78;
      v58 = *(unsigned __int8 *)v38;
      if ( (v58 & 0x80u) == 0 )
        break;
      v59 = v58 & 0x1F;
      v60 = v38[1] & 0x3F;
      if ( (unsigned __int8)v58 > 0xDFu )
      {
        v61 = (v60 << 6) | v38[2] & 0x3F;
        if ( (unsigned __int8)v58 < 0xF0u )
        {
          v38 += 3;
          v39 = (v59 << 12) | v61;
          goto LABEL_122;
        }
        v62 = v38[3];
        v38 += 4;
        v58 = ((v59 & 7) << 18) | (v61 << 6) | v62 & 0x3F;
        goto LABEL_129;
      }
      v38 += 2;
      v39 = v60 | (v59 << 6);
LABEL_122:
      if ( v39 == 1114112 )
        goto LABEL_78;
    }
    ++v38;
LABEL_129:
    v39 = v58;
    goto LABEL_122;
  }
  if ( v15 != 2 )
    goto LABEL_86;
  if ( *(_WORD *)v3 == 20058 )
  {
    v29 = -2LL;
    v15 = 2LL;
    goto LABEL_60;
  }
LABEL_83:
  v15 = 2LL;
  if ( *v3 != 82 )
  {
LABEL_86:
    v38 = aRustc9b00956e5_0;
LABEL_87:
    v45 = 0LL;
    goto LABEL_88;
  }
LABEL_84:
  v43 = v3[1];
  if ( v43 <= -65 )
    core::str::slice_error_fail(v3, v15, 1uLL, v15, (__int64)&off_59A50);
  v33 = (__int64)(v3 + 1);
  v44 = -1LL;
LABEL_92:
  v38 = aRustc9b00956e5_0;
  v32 = 0LL;
  if ( (unsigned __int8)(v43 - 65) > 0x19u )
  {
LABEL_96:
    v45 = 0LL;
    v33 = 0LL;
    goto LABEL_97;
  }
  v45 = v15 + v44;
  v32 = 0LL;
  v46 = 0LL;
  while ( v45 != v46 )
  {
    v36 = *(char *)(v33 + v46++) < 0;
    if ( v36 )
      goto LABEL_96;
  }
  v83 = (_BYTE *)v33;
  v84 = v45;
  v85 = 0LL;
  LODWORD(v86) = 0;
  v87 = 0LL;
  LODWORD(v88) = 0;
  if ( rustc_demangle::v0::Printer::print_path((__int64)&v83, 0) )
LABEL_213:
    core::result::unwrap_failed((__int64)aFmtErrorSShoul, 61LL, (__int64)&v97, (__int64)&off_59778, (__int64)&off_59A80);
  v50 = v83;
  v51 = v84;
  if ( !v83 )
    goto LABEL_147;
  v52 = v85;
  v53 = (unsigned __int8)v84 | ((((unsigned __int64)((HIBYTE(v84) << 16) | (unsigned int)*(unsigned __int16 *)((char *)&v84 + 5)) << 32) | *(unsigned int *)((char *)&v84 + 1)) << 8);
  if ( v85 < v53 && (unsigned __int8)(v83[v85] - 65) < 0x1Au )
  {
    v84 = (unsigned __int8)v84 | ((((unsigned __int64)((HIBYTE(v84) << 16) | (unsigned int)*(unsigned __int16 *)((char *)&v84 + 5)) << 32) | *(unsigned int *)((char *)&v84 + 1)) << 8);
    _mm_storel_ps((double *)&v86, (__m128)v86);
    v87 = 0LL;
    LODWORD(v88) = 0;
    if ( !rustc_demangle::v0::Printer::print_path((__int64)&v83, 0) )
    {
      v50 = v83;
      v51 = v84;
      if ( v83 )
      {
        v52 = v85;
        v53 = (unsigned __int8)v84 | ((((unsigned __int64)((HIBYTE(v84) << 16) | (unsigned int)*(unsigned __int16 *)((char *)&v84 + 5)) << 32) | *(unsigned int *)((char *)&v84 + 1)) << 8);
        goto LABEL_109;
      }
LABEL_147:
      v45 = v51 & 1;
LABEL_88:
      v33 = 0LL;
      v32 = 0LL;
LABEL_97:
      v47 = 0LL;
      goto LABEL_98;
    }
    goto LABEL_213;
  }
LABEL_109:
  if ( v52 )
  {
    if ( v53 <= v52 )
    {
      if ( v53 != v52 )
LABEL_112:
        core::str::slice_error_fail(v50, v53, v52, v53, (__int64)&off_59A98);
    }
    else if ( (char)v50[v52] <= -65 )
    {
      goto LABEL_112;
    }
  }
  v47 = v53 - v52;
  v32 = 0LL;
  v38 = &v50[v52];
  v48 = 1LL;
  if ( v47 )
    goto LABEL_152;
LABEL_117:
  v47 = 0LL;
LABEL_99:
  result = v96;
  *v96 = v48;
  result[1] = (__int64)v32;
  result[2] = v33;
  result[3] = v45;
  result[4] = (__int64)v3;
  result[5] = v15;
  result[6] = (__int64)v38;
  result[7] = v47;
  return result;
}
// 3D5EA: conditional instruction was optimized away because rsi.8==2
// 596F8: using guessed type char *off_596F8;
// 59710: using guessed type char *off_59710;
// 59728: using guessed type char *off_59728;
// 59778: using guessed type __int64 (__fastcall *off_59778)();
// 59858: using guessed type char *off_59858;
// 59870: using guessed type char *off_59870;
// 59888: using guessed type char *off_59888;
// 59A38: using guessed type char *off_59A38;
// 59A50: using guessed type char *off_59A50;
// 59A68: using guessed type char *off_59A68;
// 59A80: using guessed type char *off_59A80;
// 59A98: using guessed type char *off_59A98;
// 59C10: using guessed type char *off_59C10;
// 59C28: using guessed type char *off_59C28;

//----- (000000000003DDB0) ----------------------------------------------------
__int128 *__fastcall rustc_demangle::try_demangle(__int128 *a1, __int64 a2, __int64 a3)
{
  __int128 v3; // xmm0
  __int128 v4; // xmm1
  __int128 v5; // xmm2
  __int128 v7[4]; // [rsp+0h] [rbp-48h] BYREF

  rustc_demangle::demangle((__int64 *)v7, a2, a3);
  if ( *(_QWORD *)&v7[0] )
  {
    v3 = v7[0];
    v4 = v7[1];
    v5 = v7[2];
    a1[3] = v7[3];
    a1[2] = v5;
    a1[1] = v4;
    *a1 = v3;
  }
  else
  {
    *(_QWORD *)a1 = 2LL;
  }
  return a1;
}

//----- (000000000003DE10) ----------------------------------------------------
char __fastcall <rustc_demangle::SizeLimitedFmtAdapter<F> as core::fmt::Write>::write_str(
        _QWORD *a1,
        __int64 a2,
        unsigned __int64 a3)
{
  bool v3; // al
  bool v4; // cf
  __int64 v5; // rax

  v3 = *a1 != 0LL;
  v4 = a1[1] < a3;
  a1[1] -= a3;
  v5 = v3 | (unsigned __int8)v4;
  *a1 = v5;
  if ( (_BYTE)v5 )
    return 1;
  else
    return <core::fmt::Formatter as core::fmt::Write>::write_str(a1[2]);
}

//----- (000000000003DE40) ----------------------------------------------------
char __fastcall <rustc_demangle::Demangle as core::fmt::Display>::fmt(_QWORD *a1, __int64 a2)
{
  bool v2; // zf
  char v3; // al
  __int64 v4; // rcx
  char v5; // cl
  char result; // al
  _QWORD *v7; // [rsp+0h] [rbp-A8h] BYREF
  __int64 v8[3]; // [rsp+8h] [rbp-A0h] BYREF
  __int64 v9[2]; // [rsp+20h] [rbp-88h] BYREF
  __int64 **v10; // [rsp+30h] [rbp-78h]
  __int64 v11; // [rsp+38h] [rbp-70h]
  __int64 v12; // [rsp+40h] [rbp-68h]
  __int64 v13; // [rsp+48h] [rbp-60h]
  char v14; // [rsp+50h] [rbp-58h]
  __int64 *v15; // [rsp+58h] [rbp-50h] BYREF
  char (__fastcall *v16)(__int64 *, __int64); // [rsp+60h] [rbp-48h]
  __int64 *v17; // [rsp+68h] [rbp-40h]
  __int64 v18; // [rsp+70h] [rbp-38h]
  __int64 *v19; // [rsp+78h] [rbp-30h]
  __int64 v20; // [rsp+80h] [rbp-28h]
  __int64 v21[4]; // [rsp+88h] [rbp-20h] BYREF

  if ( *a1 )
  {
    v2 = (*(_BYTE *)(a2 + 52) & 4) == 0;
    v7 = a1 + 1;
    v8[0] = 0LL;
    v8[1] = 1000000LL;
    v8[2] = a2;
    if ( v2 )
    {
      v15 = (__int64 *)&v7;
      v16 = <&T as core::fmt::Display>::fmt;
      v9[0] = (__int64)&off_59C40;
      v9[1] = 1LL;
      v12 = 0LL;
      v10 = &v15;
      v11 = 1LL;
      v3 = core::fmt::write((__int64)v8, (__int64)off_597F8, v9);
      v4 = v8[0];
      if ( !v3 )
        goto LABEL_11;
    }
    else
    {
      v21[0] = (__int64)&v7;
      v21[1] = (__int64)<&T as core::fmt::Display>::fmt;
      v9[0] = 2LL;
      v10 = (__int64 **)(&dword_0 + 2);
      v12 = 0LL;
      v13 = 0x400000020LL;
      v14 = 3;
      v15 = (__int64 *)&off_59C40;
      v16 = (char (__fastcall *)(__int64 *, __int64))(&dword_0 + 1);
      v19 = v9;
      v20 = 1LL;
      v17 = v21;
      v18 = 1LL;
      v3 = core::fmt::write((__int64)v8, (__int64)off_597F8, &v15);
      v4 = v8[0];
      if ( !v3 )
      {
LABEL_11:
        if ( v3 )
          return 1;
        if ( v4 )
          core::result::unwrap_failed(
            (__int64)aFmtErrorFromSi,
            55LL,
            (__int64)v9,
            (__int64)&off_59758,
            (__int64)&off_59C50);
        return <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
      }
    }
    if ( v4 )
    {
      if ( (unsigned __int8)<core::fmt::Formatter as core::fmt::Write>::write_str(a2) )
        return 1;
      return <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
    }
    goto LABEL_11;
  }
  v5 = <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
  result = 1;
  if ( !v5 )
    return <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
  return result;
}
// 0: using guessed type int dword_0;
// 59758: using guessed type __int64 (__fastcall *off_59758)();
// 597F8: using guessed type __int64 (__fastcall *off_597F8[2])();
// 59C40: using guessed type char *off_59C40;
// 59C50: using guessed type char *off_59C50;

//----- (000000000003E040) ----------------------------------------------------
__int64 __fastcall <rustc_demangle::SizeLimitExhausted as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
}

//----- (000000000003E060) ----------------------------------------------------
__int64 __fastcall miniz_oxide::inflate::core::init_tree(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // eax
  unsigned __int64 v5; // r13
  unsigned __int8 *v6; // r12
  int v7; // r8d
  __int64 i; // rax
  unsigned __int64 v9; // rcx
  unsigned int v10; // eax
  int v11; // ecx
  unsigned __int64 j; // rdx
  unsigned int v13; // esi
  unsigned __int64 v14; // rdx
  __int16 v15; // r10
  unsigned __int16 v16; // r10
  unsigned __int64 v17; // rdi
  __int16 v18; // r10
  unsigned int v19; // ebp
  unsigned int v20; // r9d
  unsigned int v21; // r9d
  char v22; // r14
  char v23; // cl
  __int16 v24; // di
  __int64 v25; // r10
  unsigned __int64 k; // rax
  __int64 v27; // rcx
  __int16 v28; // r11
  int v29; // ecx
  unsigned int v30; // r9d
  char v31; // al
  unsigned __int16 v32; // r11
  int v33; // eax
  __int128 v36[4]; // [rsp+10h] [rbp-C8h] BYREF
  int v37; // [rsp+50h] [rbp-88h]
  __int128 v38[7]; // [rsp+60h] [rbp-78h] BYREF

  v3 = *(_DWORD *)(a1 + 10492);
  LOBYTE(v2) = 3;
  if ( v3 > 2 )
    return v2;
  do
  {
    v5 = *(unsigned int *)(a1 + 4LL * v3 + 10512);
    if ( v5 > 0x120 )
      return v2;
    v6 = (unsigned __int8 *)(a1 + 3488LL * v3);
    memset(v38, 0, 64);
    memset(v36, 0, sizeof(v36));
    v37 = 0;
    memset(v6, 0, 0xC80uLL);
    if ( v5 )
    {
      for ( i = 0LL; i != v5; ++i )
      {
        v9 = v6[i + 3200];
        if ( v9 > 0xF )
        {
          LOBYTE(v2) = 3;
          return v2;
        }
        ++*((_DWORD *)v38 + v9);
      }
    }
    v10 = DWORD1(v38[0]);
    v11 = 2 * DWORD1(v38[0]);
    DWORD2(v36[0]) = 2 * DWORD1(v38[0]);
    for ( j = 2LL; j < 0x10; ++j )
    {
      v13 = *((_DWORD *)v38 + j);
      v11 = 2 * (v13 + v11);
      *((_DWORD *)v36 + j + 1) = v11;
      v10 += v13;
    }
    LOBYTE(v13) = 1;
    if ( v11 != 0x10000 && v10 > 1 )
      return v13;
    if ( (_DWORD)v5 )
    {
      LOWORD(v7) = -1;
      v14 = 0LL;
      do
      {
        v17 = v14++;
        v18 = v6[v17 + 3200];
        if ( (unsigned __int8)(v18 - 17) >= 0xF0u )
        {
          v19 = *((_DWORD *)v36 + v6[v17 + 3200]);
          *((_DWORD *)v36 + v6[v17 + 3200]) = v19 + 1;
          v20 = v19 << -(char)v18 >> -(char)v18;
          if ( v20 >= 0x400 )
          {
            v21 = 0;
            if ( (unsigned __int8)(v18 - 1) >= 3u )
            {
              v22 = v18 & 0x1C;
              v21 = 0;
              do
              {
                v21 = ((v19 >> 3) & 1) + 2 * ((4 * (v19 & 1) + 8 * v21) | v19 & 2 | (v19 >> 2) & 1);
                v19 >>= 4;
                v22 -= 4;
              }
              while ( v22 );
            }
            v23 = v18 & 3;
            if ( (v18 & 3) != 0 )
            {
              do
              {
                v21 = (v19 & 1) + 2 * v21;
                v19 >>= 1;
                --v23;
              }
              while ( v23 );
            }
          }
          else
          {
            v21 = miniz_oxide::inflate::core::REVERSED_BITS_LOOKUP[v20] >> (-(char)v18 & 0x1F);
          }
          if ( (unsigned __int8)v18 >= 0xBu )
          {
            v27 = v21 & 0x3FF;
            v28 = *(_WORD *)&v6[2 * v27];
            if ( v28 )
            {
              v29 = v7;
              v30 = v21 >> 9;
              if ( (_BYTE)v18 != 11 )
                goto LABEL_34;
            }
            else
            {
              *(_WORD *)&v6[2 * v27] = v7;
              v29 = v7 - 2;
              v28 = v7;
              v30 = v21 >> 9;
              if ( (_BYTE)v18 != 11 )
              {
LABEL_34:
                v31 = v18 - 11;
                while ( 1 )
                {
                  v32 = ((v30 & 2) != 0) + ~v28;
                  if ( v32 > 0x23Fu )
                    break;
                  if ( *(_WORD *)&v6[2 * v32 + 2048] )
                  {
                    v7 = v29;
                    LOWORD(v29) = *(_WORD *)&v6[2 * v32 + 2048];
                  }
                  else
                  {
                    *(_WORD *)&v6[2 * v32 + 2048] = v29;
                    v7 = v29 - 2;
                  }
                  v30 >>= 1;
                  v15 = v29;
                  v28 = v29;
                  v29 = v7;
                  if ( !--v31 )
                    goto LABEL_14;
                }
LABEL_46:
                LOBYTE(v13) = 3;
                return v13;
              }
            }
            v7 = v29;
            v15 = v28;
LABEL_14:
            v16 = ((v30 & 2) != 0) + ~v15;
            if ( v16 > 0x23Fu )
              goto LABEL_46;
            *(_WORD *)&v6[2 * v16 + 2048] = v17;
          }
          else if ( v21 <= 0x3FF )
          {
            v24 = (v18 << 9) | v17;
            v25 = 1LL << v18;
            for ( k = v21; k < 0x400; k += v25 )
              *(_WORD *)&v6[2 * k] = v24;
          }
        }
      }
      while ( v14 < v5 );
    }
    v33 = *(_DWORD *)(a1 + 10492);
    if ( !v33 )
    {
      *(_DWORD *)(a2 + 16) = 0;
      LOBYTE(v2) = 1;
      return v2;
    }
    if ( v33 == 2 )
    {
      *(_DWORD *)(a2 + 16) = 0;
      return v13;
    }
    v3 = v33 - 1;
    *(_DWORD *)(a1 + 10492) = v3;
  }
  while ( v3 < 3 );
  return v2;
}
// 3E2E9: variable 'v7' is possibly undefined
// 3E3A6: variable 'v2' is possibly undefined
// 4B49C: using guessed type _DWORD miniz_oxide::inflate::core::REVERSED_BITS_LOOKUP[1024];

//----- (000000000003E3F0) ----------------------------------------------------
unsigned __int64 __fastcall miniz_oxide::inflate::core::transfer(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 a5,
        __int64 a6)
{
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r11
  __int64 v8; // rax
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rdx
  __int64 v11; // rax
  unsigned __int64 v12; // rdx
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  __int64 v15; // rax
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rbx
  char v19; // r13
  __int64 v20; // rax
  __int64 v21; // rax
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // r10
  unsigned __int64 v24; // rax
  __int64 v25[3]; // [rsp+0h] [rbp-58h] BYREF
  __int128 v26; // [rsp+18h] [rbp-40h]

  result = a4 - a3;
  if ( a4 < a3 )
    result = a3 - a4;
  if ( a6 != -1 )
    goto LABEL_4;
  if ( a3 >= a4 || result != 1 )
  {
    if ( a3 < a4 && result > 3 )
    {
      if ( a5 >= 4 )
      {
        v23 = a5 >> 2;
        do
        {
          v24 = a3 + 4;
          if ( a3 == -4LL )
            core::slice::index::slice_end_index_overflow_fail((__int64)&off_59D48);
          if ( a3 > v24 )
            core::slice::index::slice_index_order_fail(a3, a3 + 4, (__int64)&off_59FA0);
          if ( v24 > a2 )
            core::slice::index::slice_end_index_len_fail(v24, a2, (__int64)&off_59FA0);
          if ( a2 - 4 < a4 )
          {
            v25[0] = (__int64)&off_59D38;
            v25[1] = 1LL;
            v25[2] = (__int64)aDestIsOutOfBou;
            v26 = 0LL;
            core::panicking::panic_fmt((__int64)v25, (__int64)&off_59FA0);
          }
          result = *(unsigned int *)(a1 + a3);
          *(_DWORD *)(a1 + a4) = result;
          a3 += 4LL;
          a4 += 4LL;
          --v23;
        }
        while ( v23 );
      }
      goto LABEL_16;
    }
LABEL_4:
    if ( a5 >= 4 )
    {
      v7 = a5 >> 2;
      do
      {
        v8 = a6 & a3;
        if ( (a6 & a3) >= a2 )
          core::panicking::panic_bounds_check(v8, a2, (__int64)&off_59DC0);
        if ( a4 >= a2 )
          core::panicking::panic_bounds_check(a4, a2, (__int64)&off_59DD8);
        v9 = a3;
        *(_BYTE *)(a1 + a4) = *(_BYTE *)(a1 + v8);
        v10 = a3 + 1;
        v11 = a6 & v10;
        if ( (a6 & v10) >= a2 )
          core::panicking::panic_bounds_check(v11, a2, (__int64)&off_59DF0);
        if ( a4 + 1 >= a2 )
          core::panicking::panic_bounds_check(a4 + 1, a2, (__int64)&off_59E08);
        *(_BYTE *)(a1 + a4 + 1) = *(_BYTE *)(a1 + v11);
        v12 = v10 + 1;
        v13 = a6 & v12;
        if ( (a6 & v12) >= a2 )
          core::panicking::panic_bounds_check(v13, a2, (__int64)&off_59E20);
        if ( a4 + 2 >= a2 )
          core::panicking::panic_bounds_check(a4 + 2, a2, (__int64)&off_59E38);
        *(_BYTE *)(a1 + a4 + 2) = *(_BYTE *)(a1 + v13);
        v14 = v12 + 1;
        v15 = a6 & v14;
        if ( (a6 & v14) >= a2 )
          core::panicking::panic_bounds_check(v15, a2, (__int64)&off_59E50);
        if ( a4 + 3 >= a2 )
          core::panicking::panic_bounds_check(a4 + 3, a2, (__int64)&off_59E68);
        result = *(unsigned __int8 *)(a1 + v15);
        *(_BYTE *)(a1 + a4 + 3) = result;
        a4 += 4LL;
        a3 = v14 + 1;
        --v7;
      }
      while ( v7 );
      a3 = v9 + 4;
    }
LABEL_16:
    switch ( a5 & 3 )
    {
      case 0uLL:
        return result;
      case 1uLL:
        goto LABEL_17;
      case 2uLL:
        goto LABEL_28;
      case 3uLL:
        goto LABEL_33;
    }
    return result;
  }
  result = a4 - 1;
  if ( a4 - 1 >= a2 )
    core::panicking::panic_bounds_check(a4 - 1, a2, (__int64)&off_59D90);
  v17 = a5 & 0xFFFFFFFFFFFFFFFCLL;
  v18 = a4 + (a5 & 0xFFFFFFFFFFFFFFFCLL);
  if ( __CFADD__(a4, a5 & 0xFFFFFFFFFFFFFFFCLL) )
    core::slice::index::slice_index_order_fail(a4, a4 + (a5 & 0xFFFFFFFFFFFFFFFCLL), (__int64)&off_59DA8);
  if ( v18 > a2 )
    core::slice::index::slice_end_index_len_fail(a4 + (a5 & 0xFFFFFFFFFFFFFFFCLL), a2, (__int64)&off_59DA8);
  if ( v17 )
  {
    v19 = a5;
    result = (unsigned __int64)memset((void *)(a1 + a4), *(unsigned __int8 *)(a1 + a4 - 1), v17);
    LOBYTE(a5) = v19;
  }
  a3 = v18 - 1;
  a4 = v18;
  a6 = -1LL;
  switch ( a5 & 3 )
  {
    case 0uLL:
      return result;
    case 1uLL:
LABEL_17:
      v16 = a6 & a3;
      if ( v16 >= a2 )
        core::panicking::panic_bounds_check(v16, a2, (__int64)&off_59E80);
      if ( a4 >= a2 )
        core::panicking::panic_bounds_check(a4, a2, (__int64)&off_59E98);
      goto LABEL_39;
    case 2uLL:
LABEL_28:
      v20 = a6 & a3;
      if ( (a6 & a3) >= a2 )
        core::panicking::panic_bounds_check(v20, a2, (__int64)&off_59EB0);
      if ( a4 >= a2 )
        core::panicking::panic_bounds_check(a4, a2, (__int64)&off_59EC8);
      *(_BYTE *)(a1 + a4) = *(_BYTE *)(a1 + v20);
      v16 = a6 & (a3 + 1);
      if ( v16 >= a2 )
        core::panicking::panic_bounds_check(v16, a2, (__int64)&off_59EE0);
      if ( ++a4 >= a2 )
        core::panicking::panic_bounds_check(a4, a2, (__int64)&off_59EF8);
      goto LABEL_39;
    case 3uLL:
LABEL_33:
      v21 = a6 & a3;
      if ( (a6 & a3) >= a2 )
        core::panicking::panic_bounds_check(v21, a2, (__int64)&off_59F10);
      if ( a4 >= a2 )
        core::panicking::panic_bounds_check(a4, a2, (__int64)&off_59F28);
      *(_BYTE *)(a1 + a4) = *(_BYTE *)(a1 + v21);
      v22 = a6 & (a3 + 1);
      if ( v22 >= a2 )
        core::panicking::panic_bounds_check(v22, a2, (__int64)&off_59F40);
      if ( a4 + 1 >= a2 )
        core::panicking::panic_bounds_check(a4 + 1, a2, (__int64)&off_59F58);
      *(_BYTE *)(a1 + a4 + 1) = *(_BYTE *)(a1 + v22);
      v16 = a6 & (a3 + 2);
      if ( v16 >= a2 )
        core::panicking::panic_bounds_check(v16, a2, (__int64)&off_59F70);
      a4 += 2LL;
      if ( a4 >= a2 )
        core::panicking::panic_bounds_check(a4, a2, (__int64)&off_59F88);
LABEL_39:
      result = *(unsigned __int8 *)(a1 + v16);
      *(_BYTE *)(a1 + a4) = result;
      break;
  }
  return result;
}
// 59D38: using guessed type char *off_59D38;
// 59D48: using guessed type char *off_59D48;
// 59D90: using guessed type char *off_59D90;
// 59DA8: using guessed type char *off_59DA8;
// 59DC0: using guessed type char *off_59DC0;
// 59DD8: using guessed type char *off_59DD8;
// 59DF0: using guessed type char *off_59DF0;
// 59E08: using guessed type char *off_59E08;
// 59E20: using guessed type char *off_59E20;
// 59E38: using guessed type char *off_59E38;
// 59E50: using guessed type char *off_59E50;
// 59E68: using guessed type char *off_59E68;
// 59E80: using guessed type char *off_59E80;
// 59E98: using guessed type char *off_59E98;
// 59EB0: using guessed type char *off_59EB0;
// 59EC8: using guessed type char *off_59EC8;
// 59EE0: using guessed type char *off_59EE0;
// 59EF8: using guessed type char *off_59EF8;
// 59F10: using guessed type char *off_59F10;
// 59F28: using guessed type char *off_59F28;
// 59F40: using guessed type char *off_59F40;
// 59F58: using guessed type char *off_59F58;
// 59F70: using guessed type char *off_59F70;
// 59F88: using guessed type char *off_59F88;
// 59FA0: using guessed type char *off_59FA0;

//----- (000000000003E8A0) ----------------------------------------------------
void __fastcall miniz_oxide::inflate::core::apply_match(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 a5,
        __int64 a6)
{
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rax
  bool v11; // cf
  unsigned __int64 v12; // rsi
  void *v13; // r10
  const void *v14; // rdx
  unsigned __int64 v15; // rsi
  char **v16; // [rsp+8h] [rbp-30h] BYREF
  __int64 v17; // [rsp+10h] [rbp-28h]
  const char *v18; // [rsp+18h] [rbp-20h]
  __int128 v19; // [rsp+20h] [rbp-18h]

  v7 = a6 & (a3 - a4);
  if ( a5 == 3 )
  {
    if ( a3 <= 0xFFFFFFFFFFFFFFFCLL && a3 + 3 <= a2 )
    {
      v8 = a6 & (v7 + 2);
      if ( v8 < a2 && a2 > v7 )
      {
        v9 = a6 & (v7 + 1);
        if ( v9 < a2 )
        {
          *(_BYTE *)(a1 + a3) = *(_BYTE *)(a1 + v7);
          *(_BYTE *)(a1 + a3 + 1) = *(_BYTE *)(a1 + v9);
          *(_BYTE *)(a1 + a3 + 2) = *(_BYTE *)(a1 + v8);
        }
      }
    }
  }
  else if ( v7 >= a3 && v7 - a3 < a5 || a5 > a4 || (v10 = v7 + a5, v7 + a5 >= a2) )
  {
    miniz_oxide::inflate::core::transfer(a1, a2, v7, a3, a5, a6);
  }
  else
  {
    if ( v7 >= a3 )
    {
      v11 = a2 < v7;
      v15 = a2 - v7;
      if ( v11 )
      {
        v16 = &off_59FB8;
        v17 = 1LL;
        v18 = aDestIsOutOfBou;
        v19 = 0LL;
        core::panicking::panic_fmt((__int64)&v16, (__int64)&off_59FC8);
      }
      if ( __CFADD__(a3, a5) )
        core::slice::index::slice_index_order_fail(a3, a3 + a5, (__int64)&off_59FE0);
      if ( a3 + a5 > v7 )
        core::slice::index::slice_end_index_len_fail(a3 + a5, v7, (__int64)&off_59FE0);
      if ( v15 < a5 )
        core::slice::index::slice_end_index_len_fail(a5, v15, (__int64)&off_59FF8);
      v14 = (const void *)(a1 + v7);
      v13 = (void *)(a1 + a3);
    }
    else
    {
      v11 = a2 < a3;
      v12 = a2 - a3;
      if ( v11 )
      {
        v16 = &off_59FB8;
        v17 = 1LL;
        v18 = aDestIsOutOfBou;
        v19 = 0LL;
        core::panicking::panic_fmt((__int64)&v16, (__int64)&off_5A010);
      }
      if ( v12 < a5 )
        core::slice::index::slice_end_index_len_fail(a5, v12, (__int64)&off_5A028);
      if ( v7 > v10 )
        core::slice::index::slice_index_order_fail(v7, v7 + a5, (__int64)&off_5A040);
      if ( v10 > a3 )
        core::slice::index::slice_end_index_len_fail(v10, a3, (__int64)&off_5A040);
      v13 = (void *)(a1 + a3);
      v14 = (const void *)(a1 + v7);
    }
    memcpy(v13, v14, a5);
  }
}
// 59FB8: using guessed type char *off_59FB8;
// 59FC8: using guessed type char *off_59FC8;
// 59FE0: using guessed type char *off_59FE0;
// 59FF8: using guessed type char *off_59FF8;
// 5A010: using guessed type char *off_5A010;
// 5A028: using guessed type char *off_5A028;
// 5A040: using guessed type char *off_5A040;

//----- (000000000003EA80) ----------------------------------------------------
char __fastcall miniz_oxide::inflate::core::decompress_fast(
        __int64 a1,
        char **a2,
        __int64 *a3,
        char a4,
        unsigned __int64 *a5,
        __int64 a6)
{
  unsigned __int64 v6; // r13
  unsigned int v7; // ebx
  unsigned int v8; // r14d
  int v9; // ebp
  int v10; // r11d
  unsigned __int64 v11; // r12
  char result; // al
  char *v13; // r15
  unsigned int *v14; // rcx
  __int128 v15; // xmm0
  __int128 v16; // xmm1
  __int128 v17; // xmm2
  __int128 v18; // xmm3
  unsigned __int64 v19; // rax
  int v20; // eax
  unsigned __int64 v21; // rcx
  unsigned int v22; // eax
  int v23; // r11d
  unsigned __int64 v24; // rcx
  unsigned int v25; // eax
  unsigned int v26; // ecx
  __int64 v27; // rbp
  __int64 v28; // rcx
  unsigned __int64 v29; // r10
  int v30; // r10d
  int v31; // r10d
  unsigned __int64 v32; // rcx
  unsigned int v33; // r11d
  __int64 v34; // r10
  unsigned __int64 v35; // r10
  int v36; // r8d
  unsigned __int64 v37; // rcx
  __int64 v38; // r14
  int v39; // [rsp+Ch] [rbp-9Ch]
  unsigned __int64 v40; // [rsp+10h] [rbp-98h]
  unsigned int *v41; // [rsp+18h] [rbp-90h]
  __int64 v42; // [rsp+20h] [rbp-88h]
  unsigned int v43; // [rsp+28h] [rbp-80h]
  unsigned __int64 *v45; // [rsp+30h] [rbp-78h]
  __int64 *v46; // [rsp+40h] [rbp-68h]
  __int128 v47; // [rsp+58h] [rbp-50h]
  __int128 v48; // [rsp+68h] [rbp-40h]

  v6 = *a5;
  v7 = *((_DWORD *)a5 + 2);
  v8 = *((_DWORD *)a5 + 3);
  v9 = *((_DWORD *)a5 + 4);
  v10 = *((_DWORD *)a5 + 5);
  v11 = a3[2];
  v40 = a3[1];
  if ( v40 - v11 >= 0x103 )
  {
    v39 = *((_DWORD *)a5 + 5);
    v13 = *a2;
    v14 = (unsigned int *)a2[1];
    v42 = *a3;
    v15 = xmmword_4B2F0;
    v16 = xmmword_4B300;
    v17 = xmmword_4B310;
    v18 = xmmword_4B320;
    v41 = v14;
    while ( 1 )
    {
      if ( (unsigned __int64)((char *)v14 - v13) < 0xE )
      {
        result = 0;
        goto LABEL_51;
      }
      while ( 1 )
      {
        if ( v7 <= 0x1D )
        {
          v19 = (unsigned __int64)*(unsigned int *)v13 << v7;
          v13 += 4;
          *a2 = v13;
          v6 |= v19;
          v7 |= 0x20u;
        }
        v20 = *(__int16 *)(a1 + 2 * (v6 & 0x3FF));
        if ( v20 < 0 )
        {
          v21 = 10LL;
          v9 = *(__int16 *)(a1 + 2 * (v6 & 0x3FF));
          do
          {
            v22 = _bittest64((const __int64 *)&v6, v21) + ~v9;
            if ( v22 > 0x23F )
              break;
            v9 = *(__int16 *)(a1 + 2LL * v22 + 2048);
            v21 = (unsigned int)(v21 + 1);
          }
          while ( v9 < 0 );
        }
        else
        {
          if ( (unsigned __int16)v20 < 0x200u )
            goto LABEL_50;
          LODWORD(v21) = (unsigned int)v20 >> 9;
          v9 = *(__int16 *)(a1 + 2 * (v6 & 0x3FF));
        }
        v6 >>= v21;
        v7 -= v21;
        if ( (v9 & 0x100) != 0 )
          goto LABEL_27;
        v23 = *(__int16 *)(a1 + 2 * (v6 & 0x3FF));
        if ( v23 < 0 )
        {
          v24 = 10LL;
          do
          {
            v25 = _bittest64((const __int64 *)&v6, v24) + ~v23;
            if ( v25 > 0x23F )
              break;
            v23 = *(__int16 *)(a1 + 2LL * v25 + 2048);
            v24 = (unsigned int)(v24 + 1);
          }
          while ( v23 < 0 );
        }
        else
        {
          if ( (unsigned __int16)v23 < 0x200u )
          {
LABEL_50:
            result = -1;
            goto LABEL_51;
          }
          LODWORD(v24) = (unsigned int)v23 >> 9;
        }
        v6 >>= v24;
        if ( v11 >= v40 )
          core::panicking::panic_bounds_check(v11, v40, (__int64)&off_5A058);
        v7 -= v24;
        *(_BYTE *)(v42 + v11) = v9;
        a3[2] = v11 + 1;
        if ( (v23 & 0x100) != 0 )
          break;
        if ( v11 + 1 >= v40 )
          core::panicking::panic_bounds_check(v11 + 1, v40, (__int64)&off_5A058);
        *(_BYTE *)(v42 + v11 + 1) = v23;
        v11 += 2LL;
        a3[2] = v11;
        result = 0;
        if ( v40 - v11 < 0x103 || (unsigned __int64)((char *)v41 - v13) < 0xE )
          goto LABEL_51;
      }
      ++v11;
      LOWORD(v9) = v23;
LABEL_27:
      v26 = v9 & 0x1FF;
      if ( v26 == 256 )
      {
        v9 = 256;
        result = 0;
        goto LABEL_51;
      }
      result = -1;
      if ( v26 > 0x11D )
      {
        v9 &= 0x1FFu;
        goto LABEL_51;
      }
      v48 = v15;
      v47 = v16;
      v27 = ((_BYTE)v9 - 1) & 0x1F;
      v39 = *((unsigned __int8 *)&v47 + v27);
      v9 = word_4C4DE[v27];
      if ( v7 > 0x1D )
        goto LABEL_32;
      v28 = (char *)v41 - v13;
      if ( (unsigned __int64)((char *)v41 - v13) <= 3 )
LABEL_60:
        core::slice::index::slice_end_index_len_fail(4LL, v28, (__int64)&off_59D60);
      v29 = (unsigned __int64)*(unsigned int *)v13 << v7;
      v13 += 4;
      *a2 = v13;
      v6 |= v29;
      v7 |= 0x20u;
LABEL_32:
      if ( v39 )
      {
        v30 = v6 & ~(unsigned int)(-1LL << v39);
        v6 >>= v39;
        v7 -= v39;
        v9 += v30;
      }
      v31 = *(__int16 *)(a1 + 2 * (v6 & 0x3FF) + 3488);
      if ( v31 >= 0 )
        break;
      v32 = 10LL;
      do
      {
        v33 = _bittest64((const __int64 *)&v6, v32) + ~v31;
        if ( v33 > 0x23F )
          break;
        v31 = *(__int16 *)(a1 + 2LL * v33 + 5536);
        v32 = (unsigned int)(v32 + 1);
      }
      while ( v31 < 0 );
LABEL_40:
      v6 >>= v32;
      v34 = v31 & 0x1FF;
      v7 -= v32;
      if ( (unsigned int)v34 > 0x1D )
        goto LABEL_51;
      v48 = v17;
      v47 = v18;
      v8 = word_4C51E[v34];
      v39 = *((unsigned __int8 *)&v47 + v34);
      v45 = a5;
      if ( *((_BYTE *)&v47 + v34) )
      {
        if ( v7 < 0x1E )
        {
          v28 = (char *)v41 - v13;
          if ( (unsigned __int64)((char *)v41 - v13) <= 3 )
            goto LABEL_60;
          v35 = (unsigned __int64)*(unsigned int *)v13 << v7;
          v13 += 4;
          *a2 = v13;
          v6 |= v35;
          v7 |= 0x20u;
        }
        v36 = v6 & ~(unsigned int)(-1LL << v39);
        v6 >>= v39;
        v7 -= v39;
        v8 += v36;
      }
      v37 = v8;
      if ( (a4 & 4) != 0 && v11 < v8 )
      {
        a5 = v45;
        goto LABEL_51;
      }
      v46 = a3;
      v43 = v8;
      v38 = a6;
      miniz_oxide::inflate::core::apply_match(v42, v40, v11, v37, (unsigned int)v9, a6);
      v18 = xmmword_4B320;
      v17 = xmmword_4B310;
      v16 = xmmword_4B300;
      v15 = xmmword_4B2F0;
      a3 = v46;
      a6 = v38;
      v8 = v43;
      v11 += (unsigned int)v9;
      v46[2] = v11;
      result = 0;
      a5 = v45;
      v14 = v41;
      if ( v40 - v11 <= 0x102 )
        goto LABEL_51;
    }
    if ( (unsigned __int16)v31 >= 0x200u )
    {
      LODWORD(v32) = (unsigned int)v31 >> 9;
      goto LABEL_40;
    }
LABEL_51:
    v10 = v39;
  }
  else
  {
    result = 0;
  }
  *a5 = v6;
  *((_DWORD *)a5 + 2) = v7;
  *((_DWORD *)a5 + 3) = v8;
  *((_DWORD *)a5 + 4) = v9;
  *((_DWORD *)a5 + 5) = v10;
  return result;
}
// 4B2F0: using guessed type __int128 xmmword_4B2F0;
// 4B300: using guessed type __int128 xmmword_4B300;
// 4B310: using guessed type __int128 xmmword_4B310;
// 4B320: using guessed type __int128 xmmword_4B320;
// 4C4DE: using guessed type unsigned __int16 word_4C4DE[32];
// 4C51E: using guessed type unsigned __int16 word_4C51E[32];
// 59D60: using guessed type char *off_59D60;
// 5A058: using guessed type char *off_5A058;

//----- (000000000003EF70) ----------------------------------------------------
__int64 __fastcall miniz_oxide::inflate::core::decompress(
        __int64 a1,
        __int64 a2,
        size_t a3,
        unsigned __int64 a4,
        __int64 a5,
        unsigned __int64 a6,
        unsigned __int64 a7,
        int a8)
{
  unsigned __int64 v8; // rbp
  __int64 v9; // r12
  char v10; // r14
  unsigned __int64 v11; // r13
  unsigned __int64 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // r15
  __int64 v15; // rax
  int v16; // ecx
  int v17; // esi
  int v18; // ecx
  char v19; // al
  void *v20; // rdi
  unsigned __int64 v21; // rsi
  unsigned __int8 *v22; // r9
  int v23; // ecx
  void *v24; // rdi
  unsigned __int64 v25; // rsi
  unsigned __int8 *v26; // r9
  int v27; // ecx
  int v28; // esi
  void *v29; // rdi
  unsigned __int64 v30; // rdx
  unsigned __int8 *v31; // r9
  int v32; // ecx
  unsigned __int8 *v33; // r9
  unsigned __int64 v34; // rdi
  unsigned __int64 v35; // rcx
  unsigned int v36; // eax
  unsigned __int64 v37; // rsi
  int v38; // r8d
  unsigned __int8 *v39; // rbx
  __int64 v40; // r14
  char v41; // al
  int v42; // edi
  int v43; // ecx
  unsigned __int64 v44; // rax
  unsigned __int64 v45; // rdx
  unsigned __int8 *v46; // rax
  int v47; // eax
  unsigned int v48; // ecx
  char v49; // al
  unsigned int v50; // ecx
  unsigned int v51; // eax
  char *v52; // rdx
  unsigned __int64 v53; // rsi
  int v54; // edi
  unsigned __int8 *v55; // r14
  int v56; // ecx
  unsigned __int64 v57; // rax
  unsigned __int64 v58; // rdx
  unsigned int v59; // eax
  char *v60; // rax
  void *v61; // rax
  _OWORD *v62; // rcx
  _OWORD *v63; // rax
  char inited; // al
  char *v65; // rbx
  char *v66; // r13
  unsigned __int64 v67; // r15
  size_t v68; // r14
  int v69; // r12d
  unsigned __int64 v70; // rbp
  unsigned __int8 *v71; // rax
  int v72; // ecx
  unsigned __int64 v73; // rax
  unsigned __int8 *v74; // rdx
  char v75; // cl
  char *v76; // rdi
  __int64 v77; // rsi
  char v78; // al
  unsigned __int64 v79; // rdi
  unsigned int v80; // ecx
  __int64 v81; // rsi
  __int64 v82; // rdx
  unsigned __int8 *v83; // rdi
  unsigned __int64 v84; // rax
  __int64 v85; // r8
  char v86; // al
  unsigned int v87; // ecx
  __int64 v88; // rax
  bool v89; // dl
  unsigned __int64 v90; // rsi
  unsigned __int64 v91; // rdi
  bool v92; // zf
  unsigned __int8 *v93; // r14
  __int64 v94; // rbx
  int v95; // edi
  unsigned int v96; // eax
  unsigned int v97; // esi
  unsigned __int64 v98; // r9
  int v99; // r8d
  size_t v100; // rdx
  __int64 v101; // rsi
  __int64 v102; // rax
  __int64 v103; // rax
  char v104; // al
  int v105; // r8d
  unsigned __int64 v106; // rcx
  unsigned int v107; // eax
  unsigned __int8 *v108; // r8
  unsigned __int64 v109; // rdi
  int v110; // eax
  __int64 v111; // r8
  unsigned int v112; // ecx
  int v113; // r8d
  __int64 v114; // rax
  __int64 v115; // rsi
  unsigned __int8 *v116; // rdx
  __int64 v117; // rdi
  unsigned __int64 v118; // r9
  unsigned int v119; // r8d
  unsigned int v120; // eax
  unsigned __int8 *v121; // r10
  int v122; // ecx
  unsigned __int64 v123; // rbx
  unsigned __int64 v124; // rdx
  bool v125; // cf
  unsigned __int64 v126; // rdx
  __int64 v127; // rbp
  unsigned __int64 v128; // r14
  unsigned __int64 v129; // rbx
  __int64 v130; // r15
  unsigned int v131; // r12d
  unsigned __int64 v132; // r13
  unsigned int v133; // edi
  unsigned __int8 *v134; // rax
  int v135; // r9d
  unsigned __int64 v136; // rsi
  int v137; // ecx
  int v138; // r8d
  unsigned int v139; // ecx
  int v140; // r8d
  __int64 v141; // r8
  unsigned __int64 v142; // rax
  __int64 v143; // r10
  int v144; // r10d
  unsigned __int64 v145; // rcx
  unsigned int v146; // r11d
  unsigned __int64 v147; // rax
  int v148; // ebx
  int v149; // r11d
  unsigned __int64 v150; // rcx
  unsigned int v151; // ebp
  __int64 v152; // rcx
  __int64 v153; // rbp
  int v154; // r14d
  unsigned __int64 v155; // rdi
  unsigned __int8 v156; // cl
  size_t v157; // rbp
  __int64 v158; // r8
  unsigned __int64 v159; // r9
  int v160; // r9d
  unsigned int v161; // ecx
  int v162; // r9d
  __int64 v163; // r13
  unsigned __int64 v164; // rbx
  unsigned int v165; // eax
  unsigned __int8 *v166; // r9
  unsigned int v167; // ecx
  int v168; // ecx
  __int64 v169; // rdi
  unsigned int v170; // ecx
  int v171; // edi
  int v172; // ecx
  int v173; // r8d
  unsigned __int64 v174; // r8
  int v175; // r8d
  unsigned int v176; // ecx
  int v177; // r8d
  char v178; // al
  int v179; // ecx
  unsigned int v180; // ecx
  int v181; // r8d
  unsigned __int64 v182; // rcx
  unsigned int v183; // r8d
  unsigned int v184; // eax
  unsigned __int8 *v185; // r11
  unsigned int v186; // ecx
  __int64 v187; // r8
  int v188; // ecx
  int v189; // r9d
  unsigned __int64 v190; // rdx
  int v191; // ecx
  int v192; // r10d
  int v193; // edi
  unsigned __int64 v194; // rcx
  unsigned int v195; // edx
  __int64 v196; // rdi
  int v197; // r11d
  __int64 v198; // rdx
  unsigned __int16 v199; // ax
  __int16 v200; // si
  int v201; // ecx
  bool v202; // cl
  char v203; // di
  __int64 v204; // rbx
  unsigned int v205; // esi
  int v206; // ecx
  __int64 v207; // rax
  unsigned __int64 v208; // r15
  __int64 v209; // r14
  int v210; // eax
  char *v211; // rbp
  __int128 v213[2]; // [rsp+0h] [rbp-118h] BYREF
  void *src; // [rsp+20h] [rbp-F8h] BYREF
  size_t v215; // [rsp+28h] [rbp-F0h]
  int v216; // [rsp+30h] [rbp-E8h]
  int v217; // [rsp+34h] [rbp-E4h]
  __int64 v218; // [rsp+38h] [rbp-E0h]
  char v219; // [rsp+47h] [rbp-D1h]
  __int64 v220; // [rsp+48h] [rbp-D0h] BYREF
  unsigned __int64 v221; // [rsp+50h] [rbp-C8h]
  unsigned __int64 v222; // [rsp+58h] [rbp-C0h]
  unsigned __int64 v223; // [rsp+60h] [rbp-B8h]
  __int64 v224; // [rsp+68h] [rbp-B0h]
  __int128 v225; // [rsp+70h] [rbp-A8h] BYREF
  __int128 v226; // [rsp+80h] [rbp-98h]
  void *v227; // [rsp+90h] [rbp-88h]
  __int64 v228; // [rsp+98h] [rbp-80h]
  int v229; // [rsp+A4h] [rbp-74h]
  void *v230; // [rsp+A8h] [rbp-70h]
  void *dest; // [rsp+B0h] [rbp-68h]
  unsigned __int64 v232; // [rsp+B8h] [rbp-60h]
  size_t v233; // [rsp+C0h] [rbp-58h]
  size_t v234; // [rsp+C8h] [rbp-50h]
  void *s; // [rsp+D0h] [rbp-48h]
  __int64 v236; // [rsp+D8h] [rbp-40h]
  _OWORD *v237; // [rsp+E0h] [rbp-38h]

  v8 = a4;
  v9 = a1;
  v10 = a8;
  v11 = a7;
  v12 = a6 - 1;
  if ( !a6 )
    v12 = 0LL;
  if ( a7 > a6 || (v13 = v12 | -(__int64)((a8 & 4) != 0), (v13 & (v13 + 1)) != 0) )
  {
    *(_BYTE *)(a1 + 8) = -3;
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 16) = 0LL;
    return v9;
  }
  v14 = a2;
  v232 = v13 + 1;
  v234 = a3;
  src = (void *)a3;
  v233 = a3 + a4;
  v215 = a3 + a4;
  LOBYTE(a3) = *((_BYTE *)&stru_2AE8.r_offset + a2 + 1);
  v220 = a5;
  v221 = a6;
  v222 = a7;
  v15 = *(_QWORD *)(a2 + 10464);
  v16 = *(_DWORD *)(a2 + 10472);
  v17 = *(_DWORD *)(a2 + 10508);
  *(_QWORD *)&v213[0] = v15;
  DWORD2(v213[0]) = v16;
  *(_QWORD *)((char *)v213 + 12) = *(_QWORD *)(v14 + 10500);
  v18 = 1;
  if ( (a8 & 2) == 0 )
    v18 = 252;
  v217 = v18;
  DWORD1(v213[1]) = v17;
  v227 = (void *)(v14 + 10528);
  dest = (void *)(v14 + 3200);
  v230 = (void *)(v14 + 6688);
  s = (void *)(v14 + 10176);
  v237 = (_OWORD *)(v14 + 3344);
  v236 = v14 + 3456;
  v219 = (2 * ((a8 & 1) == 0)) | 1;
  v223 = v8;
  v224 = v14;
  v229 = a8;
  v218 = v13;
LABEL_8:
  while ( 2 )
  {
    v19 = a3;
    switch ( (char)a3 )
    {
      case 0:
        memset(v213, 0, 24);
        *(_QWORD *)(v14 + 10476) = 0LL;
        *(_DWORD *)(v14 + 10484) = 1;
        *(_DWORD *)(v14 + 10496) = 1;
        LOBYTE(a3) = v219;
        continue;
      case 1:
        v71 = (unsigned __int8 *)src;
        if ( src != (void *)v215 )
        {
          src = (char *)src + 1;
          *(_DWORD *)(v14 + 10476) = *v71;
          LOBYTE(a3) = 2;
          continue;
        }
        v203 = -4;
        LOBYTE(a3) = 1;
        v204 = 0LL;
        if ( (v10 & 2) == 0 )
          goto LABEL_435;
        goto LABEL_434;
      case 2:
        v46 = (unsigned __int8 *)src;
        if ( src != (void *)v215 )
        {
          src = (char *)src + 1;
          v47 = *v46;
          v48 = *(_DWORD *)(v14 + 10476);
          *(_DWORD *)(v14 + 10480) = v47;
          v49 = (((v47 | (v48 << 8)) % 0x1F) | v47 & 0x20 | v48 & 0xF ^ 8) != 0;
          v50 = ((unsigned __int8)(v48 >> 4) + 8) & 0x3F;
          if ( (v10 & 4) == 0 )
            v49 |= v232 >> v50 == 0;
          LOBYTE(a3) = 3;
          if ( v49 )
            LOBYTE(a3) = 29;
          if ( v50 >= 0x10 )
            LOBYTE(a3) = 29;
          continue;
        }
        v203 = -4;
        LOBYTE(a3) = 2;
        v204 = 0LL;
        if ( (v10 & 2) == 0 )
          goto LABEL_435;
        goto LABEL_434;
      case 3:
        v39 = (unsigned __int8 *)src;
        v55 = (unsigned __int8 *)v215;
        while ( 1 )
        {
          v56 = DWORD2(v213[0]);
          v57 = *(_QWORD *)&v213[0];
          if ( DWORD2(v213[0]) <= 2uLL )
          {
            if ( v39 == v55 )
            {
              v204 = 0LL;
              src = v55;
              v203 = -4;
              LOBYTE(a3) = 3;
              v10 = a8;
              if ( (a8 & 2) == 0 )
                goto LABEL_435;
              goto LABEL_434;
            }
            v58 = (unsigned __int64)*v39++ << SBYTE8(v213[0]);
            v57 = v58 | *(_QWORD *)&v213[0];
            v56 = DWORD2(v213[0]) | 8;
          }
          *(_QWORD *)&v213[0] = v57 >> 3;
          DWORD2(v213[0]) = v56 - 3;
          *(_DWORD *)(v14 + 10488) = v57 & 1;
          v59 = ((unsigned int)v57 >> 1) & 3;
          *(_DWORD *)(v14 + 10492) = v59;
          if ( v59 != 1 )
          {
            if ( !v59 )
            {
              LOBYTE(a3) = 4;
              goto LABEL_267;
            }
            v10 = a8;
            if ( v59 == 2 )
            {
              LODWORD(v213[1]) = 0;
              LOBYTE(a3) = 8;
            }
            else
            {
              LOBYTE(a3) = 25;
            }
            src = v39;
            v13 = v218;
            goto LABEL_8;
          }
          *(_QWORD *)(v14 + 10512) = 0x2000000120LL;
          v60 = (char *)dest;
          *((_OWORD *)dest + 8) = xmmword_4B330;
          memset(v60 + 96, 8, 32);
          memset(v60 + 64, 8, 32);
          memset(v60 + 32, 8, 32);
          memset(v60, 8, 32);
          v61 = v237;
          v237[6] = xmmword_4B340;
          memset(v61, 9, 96);
          v62 = (_OWORD *)v236;
          *(_QWORD *)(v236 + 16) = 0x707070707070707LL;
          *v62 = xmmword_4B350;
          *(_QWORD *)(v14 + 3480) = 0x808080808080808LL;
          v63 = v230;
          *((_OWORD *)v230 + 1) = xmmword_4B360;
          *v63 = xmmword_4B360;
          inited = miniz_oxide::inflate::core::init_tree(v14, (__int64)v213);
          if ( inited )
          {
            if ( inited != 1 )
            {
              v10 = a8;
              if ( inited == 2 )
                v203 = a3;
              else
                v203 = -1;
              src = v39;
              LOBYTE(a3) = 3;
              goto LABEL_417;
            }
LABEL_267:
            src = v39;
LABEL_268:
            v10 = a8;
            v13 = v218;
            goto LABEL_8;
          }
        }
      case 4:
        *(_QWORD *)&v213[0] >>= BYTE8(v213[0]) & 7;
        DWORD2(v213[0]) &= 0xFFFFFFF8;
        LODWORD(v213[1]) = 0;
        LOBYTE(a3) = 5;
        continue;
      case 5:
        v80 = DWORD2(v213[0]);
        v81 = LODWORD(v213[1]);
        if ( LODWORD(v213[1]) > 3uLL )
          goto LABEL_393;
        v82 = v215;
        v83 = (unsigned __int8 *)src;
        v84 = *(_QWORD *)&v213[0];
        if ( DWORD2(v213[0]) )
        {
          if ( DWORD2(v213[0]) <= 7 )
          {
            if ( src == (void *)v215 )
              goto LABEL_454;
            src = (char *)src + 1;
            v84 = ((unsigned __int64)*v83 << SBYTE8(v213[0])) | *(_QWORD *)&v213[0];
            v80 = DWORD2(v213[0]) | 8;
            ++v83;
          }
          *(_BYTE *)(v14 + LODWORD(v213[1]) + 10524) = v84;
          v84 >>= 8;
          *(_QWORD *)&v213[0] = v84;
          v80 -= 8;
          DWORD2(v213[0]) = v80;
          v85 = v81 + 1;
          LODWORD(v213[1]) = v81 + 1;
          if ( (_DWORD)v81 == 3 )
            goto LABEL_393;
        }
        else
        {
          if ( src == (void *)v215 )
            goto LABEL_454;
          src = (char *)src + 1;
          *(_BYTE *)(v14 + LODWORD(v213[1]) + 10524) = *v83;
          v80 = 0;
          ++v83;
          v85 = v81 + 1;
          LODWORD(v213[1]) = v81 + 1;
          if ( (_DWORD)v81 == 3 )
            goto LABEL_393;
        }
        if ( v80 )
        {
          if ( v80 <= 7 )
          {
            if ( v83 == (unsigned __int8 *)v82 )
              goto LABEL_454;
            src = v83 + 1;
            v84 |= (unsigned __int64)*v83 << v80;
            v80 |= 8u;
            ++v83;
          }
          *(_BYTE *)(v14 + v85 + 10524) = v84;
          v84 >>= 8;
          *(_QWORD *)&v213[0] = v84;
          v80 -= 8;
          DWORD2(v213[0]) = v80;
          v158 = v81 + 2;
          LODWORD(v213[1]) = v81 + 2;
          if ( (unsigned int)v81 > 1 )
            goto LABEL_393;
        }
        else
        {
          if ( v83 == (unsigned __int8 *)v82 )
            goto LABEL_454;
          src = v83 + 1;
          *(_BYTE *)(v14 + v85 + 10524) = *v83;
          v80 = 0;
          ++v83;
          v158 = v81 + 2;
          LODWORD(v213[1]) = v81 + 2;
          if ( (unsigned int)v81 > 1 )
            goto LABEL_393;
        }
        if ( v80 )
        {
          if ( v80 > 7 )
          {
LABEL_298:
            *(_BYTE *)(v14 + v158 + 10524) = v84;
            v84 >>= 8;
            *(_QWORD *)&v213[0] = v84;
            v80 -= 8;
            DWORD2(v213[0]) = v80;
            goto LABEL_343;
          }
          if ( v83 != (unsigned __int8 *)v82 )
          {
            src = v83 + 1;
            v84 |= (unsigned __int64)*v83 << v80;
            v80 |= 8u;
            ++v83;
            goto LABEL_298;
          }
        }
        else if ( v83 != (unsigned __int8 *)v82 )
        {
          src = v83 + 1;
          *(_BYTE *)(v14 + v158 + 10524) = *v83;
          v80 = 0;
          ++v83;
LABEL_343:
          v187 = v81 + 3;
          LODWORD(v213[1]) = v81 + 3;
          if ( !v81 )
          {
            if ( v80 )
            {
              if ( v80 > 7 )
              {
LABEL_348:
                *(_QWORD *)&v213[0] = v84 >> 8;
                v80 -= 8;
                DWORD2(v213[0]) = v80;
                *(_BYTE *)(v14 + v187 + 10524) = v84;
LABEL_392:
                LODWORD(v213[1]) = 4;
                goto LABEL_393;
              }
              if ( v83 != (unsigned __int8 *)v82 )
              {
                src = v83 + 1;
                v84 |= (unsigned __int64)*v83 << v80;
                v80 |= 8u;
                goto LABEL_348;
              }
            }
            else if ( v83 != (unsigned __int8 *)v82 )
            {
              src = v83 + 1;
              *(_BYTE *)(v14 + v187 + 10524) = *v83;
              v80 = 0;
              goto LABEL_392;
            }
            goto LABEL_454;
          }
LABEL_393:
          v199 = *(_WORD *)(v14 + 10524);
          v200 = v199 ^ *(_WORD *)(v14 + 10526);
          LODWORD(v213[1]) = v199;
          LOBYTE(a3) = 31;
          if ( v200 == -1 )
          {
            LOBYTE(a3) = 20;
            if ( v199 )
            {
              LOBYTE(a3) = 17;
              if ( !v80 )
                LOBYTE(a3) = 6;
            }
          }
          continue;
        }
LABEL_454:
        LOBYTE(a3) = 5;
        goto LABEL_455;
      case 6:
        LOBYTE(a3) = 20;
        if ( LODWORD(v213[1]) )
        {
          LOBYTE(a3) = 7;
          if ( v221 == v222 )
            goto LABEL_424;
        }
        continue;
      case 7:
        v65 = (char *)src;
        v66 = (char *)v215;
        v67 = v215 - (_QWORD)src;
        if ( (void *)v215 != src )
        {
          v228 = v9;
          v68 = v221 - v222;
          if ( v221 - v222 >= v67 )
            v68 = v215 - (_QWORD)src;
          v69 = v213[1];
          if ( v68 >= LODWORD(v213[1]) )
            v68 = LODWORD(v213[1]);
          v70 = v222 + v68;
          if ( __CFADD__(v222, v68) )
            core::slice::index::slice_index_order_fail(v222, v222 + v68, (__int64)&off_5A070);
          if ( v70 > v221 )
            core::slice::index::slice_end_index_len_fail(v222 + v68, v221, (__int64)&off_5A070);
          memcpy((void *)(v220 + v222), src, v68);
          v222 = v70;
          if ( v67 > v68 - 1 )
            v66 = &v65[v68];
          src = v66;
          LODWORD(v213[1]) = v69 - v68;
          LOBYTE(a3) = 6;
          goto LABEL_190;
        }
        v203 = -4;
        LOBYTE(a3) = 7;
        v204 = 0LL;
        v11 = a7;
        v14 = v224;
        if ( (v10 & 2) == 0 )
          goto LABEL_435;
        goto LABEL_434;
      case 8:
        v115 = LODWORD(v213[1]);
        if ( LODWORD(v213[1]) > 2uLL )
          goto LABEL_385;
        v116 = (unsigned __int8 *)src;
        v117 = v215;
        v118 = *(_QWORD *)&v213[0];
        v119 = DWORD2(v213[0]);
        *(_QWORD *)&v225 = 0x500000005LL;
        DWORD2(v225) = 4;
        v120 = *((_DWORD *)&v225 + LODWORD(v213[1]));
        if ( DWORD2(v213[0]) >= v120 )
          goto LABEL_273;
        v121 = (unsigned __int8 *)src;
        v122 = DWORD2(v213[0]);
        if ( src == (void *)v215 )
          goto LABEL_458;
        while ( 1 )
        {
          v118 |= (unsigned __int64)*v121++ << v122;
          if ( v122 + 8 >= v120 )
            break;
          v122 += 8;
          if ( v121 == (unsigned __int8 *)v215 )
          {
LABEL_425:
            src = v116;
            *(_QWORD *)&v213[0] = v118;
            DWORD2(v213[0]) = v119 + 8 * v117 - 8 * (_DWORD)v116;
            goto LABEL_426;
          }
        }
        v116 = v121;
        v119 = v122 + 8;
LABEL_273:
        v164 = v118 >> v120;
        *(_QWORD *)&v213[0] = v118 >> v120;
        v119 -= v120;
        DWORD2(v213[0]) = v119;
        *(_DWORD *)(v14 + 4LL * LODWORD(v213[1]) + 10512) = (~(unsigned int)(-1LL << v120) & v118)
                                                          + word_4C55E[LODWORD(v213[1])];
        LODWORD(v213[1]) = v115 + 1;
        if ( (_DWORD)v115 == 2 )
        {
          v13 = v218;
          goto LABEL_384;
        }
        *(_QWORD *)&v225 = 0x500000005LL;
        DWORD2(v225) = 4;
        v165 = *((_DWORD *)&v225 + v115 + 1);
        if ( v119 >= v165 )
          goto LABEL_333;
        if ( v116 == (unsigned __int8 *)v117 )
          goto LABEL_458;
        v166 = v116;
        v167 = v119;
        while ( 1 )
        {
          v164 |= (unsigned __int64)*v166++ << v167;
          if ( v167 + 8 >= v165 )
            break;
          v167 += 8;
          if ( v166 == (unsigned __int8 *)v117 )
          {
            v118 = v164;
            v8 = v223;
            v10 = a8;
            goto LABEL_425;
          }
        }
        v116 = v166;
        v119 = v167 + 8;
        v8 = v223;
LABEL_333:
        v118 = v164 >> v165;
        *(_QWORD *)&v213[0] = v164 >> v165;
        v119 -= v165;
        DWORD2(v213[0]) = v119;
        *(_DWORD *)(v14 + 4 * v115 + 10516) = (~(-1 << v165) & v164) + word_4C55E[v115 + 1];
        LODWORD(v213[1]) = v115 + 2;
        if ( (_DWORD)v115 == 1 )
        {
          v10 = a8;
          v13 = v218;
          goto LABEL_384;
        }
        *(_QWORD *)&v225 = 0x500000005LL;
        DWORD2(v225) = 4;
        v184 = *((_DWORD *)&v225 + v115 + 2);
        v10 = a8;
        v13 = v218;
        if ( v119 >= v184 )
          goto LABEL_383;
        if ( v116 != (unsigned __int8 *)v117 )
        {
          v185 = v116;
          v186 = v119;
          while ( 1 )
          {
            v118 |= (unsigned __int64)*v185++ << v186;
            if ( v186 + 8 >= v184 )
              break;
            v186 += 8;
            if ( v185 == (unsigned __int8 *)v117 )
              goto LABEL_425;
          }
          v116 = v185;
          v119 = v186 + 8;
          v13 = v218;
LABEL_383:
          *(_QWORD *)&v213[0] = v118 >> v184;
          DWORD2(v213[0]) = v119 - v184;
          *(_DWORD *)(v14 + 4 * v115 + 10520) = (~(-1 << v184) & v118) + word_4C55E[v115 + 2];
          LODWORD(v213[1]) = v115 + 3;
LABEL_384:
          src = v116;
LABEL_385:
          memset(s, 0, 0x120uLL);
          LODWORD(v213[1]) = 0;
          LOBYTE(a3) = 9;
          if ( *(_DWORD *)(v14 + 10516) >= 0x1Fu )
            LOBYTE(a3) = 27;
          if ( *(_DWORD *)(v14 + 10512) >= 0x11Fu )
            LOBYTE(a3) = 27;
          continue;
        }
LABEL_458:
        src = v116;
LABEL_426:
        v204 = 0LL;
        src = (void *)v117;
        v203 = -4;
        LOBYTE(a3) = 8;
        if ( (v10 & 2) == 0 )
          goto LABEL_435;
        goto LABEL_434;
      case 9:
        v39 = (unsigned __int8 *)src;
        v40 = v215;
        while ( 2 )
        {
          v42 = v213[1];
          if ( LODWORD(v213[1]) >= *(_DWORD *)(v14 + 10520) )
          {
            *(_DWORD *)(v14 + 10520) = 19;
            v41 = miniz_oxide::inflate::core::init_tree(v14, (__int64)v213);
            if ( v41 != 3 )
            {
              if ( v41 )
                goto LABEL_46;
              continue;
            }
            src = v39;
            v203 = -1;
            v19 = 9;
LABEL_414:
            v202 = 0;
            v10 = a8;
          }
          else
          {
            v43 = DWORD2(v213[0]);
            v44 = *(_QWORD *)&v213[0];
            if ( DWORD2(v213[0]) > 2uLL )
            {
LABEL_43:
              *(_QWORD *)&v213[0] = v44 >> 3;
              DWORD2(v213[0]) = v43 - 3;
              if ( LODWORD(v213[1]) >= 0x13 )
                core::panicking::panic_bounds_check(LODWORD(v213[1]), 19LL, (__int64)&off_5A118);
              *(_BYTE *)(v14 + byte_4C564[LODWORD(v213[1])] + 10176) = v44 & 7;
              LODWORD(v213[1]) = v42 + 1;
              continue;
            }
            if ( v39 != (unsigned __int8 *)v40 )
            {
              v45 = (unsigned __int64)*v39++ << SBYTE8(v213[0]);
              v44 = v45 | *(_QWORD *)&v213[0];
              v43 = DWORD2(v213[0]) | 8;
              goto LABEL_43;
            }
            v41 = 2;
            v39 = (unsigned __int8 *)v40;
            LOBYTE(a3) = v217;
LABEL_46:
            if ( v41 == 1 )
              goto LABEL_267;
            src = v39;
            v203 = a3;
            LOBYTE(a3) = 9;
            v10 = a8;
LABEL_417:
            v202 = v203 == 1;
            if ( v203 == 1 || (unsigned __int8)v203 == 252 )
            {
              v204 = 0LL;
              if ( v203 != 1 )
                goto LABEL_435;
              goto LABEL_434;
            }
            v19 = a3;
          }
          break;
        }
LABEL_431:
        v205 = (_DWORD)src + v8 - v215;
        v204 = DWORD2(v213[0]) >> 3;
        if ( (unsigned int)v204 >= v205 )
          v204 = v205;
        DWORD2(v213[0]) -= 8 * v204;
        LOBYTE(a3) = v19;
        if ( !v202 )
          goto LABEL_435;
        goto LABEL_434;
      case 10:
        v93 = (unsigned __int8 *)src;
        v94 = v215;
        while ( 1 )
        {
          v95 = v213[1];
          a3 = *(unsigned int *)(v14 + 10512);
          v96 = a3 + *(_DWORD *)(v14 + 10516);
          if ( LODWORD(v213[1]) >= v96 )
          {
            if ( LODWORD(v213[1]) != v96 )
            {
              src = v93;
              LOBYTE(a3) = 26;
              goto LABEL_268;
            }
            if ( (unsigned int)a3 >= 0x121 )
              core::slice::index::slice_end_index_len_fail(*(unsigned int *)(v14 + 10512), 288LL, (__int64)&off_5A088);
            memcpy(dest, v227, a3);
            v100 = *(unsigned int *)(v14 + 10516);
            if ( v100 >= 0x121 )
              core::slice::index::slice_end_index_len_fail(*(unsigned int *)(v14 + 10516), 288LL, (__int64)&off_5A0A0);
            v101 = *(unsigned int *)(v14 + 10512);
            v102 = (unsigned int)(v100 + v101);
            if ( (unsigned int)v101 > (unsigned int)v102 )
              core::slice::index::slice_index_order_fail(*(unsigned int *)(v14 + 10512), v102, (__int64)&off_5A0B8);
            if ( (unsigned int)v102 > 0x1C9 )
              core::slice::index::slice_end_index_len_fail(v102, 457LL, (__int64)&off_5A0B8);
            v103 = v102 - v101;
            if ( v103 != v100 )
              core::slice::<impl [T]>::copy_from_slice::len_mismatch_fail(
                *(unsigned int *)(v14 + 10516),
                v103,
                (__int64)&off_5A0D0);
            memcpy(v230, (char *)v227 + v101, v100);
            --*(_DWORD *)(v14 + 10492);
            v104 = miniz_oxide::inflate::core::init_tree(v14, (__int64)v213);
            if ( v104 == 3 )
            {
              src = v93;
              v203 = -1;
              v19 = 10;
              goto LABEL_414;
            }
            goto LABEL_118;
          }
          v97 = DWORD2(v213[0]);
          if ( DWORD2(v213[0]) >= 0xFuLL )
          {
            v98 = *(_QWORD *)&v213[0];
            goto LABEL_137;
          }
          if ( (unsigned __int64)(v94 - (_QWORD)v93) > 1 )
          {
            v98 = *(_QWORD *)&v213[0] | ((unsigned __int64)*(unsigned __int16 *)v93 << SBYTE8(v213[0]));
            v93 += 2;
            goto LABEL_136;
          }
          v98 = *(_QWORD *)&v213[0];
          v99 = *(__int16 *)(v14 + 2LL * (v213[0] & 0x3FF) + 6976);
          if ( v99 < 0 )
          {
            if ( DWORD2(v213[0]) >= 0xB )
            {
              v110 = 11;
              while ( 1 )
              {
                v111 = (unsigned int)_bittest64((const __int64 *)&v98, (unsigned int)(v110 - 1)) + ~v99;
                if ( (unsigned int)v111 > 0x23F )
                  break;
                v99 = *(__int16 *)(v14 + 2 * v111 + 9024);
                if ( v99 >= 0 )
                  goto LABEL_137;
                if ( DWORD2(v213[0]) < ++v110 )
                  goto LABEL_156;
              }
LABEL_462:
              core::panicking::panic_bounds_check(v111, 576LL, (__int64)&off_59D78);
            }
          }
          else if ( (unsigned __int16)v99 >= 0x200u && DWORD2(v213[0]) >= (unsigned int)v99 >> 9 )
          {
            goto LABEL_137;
          }
LABEL_156:
          v104 = 2;
          if ( v93 == (unsigned __int8 *)v94 )
          {
            LOBYTE(a3) = v217;
            v93 = (unsigned __int8 *)v94;
            goto LABEL_118;
          }
          a3 = (unsigned __int64)*v93 << SBYTE8(v213[0]);
          v98 = a3 | *(_QWORD *)&v213[0];
          *(_QWORD *)&v213[0] |= a3;
          v112 = DWORD2(v213[0]) + 8;
          DWORD2(v213[0]) += 8;
          if ( v97 <= 6 )
          {
            v113 = *(__int16 *)(v14 + 2 * (v98 & 0x3FF) + 6976);
            if ( v113 < 0 )
            {
              if ( v97 >= 3 )
              {
                LODWORD(a3) = 11;
                do
                {
                  v111 = (unsigned int)_bittest64((const __int64 *)&v98, (unsigned int)(a3 - 1)) + ~v113;
                  if ( (unsigned int)v111 > 0x23F )
                    goto LABEL_462;
                  v113 = *(__int16 *)(v14 + 2 * v111 + 9024);
                  if ( v113 >= 0 )
                    goto LABEL_161;
                  LODWORD(a3) = a3 + 1;
                }
                while ( v112 >= (unsigned int)a3 );
              }
LABEL_168:
              v108 = (unsigned __int8 *)v94;
              LOBYTE(a3) = v217;
              if ( v93 + 1 == (unsigned __int8 *)v94 )
                goto LABEL_146;
              v114 = v93[1];
              v93 += 2;
              v98 |= v114 << v112;
LABEL_136:
              *(_QWORD *)&v213[0] = v98;
              v97 |= 0x10u;
              DWORD2(v213[0]) = v97;
              goto LABEL_137;
            }
            LOBYTE(a3) = *(_WORD *)(v14 + 2 * (v98 & 0x3FF) + 6976);
            if ( (unsigned __int16)v113 < 0x200u || v112 < (unsigned int)v113 >> 9 )
              goto LABEL_168;
          }
LABEL_161:
          ++v93;
          v97 = v112;
LABEL_137:
          v105 = *(__int16 *)(v14 + 2 * (v98 & 0x3FF) + 6976);
          if ( v105 < 0 )
          {
            v106 = 10LL;
            do
            {
              v107 = _bittest64((const __int64 *)&v98, v106) + ~v105;
              if ( v107 > 0x23F )
                break;
              v105 = *(__int16 *)(v14 + 2LL * v107 + 9024);
              v106 = (unsigned int)(v106 + 1);
            }
            while ( v105 < 0 );
          }
          else
          {
            LODWORD(v106) = (unsigned int)v105 >> 9;
            v105 &= 0x1FFu;
          }
          v104 = 1;
          if ( (_DWORD)v106 )
          {
            *(_QWORD *)&v213[0] = v98 >> v106;
            DWORD2(v213[0]) = v97 - v106;
            HIDWORD(v213[0]) = v105;
            if ( (unsigned int)v105 >= 0x10 )
            {
              if ( LODWORD(v213[1]) || (LOBYTE(a3) = 32, v105 != 16) )
              {
                *(_QWORD *)&v225 = 0x300000002LL;
                DWORD2(v225) = 7;
                v109 = (unsigned int)v105 - 16LL;
                if ( v109 > 2 )
                  core::panicking::panic_bounds_check(v109, 3LL, (__int64)&off_5A130);
                DWORD1(v213[1]) = *(&v216 + (unsigned int)v105);
                LOBYTE(a3) = 11;
              }
              goto LABEL_118;
            }
            if ( LODWORD(v213[1]) >= 0x1C9 )
              core::panicking::panic_bounds_check(LODWORD(v213[1]), 457LL, (__int64)&off_5A148);
            *((_BYTE *)v227 + LODWORD(v213[1])) = v105;
            LODWORD(v213[1]) = v95 + 1;
            v104 = 0;
            v108 = v93;
LABEL_146:
            v93 = v108;
            goto LABEL_118;
          }
          LOBYTE(a3) = 35;
LABEL_118:
          if ( v104 )
          {
            v13 = v218;
            if ( v104 == 1 )
            {
              src = v93;
              v10 = a8;
              goto LABEL_8;
            }
            src = v93;
            v203 = a3;
            LOBYTE(a3) = 10;
            v10 = a8;
            goto LABEL_417;
          }
        }
      case 11:
        v28 = DWORD2(v213[0]);
        if ( DWORD2(v213[0]) >= DWORD1(v213[1]) )
        {
          v30 = *(_QWORD *)&v213[0];
LABEL_237:
          *(_QWORD *)&v213[0] = v30 >> SBYTE4(v213[1]);
          DWORD2(v213[0]) = v28 - DWORD1(v213[1]);
          *(_QWORD *)&v225 = 3LL;
          *((_QWORD *)&v225 + 1) = 3LL;
          *(_QWORD *)&v226 = 11LL;
          v152 = BYTE12(v213[0]) & 3;
          if ( v152 == 3 )
            core::panicking::panic_bounds_check(3LL, 3LL, (__int64)&off_5A160);
          v153 = *((_QWORD *)&v225 + v152);
          v154 = v213[1];
          if ( HIDWORD(v213[0]) == 16 )
          {
            v155 = LODWORD(v213[1]) - 1LL;
            if ( v155 > 0x1C8 )
              core::panicking::panic_bounds_check(v155, 457LL, (__int64)&off_5A178);
            v156 = *((_BYTE *)v227 + v155);
          }
          else
          {
            v156 = 0;
          }
          v157 = (~(-1LL << SBYTE4(v213[1])) & v30) + v153;
          if ( __CFADD__(LODWORD(v213[1]), v157) )
            core::slice::index::slice_index_order_fail(LODWORD(v213[1]), LODWORD(v213[1]) + v157, (__int64)&off_5A190);
          if ( LODWORD(v213[1]) + v157 > 0x1C9 )
            core::slice::index::slice_end_index_len_fail(LODWORD(v213[1]) + v157, 457LL, (__int64)&off_5A190);
          if ( v157 )
            memset((char *)v227 + LODWORD(v213[1]), v156, v157);
          LODWORD(v213[1]) = v154 + v157;
          LOBYTE(a3) = 10;
          v8 = v223;
          v10 = a8;
          continue;
        }
        v29 = src;
        if ( src == (void *)v215 )
          goto LABEL_409;
        v30 = *(_QWORD *)&v213[0];
        v31 = (unsigned __int8 *)src;
        v32 = DWORD2(v213[0]);
        do
        {
          v30 |= (unsigned __int64)*v31++ << v32;
          if ( (unsigned int)(v32 + 8) >= DWORD1(v213[1]) )
          {
            src = v31;
            v28 = v32 + 8;
            goto LABEL_237;
          }
          v32 += 8;
        }
        while ( v31 != (unsigned __int8 *)v215 );
        *(_QWORD *)&v213[0] = v30;
        DWORD2(v213[0]) = DWORD2(v213[0]) + 8 * v215 - 8 * (_DWORD)src;
        v29 = (void *)v215;
LABEL_409:
        v204 = 0LL;
        src = v29;
        v203 = -4;
        LOBYTE(a3) = 11;
        if ( (v10 & 2) != 0 )
LABEL_434:
          v203 = 2 - (v221 != v222 || (_BYTE)a3 == 23);
LABEL_435:
        v206 = DWORD2(v213[0]);
        v207 = *(_QWORD *)&v213[0] & ~(-1LL << SBYTE8(v213[0]));
        *(_BYTE *)(v14 + 10985) = a3;
        *(_DWORD *)(v14 + 10472) = v206;
        *(_QWORD *)(v14 + 10500) = *(_QWORD *)((char *)v213 + 12);
        *(_DWORD *)(v14 + 10508) = DWORD1(v213[1]);
        *(_QWORD *)(v14 + 10464) = v207;
        if ( (v10 & 0x40) != 0 || (v10 & 9) == 0 )
        {
          v208 = v222;
        }
        else
        {
          v208 = v222;
          if ( v203 >= 0 )
          {
            if ( v222 < v11 )
              core::slice::index::slice_index_order_fail(v11, v222, (__int64)&off_5A100);
            if ( v222 > v221 )
              core::slice::index::slice_end_index_len_fail(v222, v221, (__int64)&off_5A100);
            v209 = v224;
            LODWORD(v225) = *(_DWORD *)(v224 + 10496);
            adler::Adler32::write_slice((unsigned __int16 *)&v225, v11 + v220, v222 - v11);
            v210 = v225;
            *(_DWORD *)(v209 + 10496) = v225;
            if ( !v203 )
            {
              v229 &= 1u;
              if ( v229 )
                v203 = 2 * (v210 == *(_DWORD *)(v224 + 10484)) - 2;
            }
            v8 = v223;
          }
        }
        v211 = (char *)src + v8 - (v215 + v204);
        *(_BYTE *)(v9 + 8) = v203;
        *(_QWORD *)v9 = v211;
        *(_QWORD *)(v9 + 16) = v208 - v11;
        return v9;
      case 12:
        v33 = (unsigned __int8 *)src;
        a3 = v215;
        v34 = v222;
        v35 = v215 - (_QWORD)src;
        if ( v215 - (unsigned __int64)src < 4 )
          goto LABEL_30;
        v141 = v220;
        v90 = v221;
        while ( v90 - v34 >= 2 )
        {
          if ( v35 >= 0xE && v90 - v34 > 0x102 )
          {
            src = v33;
            v222 = v34;
            v178 = miniz_oxide::inflate::core::decompress_fast(
                     v14,
                     (char **)&src,
                     &v220,
                     v10,
                     (unsigned __int64 *)v213,
                     v13);
            if ( !v178 )
              goto LABEL_8;
            v203 = v178;
            goto LABEL_417;
          }
          v142 = *(_QWORD *)&v213[0];
          if ( DWORD2(v213[0]) < 0x1EuLL )
          {
            v143 = *(unsigned int *)v33;
            v33 += 4;
            v142 = (v143 << SBYTE8(v213[0])) | *(_QWORD *)&v213[0];
            *(_QWORD *)&v213[0] = v142;
            DWORD2(v213[0]) |= 0x20u;
          }
          v144 = *(__int16 *)(v14 + 2 * (v142 & 0x3FF));
          if ( v144 < 0 )
          {
            v145 = 10LL;
            do
            {
              v146 = _bittest64((const __int64 *)&v142, v145) + ~v144;
              if ( v146 > 0x23F )
                break;
              v144 = *(__int16 *)(v14 + 2LL * v146 + 2048);
              v145 = (unsigned int)(v145 + 1);
            }
            while ( v144 < 0 );
          }
          else
          {
            if ( (unsigned __int16)v144 < 0x200u )
              goto LABEL_329;
            LODWORD(v145) = (unsigned int)v144 >> 9;
          }
          LODWORD(v213[1]) = v144;
          v147 = v142 >> v145;
          *(_QWORD *)&v213[0] = v147;
          v148 = DWORD2(v213[0]) - v145;
          DWORD2(v213[0]) -= v145;
          if ( (v144 & 0x100) != 0 )
          {
            LOBYTE(a3) = 21;
            v13 = v218;
            goto LABEL_330;
          }
          v149 = *(__int16 *)(v14 + 2 * (v147 & 0x3FF));
          if ( v149 < 0 )
          {
            v150 = 10LL;
            do
            {
              v151 = _bittest64((const __int64 *)&v147, v150) + ~v149;
              if ( v151 > 0x23F )
                break;
              v149 = *(__int16 *)(v14 + 2LL * v151 + 2048);
              v150 = (unsigned int)(v150 + 1);
            }
            while ( v149 < 0 );
          }
          else
          {
            if ( (unsigned __int16)v149 < 0x200u )
            {
              LOBYTE(a3) = 35;
              v13 = v218;
              goto LABEL_330;
            }
            LODWORD(v150) = (unsigned int)v149 >> 9;
          }
          *(_QWORD *)&v213[0] = v147 >> v150;
          DWORD2(v213[0]) = v148 - v150;
          if ( v90 <= v34 )
            goto LABEL_464;
          *(_BYTE *)(v141 + v34) = v144;
          if ( (v149 & 0x100) != 0 )
          {
            src = v33;
            v222 = v34 + 1;
            LODWORD(v213[1]) = v149;
            LOBYTE(a3) = 21;
            v8 = v223;
            v13 = v218;
            goto LABEL_8;
          }
          v8 = v223;
          v13 = v218;
          if ( v34 + 1 >= v90 )
            core::panicking::panic_bounds_check(v34 + 1, v90, (__int64)&off_5A058);
          *(_BYTE *)(v141 + v34 + 1) = v149;
          v34 += 2LL;
          v35 = a3 - (_QWORD)v33;
          if ( a3 - (unsigned __int64)v33 < 4 )
            break;
        }
LABEL_30:
        v36 = DWORD2(v213[0]);
        if ( DWORD2(v213[0]) >= 0xFuLL )
        {
          v37 = *(_QWORD *)&v213[0];
          goto LABEL_322;
        }
        if ( v35 > 1 )
        {
          v37 = *(_QWORD *)&v213[0] | ((unsigned __int64)*(unsigned __int16 *)v33 << SBYTE8(v213[0]));
          v33 += 2;
          goto LABEL_265;
        }
        v37 = *(_QWORD *)&v213[0];
        v38 = *(__int16 *)(v14 + 2LL * (v213[0] & 0x3FF));
        if ( v38 < 0 )
        {
          if ( DWORD2(v213[0]) < 0xB )
            goto LABEL_316;
          v179 = 11;
          while ( 1 )
          {
            v111 = (unsigned int)_bittest64((const __int64 *)&v37, (unsigned int)(v179 - 1)) + ~v38;
            if ( (unsigned int)v111 > 0x23F )
              goto LABEL_462;
            v38 = *(__int16 *)(v14 + 2 * v111 + 2048);
            if ( v38 >= 0 )
              break;
            if ( DWORD2(v213[0]) < ++v179 )
              goto LABEL_316;
          }
        }
        else if ( (unsigned __int16)v38 < 0x200u || DWORD2(v213[0]) < (unsigned int)v38 >> 9 )
        {
LABEL_316:
          if ( v33 == (unsigned __int8 *)a3 )
            goto LABEL_461;
          v37 = ((unsigned __int64)*v33 << SBYTE8(v213[0])) | *(_QWORD *)&v213[0];
          *(_QWORD *)&v213[0] = v37;
          v180 = DWORD2(v213[0]) + 8;
          DWORD2(v213[0]) += 8;
          if ( v36 > 6 )
          {
LABEL_321:
            ++v33;
            v36 = v180;
            goto LABEL_322;
          }
          v181 = *(__int16 *)(v14 + 2 * (v37 & 0x3FF));
          if ( v181 < 0 )
          {
            if ( v36 >= 3 )
            {
              v197 = 11;
              do
              {
                v111 = (unsigned int)_bittest64((const __int64 *)&v37, (unsigned int)(v197 - 1)) + ~v181;
                if ( (unsigned int)v111 > 0x23F )
                  goto LABEL_462;
                v181 = *(__int16 *)(v14 + 2 * v111 + 2048);
                v13 = v218;
                if ( v181 >= 0 )
                  goto LABEL_321;
              }
              while ( v180 >= ++v197 );
            }
          }
          else if ( (unsigned __int16)v181 >= 0x200u && v180 >= (unsigned int)v181 >> 9 )
          {
            goto LABEL_321;
          }
          if ( v33 + 1 == (unsigned __int8 *)a3 )
          {
LABEL_461:
            src = (void *)a3;
            v222 = v34;
            LOBYTE(a3) = 12;
            goto LABEL_455;
          }
          v198 = v33[1];
          v33 += 2;
          v37 |= v198 << v180;
LABEL_265:
          *(_QWORD *)&v213[0] = v37;
          v36 |= 0x10u;
          DWORD2(v213[0]) = v36;
        }
LABEL_322:
        LODWORD(a3) = *(__int16 *)(v14 + 2 * (v37 & 0x3FF));
        if ( (a3 & 0x80000000) != 0LL )
        {
          v182 = 10LL;
          do
          {
            v183 = _bittest64((const __int64 *)&v37, v182) + ~(_DWORD)a3;
            if ( v183 > 0x23F )
              break;
            LODWORD(a3) = *(__int16 *)(v14 + 2LL * v183 + 2048);
            v182 = (unsigned int)(v182 + 1);
          }
          while ( (a3 & 0x80000000) != 0LL );
        }
        else
        {
          LODWORD(v182) = (unsigned int)a3 >> 9;
          LODWORD(a3) = a3 & 0x1FF;
        }
        if ( (_DWORD)v182 )
        {
          *(_QWORD *)&v213[0] = v37 >> v182;
          DWORD2(v213[0]) = v36 - v182;
          LODWORD(v213[1]) = a3;
          LOBYTE(a3) = 13;
        }
        else
        {
LABEL_329:
          LOBYTE(a3) = 35;
        }
LABEL_330:
        src = v33;
        v222 = v34;
        continue;
      case 13:
        LOBYTE(a3) = 21;
        if ( LODWORD(v213[1]) > 0xFF )
          continue;
        v90 = v221;
        v34 = v222;
        if ( v221 != v222 )
        {
          if ( v221 > v222 )
          {
            *(_BYTE *)(v220 + v222) = v213[1];
            v222 = v34 + 1;
            LOBYTE(a3) = 12;
            continue;
          }
LABEL_464:
          core::panicking::panic_bounds_check(v34, v90, (__int64)&off_5A058);
        }
LABEL_424:
        v203 = 2;
LABEL_430:
        v202 = 0;
        goto LABEL_431;
      case 14:
        LODWORD(a3) = DWORD2(v213[0]);
        if ( DWORD2(v213[0]) >= DWORD1(v213[1]) )
        {
          v25 = *(_QWORD *)&v213[0];
        }
        else
        {
          v24 = src;
          if ( src == (void *)v215 )
            goto LABEL_407;
          v25 = *(_QWORD *)&v213[0];
          v26 = (unsigned __int8 *)src;
          v27 = DWORD2(v213[0]);
          while ( 1 )
          {
            v25 |= (unsigned __int64)*v26++ << v27;
            if ( (unsigned int)(v27 + 8) >= DWORD1(v213[1]) )
              break;
            v27 += 8;
            if ( v26 == (unsigned __int8 *)v215 )
            {
              *(_QWORD *)&v213[0] = v25;
              DWORD2(v213[0]) = DWORD2(v213[0]) + 8 * v215 - 8 * (_DWORD)src;
              v24 = (void *)v215;
LABEL_407:
              v204 = 0LL;
              src = v24;
              v203 = -4;
              LOBYTE(a3) = 14;
              if ( (v10 & 2) == 0 )
                goto LABEL_435;
              goto LABEL_434;
            }
          }
          src = v26;
          LODWORD(a3) = v27 + 8;
        }
        *(_QWORD *)&v213[0] = v25 >> SBYTE4(v213[1]);
        DWORD2(v213[0]) = a3 - DWORD1(v213[1]);
        LODWORD(v213[1]) += v25 & ~(unsigned int)(-1LL << SBYTE4(v213[1]));
        LOBYTE(a3) = 15;
        continue;
      case 15:
        v51 = DWORD2(v213[0]);
        if ( DWORD2(v213[0]) >= 0xFuLL )
        {
          v53 = *(_QWORD *)&v213[0];
          goto LABEL_365;
        }
        v52 = (char *)src;
        if ( v215 - (unsigned __int64)src > 1 )
        {
          v53 = *(_QWORD *)&v213[0] | ((unsigned __int64)*(unsigned __int16 *)src << SBYTE8(v213[0]));
          src = (char *)src + 2;
          *(_QWORD *)&v213[0] = v53;
          v51 = DWORD2(v213[0]) | 0x10;
          DWORD2(v213[0]) |= 0x10u;
          goto LABEL_365;
        }
        v53 = *(_QWORD *)&v213[0];
        v54 = *(__int16 *)(v14 + 2LL * (v213[0] & 0x3FF) + 3488);
        if ( v54 < 0 )
        {
          if ( DWORD2(v213[0]) >= 0xB )
          {
            v168 = 11;
            do
            {
              v169 = (unsigned int)_bittest64((const __int64 *)&v53, (unsigned int)(v168 - 1)) + ~v54;
              if ( (unsigned int)v169 > 0x23F )
                goto LABEL_467;
              v54 = *(__int16 *)(v14 + 2 * v169 + 5536);
              if ( v54 >= 0 )
                goto LABEL_364;
            }
            while ( DWORD2(v213[0]) >= ++v168 );
          }
        }
        else if ( (unsigned __int16)v54 >= 0x200u && DWORD2(v213[0]) >= (unsigned int)v54 >> 9 )
        {
          goto LABEL_364;
        }
        if ( src == (void *)v215 )
          goto LABEL_459;
        v53 = ((unsigned __int64)*(unsigned __int8 *)src << SBYTE8(v213[0])) | *(_QWORD *)&v213[0];
        *(_QWORD *)&v213[0] = v53;
        v170 = DWORD2(v213[0]) + 8;
        DWORD2(v213[0]) += 8;
        if ( v51 > 6 )
        {
LABEL_291:
          v52 = (char *)src + 1;
          v51 = v170;
LABEL_364:
          src = v52;
LABEL_365:
          v193 = *(__int16 *)(v14 + 2 * (v53 & 0x3FF) + 3488);
          if ( v193 < 0 )
          {
            v194 = 10LL;
            do
            {
              v195 = _bittest64((const __int64 *)&v53, v194) + ~v193;
              if ( v195 > 0x23F )
                break;
              v193 = *(__int16 *)(v14 + 2LL * v195 + 5536);
              v194 = (unsigned int)(v194 + 1);
            }
            while ( v193 < 0 );
          }
          else
          {
            LODWORD(v194) = (unsigned int)v193 >> 9;
            v193 &= 0x1FFu;
          }
          LOBYTE(a3) = 35;
          if ( (_DWORD)v194 )
          {
            *(_QWORD *)&v213[0] = v53 >> v194;
            DWORD2(v213[0]) = v51 - v194;
            LOBYTE(a3) = 34;
            if ( v193 <= 29 )
            {
              v226 = xmmword_4B310;
              v225 = xmmword_4B320;
              v196 = v193 & 0x1F;
              v92 = *((_BYTE *)&v225 + v196) == 0;
              DWORD1(v213[1]) = *((unsigned __int8 *)&v225 + v196);
              HIDWORD(v213[0]) = word_4C51E[v196];
              LOBYTE(a3) = 16;
              if ( v92 )
                LOBYTE(a3) = 22;
            }
          }
          continue;
        }
        v171 = *(__int16 *)(v14 + 2 * (v53 & 0x3FF) + 3488);
        if ( v171 >= 0 )
        {
          if ( (unsigned __int16)v171 >= 0x200u && v170 >= (unsigned int)v171 >> 9 )
            goto LABEL_291;
          goto LABEL_362;
        }
        if ( v51 < 3 )
        {
LABEL_362:
          if ( (char *)src + 1 != (void *)v215 )
          {
            v52 = (char *)src + 2;
            v53 |= (unsigned __int64)*((unsigned __int8 *)src + 1) << v170;
            *(_QWORD *)&v213[0] = v53;
            v51 |= 0x10u;
            DWORD2(v213[0]) = v51;
            goto LABEL_364;
          }
LABEL_459:
          v204 = 0LL;
          src = (void *)v215;
          v203 = -4;
          LOBYTE(a3) = 15;
          if ( (v10 & 2) == 0 )
            goto LABEL_435;
          goto LABEL_434;
        }
        v192 = 11;
        while ( 1 )
        {
          v169 = (unsigned int)_bittest64((const __int64 *)&v53, (unsigned int)(v192 - 1)) + ~v171;
          if ( (unsigned int)v169 > 0x23F )
            break;
          v171 = *(__int16 *)(v14 + 2 * v169 + 5536);
          if ( v171 >= 0 )
            goto LABEL_291;
          if ( v170 < ++v192 )
            goto LABEL_362;
        }
LABEL_467:
        core::panicking::panic_bounds_check(v169, 576LL, (__int64)&off_59D78);
      case 16:
        LODWORD(a3) = DWORD2(v213[0]);
        if ( DWORD2(v213[0]) >= DWORD1(v213[1]) )
        {
          v21 = *(_QWORD *)&v213[0];
        }
        else
        {
          v20 = src;
          if ( src == (void *)v215 )
            goto LABEL_411;
          v21 = *(_QWORD *)&v213[0];
          v22 = (unsigned __int8 *)src;
          v23 = DWORD2(v213[0]);
          while ( 1 )
          {
            v21 |= (unsigned __int64)*v22++ << v23;
            if ( (unsigned int)(v23 + 8) >= DWORD1(v213[1]) )
              break;
            v23 += 8;
            if ( v22 == (unsigned __int8 *)v215 )
            {
              *(_QWORD *)&v213[0] = v21;
              DWORD2(v213[0]) = DWORD2(v213[0]) + 8 * v215 - 8 * (_DWORD)src;
              v20 = (void *)v215;
LABEL_411:
              v204 = 0LL;
              src = v20;
              v203 = -4;
              LOBYTE(a3) = 16;
              if ( (v10 & 2) == 0 )
                goto LABEL_435;
              goto LABEL_434;
            }
          }
          src = v22;
          LODWORD(a3) = v23 + 8;
        }
        *(_QWORD *)&v213[0] = v21 >> SBYTE4(v213[1]);
        DWORD2(v213[0]) = a3 - DWORD1(v213[1]);
        HIDWORD(v213[0]) += v21 & ~(unsigned int)(-1LL << SBYTE4(v213[1]));
        LOBYTE(a3) = 22;
        continue;
      case 17:
        v72 = DWORD2(v213[0]);
        v73 = *(_QWORD *)&v213[0];
        if ( DWORD2(v213[0]) > 7uLL )
          goto LABEL_85;
        v74 = (unsigned __int8 *)src;
        if ( src != (void *)v215 )
        {
          src = (char *)src + 1;
          v73 = ((unsigned __int64)*v74 << SBYTE8(v213[0])) | *(_QWORD *)&v213[0];
          v72 = DWORD2(v213[0]) | 8;
LABEL_85:
          *(_QWORD *)&v213[0] = v73 >> 8;
          DWORD2(v213[0]) = v72 - 8;
          HIDWORD(v213[0]) = (unsigned __int8)v73;
          LOBYTE(a3) = 18;
          continue;
        }
        v203 = -4;
        LOBYTE(a3) = 17;
        v204 = 0LL;
        if ( (v10 & 2) == 0 )
          goto LABEL_435;
        goto LABEL_434;
      case 18:
        v90 = v221;
        v34 = v222;
        if ( v221 == v222 )
          goto LABEL_424;
        if ( v221 <= v222 )
          goto LABEL_464;
        *(_BYTE *)(v220 + v222) = BYTE12(v213[0]);
        v91 = v34 + 1;
        LOBYTE(a3) = 17;
        if ( !DWORD2(v213[0]) )
          LOBYTE(a3) = 6;
        v92 = LODWORD(v213[1])-- == 1;
        v222 = v91;
        if ( v92 )
          LOBYTE(a3) = 6;
        continue;
      case 19:
        v228 = v9;
        v127 = v220;
        v128 = v221;
        v129 = v222;
        v130 = HIDWORD(v213[0]);
        v131 = v213[1];
        while ( v128 != v129 )
        {
          v132 = v131;
          if ( v128 - v129 < v131 )
            v132 = v128 - v129;
          miniz_oxide::inflate::core::transfer(v127, v128, v218 & (v129 - v130), v129, v132, v218);
          v129 += v132;
          v131 -= v132;
          LODWORD(v213[1]) = v131;
          if ( !v131 )
          {
            v222 = v129;
            LOBYTE(a3) = 12;
LABEL_190:
            v9 = v228;
            v8 = v223;
            v11 = a7;
            v14 = v224;
            goto LABEL_268;
          }
        }
        v222 = v128;
        v203 = 2;
        v19 = 19;
        v202 = 0;
        v9 = v228;
        v8 = v223;
        v11 = a7;
        v14 = v224;
        v10 = a8;
        goto LABEL_431;
      case 20:
        LOBYTE(a3) = 3;
        if ( *(_DWORD *)(v14 + 10488) )
        {
          v75 = BYTE8(v213[0]);
          v76 = (char *)src + v8 - v215;
          v77 = DWORD2(v213[0]) >> 3;
          if ( (unsigned int)v77 >= (unsigned int)v76 )
            v77 = (unsigned int)v76;
          v78 = (BYTE8(v213[0]) & 0xF8) - 8 * v77;
          DWORD2(v213[0]) = (DWORD2(v213[0]) & 0xFFFFFFF8) - 8 * v77;
          v79 = (unsigned __int64)&v76[-v77];
          if ( v79 > v8 )
            core::slice::index::slice_start_index_len_fail(v79, v8, (__int64)&off_5A0E8);
          src = (void *)(v234 + v79);
          v215 = v233;
          *(_QWORD *)&v213[0] = (*(_QWORD *)&v213[0] >> (v75 & 7)) & ~(-1LL << (v78 & 0x38));
          LOBYTE(a3) = 24;
          if ( (v10 & 1) != 0 )
          {
            LODWORD(v213[1]) = 0;
            LOBYTE(a3) = 23;
          }
        }
        continue;
      case 21:
        v86 = v213[1];
        v87 = v213[1] & 0x1FF;
        LODWORD(v213[1]) = v87;
        LOBYTE(a3) = 20;
        if ( v87 != 256 )
        {
          LOBYTE(a3) = 33;
          if ( v87 <= 0x11D )
          {
            v226 = xmmword_4B2F0;
            v225 = xmmword_4B300;
            v88 = (v86 - 1) & 0x1F;
            v89 = *((_BYTE *)&v225 + v88) == 0;
            DWORD1(v213[1]) = *((unsigned __int8 *)&v225 + v88);
            LODWORD(v213[1]) = word_4C4DE[v88];
            LOBYTE(a3) = v89 | 0xE;
          }
        }
        continue;
      case 22:
        if ( (v10 & 4) == 0 || (LOBYTE(a3) = 30, v222 >= HIDWORD(v213[0])) )
        {
          v123 = v222 + LODWORD(v213[1]);
          if ( v123 <= v221
            && ((v124 = v218 & (v222 - HIDWORD(v213[0])), v125 = v124 < v222, v126 = v124 - v222, v125)
             || v126 >= LODWORD(v213[1])) )
          {
            v163 = v218;
            miniz_oxide::inflate::core::apply_match(v220, v221, v222, HIDWORD(v213[0]), LODWORD(v213[1]), v218);
            v222 = v123;
            v13 = v163;
            v11 = a7;
            LOBYTE(a3) = 12;
          }
          else
          {
            LOBYTE(a3) = 19;
            if ( !LODWORD(v213[1]) )
              LOBYTE(a3) = 12;
            v13 = v218;
          }
        }
        continue;
      case 23:
        v133 = v213[1];
        v134 = (unsigned __int8 *)src;
        if ( LODWORD(v213[1]) > 3 )
          goto LABEL_401;
        a3 = v215;
        v135 = *(_DWORD *)(v14 + 10484);
        v136 = *(_QWORD *)&v213[0];
        v137 = DWORD2(v213[0]);
        if ( DWORD2(v213[0]) )
        {
          if ( DWORD2(v213[0]) <= 7 )
          {
            if ( src == (void *)v215 )
              goto LABEL_453;
            v134 = (unsigned __int8 *)src + 1;
            v136 = ((unsigned __int64)*(unsigned __int8 *)src << SBYTE8(v213[0])) | *(_QWORD *)&v213[0];
            v137 = DWORD2(v213[0]) | 8;
          }
          v138 = (unsigned __int8)v136;
          v136 >>= 8;
          *(_QWORD *)&v213[0] = v136;
          v139 = v137 - 8;
          DWORD2(v213[0]) = v139;
          v140 = (v135 << 8) | v138;
        }
        else
        {
          if ( src == (void *)v215 )
            goto LABEL_453;
          v134 = (unsigned __int8 *)src + 1;
          v139 = 0;
          v140 = *(unsigned __int8 *)src | (v135 << 8);
        }
        *(_DWORD *)(v14 + 10484) = v140;
        LODWORD(v213[1]) = v133 + 1;
        if ( v133 == 3 )
          goto LABEL_401;
        if ( v139 )
        {
          if ( v139 <= 7 )
          {
            if ( v134 == (unsigned __int8 *)a3 )
              goto LABEL_453;
            v159 = (unsigned __int64)*v134++ << v139;
            v136 |= v159;
            v139 |= 8u;
          }
          v160 = (unsigned __int8)v136;
          v136 >>= 8;
          *(_QWORD *)&v213[0] = v136;
          v161 = v139 - 8;
          DWORD2(v213[0]) = v161;
          v162 = (v140 << 8) | v160;
        }
        else
        {
          if ( v134 == (unsigned __int8 *)a3 )
            goto LABEL_453;
          v172 = *v134++;
          v173 = v172 | (v140 << 8);
          v161 = 0;
          v162 = v173;
        }
        *(_DWORD *)(v14 + 10484) = v162;
        LODWORD(v213[1]) = v133 + 2;
        if ( v133 > 1 )
          goto LABEL_401;
        if ( v161 )
        {
          if ( v161 <= 7 )
          {
            if ( v134 == (unsigned __int8 *)a3 )
              goto LABEL_453;
            v174 = (unsigned __int64)*v134++ << v161;
            v136 |= v174;
            v161 |= 8u;
          }
          v175 = (unsigned __int8)v136;
          v136 >>= 8;
          *(_QWORD *)&v213[0] = v136;
          v176 = v161 - 8;
          DWORD2(v213[0]) = v176;
          v177 = (v162 << 8) | v175;
        }
        else
        {
          if ( v134 == (unsigned __int8 *)a3 )
            goto LABEL_453;
          v188 = *v134++;
          v189 = v188 | (v162 << 8);
          v176 = 0;
          v177 = v189;
        }
        *(_DWORD *)(v14 + 10484) = v177;
        LODWORD(v213[1]) = v133 + 3;
        if ( v133 )
        {
LABEL_401:
          src = v134;
          LOBYTE(a3) = 24;
          continue;
        }
        if ( v176 )
        {
          if ( v176 > 7 )
          {
LABEL_356:
            *(_QWORD *)&v213[0] = v136 >> 8;
            DWORD2(v213[0]) = v176 - 8;
            v191 = (v177 << 8) | (unsigned __int8)v136;
LABEL_400:
            *(_DWORD *)(v14 + 10484) = v191;
            LODWORD(v213[1]) = 4;
            goto LABEL_401;
          }
          if ( v134 != (unsigned __int8 *)a3 )
          {
            v190 = (unsigned __int64)*v134++ << v176;
            v136 |= v190;
            v176 |= 8u;
            goto LABEL_356;
          }
        }
        else if ( v134 != (unsigned __int8 *)a3 )
        {
          v201 = *v134++;
          v191 = v201 | (v177 << 8);
          goto LABEL_400;
        }
LABEL_453:
        src = (void *)a3;
        LOBYTE(a3) = 23;
LABEL_455:
        v203 = v217;
        goto LABEL_417;
      case 24:
        v202 = 0;
        v203 = 0;
        goto LABEL_431;
      default:
        v203 = -1;
        goto LABEL_430;
    }
  }
}
// 3F0D0: variable 'a3' is possibly undefined
// 2AE8: using guessed type Elf64_Rela stru_2AE8;
// 4B2F0: using guessed type __int128 xmmword_4B2F0;
// 4B300: using guessed type __int128 xmmword_4B300;
// 4B310: using guessed type __int128 xmmword_4B310;
// 4B320: using guessed type __int128 xmmword_4B320;
// 4B330: using guessed type __int128 xmmword_4B330;
// 4B340: using guessed type __int128 xmmword_4B340;
// 4B350: using guessed type __int128 xmmword_4B350;
// 4B360: using guessed type __int128 xmmword_4B360;
// 4C4DE: using guessed type unsigned __int16 word_4C4DE[32];
// 4C51E: using guessed type unsigned __int16 word_4C51E[32];
// 4C55E: using guessed type unsigned __int16 word_4C55E[3];
// 4C564: using guessed type unsigned __int8 byte_4C564[28];
// 59D78: using guessed type char *off_59D78;
// 5A058: using guessed type char *off_5A058;
// 5A070: using guessed type char *off_5A070;
// 5A088: using guessed type char *off_5A088;
// 5A0A0: using guessed type char *off_5A0A0;
// 5A0B8: using guessed type char *off_5A0B8;
// 5A0D0: using guessed type char *off_5A0D0;
// 5A0E8: using guessed type char *off_5A0E8;
// 5A100: using guessed type char *off_5A100;
// 5A118: using guessed type char *off_5A118;
// 5A130: using guessed type char *off_5A130;
// 5A148: using guessed type char *off_5A148;
// 5A160: using guessed type char *off_5A160;
// 5A178: using guessed type char *off_5A178;
// 5A190: using guessed type char *off_5A190;

//----- (0000000000041150) ----------------------------------------------------
__int64 __fastcall adler::Adler32::write_slice(unsigned __int16 *a1, __int64 a2, unsigned __int64 a3)
{
  int v3; // r11d
  unsigned int v4; // r10d
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // r14
  float v8; // edx
  __m128i v9; // xmm4
  __m128i v10; // xmm2
  float v11; // eax
  int v12; // r14d
  unsigned int v13; // ebp
  __m128i si128; // xmm2
  __m128i v15; // xmm3
  unsigned int v16; // r9d
  unsigned __int64 v17; // r12
  __int64 v18; // r13
  __m128i v19; // xmm4
  __m128i v20; // xmm1
  __int64 v21; // r8
  int v22; // edi
  unsigned int v23; // r11d
  __m128i v24; // xmm5
  __m128i v25; // xmm5
  __m128i v26; // xmm5
  __m128 v27; // xmm1
  __m128 v28; // xmm0
  unsigned int v29; // r9d
  unsigned int v30; // r8d
  __m128 v31; // xmm3
  __m128 v32; // xmm2
  unsigned int v33; // r10d
  unsigned int v34; // ebx
  unsigned int v35; // r14d
  int v36; // edi
  unsigned int v37; // r11d
  unsigned int v38; // edx
  unsigned int v39; // r11d
  __int64 result; // rax
  int v41; // [rsp+0h] [rbp-4Ch]
  unsigned __int64 v42; // [rsp+4h] [rbp-48h]
  __int64 v43; // [rsp+Ch] [rbp-40h]

  v3 = *a1;
  v4 = a1[1];
  v5 = a3 & 0xFFFFFFFFFFFFFFFCLL;
  v6 = 22208 * (a3 / 0x56C0);
  v7 = (a3 & 0xFFFFFFFFFFFFFFFCLL) - v6;
  v43 = a3 & 3;
  if ( v6 >= 0x56C0 )
  {
    v42 = (a3 & 0xFFFFFFFFFFFFFFFCLL) - v6;
    v41 = *a1;
    v12 = 22208 * v3;
    v13 = 0;
    si128 = _mm_load_si128((const __m128i *)&xmmword_4C580);
    v15 = _mm_load_si128((const __m128i *)&xmmword_4C590);
    v16 = 0;
    v17 = 22208 * (a3 / 0x56C0);
    v18 = a2;
    v11 = 0.0;
    v8 = 0.0;
    v19 = 0LL;
    v20 = 0LL;
    do
    {
      v21 = -22208LL;
      do
      {
        v22 = LODWORD(v11) + *(unsigned __int8 *)(v18 + v21 + 22208);
        v23 = v16 + *(unsigned __int8 *)(v18 + v21 + 22209);
        v24 = _mm_add_epi32(
                _mm_unpacklo_epi16(
                  _mm_unpacklo_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(v18 + v21 + 22210)), (__m128i)0LL),
                  (__m128i)0LL),
                v19);
        LODWORD(v11) = v22 + *(unsigned __int8 *)(v18 + v21 + 22212);
        v16 = v23 + *(unsigned __int8 *)(v18 + v21 + 22213);
        v19 = _mm_add_epi32(
                _mm_unpacklo_epi16(
                  _mm_unpacklo_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(v18 + v21 + 22214)), (__m128i)0LL),
                  (__m128i)0LL),
                v24);
        LODWORD(v8) += LODWORD(v11) + v22;
        v13 += v16 + v23;
        v20 = _mm_add_epi32(_mm_add_epi32(v20, v24), v19);
        v21 += 8LL;
      }
      while ( v21 );
      v18 += 22208LL;
      v17 -= 22208LL;
      LODWORD(v11) %= 0xFFF1u;
      v16 %= 0xFFF1u;
      v25 = _mm_srli_epi32(
              _mm_unpacklo_epi32(
                _mm_shuffle_epi32(_mm_mul_epu32(v19, si128), 237),
                _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v19, 245), si128), 237)),
              0xFu);
      v19 = _mm_sub_epi32(
              v19,
              _mm_unpacklo_epi32(
                _mm_shuffle_epi32(_mm_mul_epu32(v25, v15), 232),
                _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v25, 245), v15), 232)));
      LODWORD(v8) %= 0xFFF1u;
      v13 %= 0xFFF1u;
      v26 = _mm_srli_epi32(
              _mm_unpacklo_epi32(
                _mm_shuffle_epi32(_mm_mul_epu32(v20, si128), 237),
                _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v20, 245), si128), 237)),
              0xFu);
      v20 = _mm_sub_epi32(
              v20,
              _mm_unpacklo_epi32(
                _mm_shuffle_epi32(_mm_mul_epu32(v26, v15), 232),
                _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v26, 245), v15), 232)));
      v4 = (v12 + v4) % 0xFFF1;
    }
    while ( v17 >= 0x56C0 );
    v10 = _mm_unpacklo_epi64(_mm_slli_epi64(_mm_cvtsi32_si128(v16), 0x20u), v19);
    v9 = _mm_unpacklo_epi64(_mm_slli_epi64(_mm_cvtsi32_si128(v13), 0x20u), v20);
    v3 = v41;
    v7 = v42;
  }
  else
  {
    v8 = 0.0;
    v9 = 0LL;
    v10 = 0LL;
    v11 = 0.0;
  }
  v27 = (__m128)v10;
  v27.m128_f32[0] = v11;
  v28 = (__m128)v9;
  v28.m128_f32[0] = v8;
  if ( v7 )
  {
    v29 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v10, 85));
    v30 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v9, 85));
    v31 = (__m128)_mm_shuffle_epi32(v10, 238);
    v32 = (__m128)_mm_shuffle_epi32(v9, 238);
    do
    {
      LODWORD(v11) += *(unsigned __int8 *)(a2 + v6);
      v29 += *(unsigned __int8 *)(a2 + v6 + 1);
      v31 = (__m128)_mm_add_epi32(
                      (__m128i)v31,
                      _mm_unpacklo_epi16(
                        _mm_unpacklo_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(a2 + v6 + 2)), (__m128i)0LL),
                        (__m128i)0LL));
      LODWORD(v8) += LODWORD(v11);
      v30 += v29;
      v32 = (__m128)_mm_add_epi32((__m128i)v32, (__m128i)v31);
      v6 += 4LL;
    }
    while ( v5 != v6 );
    v27 = _mm_movelh_ps(_mm_unpacklo_ps(v27, (__m128)_mm_cvtsi32_si128(v29)), v31);
    v28 = _mm_movelh_ps(_mm_unpacklo_ps(v28, (__m128)_mm_cvtsi32_si128(v30)), v32);
    LODWORD(v11) %= 0xFFF1u;
    LODWORD(v8) %= 0xFFF1u;
  }
  v33 = v3 * v7 + v4;
  v34 = _mm_cvtsi128_si32(_mm_shuffle_epi32((__m128i)v27, 85)) % 0xFFF1u;
  v35 = _mm_cvtsi128_si32(_mm_shuffle_epi32((__m128i)v27, 238)) % 0xFFF1u;
  v36 = v3;
  v37 = _mm_cvtsi128_si32(_mm_shuffle_epi32((__m128i)v27, 255)) % 0xFFF1u;
  v38 = v33 % 0xFFF1
      + 4 * (_mm_cvtsi128_si32(_mm_shuffle_epi32((__m128i)v28, 238)) % 0xFFF1u)
      + 4 * (_mm_cvtsi128_si32(_mm_shuffle_epi32((__m128i)v28, 85)) % 0xFFF1u)
      - (v34
       + 2 * v35)
      + 4 * (LODWORD(v8) + _mm_cvtsi128_si32(_mm_shuffle_epi32((__m128i)v28, 255)) % 0xFFF1u)
      + 3 * (65521 - v37)
      + 196563;
  v39 = v34 + v36 + LODWORD(v11) + v35 + v37;
  if ( v43 )
  {
    v39 += *(unsigned __int8 *)(a2 + v5);
    v38 += v39;
    if ( (_DWORD)v43 != 1 )
    {
      v39 += *(unsigned __int8 *)(a2 + v5 + 1);
      v38 += v39;
      if ( (_DWORD)v43 != 2 )
      {
        v39 += *(unsigned __int8 *)(a2 + v5 + 2);
        v38 += v39;
      }
    }
  }
  *a1 = v39 % 0xFFF1;
  result = 65521 * (v38 / 0xFFF1);
  a1[1] = v38 % 0xFFF1;
  return result;
}
// 4C580: using guessed type __int128 xmmword_4C580;
// 4C590: using guessed type __int128 xmmword_4C590;

//----- (0000000000041620) ----------------------------------------------------
__int64 __fastcall <core::alloc::layout::LayoutError as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return <core::fmt::Formatter as core::fmt::Write>::write_str(a2);
}

//----- (0000000000041640) ----------------------------------------------------
void __noreturn alloc::raw_vec::capacity_overflow()
{
  __int64 v0[3]; // [rsp+8h] [rbp-30h] BYREF
  __int128 v1; // [rsp+20h] [rbp-18h]

  v0[0] = (__int64)&off_5A1C8;
  v0[1] = 1LL;
  v0[2] = (__int64)aCalledResultUn_0;
  v1 = 0LL;
  core::panicking::panic_fmt((__int64)v0, (__int64)&off_5A1D8);
}
// 5A1C8: using guessed type char *off_5A1C8;
// 5A1D8: using guessed type char *off_5A1D8;

//----- (0000000000041680) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::RawVec<T,A>::reserve_for_push(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v4; // r14
  __int64 v5; // rax
  __int64 result; // rax
  __int64 v7; // [rsp+8h] [rbp-40h] BYREF
  __int64 v8; // [rsp+10h] [rbp-38h]
  __int64 v9; // [rsp+18h] [rbp-30h]
  __int64 v10[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = a2 + 1;
  if ( !v2 )
    goto LABEL_12;
  v3 = *a1;
  if ( 2 * *a1 > v2 )
    v2 = 2 * *a1;
  v4 = 8LL;
  if ( v2 >= 9 )
    v4 = v2;
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = v3;
    v5 = 1LL;
  }
  else
  {
    v5 = 0LL;
  }
  v10[1] = v5;
  alloc::raw_vec::finish_grow(&v7, v4 >= 0, v4, v10);
  if ( v7 )
  {
    if ( v8 )
      alloc::alloc::handle_alloc_error(v8, v9);
LABEL_12:
    alloc::raw_vec::capacity_overflow();
  }
  result = v8;
  a1[1] = v8;
  *a1 = v4;
  return result;
}

//----- (0000000000041730) ----------------------------------------------------
__int64 __fastcall alloc::raw_vec::finish_grow(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 result; // rax

  v4 = 1LL;
  if ( !a2 )
  {
    result = 1LL;
    v5 = 0LL;
    goto LABEL_12;
  }
  v5 = a3;
  if ( a4[1] )
  {
    v6 = a4[2];
    if ( v6 )
    {
      v7 = _rust_realloc(*a4, v6, 1LL, a3);
      if ( !v7 )
        goto LABEL_8;
      goto LABEL_11;
    }
  }
  if ( !a3 )
  {
    v7 = 1LL;
    goto LABEL_11;
  }
  v7 = _rust_alloc(a3, 1LL);
  if ( v7 )
  {
LABEL_11:
    a1[1] = v7;
    result = 2LL;
    v4 = 0LL;
    goto LABEL_12;
  }
LABEL_8:
  a1[1] = 1LL;
  result = 2LL;
LABEL_12:
  a1[result] = v5;
  *a1 = v4;
  return result * 8;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000417E0) ----------------------------------------------------
__int64 *__fastcall <&[u8] as alloc::ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl(
        __int64 *a1,
        const void *a2,
        size_t a3)
{
  __int64 v3; // r14
  void *v5; // rax
  __int64 v6; // r12
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v11[9]; // [rsp+0h] [rbp-48h] BYREF

  v3 = a3 + 1;
  if ( a3 == -1LL )
    core::option::unwrap_failed((__int64)&off_5A1F0);
  if ( (__int64)(a3 + 1) < 0 )
    alloc::raw_vec::capacity_overflow();
  v5 = (void *)_rust_alloc(a3 + 1, 1LL);
  if ( !v5 )
    alloc::alloc::handle_alloc_error(1LL, v3);
  v6 = (__int64)v5;
  memcpy(v5, a2, a3);
  if ( a3 >= 0x10 )
  {
    v8 = core::slice::memchr::memchr_aligned(0, (__int64)a2, a3);
  }
  else
  {
    if ( a3 )
    {
      v7 = 0LL;
      while ( *((_BYTE *)a2 + v7) )
      {
        if ( a3 == ++v7 )
          goto LABEL_15;
      }
      goto LABEL_13;
    }
    v7 = 0LL;
    v8 = 0LL;
  }
  if ( !v8 )
  {
LABEL_15:
    v11[0] = v3;
    v11[1] = v6;
    v11[2] = a3;
    a1[1] = alloc::ffi::c_str::CString::_from_vec_unchecked(v11);
    a1[2] = v9;
    *a1 = 0x8000000000000000LL;
    return a1;
  }
LABEL_13:
  *a1 = v3;
  a1[1] = v6;
  a1[2] = a3;
  a1[3] = v7;
  return a1;
}
// 4188E: variable 'v7' is possibly undefined
// 418B9: variable 'v9' is possibly undefined
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 5A1F0: using guessed type char *off_5A1F0;

//----- (0000000000041920) ----------------------------------------------------
__int64 __fastcall alloc::ffi::c_str::CString::_from_vec_unchecked(__int64 *a1)
{
  __int64 v1; // r14
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // r12
  unsigned __int64 v5; // rbx
  __int64 result; // rax
  __int64 v7; // [rsp+8h] [rbp-50h] BYREF
  __int64 v8; // [rsp+10h] [rbp-48h]
  __int64 v9; // [rsp+18h] [rbp-40h]
  __int64 v10[7]; // [rsp+20h] [rbp-38h] BYREF

  v1 = *a1;
  v2 = a1[2];
  if ( *a1 == v2 )
  {
    v1 = v2 + 1;
    if ( v2 != -1 )
    {
      if ( v2 )
      {
        v10[0] = a1[1];
        v10[2] = v2;
        v3 = 1LL;
      }
      else
      {
        v3 = 0LL;
      }
      v10[1] = v3;
      alloc::raw_vec::finish_grow(&v7, v1 >= 0, v2 + 1, v10);
      if ( !v7 )
      {
        a1[1] = v8;
        *a1 = v1;
        goto LABEL_8;
      }
      if ( v8 )
        alloc::alloc::handle_alloc_error(v8, v9);
    }
    alloc::raw_vec::capacity_overflow();
  }
LABEL_8:
  if ( v2 == v1 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve_for_push(a1, v2);
    v1 = *a1;
    v2 = a1[2];
  }
  v4 = a1[1];
  *(_BYTE *)(v4 + v2) = 0;
  v5 = v2 + 1;
  a1[2] = v5;
  if ( v1 <= v5 )
    return v4;
  if ( v5 )
  {
    result = _rust_realloc(v4, v1, 1LL, v5);
    if ( !result )
      alloc::alloc::handle_alloc_error(1LL, v5);
  }
  else
  {
    _rust_dealloc(v4, v1, 1LL);
    return 1LL;
  }
  return result;
}
// 9B20: using guessed type __int64 __fastcall _rust_dealloc(_QWORD, _QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall _rust_realloc(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000041A70) ----------------------------------------------------
_OWORD *__fastcall alloc::string::String::from_utf8_lossy(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r13
  _OWORD *v4; // rbx
  const char *v5; // r12
  size_t v6; // r15
  __int64 v7; // rax
  __int64 v8; // rbp
  __int64 v9; // r14
  __int64 v10; // r14
  __int64 v11; // r14
  void *v12; // rbp
  size_t v13; // rbx
  __int64 v14; // r15
  __int64 v15; // r13
  __int128 v17; // [rsp+8h] [rbp-90h] BYREF
  __int64 v18; // [rsp+18h] [rbp-80h]
  _QWORD *v19; // [rsp+20h] [rbp-78h]
  __int128 v20; // [rsp+28h] [rbp-70h] BYREF
  void *src; // [rsp+38h] [rbp-60h] BYREF
  size_t n; // [rsp+40h] [rbp-58h]
  __int64 v23; // [rsp+50h] [rbp-48h]
  __int128 v24[4]; // [rsp+58h] [rbp-40h] BYREF

  v3 = a3;
  v4 = a1;
  *(_QWORD *)&v20 = a2;
  *((_QWORD *)&v20 + 1) = a3;
  <core::str::lossy::Utf8Chunks as core::iter::traits::iterator::Iterator>::next(&src, (__int64 *)&v20);
  v5 = (const char *)src;
  if ( !src )
  {
    v5 = aCalledResultUn_0;
    v6 = 0LL;
    goto LABEL_8;
  }
  v6 = n;
  if ( !v23 )
  {
LABEL_8:
    a1[1] = v5;
    a1[2] = v6;
    *a1 = 0x8000000000000000LL;
    return v4;
  }
  v19 = a1;
  if ( v3 )
  {
    if ( v3 < 0 )
      alloc::raw_vec::capacity_overflow();
    v7 = _rust_alloc(v3, 1LL);
    if ( !v7 )
      alloc::alloc::handle_alloc_error(1LL, v3);
    v8 = v7;
  }
  else
  {
    v8 = 1LL;
  }
  *(_QWORD *)&v17 = v3;
  *((_QWORD *)&v17 + 1) = v8;
  v18 = 0LL;
  if ( v6 <= v3 )
  {
    v9 = 0LL;
  }
  else
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v17, 0LL, v6);
    v9 = v18;
    v8 = *((_QWORD *)&v17 + 1);
    v3 = v17;
  }
  memcpy((void *)(v9 + v8), v5, v6);
  v10 = v6 + v9;
  v18 = v10;
  if ( (unsigned __int64)(v3 - v10) <= 2 )
  {
    alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v17, v10, 3LL);
    v8 = *((_QWORD *)&v17 + 1);
    v10 = v18;
  }
  *(_BYTE *)(v8 + v10 + 2) = -67;
  *(_WORD *)(v8 + v10) = -16401;
  v11 = v10 + 3;
  v18 = v11;
  v24[0] = v20;
  while ( 1 )
  {
    <core::str::lossy::Utf8Chunks as core::iter::traits::iterator::Iterator>::next(&src, (__int64 *)v24);
    v12 = src;
    if ( !src )
      break;
    v13 = n;
    v14 = v23;
    if ( (__int64)v17 - v11 < n )
    {
      alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v17, v11, n);
      v11 = v18;
    }
    v15 = *((_QWORD *)&v17 + 1);
    memcpy((void *)(v11 + *((_QWORD *)&v17 + 1)), v12, v13);
    v11 += v13;
    v18 = v11;
    if ( v14 )
    {
      if ( (unsigned __int64)(v17 - v11) <= 2 )
      {
        alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle((__int64 *)&v17, v11, 3LL);
        v15 = *((_QWORD *)&v17 + 1);
        v11 = v18;
      }
      *(_BYTE *)(v15 + v11 + 2) = -67;
      *(_WORD *)(v15 + v11) = -16401;
      v11 += 3LL;
      v18 = v11;
    }
  }
  v4 = v19;
  v19[2] = v18;
  *v4 = v17;
  return v4;
}
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);
// 41A70: using guessed type __int128 var_40[4];

//----- (0000000000041CE0) ----------------------------------------------------
__int64 __fastcall alloc::string::String::try_reserve(__int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rdx
  __int64 result; // rax
  bool v5; // cf
  unsigned __int64 v6; // rdx
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // [rsp+0h] [rbp-48h] BYREF
  __int64 v10; // [rsp+8h] [rbp-40h]
  __int64 v11[6]; // [rsp+18h] [rbp-30h] BYREF

  v2 = *a1;
  v3 = a1[2];
  result = 0x8000000000000001LL;
  if ( *a1 - v3 < a2 )
  {
    v5 = __CFADD__(a2, v3);
    v6 = a2 + v3;
    if ( v5 )
    {
      return 0LL;
    }
    else
    {
      if ( 2 * v2 > v6 )
        v6 = 2 * v2;
      v7 = 8LL;
      if ( v6 >= 9 )
        v7 = v6;
      if ( v2 )
      {
        v11[0] = a1[1];
        v11[2] = v2;
        v8 = 1LL;
      }
      else
      {
        v8 = 0LL;
      }
      v11[1] = v8;
      alloc::raw_vec::finish_grow(&v9, v7 >= 0, v7, v11);
      if ( v9 )
      {
        return v10;
      }
      else
      {
        a1[1] = v10;
        *a1 = v7;
        return 0x8000000000000001LL;
      }
    }
  }
  return result;
}

//----- (0000000000041DA0) ----------------------------------------------------
__int64 *__fastcall <alloc::string::String as core::convert::From<alloc::borrow::Cow<str>>>::from(
        __int64 *a1,
        __int64 a2)
{
  const void *v2; // r15
  __int64 v3; // r14
  __int64 v4; // rax
  void *v5; // r12

  if ( *(_QWORD *)a2 == 0x8000000000000000LL )
  {
    v2 = *(const void **)(a2 + 8);
    v3 = *(_QWORD *)(a2 + 16);
    if ( v3 )
    {
      if ( v3 < 0 )
        alloc::raw_vec::capacity_overflow();
      v4 = _rust_alloc(v3, 1LL);
      if ( !v4 )
        alloc::alloc::handle_alloc_error(1LL, v3);
      v5 = (void *)v4;
    }
    else
    {
      v5 = &dword_0 + 1;
    }
    memcpy(v5, v2, v3);
    *a1 = v3;
    a1[1] = (__int64)v5;
    a1[2] = v3;
  }
  else
  {
    a1[2] = *(_QWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
  }
  return a1;
}
// 0: using guessed type int dword_0;
// 9B10: using guessed type __int64 __fastcall _rust_alloc(_QWORD, _QWORD);

//----- (0000000000041E40) ----------------------------------------------------
__int64 __fastcall alloc::sync::arcinner_layout_for_value_layout(unsigned __int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdi
  bool v4; // cf
  __int64 v5; // rdi
  unsigned __int64 v6; // rdi
  char v7; // [rsp+1h] [rbp-1h] BYREF

  result = 8LL;
  if ( a1 >= 9 )
    result = a1;
  v3 = ((a1 + 15) & -(__int64)a1) - 16;
  v4 = __CFADD__(v3, 16LL);
  v5 = v3 + 16;
  if ( v4 || (v4 = __CFADD__(a2, v5), v6 = a2 + v5, v4) || v6 > 0x8000000000000000LL - result )
  {
    v7 = HIBYTE(result);
    core::result::unwrap_failed(
      (__int64)aCalledResultUn_0,
      43LL,
      (__int64)&v7,
      (__int64)&off_5A1A8,
      (__int64)&off_5A208);
  }
  return result;
}
// 5A1A8: using guessed type __int64 (__fastcall *off_5A1A8)();
// 5A208: using guessed type char *off_5A208;

//----- (0000000000041EB0) ----------------------------------------------------
void __noreturn core::ops::function::FnOnce::call_once()
{
  while ( 1 )
    ;
}
// 41EB0: using guessed type void __noreturn core::ops::function::FnOnce::call_once();

//----- (0000000000041EF0) ----------------------------------------------------
__int64 __fastcall core::num::from_str_radix(unsigned __int8 *a1, unsigned __int64 a2, unsigned int a3)
{
  __int64 v4; // rcx
  int v5; // eax
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // rax
  int v9; // r10d
  unsigned int v10; // r11d
  int v11; // r10d
  bool v12; // cf
  unsigned int v13; // r10d
  __int64 v14; // r9
  int v15; // ebx
  int v16; // kr00_4
  unsigned int v17; // ebp
  int v18; // ebx
  unsigned int v19; // ebx
  int v20; // kr08_4
  unsigned int v21; // r10d
  unsigned int v22; // r9d
  unsigned int v24; // [rsp+4h] [rbp-54h] BYREF
  __int64 v25[2]; // [rsp+8h] [rbp-50h] BYREF
  __int64 v26[8]; // [rsp+18h] [rbp-40h] BYREF

  v24 = a3;
  if ( a3 - 2 >= 0x23 )
  {
    v25[0] = (__int64)&v24;
    v25[1] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt;
    v26[0] = (__int64)&off_5A220;
    v26[1] = 1LL;
    v26[4] = 0LL;
    v26[2] = (__int64)v25;
    v26[3] = 1LL;
    core::panicking::panic_fmt((__int64)v26, (__int64)&off_5A230);
  }
  v4 = 1LL;
  if ( !a2 )
  {
    v6 = 0LL;
    return v6 | v4;
  }
  v5 = *a1;
  if ( v5 == 43 )
  {
    if ( !--a2 )
    {
LABEL_20:
      v6 = 256LL;
      return v6 | v4;
    }
    ++a1;
    if ( a3 > 0x10 || a2 >= 9 )
      goto LABEL_21;
LABEL_13:
    v7 = 0LL;
    if ( a3 <= 0xA )
    {
      LODWORD(v8) = 0;
      while ( 1 )
      {
        v22 = a1[v7] - 48;
        if ( v22 >= a3 )
          break;
        v8 = v22 + a3 * (_DWORD)v8;
        if ( a2 == ++v7 )
          goto LABEL_40;
      }
    }
    else
    {
      LODWORD(v8) = 0;
      while ( 1 )
      {
        v9 = a1[v7];
        v10 = v9 - 48;
        if ( (unsigned int)(v9 - 48) >= 0xA )
        {
          v11 = (v9 | 0x20) - 97;
          v12 = __CFADD__(v11, 10);
          v13 = v11 + 10;
          if ( v12 )
            v13 = -1;
          v10 = v13;
          if ( v13 >= a3 )
            break;
        }
        v8 = v10 + a3 * (_DWORD)v8;
        if ( a2 == ++v7 )
          goto LABEL_40;
      }
    }
    goto LABEL_20;
  }
  if ( v5 == 45 )
  {
    v6 = 256LL;
    if ( a2 == 1 )
      return v6 | v4;
  }
  if ( a2 <= 8 && a3 <= 0x10 )
    goto LABEL_13;
LABEL_21:
  v14 = 0LL;
  if ( a3 <= 0xA )
  {
    v8 = 0LL;
    while ( a2 != v14 )
    {
      v20 = a3 * v8;
      v21 = a1[v14] - 48;
      if ( v21 >= a3 || !is_mul_ok(a3, v8) )
      {
        v6 = ((unsigned __int8)(v21 < a3) << 8) + 256LL;
        return v6 | v4;
      }
      ++v14;
      v8 = v21 + v20;
      if ( __CFADD__(v21, v20) )
      {
        v6 = 512LL;
        return v6 | v4;
      }
    }
  }
  else
  {
    v8 = 0LL;
    while ( a2 != v14 )
    {
      v15 = a1[v14];
      v16 = a3 * v8;
      v17 = v15 - 48;
      if ( (unsigned int)(v15 - 48) >= 0xA )
      {
        v18 = (v15 | 0x20) - 97;
        v12 = __CFADD__(v18, 10);
        v19 = v18 + 10;
        if ( v12 )
          v19 = -1;
        v17 = v19;
        if ( v19 >= a3 )
          goto LABEL_20;
      }
      v6 = 512LL;
      if ( is_mul_ok(a3, v8) )
      {
        ++v14;
        v8 = v17 + v16;
        if ( !__CFADD__(v17, v16) )
          continue;
      }
      return v6 | v4;
    }
  }
LABEL_40:
  v4 = 0LL;
  v6 = v8 << 32;
  return v6 | v4;
}
// 5A220: using guessed type void *off_5A220;
// 5A230: using guessed type char *off_5A230;

//----- (0000000000042100) ----------------------------------------------------
char __fastcall core::num::from_str_radix(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, unsigned int a4)
{
  unsigned __int64 v4; // r8
  int v5; // eax
  __int64 v6; // r9
  __int64 v7; // rax
  int v8; // r11d
  unsigned int v9; // ebx
  int v10; // r11d
  bool v11; // cf
  unsigned int v12; // r11d
  __int64 v13; // r10
  int v14; // ebx
  unsigned __int128 v15; // rax
  unsigned int v16; // ebp
  int v17; // ebx
  unsigned int v18; // ebx
  unsigned __int128 v19; // rax
  unsigned int v20; // r11d
  char result; // al
  __int64 v22; // r10
  unsigned int v23; // eax
  unsigned int v24; // [rsp+4h] [rbp-54h] BYREF
  __int64 v25[2]; // [rsp+8h] [rbp-50h] BYREF
  __int64 v26[8]; // [rsp+18h] [rbp-40h] BYREF

  v24 = a4;
  if ( a4 - 2 >= 0x23 )
  {
    v25[0] = (__int64)&v24;
    v25[1] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt;
    v26[0] = (__int64)&off_5A220;
    v26[1] = 1LL;
    v26[4] = 0LL;
    v26[2] = (__int64)v25;
    v26[3] = 1LL;
    core::panicking::panic_fmt((__int64)v26, (__int64)&off_5A230);
  }
  v4 = a3;
  if ( !a3 )
  {
    *(_BYTE *)(a1 + 1) = 0;
LABEL_37:
    result = 1;
    goto LABEL_38;
  }
  v5 = *a2;
  if ( v5 == 43 )
  {
    v4 = a3 - 1;
    if ( a3 != 1 )
    {
      ++a2;
      if ( a4 > 0x10 || v4 > 0x10 )
        goto LABEL_21;
      goto LABEL_13;
    }
LABEL_20:
    *(_BYTE *)(a1 + 1) = 1;
    goto LABEL_37;
  }
  if ( v5 == 45 && a3 == 1 )
    goto LABEL_20;
  if ( a3 <= 0x10 && a4 <= 0x10 )
  {
LABEL_13:
    v6 = 0LL;
    if ( a4 <= 0xA )
    {
      v22 = 0LL;
      while ( 1 )
      {
        v23 = a2[v6] - 48;
        if ( v23 >= a4 )
          break;
        v7 = a4 * v22 + v23;
        ++v6;
        v22 = v7;
        if ( v4 == v6 )
          goto LABEL_42;
      }
    }
    else
    {
      v7 = 0LL;
      while ( 1 )
      {
        v8 = a2[v6];
        v9 = v8 - 48;
        if ( (unsigned int)(v8 - 48) >= 0xA )
        {
          v10 = (v8 | 0x20) - 97;
          v11 = __CFADD__(v10, 10);
          v12 = v10 + 10;
          if ( v11 )
            v12 = -1;
          v9 = v12;
          if ( v12 >= a4 )
            break;
        }
        v7 = v9 + a4 * v7;
        if ( v4 == ++v6 )
          goto LABEL_42;
      }
    }
    goto LABEL_20;
  }
LABEL_21:
  v13 = 0LL;
  if ( a4 <= 0xA )
  {
    v7 = 0LL;
    while ( v4 != v13 )
    {
      v19 = a4 * (unsigned __int128)(unsigned __int64)v7;
      BYTE8(v19) = *((_QWORD *)&v19 + 1) != 0LL;
      v20 = a2[v13] - 48;
      if ( v20 >= a4 )
        goto LABEL_20;
      if ( !BYTE8(v19) )
      {
        ++v13;
        v11 = __CFADD__(v20, (_QWORD)v19);
        v7 = v20 + (_QWORD)v19;
        if ( !v11 )
          continue;
      }
LABEL_36:
      *(_BYTE *)(a1 + 1) = 2;
      goto LABEL_37;
    }
  }
  else
  {
    v7 = 0LL;
    while ( v4 != v13 )
    {
      v14 = a2[v13];
      v15 = a4 * (unsigned __int128)(unsigned __int64)v7;
      BYTE8(v15) = *((_QWORD *)&v15 + 1) != 0LL;
      v16 = v14 - 48;
      if ( (unsigned int)(v14 - 48) >= 0xA )
      {
        v17 = (v14 | 0x20) - 97;
        v11 = __CFADD__(v17, 10);
        v18 = v17 + 10;
        if ( v11 )
          v18 = -1;
        v16 = v18;
        if ( v18 >= a4 )
          goto LABEL_20;
      }
      if ( !BYTE8(v15) )
      {
        ++v13;
        v11 = __CFADD__(v16, (_QWORD)v15);
        v7 = v16 + (_QWORD)v15;
        if ( !v11 )
          continue;
      }
      goto LABEL_36;
    }
  }
LABEL_42:
  *(_QWORD *)(a1 + 8) = v7;
  result = 0;
LABEL_38:
  *(_BYTE *)a1 = result;
  return result;
}
// 5A220: using guessed type void *off_5A220;
// 5A230: using guessed type char *off_5A230;

//----- (0000000000042300) ----------------------------------------------------
char __fastcall <core::ops::range::Range<Idx> as core::fmt::Debug>::fmt(unsigned __int64 *a1, __int64 a2)
{
  if ( (unsigned __int8)core::fmt::num::<impl core::fmt::Debug for usize>::fmt(a1, a2)
    || (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 40) + 24LL))(
         *(_QWORD *)(a2 + 32),
         asc_4C91B,
         2LL) )
  {
    return 1;
  }
  else
  {
    return core::fmt::num::<impl core::fmt::Debug for usize>::fmt(a1 + 1, a2);
  }
}

//----- (0000000000042350) ----------------------------------------------------
__int64 <T as core::any::Any>::type_id()
{
  return 0x1D879E542ED896BELL;
}
// 42350: using guessed type __int64 <T as core::any::Any>::type_id();

//----- (0000000000042370) ----------------------------------------------------
__int64 __fastcall <core::cell::BorrowMutError as core::fmt::Debug>::fmt(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 40) + 24LL))(
           *(_QWORD *)(a2 + 32),
           aBorrowmuterror,
           14LL);
}

//----- (0000000000042390) ----------------------------------------------------
char __fastcall core::char::methods::<impl char>::escape_debug_ext(__int64 a1, unsigned int a2, int a3)
{
  unsigned __int64 v3; // rax
  unsigned int v4; // eax
  __int64 v5; // rdx
  unsigned int v7; // edi
  unsigned __int64 v8; // rdi
  __int64 v9; // rcx
  __int64 v11; // [rsp+Eh] [rbp-2Ah]
  __int16 v12; // [rsp+16h] [rbp-22h]
  __int64 v13; // [rsp+18h] [rbp-20h]
  __int16 v14; // [rsp+20h] [rbp-18h]

  LOBYTE(v3) = a2;
  switch ( a2 )
  {
    case 0u:
      *(_WORD *)a1 = 12380;
      goto LABEL_21;
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 0xBu:
    case 0xCu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x23u:
    case 0x24u:
    case 0x25u:
    case 0x26u:
      goto LABEL_5;
    case 9u:
      *(_WORD *)a1 = 29788;
      goto LABEL_21;
    case 0xAu:
      *(_WORD *)a1 = 28252;
      goto LABEL_21;
    case 0xDu:
      *(_WORD *)a1 = 29276;
      goto LABEL_21;
    case 0x22u:
      if ( (a3 & 0x10000) == 0 )
        goto LABEL_16;
      *(_WORD *)a1 = 8796;
      goto LABEL_21;
    case 0x27u:
      if ( (a3 & 0x100) == 0 )
        goto LABEL_16;
      *(_WORD *)a1 = 10076;
      goto LABEL_21;
    default:
      if ( a2 == 92 )
      {
        *(_WORD *)a1 = 23644;
LABEL_21:
        *(_QWORD *)(a1 + 2) = 0LL;
        *(_WORD *)(a1 + 10) = 512;
      }
      else
      {
LABEL_5:
        if ( a2 >= 0x80 && (a3 & 1) != 0 && core::unicode::unicode_data::grapheme_extend::lookup(a2) )
        {
          BYTE2(v11) = 0;
          LOWORD(v11) = 0;
          HIBYTE(v12) = 125;
          BYTE3(v11) = a0123456789abcd[(a2 >> 20) & 0xF];
          BYTE4(v11) = a0123456789abcd[HIWORD(a2) & 0xF];
          BYTE5(v11) = a0123456789abcd[(unsigned __int16)a2 >> 12];
          BYTE6(v11) = a0123456789abcd[(a2 >> 8) & 0xF];
          HIBYTE(v11) = a0123456789abcd[(unsigned __int8)a2 >> 4];
          LOBYTE(v12) = a0123456789abcd[a2 & 0xF];
          _BitScanReverse(&v4, a2 | 1);
          v3 = ((v4 ^ 0x1C) >> 2) - 2LL;
          if ( v3 >= 0xB )
            core::slice::index::slice_start_index_len_fail(v3, 10LL, (__int64)&off_5A6A8);
          *((_BYTE *)&v11 + v3 + 2) = 123;
          *(_WORD *)((char *)&v11 + v3) = 30044;
          v14 = v12;
          v5 = v11;
          v13 = v11;
          *(_WORD *)(a1 + 8) = v12;
          *(_QWORD *)a1 = v5;
          *(_BYTE *)(a1 + 10) = v3;
          *(_BYTE *)(a1 + 11) = 10;
        }
        else
        {
LABEL_16:
          LOBYTE(v3) = core::unicode::printable::is_printable(a2);
          if ( (_BYTE)v3 )
          {
            *(_BYTE *)a1 = 0x80;
            *(_DWORD *)(a1 + 4) = a2;
          }
          else
          {
            BYTE2(v11) = 0;
            LOWORD(v11) = 0;
            HIBYTE(v12) = 125;
            BYTE3(v11) = a0123456789abcd[(a2 >> 20) & 0xF];
            BYTE4(v11) = a0123456789abcd[HIWORD(a2) & 0xF];
            BYTE5(v11) = a0123456789abcd[(unsigned __int16)a2 >> 12];
            BYTE6(v11) = a0123456789abcd[(a2 >> 8) & 0xF];
            HIBYTE(v11) = a0123456789abcd[(unsigned __int8)a2 >> 4];
            LOBYTE(v12) = a0123456789abcd[a2 & 0xF];
            _BitScanReverse(&v7, a2 | 1);
            v8 = ((v7 ^ 0x1C) >> 2) - 2LL;
            if ( v8 >= 0xB )
              core::slice::index::slice_start_index_len_fail(v8, 10LL, (__int64)&off_5A6A8);
            *((_BYTE *)&v11 + v8 + 2) = 123;
            *(_WORD *)((char *)&v11 + v8) = 30044;
            LOBYTE(v3) = v12;
            v14 = v12;
            v9 = v11;
            v13 = v11;
            *(_WORD *)(a1 + 8) = v12;
            *(_QWORD *)a1 = v9;
            *(_BYTE *)(a1 + 10) = v8;
            *(_BYTE *)(a1 + 11) = 10;
          }
        }
      }
      return v3;
  }
}
// 5A6A8: using guessed type char *off_5A6A8;

//----- (0000000000042620) ----------------------------------------------------
__int64 __fastcall core::char::EscapeUnicode::new(__int64 a1, unsigned int a2)
{
  unsigned int v2; // eax
  unsigned __int64 v3; // rax
  __int64 v5; // [rsp+Eh] [rbp-Ah]
  __int16 v6; // [rsp+16h] [rbp-2h]

  BYTE2(v5) = 0;
  LOWORD(v5) = 0;
  HIBYTE(v6) = 125;
  BYTE3(v5) = a0123456789abcd[(a2 >> 20) & 0xF];
  BYTE4(v5) = a0123456789abcd[HIWORD(a2) & 0xF];
  BYTE5(v5) = a0123456789abcd[(unsigned __int16)a2 >> 12];
  BYTE6(v5) = a0123456789abcd[(a2 >> 8) & 0xF];
  HIBYTE(v5) = a0123456789abcd[(unsigned __int8)a2 >> 4];
  LOBYTE(v6) = a0123456789abcd[a2 & 0xF];
  _BitScanReverse(&v2, a2 | 1);
  v3 = ((v2 ^ 0x1C) >> 2) - 2LL;
  if ( v3 >= 0xB )
    core::slice::index::slice_start_index_len_fail(v3, 10LL, (__int64)&off_5A6A8);
  *((_BYTE *)&v5 + v3 + 2) = 123;
  *(_WORD *)((char *)&v5 + v3) = 30044;
  *(_WORD *)(a1 + 8) = v6;
  *(_QWORD *)a1 = v5;
  *(_BYTE *)(a1 + 10) = v3;
  *(_BYTE *)(a1 + 11) = 10;
  return a1;
}
// 5A6A8: using guessed type char *off_5A6A8;

//----- (00000000000426F0) ----------------------------------------------------
__int64 __fastcall core::char::EscapeDebug::backslash(__int64 a1, __int16 a2)
{
  __int64 result; // rax

  result = a1;
  *(_WORD *)a1 = (a2 << 8) | 0x5C;
  *(_QWORD *)(a1 + 2) = 0LL;
  *(_WORD *)(a1 + 10) = 512;
  return result;
}

//----- (0000000000042710) ----------------------------------------------------
void __fastcall core::char::EscapeDebug::clear(__int64 a1)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = 0LL;
}

//----- (0000000000042720) ----------------------------------------------------
_QWORD *__fastcall core::ffi::c_str::CStr::from_bytes_with_nul(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  _QWORD *result; // rax
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rdi
  __m128i si128; // xmm0
  __m128i v8; // xmm1
  __m128i v9; // xmm1

  result = a1;
  if ( a3 >= 0x10 )
  {
    v5 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8LL) - a2;
    if ( v5 )
    {
      v4 = 0LL;
      while ( *(_BYTE *)(a2 + v4) )
      {
        if ( v5 == ++v4 )
        {
          v6 = a3 - 16;
          if ( v5 <= a3 - 16 )
            goto LABEL_14;
          goto LABEL_17;
        }
      }
      goto LABEL_22;
    }
    v6 = a3 - 16;
LABEL_14:
    si128 = _mm_load_si128((const __m128i *)&xmmword_4C660);
    do
    {
      v8 = _mm_loadu_si128((const __m128i *)(a2 + v5));
      v9 = _mm_andnot_si128(v8, _mm_add_epi64(v8, si128));
      if ( (_mm_or_si128(_mm_shuffle_epi32(v9, 238), v9).m128i_u64[0] & 0x8080808080808080LL) != 0 )
        break;
      v5 += 16LL;
    }
    while ( v5 <= v6 );
LABEL_17:
    if ( v5 != a3 )
    {
      while ( *(_BYTE *)(a2 + v5) )
      {
        if ( a3 == ++v5 )
          goto LABEL_20;
      }
      v4 = v5;
      goto LABEL_22;
    }
LABEL_20:
    result[1] = 1LL;
    *result = 1LL;
    return result;
  }
  if ( !a3 )
    goto LABEL_20;
  v4 = 0LL;
  while ( *(_BYTE *)(a2 + v4) )
  {
    if ( a3 == ++v4 )
      goto LABEL_20;
  }
LABEL_22:
  if ( v4 + 1 == a3 )
  {
    result[1] = a2;
    result[2] = a3;
    *result = 0LL;
  }
  else
  {
    result[1] = 0LL;
    result[2] = v4;
    *result = 1LL;
  }
  return result;
}
// 4C660: using guessed type __int128 xmmword_4C660;

//----- (0000000000042840) ----------------------------------------------------
char __fastcall <core::panic::location::Location as core::fmt::Display>::fmt(__int64 a1, __int64 a2)
{
  __int64 v3[6]; // [rsp+8h] [rbp-60h] BYREF
  __int64 v4[6]; // [rsp+38h] [rbp-30h] BYREF

  v3[0] = a1;
  v3[1] = (__int64)<&T as core::fmt::Display>::fmt;
  v3[2] = a1 + 16;
  v3[3] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt;
  v3[4] = a1 + 20;
  v3[5] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt;
  v4[0] = (__int64)&off_5A268;
  v4[1] = 3LL;
  v4[4] = 0LL;
  v4[2] = (__int64)v3;
  v4[3] = 3LL;
  return core::fmt::write(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40), v4);
}
// 5A268: using guessed type void *off_5A268;

//----- (00000000000428D0) ----------------------------------------------------
__int64 __fastcall <core::panic::panic_info::PanicInfo as core::fmt::Display>::fmt(const char ***a1, __int64 a2)
{
  unsigned int v2; // ebx
  __int64 v3; // r14
  __int64 v4; // r15
  unsigned __int8 (__fastcall *v5)(__int64, const char *, __int64); // r13
  __int128 *v6; // rbp
  __int128 v7; // xmm0
  __int128 v8; // xmm1
  const char **v9; // r15
  __int64 v10; // rdx
  __int128 v12; // [rsp+0h] [rbp-98h] BYREF
  __int128 v13; // [rsp+10h] [rbp-88h]
  __int128 v14; // [rsp+20h] [rbp-78h]
  __int64 v15[12]; // [rsp+38h] [rbp-60h] BYREF

  v3 = *(_QWORD *)(a2 + 32);
  v4 = *(_QWORD *)(a2 + 40);
  v5 = *(unsigned __int8 (__fastcall **)(__int64, const char *, __int64))(v4 + 24);
  LOBYTE(v2) = 1;
  if ( !v5(v3, aPanickedAt_0, 12LL) )
  {
    *(_QWORD *)&v12 = a1[3];
    *((_QWORD *)&v12 + 1) = <&T as core::fmt::Display>::fmt;
    *(_QWORD *)&v13 = v12 + 16;
    *((_QWORD *)&v13 + 1) = core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt;
    *(_QWORD *)&v14 = v12 + 20;
    *((_QWORD *)&v14 + 1) = core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt;
    v15[0] = (__int64)&off_5A268;
    v15[1] = 3LL;
    v15[4] = 0LL;
    v15[2] = (__int64)&v12;
    v15[3] = 3LL;
    if ( !core::fmt::write(v3, v4, v15) )
    {
      v6 = (__int128 *)a1[2];
      if ( v6 )
      {
        if ( v5(v3, asc_4C9F6, 2LL) )
          return v2;
        v7 = *v6;
        v8 = v6[1];
        v14 = v6[2];
        v13 = v8;
        v12 = v7;
        if ( core::fmt::write(v3, v4, &v12) )
          return v2;
        return 0;
      }
      v9 = *a1;
      if ( ((__int64 (__fastcall *)(const char **))a1[1][3])(*a1) != 0xFDBC168100B1EF64LL
        || v10 != 0xC1A2C89CCD1E7BC1LL
        || !v5(v3, asc_4C9F6, 2LL) && !v5(v3, *v9, (__int64)v9[1]) )
      {
        return 0;
      }
    }
  }
  return v2;
}
// 42A07: variable 'v10' is possibly undefined
// 42A32: variable 'v2' is possibly undefined
// 5A268: using guessed type void *off_5A268;

//----- (0000000000042A50) ----------------------------------------------------
void __fastcall __noreturn core::panicking::panic_display(__int64 a1, __int64 a2)
{
  __int64 v2[2]; // [rsp+8h] [rbp-40h] BYREF
  __int64 v3[6]; // [rsp+18h] [rbp-30h] BYREF

  v2[0] = a1;
  v2[1] = (__int64)<&T as core::fmt::Display>::fmt;
  v3[0] = (__int64)&off_5A258;
  v3[1] = 1LL;
  v3[4] = 0LL;
  v3[2] = (__int64)v2;
  v3[3] = 1LL;
  core::panicking::panic_fmt((__int64)v3, a2);
}
// 5A258: using guessed type void *off_5A258;

//----- (0000000000042AB0) ----------------------------------------------------
char __fastcall <core::fmt::builders::PadAdapter as core::fmt::Write>::write_str(
        __int64 *a1,
        __int64 a2,
        unsigned __int64 a3,
        __m128i a4,
        double a5)
{
  unsigned __int64 v6; // r12
  __m128i si128; // xmm2
  __m128i v8; // xmm3
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r13
  char *v11; // rcx
  const __m128i *v12; // rax
  char *v13; // rdi
  const __m128i *v14; // r9
  char *v15; // rdx
  unsigned __int64 v16; // rdi
  __m128i v17; // xmm0
  char v18; // r14
  unsigned __int64 v19; // rbp
  char v20; // al
  bool v21; // al
  __int64 v23; // [rsp+8h] [rbp-50h]
  __int64 v24; // [rsp+10h] [rbp-48h]
  __int64 v25; // [rsp+18h] [rbp-40h]
  bool *v26; // [rsp+20h] [rbp-38h]

  v26 = (bool *)a1[2];
  v25 = *a1;
  v24 = a1[1];
  v6 = 0LL;
  si128 = _mm_load_si128((const __m128i *)&xmmword_4C670);
  v8 = _mm_load_si128((const __m128i *)&xmmword_4C660);
  v9 = 0LL;
  v23 = a2;
  do
  {
    if ( v6 > a3 )
    {
      v10 = v6;
      goto LABEL_29;
    }
    while ( 1 )
    {
      v11 = (char *)(a3 - v6);
      v12 = (const __m128i *)(a2 + v6);
      if ( a3 - v6 >= 0x10 )
        break;
      if ( a3 == v6 )
        goto LABEL_28;
      v13 = 0LL;
      while ( v13[(_QWORD)v12] != 10 )
      {
        if ( v11 == ++v13 )
          goto LABEL_28;
      }
LABEL_25:
      v10 = (unsigned __int64)&v13[v6 + 1];
      if ( (unsigned __int64)&v13[v6] < a3 && v12->m128i_i8[(_QWORD)v13] == 10 )
      {
        v18 = 1;
        v6 += (unsigned __int64)(v13 + 1);
        v19 = v10;
        goto LABEL_30;
      }
      v6 += (unsigned __int64)(v13 + 1);
      if ( v10 > a3 )
        goto LABEL_29;
    }
    v14 = (const __m128i *)(((unsigned __int64)v12->m128i_u64 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    v15 = (char *)((char *)v14 - (char *)v12);
    if ( v14 != v12 )
    {
      v13 = 0LL;
      while ( v13[(_QWORD)v12] != 10 )
      {
        if ( v15 == ++v13 )
        {
          v16 = (unsigned __int64)(v11 - 16);
          goto LABEL_17;
        }
      }
      goto LABEL_25;
    }
    v16 = (unsigned __int64)(v11 - 16);
    do
    {
      v17 = _mm_loadu_si128(v14);
      a4 = _mm_andnot_si128(v17, _mm_add_epi64(_mm_xor_si128(v17, si128), v8));
      *(_QWORD *)&a5 = _mm_or_si128(_mm_shuffle_epi32(a4, 238), a4).m128i_u64[0];
      if ( (*(_QWORD *)&a5 & 0x8080808080808080LL) != 0 )
        break;
      v15 += 16;
      ++v14;
LABEL_17:
      ;
    }
    while ( (unsigned __int64)v15 <= v16 );
    if ( v11 != v15 )
    {
      while ( v15[(_QWORD)v12] != 10 )
      {
        if ( v11 == ++v15 )
          goto LABEL_28;
      }
      v13 = v15;
      goto LABEL_25;
    }
LABEL_28:
    v10 = a3;
LABEL_29:
    v18 = 0;
    v6 = v10;
    v10 = v9;
    v19 = a3;
    v20 = 0;
    if ( v9 == a3 )
      return v20 & 1;
LABEL_30:
    if ( *v26 )
    {
      a2 = v23;
      if ( (*(unsigned __int8 (__fastcall **)(__int64, void *, __int64, double, double, double, double))(v24 + 24))(
             v25,
             &unk_4C798,
             4LL,
             *(double *)a4.m128i_i64,
             a5,
             *(double *)si128.m128i_i64,
             *(double *)v8.m128i_i64) )
      {
        v20 = 1;
        return v20 & 1;
      }
    }
    v21 = v19 != v9 && *(_BYTE *)(a2 + v19 - 1) == 10;
    *v26 = v21;
    v20 = -(*(char (__fastcall **)(__int64, unsigned __int64, unsigned __int64, double, double, double, double))(v24 + 24))(
             v25,
             a2 + v9,
             v19 - v9,
             *(double *)a4.m128i_i64,
             a5,
             *(double *)si128.m128i_i64,
             *(double *)v8.m128i_i64);
    if ( v20 )
      break;
    v9 = v10;
    a2 = v23;
    si128 = _mm_load_si128((const __m128i *)&xmmword_4C670);
    v8 = _mm_load_si128((const __m128i *)&xmmword_4C660);
  }
  while ( v18 == 1 );
  return v20 & 1;
}
// 4C660: using guessed type __int128 xmmword_4C660;
// 4C670: using guessed type __int128 xmmword_4C670;

//----- (0000000000042D00) ----------------------------------------------------
char __fastcall <core::fmt::builders::PadAdapter as core::fmt::Write>::write_char(_QWORD *a1, int a2)
{
  bool *v2; // r14
  __int64 v3; // rbx
  __int64 v4; // r15

  v2 = (bool *)a1[2];
  v3 = *a1;
  v4 = a1[1];
  if ( *v2 && (*(unsigned __int8 (__fastcall **)(_QWORD, void *, __int64))(v4 + 24))(*a1, &unk_4C798, 4LL) )
    return 1;
  *v2 = a2 == 10;
  return (*(__int64 (__fastcall **)(__int64))(v4 + 32))(v3);
}

//----- (0000000000042D60) ----------------------------------------------------
_BYTE *__fastcall core::fmt::builders::DebugStruct::field(
        _BYTE *a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        double a6,
        double a7)
{
  char v8; // bp
  __int64 v11; // r15
  int v12; // eax
  char v13; // cl
  unsigned __int64 v15; // r12
  __int64 v16; // rdx
  void *v17; // rsi
  unsigned __int64 v18; // r13
  int v19; // ecx
  char v20; // di
  __m128i v21; // xmm0
  char v22; // [rsp+7h] [rbp-A1h] BYREF
  __int64 v23; // [rsp+8h] [rbp-A0h]
  __int128 v24; // [rsp+10h] [rbp-98h] BYREF
  char *v25; // [rsp+20h] [rbp-88h]
  __int128 v26; // [rsp+30h] [rbp-78h] BYREF
  __m128i v27; // [rsp+40h] [rbp-68h]
  __int128 *v28; // [rsp+50h] [rbp-58h]
  __int64 (__fastcall **v29)(); // [rsp+58h] [rbp-50h]
  int v30; // [rsp+60h] [rbp-48h]
  int v31; // [rsp+64h] [rbp-44h]
  char v32; // [rsp+68h] [rbp-40h]

  v8 = 1;
  if ( !a1[8] )
  {
    v23 = a5;
    v11 = *(_QWORD *)a1;
    v12 = *(_DWORD *)(*(_QWORD *)a1 + 52LL);
    v13 = a1[9];
    if ( (v12 & 4) != 0 )
    {
      if ( !v13 )
      {
        v18 = a3;
        v8 = 1;
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v11 + 40) + 24LL))(
               *(_QWORD *)(v11 + 32),
               asc_4CAAC,
               3LL) )
        {
          goto LABEL_2;
        }
        v12 = *(_DWORD *)(v11 + 52);
        a3 = v18;
      }
      v22 = 1;
      v24 = *(_OWORD *)(v11 + 32);
      v25 = &v22;
      v19 = *(_DWORD *)(v11 + 48);
      v20 = *(_BYTE *)(v11 + 56);
      v31 = v12;
      v30 = v19;
      v32 = v20;
      v26 = *(_OWORD *)v11;
      v27 = *(__m128i *)(v11 + 16);
      v21 = v27;
      v28 = &v24;
      v29 = off_5A398;
      if ( <core::fmt::builders::PadAdapter as core::fmt::Write>::write_str((__int64 *)&v24, a2, a3, v27, a7)
        || <core::fmt::builders::PadAdapter as core::fmt::Write>::write_str(
             (__int64 *)&v24,
             (__int64)asc_4CAA5,
             2uLL,
             v21,
             a7)
        || (*(unsigned __int8 (__fastcall **)(__int64, __int128 *))(v23 + 24))(a4, &v26) )
      {
        v8 = 1;
      }
      else
      {
        v8 = ((__int64 (__fastcall *)(__int128 *, const char *, __int64))v29[3])(v28, asc_4CAAF, 2LL);
      }
    }
    else
    {
      v15 = a3;
      v16 = 0LL;
      v17 = &unk_4CAAA;
      if ( !v13 )
        v17 = &unk_4CAA7;
      LOBYTE(v16) = v13 == 0;
      v8 = 1;
      if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, void *, __int64))(*(_QWORD *)(v11 + 40) + 24LL))(
              *(_QWORD *)(v11 + 32),
              v17,
              v16 | 2)
        && !(*(unsigned __int8 (__fastcall **)(_QWORD, __int64, unsigned __int64))(*(_QWORD *)(v11 + 40) + 24LL))(
              *(_QWORD *)(v11 + 32),
              a2,
              v15)
        && !(*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v11 + 40) + 24LL))(
              *(_QWORD *)(v11 + 32),
              asc_4CAA5,
              2LL) )
      {
        v8 = (*(__int64 (__fastcall **)(__int64, __int64))(v23 + 24))(a4, v11);
      }
    }
  }
LABEL_2:
  a1[8] = v8;
  a1[9] = 1;
  return a1;
}
// 5A398: using guessed type __int64 (__fastcall *off_5A398[2])();

//----- (0000000000042F20) ----------------------------------------------------
char __fastcall core::fmt::builders::DebugStruct::finish(_BYTE *a1)
{
  char v1; // cl
  char result; // al
  __int64 v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rax
  const char *v7; // rsi
  __int64 v8; // rdx

  v1 = a1[8];
  if ( !a1[9] )
    return v1 != 0;
  result = 1;
  if ( v1 )
  {
    a1[8] = 1;
  }
  else
  {
    v4 = *(_QWORD *)a1;
    if ( (*(_BYTE *)(*(_QWORD *)a1 + 52LL) & 4) != 0 )
    {
      v5 = *(_QWORD *)(v4 + 32);
      v6 = *(_QWORD *)(v4 + 40);
      v7 = asc_4CAB1;
      v8 = 1LL;
    }
    else
    {
      v5 = *(_QWORD *)(v4 + 32);
      v6 = *(_QWORD *)(v4 + 40);
      v7 = asc_4CAB2;
      v8 = 2LL;
    }
    result = (*(__int64 (__fastcall **)(__int64, const char *, __int64))(v6 + 24))(v5, v7, v8);
    a1[8] = result;
  }
  return result;
}
// 4CAB1: using guessed type char asc_4CAB1;

//----- (0000000000042F80) ----------------------------------------------------
__int64 *__fastcall core::fmt::builders::DebugTuple::field(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r12
  char v5; // al
  __int64 v7; // r14
  int v8; // eax
  __int64 v10; // r13
  __int64 v11; // rdx
  void *v12; // rsi
  char v13; // cl
  __int64 v14; // r13
  char v15; // cl
  int v16; // ecx
  char v17; // di
  char v18; // [rsp+Fh] [rbp-89h] BYREF
  __int128 v19[2]; // [rsp+10h] [rbp-88h] BYREF
  __int128 *v20; // [rsp+30h] [rbp-68h]
  __int64 (__fastcall **v21)(); // [rsp+38h] [rbp-60h]
  int v22; // [rsp+40h] [rbp-58h]
  int v23; // [rsp+44h] [rbp-54h]
  char v24; // [rsp+48h] [rbp-50h]
  __int128 v25; // [rsp+50h] [rbp-48h] BYREF
  char *v26; // [rsp+60h] [rbp-38h]

  v4 = *a1;
  v5 = 1;
  if ( !*((_BYTE *)a1 + 16) )
  {
    v7 = a1[1];
    v8 = *(_DWORD *)(v7 + 52);
    if ( (v8 & 4) != 0 )
    {
      if ( !v4 )
      {
        v14 = a3;
        v15 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v7 + 40) + 24LL))(
                *(_QWORD *)(v7 + 32),
                asc_4CAB5,
                2LL);
        v5 = 1;
        if ( v15 )
          goto LABEL_2;
        v8 = *(_DWORD *)(v7 + 52);
        a3 = v14;
      }
      v18 = 1;
      v25 = *(_OWORD *)(v7 + 32);
      v26 = &v18;
      v16 = *(_DWORD *)(v7 + 48);
      v17 = *(_BYTE *)(v7 + 56);
      v23 = v8;
      v22 = v16;
      v24 = v17;
      v19[0] = *(_OWORD *)v7;
      v19[1] = *(_OWORD *)(v7 + 16);
      v20 = &v25;
      v21 = off_5A398;
      if ( (*(unsigned __int8 (__fastcall **)(__int64, __int128 *))(a3 + 24))(a2, v19) )
        v5 = 1;
      else
        v5 = ((__int64 (__fastcall *)(__int128 *, const char *, __int64))v21[3])(v20, asc_4CAAF, 2LL);
    }
    else
    {
      v10 = a3;
      v11 = 0LL;
      v12 = &unk_4CAAA;
      if ( !v4 )
        v12 = &unk_4CAB4;
      LOBYTE(v11) = v4 != 0;
      v13 = (*(__int64 (__fastcall **)(_QWORD, void *, __int64))(*(_QWORD *)(v7 + 40) + 24LL))(
              *(_QWORD *)(v7 + 32),
              v12,
              v11 + 1);
      v5 = 1;
      if ( !v13 )
        v5 = (*(__int64 (__fastcall **)(__int64, __int64))(v10 + 24))(a2, v7);
    }
  }
LABEL_2:
  *((_BYTE *)a1 + 16) = v5;
  *a1 = v4 + 1;
  return a1;
}
// 5A398: using guessed type __int64 (__fastcall *off_5A398[2])();

//----- (00000000000430D0) ----------------------------------------------------
bool __fastcall core::fmt::builders::DebugTuple::finish(__int64 a1)
{
  char v1; // dl
  char v2; // al
  __int64 v3; // rbx
  char v4; // cl

  v1 = *(_BYTE *)(a1 + 16);
  if ( *(_QWORD *)a1 )
  {
    v2 = 1;
    if ( !v1 )
    {
      v3 = *(_QWORD *)(a1 + 8);
      if ( *(_QWORD *)a1 != 1LL
        || !*(_BYTE *)(a1 + 17)
        || (*(_BYTE *)(v3 + 52) & 4) != 0
        || (v4 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v3 + 40) + 24LL))(
                   *(_QWORD *)(v3 + 32),
                   asc_4CAB7,
                   1LL),
            v2 = 1,
            !v4) )
      {
        v2 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v3 + 40) + 24LL))(
               *(_QWORD *)(v3 + 32),
               asc_4C91A,
               1LL);
      }
    }
    *(_BYTE *)(a1 + 16) = v2;
    v1 = v2;
  }
  return v1 != 0;
}
// 4C91A: using guessed type char asc_4C91A;
// 4CAB7: using guessed type char asc_4CAB7;

//----- (0000000000043160) ----------------------------------------------------
_BYTE *__fastcall core::fmt::builders::DebugList::entry(_BYTE *a1, __int64 a2, __int64 a3)
{
  char v4; // al
  __int64 v6; // r14
  int v7; // eax
  char v8; // cl
  __int64 v9; // r15
  char v10; // al
  char v11; // cl
  __int64 v12; // r15
  char v13; // cl
  int v14; // ecx
  char v15; // di
  char v16; // [rsp+Fh] [rbp-79h] BYREF
  __int128 v17[2]; // [rsp+10h] [rbp-78h] BYREF
  __int128 *v18; // [rsp+30h] [rbp-58h]
  __int64 (__fastcall **v19)(); // [rsp+38h] [rbp-50h]
  int v20; // [rsp+40h] [rbp-48h]
  int v21; // [rsp+44h] [rbp-44h]
  char v22; // [rsp+48h] [rbp-40h]
  __int128 v23; // [rsp+50h] [rbp-38h] BYREF
  char *v24; // [rsp+60h] [rbp-28h]

  v4 = 1;
  if ( !a1[8] )
  {
    v6 = *(_QWORD *)a1;
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 52LL);
    v8 = a1[9];
    if ( (v7 & 4) != 0 )
    {
      if ( !v8 )
      {
        v12 = a3;
        v13 = (*(__int64 (__fastcall **)(_QWORD, void *, __int64))(*(_QWORD *)(v6 + 40) + 24LL))(
                *(_QWORD *)(v6 + 32),
                &unk_4CAB8,
                1LL);
        v4 = 1;
        if ( v13 )
          goto LABEL_2;
        a3 = v12;
        v7 = *(_DWORD *)(v6 + 52);
      }
      v16 = 1;
      v23 = *(_OWORD *)(v6 + 32);
      v24 = &v16;
      v14 = *(_DWORD *)(v6 + 48);
      v15 = *(_BYTE *)(v6 + 56);
      v21 = v7;
      v20 = v14;
      v22 = v15;
      v17[0] = *(_OWORD *)v6;
      v17[1] = *(_OWORD *)(v6 + 16);
      v18 = &v23;
      v19 = off_5A398;
      if ( (*(unsigned __int8 (__fastcall **)(__int64, __int128 *))(a3 + 24))(a2, v17) )
        v4 = 1;
      else
        v4 = ((__int64 (__fastcall *)(__int128 *, const char *, __int64))v19[3])(v18, asc_4CAAF, 2LL);
    }
    else if ( !v8
           || (v9 = a3,
               v10 = (*(__int64 (__fastcall **)(_QWORD, void *, __int64))(*(_QWORD *)(v6 + 40) + 24LL))(
                       *(_QWORD *)(v6 + 32),
                       &unk_4CAAA,
                       2LL),
               a3 = v9,
               v11 = v10,
               v4 = 1,
               !v11) )
    {
      v4 = (*(__int64 (__fastcall **)(__int64, __int64))(a3 + 24))(a2, v6);
    }
  }
LABEL_2:
  a1[8] = v4;
  a1[9] = 1;
  return a1;
}
// 5A398: using guessed type __int64 (__fastcall *off_5A398[2])();

//----- (00000000000432B0) ----------------------------------------------------
char __fastcall core::fmt::builders::DebugList::finish(_BYTE *a1)
{
  if ( a1[8] )
    return 1;
  else
    return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(*(_QWORD *)a1 + 40LL) + 24LL))(
             *(_QWORD *)(*(_QWORD *)a1 + 32LL),
             asc_4CAB9,
             1LL);
}
// 4CAB9: using guessed type char asc_4CAB9;

//----- (00000000000432E0) ----------------------------------------------------
char __fastcall core::fmt::Write::write_fmt(__int64 a1, _QWORD *a2)
{
  return core::fmt::write(a1, (__int64)off_5A398, a2);
}
// 5A398: using guessed type __int64 (__fastcall *off_5A398[2])();

//----- (00000000000432F0) ----------------------------------------------------
char __fastcall <core::fmt::Arguments as core::fmt::Display>::fmt(_QWORD *a1, __int64 a2)
{
  return core::fmt::write(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40), a1);
}

//----- (0000000000043310) ----------------------------------------------------
char __fastcall core::fmt::write(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // r12
  __int64 v4; // rax
  __int64 v5; // rbp
  _QWORD *v6; // r13
  __int64 v7; // r14
  __int64 v8; // rbx
  unsigned __int64 v9; // r15
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rbx
  __int64 v16; // r12
  __int64 v17; // r13
  __int64 v18; // rbx
  __int64 v19; // rbp
  __int64 v22[2]; // [rsp+8h] [rbp-70h] BYREF
  __int64 v23; // [rsp+18h] [rbp-60h]
  __int64 v24; // [rsp+20h] [rbp-58h]
  __int64 v25; // [rsp+28h] [rbp-50h]
  __int64 v26; // [rsp+30h] [rbp-48h]
  __int64 v27; // [rsp+38h] [rbp-40h]
  char v28; // [rsp+40h] [rbp-38h]

  v27 = 32LL;
  v28 = 3;
  v22[0] = 0LL;
  v23 = 0LL;
  v25 = a1;
  v26 = a2;
  v3 = a3[4];
  if ( v3 )
  {
    v4 = a3[5];
    if ( v4 )
    {
      v5 = a3[2];
      v6 = (_QWORD *)(*a3 + 8LL);
      v7 = 56 * v4;
      v8 = 0LL;
      v9 = 0LL;
      while ( 1 )
      {
        if ( *v6 && (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v26 + 24))(v25, *(v6 - 1)) )
          return 1;
        LODWORD(v27) = *(_DWORD *)(v3 + v8 + 40);
        v28 = *(_BYTE *)(v3 + v8 + 48);
        HIDWORD(v27) = *(_DWORD *)(v3 + v8 + 44);
        v10 = *(_QWORD *)(v3 + v8 + 16);
        v11 = *(_QWORD *)(v3 + v8 + 24);
        if ( !v10 )
          goto LABEL_11;
        if ( (_DWORD)v10 == 1 )
        {
          v11 *= 16LL;
          if ( *(void (__noreturn **)())(v5 + v11 + 8) == core::ops::function::FnOnce::call_once )
            break;
        }
        v12 = 0LL;
LABEL_12:
        v22[0] = v12;
        v22[1] = v11;
        v13 = *(_QWORD *)(v3 + v8);
        if ( v13 != 2 )
        {
          v11 = *(_QWORD *)(v3 + v8 + 8);
          if ( (_DWORD)v13 != 1 )
            goto LABEL_17;
          v11 *= 16LL;
          if ( *(void (__noreturn **)())(v5 + v11 + 8) == core::ops::function::FnOnce::call_once )
          {
            v11 = **(_QWORD **)(v5 + v11);
LABEL_17:
            v14 = 1LL;
            goto LABEL_18;
          }
        }
        v14 = 0LL;
LABEL_18:
        v23 = v14;
        v24 = v11;
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD, __int64 *))(v5 + 16LL * *(_QWORD *)(v3 + v8 + 32) + 8))(
               *(_QWORD *)(v5 + 16LL * *(_QWORD *)(v3 + v8 + 32)),
               v22) )
        {
          return 1;
        }
        v6 += 2;
        v8 += 56LL;
        ++v9;
        if ( v7 == v8 )
          goto LABEL_29;
      }
      v11 = **(_QWORD **)(v5 + v11);
LABEL_11:
      v12 = 1LL;
      goto LABEL_12;
    }
    v9 = 0LL;
LABEL_29:
    if ( v9 >= a3[1] )
      return 0;
    goto LABEL_30;
  }
  v15 = a3[3];
  if ( v15 )
  {
    v16 = a3[2];
    v17 = *a3;
    v18 = 16 * v15;
    v19 = 0LL;
    v9 = 0LL;
    while ( (!*(_QWORD *)(v17 + v19 + 8)
          || !(*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v26 + 24))(v25, *(_QWORD *)(v17 + v19)))
         && !(*(unsigned __int8 (__fastcall **)(_QWORD, __int64 *))(v16 + v19 + 8))(*(_QWORD *)(v16 + v19), v22) )
    {
      v19 += 16LL;
      ++v9;
      if ( v18 == v19 )
        goto LABEL_29;
    }
    return 1;
  }
  v9 = 0LL;
  if ( a3[1] )
  {
LABEL_30:
    if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD))(v26 + 24))(
           v25,
           *(_QWORD *)(*a3 + 16 * v9),
           *(_QWORD *)(*a3 + 16 * v9 + 8)) )
    {
      return 1;
    }
  }
  return 0;
}
// 41EB0: using guessed type void __noreturn core::ops::function::FnOnce::call_once();

//----- (0000000000043540) ----------------------------------------------------
__int64 __fastcall core::fmt::Formatter::pad_integral(
        __int64 a1,
        int a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // r13
  __int64 v7; // rbp
  int v9; // ebx
  unsigned int v10; // edx
  unsigned __int64 v11; // r14
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r15
  bool v15; // cc
  unsigned __int64 v16; // r15
  unsigned __int64 v17; // rbp
  __int64 v18; // rbx
  __int64 v19; // r14
  __int64 v20; // rdi
  __int64 v21; // rsi
  unsigned int v22; // r13d
  __int64 v23; // r14
  __int64 v24; // rbx
  char v25; // al
  unsigned __int64 v26; // r15
  __m128i v27; // xmm0
  __int64 v28; // rax
  __m128i si128; // xmm1
  __m128i v30; // xmm2
  __m128i v31; // xmm3
  char v32; // al
  __int64 v34; // r13
  __int64 v35; // r14
  unsigned int v36; // ebx
  unsigned __int64 v37; // r12
  char v38; // [rsp+3h] [rbp-55h]
  unsigned int v39; // [rsp+4h] [rbp-54h]
  __int64 v41; // [rsp+10h] [rbp-48h]
  __int64 v42; // [rsp+18h] [rbp-40h]
  int v44; // [rsp+24h] [rbp-34h]

  v6 = a6;
  v7 = a4;
  if ( a2 )
  {
    v9 = *(_DWORD *)(a1 + 52);
    v10 = 43;
    if ( (v9 & 1) == 0 )
      v10 = 1114112;
    v11 = a6 + (*(_DWORD *)(a1 + 52) & 1);
    if ( (v9 & 4) != 0 )
    {
LABEL_5:
      if ( a4 >= 0x20 )
      {
        v22 = v10;
        v12 = core::str::count::do_count_chars(a3, a4);
        v10 = v22;
        v6 = a6;
        goto LABEL_26;
      }
      v12 = a4;
      if ( !a4 )
        goto LABEL_26;
      if ( a4 == 1 )
      {
        v12 = 0LL;
        v13 = 0LL;
      }
      else
      {
        v13 = a4 & 0x1E;
        v27 = 0LL;
        v28 = 0LL;
        si128 = _mm_load_si128((const __m128i *)&xmmword_4C680);
        v30 = _mm_load_si128((const __m128i *)&xmmword_4C690);
        do
        {
          v31 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(a3 + v28)), si128);
          v27 = _mm_add_epi64(
                  v27,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v31, v31), 212), 212), v30));
          v28 += 2LL;
        }
        while ( v13 != v28 );
        v12 = _mm_add_epi64(_mm_shuffle_epi32(v27, 238), v27).m128i_u64[0];
        if ( v13 == v7 )
        {
LABEL_26:
          v11 += v12;
          if ( !*(_QWORD *)a1 )
            goto LABEL_27;
          goto LABEL_11;
        }
      }
      do
        v12 += *(_BYTE *)(a3 + v13++) >= 0xC0;
      while ( v7 != v13 );
      goto LABEL_26;
    }
  }
  else
  {
    v11 = a6 + 1;
    v9 = *(_DWORD *)(a1 + 52);
    v10 = 45;
    if ( (v9 & 4) != 0 )
      goto LABEL_5;
  }
  a3 = 0LL;
  if ( !*(_QWORD *)a1 )
  {
LABEL_27:
    v18 = *(_QWORD *)(a1 + 32);
    v19 = *(_QWORD *)(a1 + 40);
    v20 = v18;
    v21 = v19;
    goto LABEL_28;
  }
LABEL_11:
  v39 = v10;
  v14 = *(_QWORD *)(a1 + 8);
  v15 = v14 <= v11;
  v16 = v14 - v11;
  if ( !v15 )
  {
    if ( (v9 & 8) != 0 )
    {
      v44 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)(a1 + 48) = 48;
      v38 = *(_BYTE *)(a1 + 56);
      *(_BYTE *)(a1 + 56) = 1;
      v23 = *(_QWORD *)(a1 + 32);
      v24 = *(_QWORD *)(a1 + 40);
      v25 = core::fmt::Formatter::pad_integral::write_prefix(v23, v24, v10, a3, v7);
      LOBYTE(v7) = 1;
      if ( !v25 )
      {
        v26 = v16 + 1;
        while ( --v26 )
        {
          if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64))(v24 + 32))(v23, 48LL) )
            return (unsigned int)v7;
        }
        if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(v24 + 24))(v23, a5, v6) )
        {
          *(_DWORD *)(a1 + 48) = v44;
          *(_BYTE *)(a1 + 56) = v38;
          LODWORD(v7) = 0;
        }
      }
    }
    else
    {
      v41 = v7;
      v17 = *(unsigned __int8 *)(a1 + 56);
      v42 = v6;
      switch ( *(_BYTE *)(a1 + 56) )
      {
        case 0:
          break;
        case 1:
        case 3:
          v17 = v16;
          v16 = 0LL;
          break;
        case 2:
          v17 = v16 >> 1;
          v16 = (v16 + 1) >> 1;
          break;
      }
      v34 = *(_QWORD *)(a1 + 32);
      v35 = *(_QWORD *)(a1 + 40);
      v36 = *(_DWORD *)(a1 + 48);
      v7 = v17 + 1;
      while ( --v7 )
      {
        if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v35 + 32))(v34, v36) )
        {
          LOBYTE(v7) = 1;
          return (unsigned int)v7;
        }
      }
      LODWORD(v7) = 1;
      if ( !core::fmt::Formatter::pad_integral::write_prefix(v34, v35, v39, a3, v41)
        && !(*(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(v35 + 24))(v34, a5, v42) )
      {
        v7 = -(__int64)v16;
        v37 = -1LL;
        while ( v37 - v16 != -1LL )
        {
          ++v37;
          if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v35 + 32))(v34, v36) )
            goto LABEL_45;
        }
        v37 = v16;
LABEL_45:
        LOBYTE(v7) = v37 < v16;
      }
    }
    return (unsigned int)v7;
  }
  v18 = *(_QWORD *)(a1 + 32);
  v19 = *(_QWORD *)(a1 + 40);
  v20 = v18;
  v21 = v19;
LABEL_28:
  v32 = core::fmt::Formatter::pad_integral::write_prefix(v20, v21, v10, a3, v7);
  LOBYTE(v7) = 1;
  if ( v32 )
    return (unsigned int)v7;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v19 + 24))(v18, a5, v6);
}
// 4C680: using guessed type __int128 xmmword_4C680;
// 4C690: using guessed type __int128 xmmword_4C690;

//----- (0000000000043860) ----------------------------------------------------
char __fastcall core::fmt::Formatter::pad_integral::write_prefix(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5)
{
  char v7; // cl
  char result; // al

  if ( a3 == 1114112 || (v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a2 + 32))(a1, a3), result = 1, !v7) )
  {
    if ( a4 )
      return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(a2 + 24))(a1, a4, a5);
    else
      return 0;
  }
  return result;
}

//----- (00000000000438C0) ----------------------------------------------------
char __fastcall core::fmt::Formatter::pad(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v5; // rcx
  __int64 v6; // rsi
  char *v7; // rdx
  char *v8; // rcx
  char *v9; // r8
  char *v10; // r9
  char v11; // r9
  unsigned __int64 v12; // r12
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rcx
  __m128i v15; // xmm0
  __int64 v16; // rax
  __m128i si128; // xmm1
  __m128i v18; // xmm2
  __m128i v19; // xmm3
  bool v20; // cc
  unsigned __int64 v21; // r12
  char result; // al
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rax
  __int64 v25; // r15
  __int64 v26; // r13
  unsigned int v27; // ebp
  unsigned __int64 v28; // r12
  char v29; // cl
  unsigned __int64 v30; // rbx
  unsigned __int64 v31; // [rsp+0h] [rbp-38h]

  v3 = a3;
  v5 = *(_QWORD *)(a1 + 16);
  if ( !(v5 | *(_QWORD *)a1) )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int64))(*(_QWORD *)(a1 + 40) + 24LL))(
             *(_QWORD *)(a1 + 32),
             a2,
             v3);
  if ( v5 )
  {
    v6 = *(_QWORD *)(a1 + 24);
    v7 = (char *)(a2 + a3);
    v8 = 0LL;
    if ( v6 )
    {
      v9 = (char *)a2;
      while ( v9 != v7 )
      {
        v11 = *v9;
        if ( *v9 >= 0 )
        {
          v10 = v9 + 1;
        }
        else if ( (unsigned __int8)v11 < 0xE0u )
        {
          v10 = v9 + 2;
        }
        else if ( (unsigned __int8)v11 < 0xF0u )
        {
          v10 = v9 + 3;
        }
        else
        {
          if ( (((v11 & 7) << 18) | ((v9[1] & 0x3F) << 12) | ((v9[2] & 0x3F) << 6) | v9[3] & 0x3F) == 1114112 )
            break;
          v10 = v9 + 4;
        }
        v8 = &v10[v8 - v9];
        v9 = v10;
        if ( !--v6 )
          goto LABEL_16;
      }
    }
    else
    {
      v10 = (char *)a2;
LABEL_16:
      if ( v10 != v7
        && ((unsigned __int8)*v10 < 0xF0u
         || (((*v10 & 7) << 18) | ((v10[1] & 0x3F) << 12) | ((v10[2] & 0x3F) << 6) | v10[3] & 0x3F) != 1114112) )
      {
        if ( v8 )
        {
          if ( (unsigned __int64)v8 >= v3 )
          {
            if ( v8 != (char *)v3 )
              goto LABEL_25;
          }
          else if ( v8[a2] < -64 )
          {
            goto LABEL_25;
          }
        }
        v3 = (unsigned __int64)v8;
      }
    }
  }
LABEL_25:
  if ( !*(_QWORD *)a1 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int64))(*(_QWORD *)(a1 + 40) + 24LL))(
             *(_QWORD *)(a1 + 32),
             a2,
             v3);
  v12 = *(_QWORD *)(a1 + 8);
  if ( v3 >= 0x20 )
  {
    v13 = core::str::count::do_count_chars(a2, v3);
  }
  else
  {
    v13 = v3;
    if ( v3 )
    {
      if ( v3 != 1 )
      {
        v14 = v3 & 0x1E;
        v15 = 0LL;
        v16 = 0LL;
        si128 = _mm_load_si128((const __m128i *)&xmmword_4C680);
        v18 = _mm_load_si128((const __m128i *)&xmmword_4C690);
        do
        {
          v19 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(a2 + v16)), si128);
          v15 = _mm_add_epi64(
                  v15,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v19, v19), 212), 212), v18));
          v16 += 2LL;
        }
        while ( v14 != v16 );
        v13 = _mm_add_epi64(_mm_shuffle_epi32(v15, 238), v15).m128i_u64[0];
        goto LABEL_35;
      }
      v13 = 0LL;
      v14 = 0LL;
      do
      {
        v13 += *(_BYTE *)(a2 + v14++) >= 0xC0;
LABEL_35:
        ;
      }
      while ( v3 != v14 );
    }
  }
  v20 = v12 <= v13;
  v21 = v12 - v13;
  if ( v20 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int64))(*(_QWORD *)(a1 + 40) + 24LL))(
             *(_QWORD *)(a1 + 32),
             a2,
             v3);
  switch ( *(_BYTE *)(a1 + 56) )
  {
    case 0:
    case 3:
      v31 = v21;
      v21 = 0LL;
      break;
    case 1:
      v23 = 0LL;
      goto LABEL_42;
    case 2:
      v24 = v21;
      v21 >>= 1;
      v23 = (v24 + 1) >> 1;
LABEL_42:
      v31 = v23;
      break;
  }
  v25 = *(_QWORD *)(a1 + 32);
  v26 = *(_QWORD *)(a1 + 40);
  v27 = *(_DWORD *)(a1 + 48);
  v28 = v21 + 1;
  while ( --v28 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v26 + 32))(v25, v27) )
      return 1;
  }
  v29 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v26 + 24))(v25, a2, v3);
  result = 1;
  if ( !v29 )
  {
    v30 = -1LL;
    while ( v30 - v31 != -1LL )
    {
      ++v30;
      if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v26 + 32))(v25, v27) )
        return v30 < v31;
    }
    v30 = v31;
    return v30 < v31;
  }
  return result;
}
// 4C680: using guessed type __int128 xmmword_4C680;
// 4C690: using guessed type __int128 xmmword_4C690;

//----- (0000000000043BA0) ----------------------------------------------------
__int64 __fastcall <core::fmt::Formatter as core::fmt::Write>::write_str(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 40) + 24LL))(*(_QWORD *)(a1 + 32));
}

//----- (0000000000043BC0) ----------------------------------------------------
__int64 __fastcall core::fmt::Formatter::debug_struct(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // al

  v4 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)(a2 + 40) + 24LL))(*(_QWORD *)(a2 + 32), a3, a4);
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 8) = v4;
  *(_BYTE *)(a1 + 9) = 0;
  return a1;
}

//----- (0000000000043C00) ----------------------------------------------------
char __fastcall core::fmt::Formatter::debug_struct_field1_finish(
        __int64 a1,
        double a2,
        double a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        unsigned __int64 a7,
        __int64 a8,
        __int64 a9)
{
  double v12; // xmm0_8
  char v13; // al
  char result; // al
  const char *v15; // rsi
  __int64 v16; // rdx
  __int64 v17; // [rsp+0h] [rbp-38h] BYREF
  char v18; // [rsp+8h] [rbp-30h]
  char v19; // [rsp+9h] [rbp-2Fh]

  v12 = (*(double (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 40) + 24LL))(*(_QWORD *)(a1 + 32));
  v17 = a1;
  v18 = v13;
  v19 = 0;
  core::fmt::builders::DebugStruct::field(&v17, a6, a7, a8, a9, v12, a3);
  if ( !v19 )
    return v18 != 0;
  result = 1;
  if ( !v18 )
  {
    if ( (*(_BYTE *)(v17 + 52) & 4) != 0 )
    {
      v15 = asc_4CAB1;
      v16 = 1LL;
    }
    else
    {
      v15 = asc_4CAB2;
      v16 = 2LL;
    }
    return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v17 + 40) + 24LL))(
             *(_QWORD *)(v17 + 32),
             v15,
             v16);
  }
  return result;
}
// 43C2E: variable 'v13' is possibly undefined
// 4CAB1: using guessed type char asc_4CAB1;

//----- (0000000000043CB0) ----------------------------------------------------
char __fastcall core::fmt::Formatter::debug_struct_field2_finish(
        __int64 a1,
        double a2,
        double a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        unsigned __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        unsigned __int64 a11,
        __int64 a12,
        __int64 a13)
{
  double v16; // xmm0_8
  char v17; // al
  char result; // al
  const char *v19; // rsi
  __int64 v20; // rdx
  __int64 v21; // [rsp+8h] [rbp-40h] BYREF
  char v22; // [rsp+10h] [rbp-38h]
  char v23; // [rsp+11h] [rbp-37h]

  v16 = (*(double (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 40) + 24LL))(*(_QWORD *)(a1 + 32));
  v21 = a1;
  v22 = v17;
  v23 = 0;
  core::fmt::builders::DebugStruct::field(&v21, a6, a7, a8, a9, v16, a3);
  core::fmt::builders::DebugStruct::field(&v21, a10, a11, a12, a13, v16, a3);
  if ( !v23 )
    return v22 != 0;
  result = 1;
  if ( !v22 )
  {
    if ( (*(_BYTE *)(v21 + 52) & 4) != 0 )
    {
      v19 = asc_4CAB1;
      v20 = 1LL;
    }
    else
    {
      v19 = asc_4CAB2;
      v20 = 2LL;
    }
    return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v21 + 40) + 24LL))(
             *(_QWORD *)(v21 + 32),
             v19,
             v20);
  }
  return result;
}
// 43CE0: variable 'v17' is possibly undefined
// 4CAB1: using guessed type char asc_4CAB1;

//----- (0000000000043D80) ----------------------------------------------------
__int64 __fastcall core::fmt::Formatter::debug_tuple(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v5; // al

  v5 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)(a2 + 40) + 24LL))(*(_QWORD *)(a2 + 32), a3, a4);
  *(_QWORD *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 16) = v5;
  *(_QWORD *)a1 = 0LL;
  *(_BYTE *)(a1 + 17) = a4 == 0;
  return a1;
}

//----- (0000000000043DC0) ----------------------------------------------------
bool __fastcall core::fmt::Formatter::debug_tuple_field1_finish(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5)
{
  char v8; // al
  char v9; // al
  __int64 v10; // rbx
  char v11; // cl
  __int64 v13; // [rsp+0h] [rbp-38h] BYREF
  __int64 v14; // [rsp+8h] [rbp-30h]
  char v15; // [rsp+10h] [rbp-28h]
  bool v16; // [rsp+11h] [rbp-27h]

  v8 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 40) + 24LL))(*(_QWORD *)(a1 + 32));
  v14 = a1;
  v15 = v8;
  v13 = 0LL;
  v16 = a3 == 0;
  core::fmt::builders::DebugTuple::field(&v13, a4, a5);
  if ( v13 )
  {
    v9 = 1;
    if ( !v15 )
    {
      v10 = v14;
      if ( v13 != 1
        || !v16
        || (*(_BYTE *)(v14 + 52) & 4) != 0
        || (v11 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v14 + 40) + 24LL))(
                    *(_QWORD *)(v14 + 32),
                    asc_4CAB7,
                    1LL),
            v9 = 1,
            !v11) )
      {
        v9 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v10 + 40) + 24LL))(
               *(_QWORD *)(v10 + 32),
               asc_4C91A,
               1LL);
      }
    }
  }
  else
  {
    v9 = v15;
  }
  return v9 != 0;
}
// 4C91A: using guessed type char asc_4C91A;
// 4CAB7: using guessed type char asc_4CAB7;

//----- (0000000000043E90) ----------------------------------------------------
bool __fastcall core::fmt::Formatter::debug_tuple_field2_finish(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7)
{
  char v11; // al
  char v12; // al
  __int64 v13; // rbx
  char v14; // cl
  __int64 v16; // [rsp+0h] [rbp-48h] BYREF
  __int64 v17; // [rsp+8h] [rbp-40h]
  char v18; // [rsp+10h] [rbp-38h]
  bool v19; // [rsp+11h] [rbp-37h]

  v11 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 40) + 24LL))(*(_QWORD *)(a1 + 32));
  v17 = a1;
  v18 = v11;
  v16 = 0LL;
  v19 = a3 == 0;
  core::fmt::builders::DebugTuple::field(&v16, a4, a5);
  core::fmt::builders::DebugTuple::field(&v16, a6, a7);
  if ( v16 )
  {
    v12 = 1;
    if ( !v18 )
    {
      v13 = v17;
      if ( v16 != 1
        || !v19
        || (*(_BYTE *)(v17 + 52) & 4) != 0
        || (v14 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v17 + 40) + 24LL))(
                    *(_QWORD *)(v17 + 32),
                    asc_4CAB7,
                    1LL),
            v12 = 1,
            !v14) )
      {
        v12 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v13 + 40) + 24LL))(
                *(_QWORD *)(v13 + 32),
                asc_4C91A,
                1LL);
      }
    }
  }
  else
  {
    v12 = v18;
  }
  return v12 != 0;
}
// 4C91A: using guessed type char asc_4C91A;
// 4CAB7: using guessed type char asc_4CAB7;

//----- (0000000000043F80) ----------------------------------------------------
__int64 __fastcall core::fmt::Formatter::debug_list(__int64 a1, __int64 a2)
{
  char v2; // al

  v2 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 40) + 24LL))(
         *(_QWORD *)(a2 + 32),
         asc_4C9BE,
         1LL);
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 9) = 0;
  return a1;
}
// 4C9BE: using guessed type char asc_4C9BE;

//----- (0000000000043FC0) ----------------------------------------------------
__int64 __fastcall <core::fmt::Formatter as core::fmt::Write>::write_char(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 40) + 32LL))(*(_QWORD *)(a1 + 32));
}

//----- (0000000000043FE0) ----------------------------------------------------
char __fastcall <str as core::fmt::Debug>::fmt(unsigned __int8 *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r14
  unsigned __int8 *v4; // r15
  __int64 v5; // rbx
  __int64 v6; // r12
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // r12
  unsigned __int8 *v10; // rbx
  unsigned int v11; // ebp
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  char v15; // r14
  __int64 v16; // rsi
  unsigned __int64 v17; // r13
  unsigned __int64 v18; // r14
  __int64 v20; // r13
  __int64 v21; // [rsp+8h] [rbp-80h]
  int v22; // [rsp+10h] [rbp-78h]
  unsigned __int8 *v23; // [rsp+18h] [rbp-70h]
  __int64 v24; // [rsp+20h] [rbp-68h]
  __int64 v25; // [rsp+28h] [rbp-60h]
  unsigned __int8 (__fastcall *v26)(__int64, __int64); // [rsp+30h] [rbp-58h]
  __int64 v27; // [rsp+3Ch] [rbp-4Ch] BYREF
  int v28; // [rsp+44h] [rbp-44h]
  __int64 v29; // [rsp+48h] [rbp-40h]
  unsigned __int8 *v30; // [rsp+50h] [rbp-38h]

  v3 = a2;
  v4 = a1;
  v5 = *(_QWORD *)(a3 + 32);
  v6 = *(_QWORD *)(a3 + 40);
  v26 = *(unsigned __int8 (__fastcall **)(__int64, __int64))(v6 + 32);
  if ( v26(v5, 34LL) )
    return 1;
  if ( !a2 )
  {
    v8 = 0LL;
    goto LABEL_46;
  }
  v25 = v6;
  v24 = v5;
  v30 = &a1[a2];
  v8 = 0LL;
  v23 = a1;
  v9 = 0LL;
  v29 = a2;
  while ( 1 )
  {
    v10 = v4;
    v11 = *v4;
    if ( (v11 & 0x80u) != 0 )
      break;
    ++v4;
LABEL_15:
    core::char::methods::<impl char>::escape_debug_ext((__int64)&v27, v11, 65537);
    if ( (_BYTE)v27 != 0x80 && HIBYTE(v28) - BYTE2(v28) != 1 )
    {
      if ( v9 < v8 )
        goto LABEL_56;
      if ( v8 )
      {
        if ( v8 >= v3 )
        {
          if ( v8 != v3 )
            goto LABEL_56;
        }
        else if ( (char)v23[v8] < -64 )
        {
          goto LABEL_56;
        }
      }
      if ( v9 )
      {
        if ( v9 >= v3 )
        {
          if ( v9 != v3 )
LABEL_56:
            core::str::slice_error_fail(v23, v3, v8, v9, (__int64)&off_5A400);
        }
        else if ( (char)v23[v9] <= -65 )
        {
          goto LABEL_56;
        }
      }
      if ( (*(unsigned __int8 (__fastcall **)(__int64, unsigned __int8 *, unsigned __int64))(v25 + 24))(
             v24,
             &v23[v8],
             v9 - v8) )
      {
        return 1;
      }
      v22 = v28;
      v21 = v27;
      if ( (_BYTE)v27 == 0x80 )
      {
        v15 = 0x80;
        while ( 1 )
        {
          if ( v15 == (char)0x80 )
          {
            v16 = HIDWORD(v21);
            v22 = 0;
            v21 = 0LL;
            v15 = 0;
          }
          else
          {
            v17 = BYTE2(v22);
            if ( BYTE2(v22) >= HIBYTE(v22) )
              goto LABEL_42;
            ++BYTE2(v22);
            if ( (unsigned __int8)v17 >= 0xAu )
              goto LABEL_55;
            v16 = *((unsigned __int8 *)&v21 + v17);
          }
          if ( v26(v24, v16) )
            return 1;
        }
      }
      v18 = HIBYTE(v22);
      v17 = BYTE2(v22);
      while ( v17 < v18 )
      {
        BYTE2(v22) = v17 + 1;
        if ( v17 > 9 )
LABEL_55:
          core::panicking::panic_bounds_check(v17, 10LL, (__int64)&off_5A6C0);
        if ( v26(v24, *((unsigned __int8 *)&v21 + v17++)) )
          return 1;
      }
LABEL_42:
      v20 = 1LL;
      if ( v11 >= 0x80 )
      {
        v20 = 2LL;
        if ( v11 >= 0x800 )
          v20 = 4LL - (v11 < 0x10000);
      }
      v8 = v9 + v20;
      v3 = v29;
    }
    v9 = (unsigned __int64)&v4[v9 - (_QWORD)v10];
    if ( v4 == v30 )
      goto LABEL_48;
  }
  v12 = v11 & 0x1F;
  v13 = v4[1] & 0x3F;
  if ( (unsigned __int8)v11 <= 0xDFu )
  {
    v4 += 2;
    v11 = v13 | (v12 << 6);
    goto LABEL_15;
  }
  v4 += 3;
  v14 = (v13 << 6) | v10[2] & 0x3F;
  if ( (unsigned __int8)v11 < 0xF0u )
  {
    v11 = (v12 << 12) | v14;
    goto LABEL_15;
  }
  v11 = ((v11 & 7) << 18) | (v14 << 6) | *v4 & 0x3F;
  if ( v11 != 1114112 )
  {
    v4 = v10 + 4;
    goto LABEL_15;
  }
LABEL_48:
  if ( v8 )
  {
    v5 = v24;
    v4 = v23;
    v6 = v25;
    if ( v8 >= v3 )
    {
      if ( v8 != v3 )
        goto LABEL_54;
    }
    else if ( (char)v23[v8] <= -65 )
    {
LABEL_54:
      core::str::slice_error_fail(v23, v3, v8, v3, (__int64)&off_5A3E8);
    }
  }
  else
  {
    v8 = 0LL;
    v5 = v24;
    v4 = v23;
    v6 = v25;
  }
LABEL_46:
  if ( (*(unsigned __int8 (__fastcall **)(__int64, unsigned __int8 *, unsigned __int64))(v6 + 24))(v5, &v4[v8], v3 - v8) )
    return 1;
  return v26(v5, 34LL);
}
// 5A3E8: using guessed type char *off_5A3E8;
// 5A400: using guessed type char *off_5A400;
// 5A6C0: using guessed type char *off_5A6C0;

//----- (0000000000044360) ----------------------------------------------------
char __fastcall <str as core::fmt::Display>::fmt(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  return core::fmt::Formatter::pad(a3, a1, a2);
}

//----- (0000000000044380) ----------------------------------------------------
char __fastcall <char as core::fmt::Debug>::fmt(unsigned int *a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned __int8 (__fastcall *v3)(__int64, __int64); // r12
  char v5; // bp
  __int64 v6; // rsi
  unsigned __int64 i; // r14
  unsigned __int64 v8; // r15
  __int64 v10; // [rsp+0h] [rbp-38h] BYREF
  int v11; // [rsp+8h] [rbp-30h]

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)(a2 + 40) + 32LL);
  if ( v3(v2, 39LL) )
    return 1;
  core::char::methods::<impl char>::escape_debug_ext((__int64)&v10, *a1, 257);
  if ( (_BYTE)v10 == 0x80 )
  {
    v5 = 0x80;
    while ( 1 )
    {
      while ( v5 == (char)0x80 )
      {
        v6 = HIDWORD(v10);
        v11 = 0;
        v10 = 0LL;
        v5 = 0;
        if ( v3(v2, v6) )
          return 1;
      }
      i = BYTE2(v11);
      if ( BYTE2(v11) >= HIBYTE(v11) )
        break;
      ++BYTE2(v11);
      if ( (unsigned __int8)i >= 0xAu )
        goto LABEL_17;
      if ( v3(v2, *((unsigned __int8 *)&v10 + i)) )
        return 1;
    }
  }
  else
  {
    v8 = HIBYTE(v11);
    for ( i = BYTE2(v11); i < v8; ++i )
    {
      BYTE2(v11) = i + 1;
      if ( i > 9 )
LABEL_17:
        core::panicking::panic_bounds_check(i, 10LL, (__int64)&off_5A6C0);
      if ( v3(v2, *((unsigned __int8 *)&v10 + i)) )
        return 1;
    }
  }
  return v3(v2, 39LL);
}
// 5A6C0: using guessed type char *off_5A6C0;

//----- (00000000000444B0) ----------------------------------------------------
char __fastcall <char as core::fmt::Display>::fmt(unsigned int *a1, _QWORD *a2)
{
  unsigned int v2; // eax
  unsigned __int64 v4; // rdx
  int v5; // [rsp+0h] [rbp-4h] BYREF

  v2 = *a1;
  if ( !(a2[2] | *a2) )
    return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(a2[5] + 32LL))(a2[4], v2);
  v5 = 0;
  if ( v2 >= 0x80 )
  {
    if ( v2 >= 0x800 )
    {
      if ( v2 >= 0x10000 )
      {
        LOBYTE(v5) = (v2 >> 18) | 0xF0;
        BYTE1(v5) = (v2 >> 12) & 0x3F | 0x80;
        BYTE2(v5) = (v2 >> 6) & 0x3F | 0x80;
        HIBYTE(v5) = v2 & 0x3F | 0x80;
        v4 = 4LL;
      }
      else
      {
        LOBYTE(v5) = (v2 >> 12) | 0xE0;
        BYTE1(v5) = (v2 >> 6) & 0x3F | 0x80;
        BYTE2(v5) = v2 & 0x3F | 0x80;
        v4 = 3LL;
      }
    }
    else
    {
      LOBYTE(v5) = (v2 >> 6) | 0xC0;
      BYTE1(v5) = v2 & 0x3F | 0x80;
      v4 = 2LL;
    }
  }
  else
  {
    LOBYTE(v5) = v2;
    v4 = 1LL;
  }
  return core::fmt::Formatter::pad((__int64)a2, (__int64)&v5, v4);
}

//----- (0000000000044590) ----------------------------------------------------
__int64 __fastcall core::fmt::pointer_fmt_inner(unsigned __int64 a1, __m128i *a2)
{
  __m128i v2; // xmm0
  int v3; // ebp
  int v4; // eax
  char *v5; // r8
  __int64 v6; // r9
  unsigned __int64 v7; // rax
  char v8; // dl
  bool v9; // cf
  __int64 result; // rax
  char v11; // [rsp+98h] [rbp-10h] BYREF

  v2 = _mm_loadu_si128(a2);
  v3 = a2[3].m128i_i32[1];
  v4 = v3;
  if ( (v3 & 4) != 0 )
  {
    v4 = v3 | 8;
    if ( !v2.m128i_i64[0] )
    {
      a2->m128i_i64[0] = 1LL;
      a2->m128i_i64[1] = 18LL;
    }
  }
  a2[3].m128i_i32[1] = v4 | 4;
  v5 = &v11;
  v6 = 0LL;
  v7 = a1;
  do
  {
    v7 >>= 4;
    v8 = (a1 & 0xF) + 87;
    if ( (a1 & 0xF) < 0xA )
      v8 = (a1 & 0xF) + 48;
    *--v5 = v8;
    ++v6;
    v9 = a1 < 0x10;
    a1 = v7;
  }
  while ( !v9 );
  if ( (unsigned __int64)(128 - v6) >= 0x81 )
    core::slice::index::slice_start_index_len_fail(128 - v6, 128LL, (__int64)&off_5A3C8);
  result = core::fmt::Formatter::pad_integral((__int64)a2, 1, (__int64)a0x_0, 2uLL, (__int64)v5, v6);
  *a2 = v2;
  a2[3].m128i_i32[1] = v3;
  return result;
}
// 5A3C8: using guessed type char *off_5A3C8;

//----- (0000000000044670) ----------------------------------------------------
__int64 __fastcall core::slice::memchr::memchr_aligned(unsigned __int8 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r8
  __int64 i; // rcx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rdx
  __int64 v7; // rsi
  __int64 result; // rax
  __int64 v9; // rcx

  v3 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8LL) - a2;
  if ( !v3 )
    goto LABEL_10;
  if ( v3 >= a3 )
    v3 = a3;
  if ( v3 )
  {
    for ( i = 0LL; i != v3; ++i )
    {
      if ( *(_BYTE *)(a2 + i) == a1 )
        return 1LL;
    }
    v5 = a3 - 16;
    if ( v3 <= a3 - 16 )
      goto LABEL_11;
  }
  else
  {
LABEL_10:
    v5 = a3 - 16;
    v3 = 0LL;
    do
    {
LABEL_11:
      if ( (((((0x101010101010101LL * a1) ^ *(_QWORD *)(a2 + v3)) - 0x101010101010101LL) & ~((0x101010101010101LL * a1) ^ *(_QWORD *)(a2 + v3)) | (((0x101010101010101LL * a1) ^ *(_QWORD *)(a2 + v3 + 8)) - 0x101010101010101LL) & ~((0x101010101010101LL * a1) ^ *(_QWORD *)(a2 + v3 + 8))) & 0x8080808080808080LL) != 0 )
        break;
      v3 += 16LL;
    }
    while ( v3 <= v5 );
  }
  v6 = a3 - v3;
  if ( !v6 )
    return 0LL;
  v7 = v3 + a2;
  result = 0LL;
  v9 = 0LL;
  while ( *(_BYTE *)(v7 + v9) != a1 )
  {
    if ( v6 == ++v9 )
      return result;
  }
  return 1LL;
}

//----- (0000000000044760) ----------------------------------------------------
__int64 __fastcall core::slice::memchr::memrchr(unsigned __int8 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx
  bool v6; // cf
  unsigned __int64 v7; // rax
  _BYTE *v8; // r10
  __int64 i; // r9
  bool v10; // zf
  __int64 v11; // r10
  unsigned __int64 v12; // rcx
  __int64 result; // rax

  v3 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8LL) - a2;
  v4 = ((_BYTE)a3 - (_BYTE)v3) & 0xF;
  v5 = 0LL;
  v6 = a3 < v3;
  if ( a3 <= v3 )
    v3 = a3;
  if ( !v6 )
    v5 = v4;
  v7 = a3 - v5;
  if ( a3 < v5 )
    core::slice::index::slice_start_index_len_fail(v7, a3, (__int64)&off_5A418);
  v8 = (_BYTE *)(a3 + a2 - 1);
  for ( i = 0LL; v5 != i; ++i )
  {
    v10 = *v8-- == a1;
    if ( v10 )
      return 1LL;
  }
  do
  {
    v12 = v7;
    if ( v7 <= v3 )
      break;
    v7 -= 16LL;
    v11 = 0x101010101010101LL * a1;
  }
  while ( ((((v11 ^ *(_QWORD *)(a2 + v12 - 16)) - 0x101010101010101LL) & ~(v11 ^ *(_QWORD *)(a2 + v12 - 16)) | ((v11 ^ *(_QWORD *)(a2 + v12 - 8)) - 0x101010101010101LL) & ~(v11 ^ *(_QWORD *)(a2 + v12 - 8))) & 0x8080808080808080LL) == 0 );
  if ( v12 > a3 )
    core::slice::index::slice_end_index_len_fail(v12, a3, (__int64)&off_5A430);
  result = 0LL;
  while ( v12 )
  {
    v10 = *(_BYTE *)(a2 + v12-- - 1) == a1;
    if ( v10 )
      return 1LL;
  }
  return result;
}
// 5A418: using guessed type char *off_5A418;
// 5A430: using guessed type char *off_5A430;

//----- (0000000000044870) ----------------------------------------------------
void __fastcall __noreturn core::slice::index::slice_start_index_len_fail_rt(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // [rsp+8h] [rbp-60h] BYREF
  __int64 v4; // [rsp+10h] [rbp-58h] BYREF
  __int64 v5[4]; // [rsp+18h] [rbp-50h] BYREF
  __int64 v6[6]; // [rsp+38h] [rbp-30h] BYREF

  v3 = a1;
  v4 = a2;
  v5[0] = (__int64)&v3;
  v5[1] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v5[2] = (__int64)&v4;
  v5[3] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v6[0] = (__int64)&off_5A448;
  v6[1] = 2LL;
  v6[4] = 0LL;
  v6[2] = (__int64)v5;
  v6[3] = 2LL;
  core::panicking::panic_fmt((__int64)v6, a3);
}
// 5A448: using guessed type char *off_5A448;

//----- (00000000000448F0) ----------------------------------------------------
void __fastcall __noreturn core::slice::index::slice_end_index_len_fail_rt(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // [rsp+8h] [rbp-60h] BYREF
  __int64 v4; // [rsp+10h] [rbp-58h] BYREF
  __int64 v5[4]; // [rsp+18h] [rbp-50h] BYREF
  __int64 v6[6]; // [rsp+38h] [rbp-30h] BYREF

  v3 = a1;
  v4 = a2;
  v5[0] = (__int64)&v3;
  v5[1] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v5[2] = (__int64)&v4;
  v5[3] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v6[0] = (__int64)&off_5A468;
  v6[1] = 2LL;
  v6[4] = 0LL;
  v6[2] = (__int64)v5;
  v6[3] = 2LL;
  core::panicking::panic_fmt((__int64)v6, a3);
}
// 5A468: using guessed type char *off_5A468;

//----- (0000000000044970) ----------------------------------------------------
void __fastcall __noreturn core::slice::index::slice_index_order_fail_rt(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // [rsp+8h] [rbp-60h] BYREF
  __int64 v4; // [rsp+10h] [rbp-58h] BYREF
  __int64 v5[4]; // [rsp+18h] [rbp-50h] BYREF
  __int64 v6[6]; // [rsp+38h] [rbp-30h] BYREF

  v3 = a1;
  v4 = a2;
  v5[0] = (__int64)&v3;
  v5[1] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v5[2] = (__int64)&v4;
  v5[3] = (__int64)core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
  v6[0] = (__int64)&off_5A488;
  v6[1] = 2LL;
  v6[4] = 0LL;
  v6[2] = (__int64)v5;
  v6[3] = 2LL;
  core::panicking::panic_fmt((__int64)v6, a3);
}
// 5A488: using guessed type char *off_5A488;

//----- (00000000000449F0) ----------------------------------------------------
__int64 __fastcall core::str::converts::from_utf8(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 result; // rax
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rbx
  int v7; // ebp
  char v8; // r9
  unsigned __int64 v9; // r14
  char v10; // bp
  char v11; // bp
  __int64 v12; // rcx

  result = a1;
  v4 = 0LL;
  if ( a3 >= 0xF )
    v4 = a3 - 15;
  if ( !a3 )
  {
LABEL_50:
    *(_QWORD *)(result + 8) = a2;
    *(_QWORD *)(result + 16) = a3;
    v12 = 0LL;
    goto LABEL_55;
  }
  v5 = 0LL;
  while ( 1 )
  {
    v6 = *(unsigned __int8 *)(a2 + v5);
    if ( (v6 & 0x80u) == 0LL )
    {
      if ( (((((_BYTE)a2 + 7) & 0xF8) - (_BYTE)a2 - (_BYTE)v5) & 7) != 0 )
      {
        ++v5;
      }
      else
      {
        while ( v5 < v4 && ((*(_QWORD *)(a2 + v5) | *(_QWORD *)(a2 + v5 + 8)) & 0x8080808080808080LL) == 0 )
          v5 += 16LL;
        if ( v5 < a3 )
        {
          while ( *(char *)(a2 + v5) >= 0 )
          {
            if ( a3 == ++v5 )
              goto LABEL_50;
          }
        }
      }
      goto LABEL_6;
    }
    v7 = byte_4CC8C[v6];
    v8 = 1;
    if ( v7 != 4 )
    {
      if ( v7 == 3 )
      {
        if ( v5 + 1 >= a3 )
          goto LABEL_51;
        v10 = *(_BYTE *)(a2 + v5 + 1);
        if ( v6 == 224 )
        {
          if ( (v10 & 0xE0) != 0xA0 )
            goto LABEL_52;
        }
        else if ( (_DWORD)v6 == 237 )
        {
          if ( v10 > -97 )
            goto LABEL_52;
        }
        else if ( (unsigned __int8)(v6 + 31) >= 0xCu && (LOBYTE(v6) = v6 & 0xFE, (_BYTE)v6 != 0xEE) || v10 >= -64 )
        {
LABEL_52:
          LOBYTE(v6) = 1;
          goto LABEL_54;
        }
        v9 = v5 + 2;
        if ( v5 + 2 >= a3 )
          goto LABEL_51;
        if ( *(char *)(a2 + v9) > -65 )
          break;
      }
      else
      {
        if ( v7 != 2 )
          goto LABEL_52;
        v9 = v5 + 1;
        if ( v5 + 1 >= a3 )
        {
LABEL_51:
          v8 = 0;
          goto LABEL_54;
        }
        LOBYTE(v6) = 1;
        if ( *(char *)(a2 + v9) > -65 )
          goto LABEL_54;
      }
      goto LABEL_5;
    }
    if ( v5 + 1 >= a3 )
      goto LABEL_51;
    v11 = *(_BYTE *)(a2 + v5 + 1);
    if ( v6 == 240 )
    {
      if ( (unsigned __int8)(v11 + 112) >= 0x30u )
        goto LABEL_52;
    }
    else if ( (_DWORD)v6 == 244 )
    {
      if ( v11 > -113 )
        goto LABEL_52;
    }
    else if ( (unsigned __int8)(v6 + 15) > 2u || v11 >= -64 )
    {
      goto LABEL_52;
    }
    v6 = v5 + 2;
    if ( v5 + 2 >= a3 )
      goto LABEL_51;
    if ( *(char *)(a2 + v6) > -65 )
      break;
    v9 = v5 + 3;
    if ( v5 + 3 >= a3 )
      goto LABEL_51;
    if ( *(char *)(a2 + v9) > -65 )
    {
      LOBYTE(v6) = 3;
      goto LABEL_54;
    }
LABEL_5:
    v5 = v9 + 1;
LABEL_6:
    if ( v5 >= a3 )
      goto LABEL_50;
  }
  LOBYTE(v6) = 2;
LABEL_54:
  *(_QWORD *)(result + 8) = v5;
  *(_BYTE *)(result + 16) = v8;
  *(_BYTE *)(result + 17) = v6;
  v12 = 1LL;
LABEL_55:
  *(_QWORD *)result = v12;
  return result;
}
// 4CC8C: using guessed type unsigned __int8 byte_4CC8C[256];

//----- (0000000000044BF0) ----------------------------------------------------
unsigned __int64 __fastcall core::str::count::do_count_chars(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 i; // rcx
  int v6; // eax
  unsigned __int64 v7; // rdx
  __m128i v8; // xmm0
  __int64 v9; // rax
  __m128i v10; // xmm2
  __m128i v11; // xmm3
  __m128i v12; // xmm1
  __m128i v13; // xmm4
  __m128i v14; // xmm5
  __m128i v15; // xmm1
  unsigned __int64 v16; // rsi
  __m128i v17; // xmm0
  __int64 v18; // rdx
  __m128i si128; // xmm2
  __m128i v20; // xmm3
  __m128i v21; // xmm1
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm1
  unsigned __int64 v25; // rdi
  unsigned __int64 v26; // rsi
  __int64 v27; // r8
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rcx
  __m128i v30; // xmm1
  unsigned __int64 v31; // r8
  int v32; // ebx
  const __m128i *v33; // r9
  __int64 v34; // r10
  __int64 v35; // rdi
  __int64 v36; // r14
  const __m128i *v37; // rbx
  __m128i v38; // xmm4
  unsigned __int64 v39; // r8
  const __m128i *v40; // r12
  __m128i v41; // xmm2
  __m128i v42; // xmm5
  __m128i v43; // xmm3
  __m128i v44; // xmm3
  __m128i v45; // xmm4
  __m128i v46; // xmm6
  __m128i v47; // xmm2
  __m128i v48; // xmm5
  __m128i v49; // xmm4
  const __m128i *v50; // rdi
  __m128i v51; // xmm2
  __m128i v52; // xmm3
  __m128i v53; // xmm2
  __int64 v54; // r10
  unsigned __int64 v55; // rax

  v2 = ((a1 + 7) & 0xFFFFFFFFFFFFFFF8LL) - a1;
  v3 = a2 - v2;
  if ( a2 >= v2 && v3 >= 8 )
  {
    v6 = v3 & 7;
    if ( ((a1 + 7) & 0xFFFFFFFFFFFFFFF8LL) == a1 )
    {
      v7 = 0LL;
    }
    else
    {
      if ( v2 >= 4 )
      {
        v16 = v2 & 4;
        v17 = 0LL;
        v18 = 0LL;
        si128 = _mm_load_si128((const __m128i *)&xmmword_4C680);
        v20 = _mm_load_si128((const __m128i *)&xmmword_4C690);
        v21 = 0LL;
        do
        {
          v22 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(a1 + v18)), si128);
          v17 = _mm_add_epi64(
                  v17,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v22, v22), 212), 212), v20));
          v23 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(a1 + v18 + 2)), si128);
          v21 = _mm_add_epi64(
                  v21,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v23, v23), 212), 212), v20));
          v18 += 4LL;
        }
        while ( v16 != v18 );
        v24 = _mm_add_epi64(v21, v17);
        v7 = _mm_add_epi64(_mm_shuffle_epi32(v24, 238), v24).m128i_u64[0];
        goto LABEL_20;
      }
      v7 = 0LL;
      v16 = 0LL;
      do
      {
        v7 += *(_BYTE *)(a1 + v16++) >= 0xC0;
LABEL_20:
        ;
      }
      while ( v2 != v16 );
    }
    v25 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    if ( (v3 & 7) != 0 )
    {
      v26 = v3 & 0xFFFFFFFFFFFFFFF8LL;
      v27 = *(_BYTE *)(v25 + (v3 & 0xFFFFFFFFFFFFFFF8LL)) >= 0xC0;
      if ( v6 != 1 )
      {
        v27 += *(_BYTE *)(v25 + v26 + 1) >= 0xC0;
        if ( v6 != 2 )
        {
          v27 += *(_BYTE *)(v25 + v26 + 2) >= 0xC0;
          if ( v6 != 3 )
          {
            v27 += *(_BYTE *)(v25 + v26 + 3) >= 0xC0;
            if ( v6 != 4 )
            {
              v27 += *(_BYTE *)(v25 + v26 + 4) >= 0xC0;
              if ( v6 != 5 )
              {
                v27 += *(_BYTE *)(v25 + v26 + 5) >= 0xC0;
                if ( v6 != 6 )
                  v27 += *(_BYTE *)(v25 + v26 + 6) >= 0xC0;
              }
            }
          }
        }
      }
    }
    else
    {
      v27 = 0LL;
    }
    v28 = v7 + v27;
    v29 = v3 >> 3;
    v30 = _mm_load_si128((const __m128i *)&xmmword_4C6A0);
    while ( 1 )
    {
      result = v28;
      if ( !v29 )
        return result;
      v33 = (const __m128i *)v25;
      v34 = 192LL;
      if ( v29 < 0xC0 )
        v34 = v29;
      if ( v29 < 4 )
      {
        v31 = 0LL;
      }
      else
      {
        v35 = (unsigned int)v34 >> 2;
        if ( ((v35 + 0x7FFFFFFFFFFFFFFLL) & 0x7FFFFFFFFFFFFFFLL) != 0 )
        {
          v36 = ((v35 + 0x7FFFFFFFFFFFFFFLL) & 0x7FFFFFFFFFFFFFFLL) + 1;
          v37 = &v33[2 * (v36 & 0xFFFFFFFFFFFFFFFELL)];
          v38 = 0LL;
          v39 = v36 & 0xFFFFFFFFFFFFFFFELL;
          v40 = v33;
          do
          {
            v41 = _mm_loadu_si128(v40);
            v42 = _mm_loadu_si128(v40 + 2);
            v43 = _mm_unpacklo_epi64(v41, v42);
            v44 = _mm_add_epi64(
                    _mm_and_si128(
                      _mm_or_si128(_mm_srli_epi64(v43, 6u), _mm_srli_epi64(_mm_xor_si128(v43, (__m128i)-1LL), 7u)),
                      v30),
                    v38);
            v45 = _mm_loadu_si128(v40 + 1);
            v46 = _mm_loadu_si128(v40 + 3);
            v47 = _mm_unpackhi_epi64(v41, v42);
            v48 = _mm_unpacklo_epi64(v45, v46);
            v49 = _mm_unpackhi_epi64(v45, v46);
            v38 = _mm_add_epi64(
                    _mm_and_si128(
                      _mm_or_si128(_mm_srli_epi64(v49, 6u), _mm_srli_epi64(_mm_xor_si128(v49, (__m128i)-1LL), 7u)),
                      v30),
                    _mm_add_epi64(
                      _mm_add_epi64(
                        _mm_and_si128(
                          _mm_or_si128(_mm_srli_epi64(v48, 6u), _mm_srli_epi64(_mm_xor_si128(v48, (__m128i)-1LL), 7u)),
                          v30),
                        _mm_and_si128(
                          _mm_or_si128(_mm_srli_epi64(v47, 6u), _mm_srli_epi64(_mm_xor_si128(v47, (__m128i)-1LL), 7u)),
                          v30)),
                      v44));
            v40 += 4;
            v39 -= 2LL;
          }
          while ( v39 );
          v31 = _mm_add_epi64(_mm_shuffle_epi32(v38, 238), v38).m128i_u64[0];
          if ( v36 == (v36 & 0xFFFFFFFFFFFFFFFELL) )
            goto LABEL_32;
        }
        else
        {
          v31 = 0LL;
          v37 = v33;
        }
        v50 = (const __m128i *)((char *)v33 + (unsigned int)(32 * v35));
        do
        {
          v51 = _mm_loadu_si128(v37);
          v52 = _mm_loadu_si128(v37 + 1);
          v53 = _mm_add_epi64(
                  _mm_and_si128(
                    _mm_or_si128(_mm_srli_epi64(v51, 6u), _mm_srli_epi64(_mm_xor_si128(v51, (__m128i)-1LL), 7u)),
                    v30),
                  _mm_and_si128(
                    _mm_or_si128(_mm_srli_epi64(v52, 6u), _mm_srli_epi64(_mm_xor_si128(v52, (__m128i)-1LL), 7u)),
                    v30));
          v31 += _mm_add_epi64(_mm_shuffle_epi32(v53, 238), v53).m128i_u64[0];
          v37 += 2;
        }
        while ( v37 != v50 );
      }
LABEL_32:
      v25 = (unsigned __int64)v33 + 8 * (unsigned int)v34;
      v29 -= v34;
      v32 = v34 & 3;
      v28 = result + ((0x1000100010001LL * ((v31 & 0xFF00FF00FF00FFLL) + ((v31 >> 8) & 0xFF00FF00FF00FFLL))) >> 48);
      if ( (v34 & 3) != 0 )
      {
        v54 = (unsigned __int8)v34 & 0xFC;
        v55 = (((unsigned __int64)~v33->m128i_i64[(unsigned int)v54] >> 7) | ((unsigned __int64)v33->m128i_i64[(unsigned int)v54] >> 6)) & 0x101010101010101LL;
        if ( v32 != 1 )
        {
          v55 += (((unsigned __int64)~v33->m128i_i64[v54 + 1] >> 7) | ((unsigned __int64)v33->m128i_i64[v54 + 1] >> 6)) & 0x101010101010101LL;
          if ( v32 != 2 )
            v55 += (((unsigned __int64)~v33[1].m128i_i64[v54] >> 7) | ((unsigned __int64)v33[1].m128i_i64[v54] >> 6)) & 0x101010101010101LL;
        }
        return v28 + ((0x1000100010001LL * ((v55 & 0xFF00FF00FF00FFLL) + ((v55 >> 8) & 0xFF00FF00FF00FFLL))) >> 48);
      }
    }
  }
  if ( !a2 )
    return 0LL;
  if ( a2 < 4 )
  {
    result = 0LL;
    for ( i = 0LL; i != a2; ++i )
LABEL_12:
      result += *(_BYTE *)(a1 + i) >= 0xC0;
    return result;
  }
  i = a2 & 0xFFFFFFFFFFFFFFFCLL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = _mm_load_si128((const __m128i *)&xmmword_4C680);
  v11 = _mm_load_si128((const __m128i *)&xmmword_4C690);
  v12 = 0LL;
  do
  {
    v13 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(a1 + v9)), v10);
    v8 = _mm_add_epi64(
           v8,
           _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v13, v13), 212), 212), v11));
    v14 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(a1 + v9 + 2)), v10);
    v12 = _mm_add_epi64(
            v12,
            _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v14, v14), 212), 212), v11));
    v9 += 4LL;
  }
  while ( i != v9 );
  v15 = _mm_add_epi64(v12, v8);
  result = _mm_add_epi64(_mm_shuffle_epi32(v15, 238), v15).m128i_u64[0];
  if ( i != a2 )
    goto LABEL_12;
  return result;
}
// 4C680: using guessed type __int128 xmmword_4C680;
// 4C690: using guessed type __int128 xmmword_4C690;
// 4C6A0: using guessed type __int128 xmmword_4C6A0;

//----- (00000000000450F0) ----------------------------------------------------
unsigned __int64 __fastcall core::str::count::char_count_general_case(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  unsigned __int64 i; // rcx
  __m128i v4; // xmm0
  __int64 v5; // rax
  __m128i si128; // xmm2
  __m128i v7; // xmm3
  __m128i v8; // xmm1
  __m128i v9; // xmm4
  __m128i v10; // xmm5
  __m128i v11; // xmm1

  if ( !a2 )
    return 0LL;
  if ( a2 < 4 )
  {
    result = 0LL;
    for ( i = 0LL; i != a2; ++i )
LABEL_8:
      result += *(_BYTE *)(a1 + i) >= 0xC0;
    return result;
  }
  i = a2 & 0xFFFFFFFFFFFFFFFCLL;
  v4 = 0LL;
  v5 = 0LL;
  si128 = _mm_load_si128((const __m128i *)&xmmword_4C680);
  v7 = _mm_load_si128((const __m128i *)&xmmword_4C690);
  v8 = 0LL;
  do
  {
    v9 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(a1 + v5)), si128);
    v4 = _mm_add_epi64(
           v4,
           _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v9, v9), 212), 212), v7));
    v10 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*(unsigned __int16 *)(a1 + v5 + 2)), si128);
    v8 = _mm_add_epi64(
           v8,
           _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v10, v10), 212), 212), v7));
    v5 += 4LL;
  }
  while ( i != v5 );
  v11 = _mm_add_epi64(v8, v4);
  result = _mm_add_epi64(_mm_shuffle_epi32(v11, 238), v11).m128i_u64[0];
  if ( i != a2 )
    goto LABEL_8;
  return result;
}
// 4C680: using guessed type __int128 xmmword_4C680;
// 4C690: using guessed type __int128 xmmword_4C690;

//----- (00000000000451C0) ----------------------------------------------------
__int64 __fastcall core::str::pattern::StrSearcher::new(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        _BYTE *a4,
        unsigned __int64 a5)
{
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rax
  size_t v10; // rbp
  __int64 v11; // rcx
  unsigned __int64 v12; // r15
  unsigned __int64 v13; // rsi
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // r10
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r10
  unsigned __int64 v20; // rdi
  __int64 v21; // rdi
  unsigned __int8 v22; // di
  __int64 v23; // rdi
  __int64 v24; // rdi
  __int64 v25; // r9
  __int64 v26; // rsi
  __int64 v27; // r8
  unsigned __int64 v28; // rdi
  unsigned __int8 v29; // di
  __int64 v30; // rdi
  __int64 v31; // rdi
  __int64 v32; // rsi
  __int64 v33; // r8
  __int64 v34; // r9
  unsigned __int64 v35; // rcx
  __int64 v36; // r10
  unsigned __int64 v37; // rdi
  unsigned __int64 v38; // rax
  unsigned __int8 v39; // al
  __int64 v40; // r8
  __int64 v41; // rax
  __int64 v42; // r8
  __int64 v43; // r9
  __int64 v44; // r10
  unsigned __int64 v45; // rsi
  __int64 v46; // r11
  unsigned __int8 v47; // al
  __int64 v48; // r9
  __int64 v49; // rax
  size_t v50; // rcx
  __int64 v51; // rdi
  char *v52; // rdx
  __int64 v53; // rsi
  __int64 v54; // rsi
  __int64 v55; // rdx
  char *v56; // rdi
  __int64 v57; // r8

  if ( !a5 )
  {
    *(_QWORD *)(a1 + 72) = a2;
    *(_QWORD *)(a1 + 80) = a3;
    *(_QWORD *)(a1 + 88) = a4;
    *(_QWORD *)(a1 + 96) = 0LL;
    *(_OWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 16) = a3;
    *(_WORD *)(a1 + 24) = 257;
    *(_BYTE *)(a1 + 26) = 0;
    return a1;
  }
  if ( a5 != 1 )
  {
    v17 = 1LL;
    v8 = 1LL;
    v18 = 0LL;
    v9 = 0LL;
    v19 = 1LL;
    while ( 1 )
    {
      while ( 1 )
      {
        v21 = v9 + v18;
        if ( v9 + v18 >= a5 )
LABEL_86:
          core::panicking::panic_bounds_check(v21, a5, (__int64)&off_5A528);
        v22 = a4[v21];
        if ( a4[v17] >= v22 )
          break;
        v20 = v18 + v19 + 1;
        v8 = v20 - v9;
LABEL_18:
        v18 = 0LL;
        v17 = v20;
        v19 = v20;
        if ( v20 >= a5 )
          goto LABEL_27;
      }
      if ( a4[v17] != v22 )
      {
        v20 = v19 + 1;
        v8 = 1LL;
        v9 = v19;
        goto LABEL_18;
      }
      ++v18;
      v23 = 0LL;
      if ( v18 == v8 )
      {
        v23 = v18;
        v18 = 0LL;
      }
      v24 = v19 + v23;
      v17 = v18 + v24;
      v19 = v24;
      if ( v18 + v24 >= a5 )
      {
LABEL_27:
        v25 = 1LL;
        v11 = 1LL;
        v26 = 0LL;
        v10 = 0LL;
        v27 = 1LL;
        while ( 1 )
        {
          while ( 1 )
          {
            v21 = v26 + v10;
            if ( v26 + v10 >= a5 )
              goto LABEL_86;
            v29 = a4[v21];
            if ( a4[v25] <= v29 )
              break;
            v28 = v26 + v27 + 1;
            v11 = v28 - v10;
LABEL_29:
            v26 = 0LL;
            v25 = v28;
            v27 = v28;
            if ( v28 >= a5 )
              goto LABEL_4;
          }
          if ( a4[v25] != v29 )
          {
            v28 = v27 + 1;
            v11 = 1LL;
            v10 = v27;
            goto LABEL_29;
          }
          ++v26;
          v30 = 0LL;
          if ( v26 == v11 )
          {
            v30 = v26;
            v26 = 0LL;
          }
          v31 = v27 + v30;
          v25 = v26 + v31;
          v27 = v31;
          if ( v26 + v31 >= a5 )
            goto LABEL_4;
        }
      }
    }
  }
  v8 = 1LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 1LL;
LABEL_4:
  if ( v9 <= v10 )
    v8 = v11;
  else
    v10 = v9;
  v12 = a5 - v10;
  if ( a5 < v10 )
    core::slice::index::slice_end_index_len_fail(v10, a5, (__int64)&off_5A4F8);
  v13 = v10 + v8;
  if ( __CFADD__(v10, v8) )
    core::slice::index::slice_index_order_fail(v8, v13, (__int64)&off_5A510);
  if ( v13 > a5 )
    core::slice::index::slice_end_index_len_fail(v10 + v8, a5, (__int64)&off_5A510);
  if ( bcmp(a4, &a4[v8], v10) )
  {
    if ( v10 > v12 )
      v12 = v10;
    if ( a5 - 1 >= 3 )
    {
      v14 = 0LL;
      v15 = 0LL;
      v16 = a3;
      do
      {
        v14 |= (1LL << a4[v15]) | (1LL << a4[v15 + 1]) | (1LL << a4[v15 + 2]) | (1LL << a4[v15 + 3]);
        v15 += 4LL;
      }
      while ( (a5 & 0xFFFFFFFFFFFFFFFCLL) != v15 );
    }
    else
    {
      v14 = 0LL;
      v15 = 0LL;
      v16 = a3;
    }
    if ( (a5 & 3) != 0 )
    {
      v52 = &a4[v15];
      v53 = 0LL;
      do
        v14 |= 1LL << v52[v53++];
      while ( (a5 & 3) != v53 );
    }
    v54 = -1LL;
    v55 = -1LL;
    v8 = v12 + 1;
    v50 = v10;
  }
  else
  {
    v32 = 1LL;
    v33 = 0LL;
    v34 = 1LL;
    v35 = 0LL;
    do
    {
      if ( v34 + v33 >= a5 )
        break;
      v37 = ~v34 + a5 - v33;
      if ( v37 >= a5 )
LABEL_87:
        core::panicking::panic_bounds_check(v37, a5, (__int64)&off_5A540);
      v38 = a5 + ~v33 - v35;
      if ( v38 >= a5 )
LABEL_88:
        core::panicking::panic_bounds_check(v38, a5, (__int64)&off_5A558);
      v36 = v34 + 1;
      v39 = a4[v38];
      if ( a4[v37] < v39 )
      {
        v36 = v33 + v34 + 1;
        v32 = v36 - v35;
        v33 = 0LL;
      }
      else if ( a4[v37] == v39 )
      {
        v40 = v33 + 1;
        v41 = v40;
        if ( v40 == v32 )
          v41 = 0LL;
        else
          v40 = 0LL;
        v36 = v34 + v40;
        v33 = v41;
      }
      else
      {
        v32 = 1LL;
        v33 = 0LL;
        v35 = v34;
      }
      v34 = v36;
    }
    while ( v32 != v8 );
    v42 = 1LL;
    v43 = 0LL;
    v44 = 1LL;
    v45 = 0LL;
    while ( v44 + v43 < a5 )
    {
      v37 = ~v44 + a5 - v43;
      if ( v37 >= a5 )
        goto LABEL_87;
      v38 = a5 + ~v43 - v45;
      if ( v38 >= a5 )
        goto LABEL_88;
      v46 = v44 + 1;
      v47 = a4[v38];
      if ( a4[v37] > v47 )
      {
        v46 = v43 + v44 + 1;
        v42 = v46 - v45;
        v43 = 0LL;
      }
      else if ( a4[v37] == v47 )
      {
        v48 = v43 + 1;
        v49 = v48;
        if ( v48 == v42 )
          v49 = 0LL;
        else
          v48 = 0LL;
        v46 = v44 + v48;
        v43 = v49;
      }
      else
      {
        v42 = 1LL;
        v43 = 0LL;
        v45 = v44;
      }
      v44 = v46;
      if ( v42 == v8 )
        break;
    }
    if ( v35 > v45 )
      v45 = v35;
    v50 = a5 - v45;
    if ( v8 )
    {
      v16 = a3;
      if ( v8 >= 4 )
      {
        v14 = 0LL;
        v51 = 0LL;
        do
        {
          v14 |= (1LL << a4[v51]) | (1LL << a4[v51 + 1]) | (1LL << a4[v51 + 2]) | (1LL << a4[v51 + 3]);
          v51 += 4LL;
        }
        while ( (v8 & 0xFFFFFFFFFFFFFFFCLL) != v51 );
      }
      else
      {
        v14 = 0LL;
        v51 = 0LL;
      }
      if ( (v8 & 3) != 0 )
      {
        v56 = &a4[v51];
        v54 = 0LL;
        v57 = 0LL;
        do
          v14 |= 1LL << v56[v57++];
        while ( (v8 & 3) != v57 );
      }
      else
      {
        v54 = 0LL;
      }
      v55 = a5;
    }
    else
    {
      v54 = 0LL;
      v55 = a5;
      v14 = 0LL;
      v8 = 0LL;
      v16 = a3;
    }
  }
  *(_QWORD *)(a1 + 72) = a2;
  *(_QWORD *)(a1 + 80) = v16;
  *(_QWORD *)(a1 + 88) = a4;
  *(_QWORD *)(a1 + 96) = a5;
  *(_QWORD *)a1 = 1LL;
  *(_QWORD *)(a1 + 8) = v10;
  *(_QWORD *)(a1 + 16) = v50;
  *(_QWORD *)(a1 + 24) = v8;
  *(_QWORD *)(a1 + 32) = v14;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = v16;
  *(_QWORD *)(a1 + 56) = v54;
  *(_QWORD *)(a1 + 64) = v55;
  return a1;
}
// 5A4F8: using guessed type char *off_5A4F8;
// 5A510: using guessed type char *off_5A510;
// 5A528: using guessed type char *off_5A528;
// 5A540: using guessed type char *off_5A540;
// 5A558: using guessed type char *off_5A558;

//----- (0000000000045720) ----------------------------------------------------
_QWORD *__fastcall <core::str::lossy::Utf8Chunks as core::iter::traits::iterator::Iterator>::next(
        _QWORD *a1,
        __int64 *a2)
{
  _QWORD *result; // rax
  unsigned __int64 v3; // rdx
  __int64 v4; // rcx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // r8
  __int64 v8; // r11
  int v9; // ebx
  char *v10; // r11
  char *v11; // rbx
  char v12; // bl
  char *v13; // rbx
  char v14; // bl
  char *v15; // r11
  char *v16; // r11
  char *v17; // r11

  result = a1;
  v3 = a2[1];
  if ( v3 )
  {
    v4 = *a2;
    v5 = 0LL;
    while ( 1 )
    {
      v8 = *(unsigned __int8 *)(v4 + v5);
      v7 = v5 + 1;
      if ( (v8 & 0x80u) != 0LL )
      {
        v9 = byte_4CC8C[v8];
        switch ( v9 )
        {
          case 4:
            v13 = (char *)(v4 + v7);
            if ( v7 >= v3 )
              v13 = &byte_4CDAB;
            v14 = *v13;
            if ( v8 == 240 )
            {
              if ( (unsigned __int8)(v14 + 112) >= 0x30u )
                goto LABEL_45;
            }
            else if ( (_DWORD)v8 == 244 )
            {
              if ( v14 > -113 )
                goto LABEL_45;
            }
            else if ( (unsigned __int8)(v8 + 15) > 2u || v14 >= -64 )
            {
              goto LABEL_45;
            }
            v7 = v5 + 2;
            v16 = (char *)(v4 + v5 + 2);
            if ( v5 + 2 >= v3 )
              v16 = &byte_4CDAB;
            if ( (*v16 & 0xC0) != 0x80 )
              goto LABEL_45;
            v7 = v5 + 3;
            v17 = (char *)(v4 + v5 + 3);
            if ( v5 + 3 >= v3 )
              v17 = &byte_4CDAB;
            if ( (*v17 & 0xC0) != 0x80 )
              goto LABEL_45;
            v6 = v5 + 4;
            break;
          case 3:
            v11 = (char *)(v4 + v7);
            if ( v7 >= v3 )
              v11 = &byte_4CDAB;
            v12 = *v11;
            if ( (_DWORD)v8 == 224 )
            {
              if ( (v12 & 0xE0) != 0xA0 )
                goto LABEL_45;
            }
            else if ( (_DWORD)v8 == 237 )
            {
              if ( v12 > -97 )
                goto LABEL_45;
            }
            else if ( (unsigned __int8)(v8 + 31) >= 0xCu && (v8 & 0xFE) != 0xEE || v12 >= -64 )
            {
              goto LABEL_45;
            }
            v7 = v5 + 2;
            v15 = (char *)(v4 + v5 + 2);
            if ( v5 + 2 >= v3 )
              v15 = &byte_4CDAB;
            if ( (*v15 & 0xC0) != 0x80 )
            {
LABEL_45:
              *a2 = v4 + v7;
              a2[1] = v3 - v7;
              *result = v4;
              result[1] = v5;
              result[2] = v5 + v4;
              result[3] = v7 - v5;
              return result;
            }
            v6 = v5 + 3;
            break;
          case 2:
            v10 = (char *)(v4 + v7);
            if ( v7 >= v3 )
              v10 = &byte_4CDAB;
            if ( (*v10 & 0xC0) != 0x80 )
              goto LABEL_45;
            v6 = v5 + 2;
            break;
          default:
            goto LABEL_45;
        }
        v7 = v6;
      }
      v5 = v7;
      if ( v7 >= v3 )
        goto LABEL_45;
    }
  }
  *a1 = 0LL;
  return result;
}
// 4CC8C: using guessed type unsigned __int8 byte_4CC8C[256];
// 4CDAB: using guessed type char;

//----- (00000000000458E0) ----------------------------------------------------
void __fastcall __noreturn core::str::slice_error_fail_rt(
        _BYTE *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5)
{
  __int64 v5; // r9
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rcx
  __int64 v8; // rax
  _BYTE *v9; // r9
  _BYTE *v10; // rdx
  char v11; // dl
  __int64 v12; // rcx
  int v13; // ecx
  int v14; // r9d
  int v15; // esi
  unsigned int v16; // edx
  unsigned int v17; // [rsp+Ch] [rbp-CCh] BYREF
  _BYTE *v18; // [rsp+10h] [rbp-C8h] BYREF
  unsigned __int64 v19; // [rsp+18h] [rbp-C0h]
  char **v20; // [rsp+20h] [rbp-B8h] BYREF
  __int64 v21; // [rsp+28h] [rbp-B0h]
  unsigned __int64 **v22; // [rsp+30h] [rbp-A8h]
  __int64 v23; // [rsp+38h] [rbp-A0h]
  __int64 v24; // [rsp+40h] [rbp-98h]
  unsigned __int64 *v25; // [rsp+50h] [rbp-88h] BYREF
  __int64 (__fastcall *v26)(unsigned __int64 *, __int64); // [rsp+58h] [rbp-80h]
  unsigned __int64 *v27; // [rsp+60h] [rbp-78h]
  void *v28; // [rsp+68h] [rbp-70h]
  const char **v29; // [rsp+70h] [rbp-68h]
  void *v30; // [rsp+78h] [rbp-60h]
  const char **v31; // [rsp+80h] [rbp-58h]
  char (__fastcall *v32)(__int64, __int64); // [rsp+88h] [rbp-50h]
  const char **v33; // [rsp+90h] [rbp-48h]
  char (__fastcall *v34)(__int64, __int64); // [rsp+98h] [rbp-40h]
  const char *v35; // [rsp+A0h] [rbp-38h] BYREF
  __int64 v36; // [rsp+A8h] [rbp-30h]
  __int64 v37[2]; // [rsp+B0h] [rbp-28h] BYREF
  unsigned __int64 v38; // [rsp+C0h] [rbp-18h] BYREF
  unsigned __int64 v39; // [rsp+C8h] [rbp-10h] BYREF
  unsigned __int64 v40; // [rsp+D0h] [rbp-8h] BYREF

  v38 = a3;
  v39 = a4;
  if ( a2 < 0x101 )
  {
    v18 = a1;
    v19 = a2;
    v35 = (const char *)&unk_4C8A8;
    v36 = 0LL;
    if ( a3 > a2 )
      goto LABEL_12;
  }
  else
  {
    v5 = 3LL;
    if ( (char)a1[256] <= -65 )
    {
      v5 = 2LL;
      if ( (char)a1[255] <= -65 )
        v5 = a1[254] >= 0xC0;
    }
    if ( (char)a1[v5 + 253] <= -65 )
      core::str::slice_error_fail(a1, a2, 0LL, v5 + 253, a5);
    v18 = a1;
    v19 = v5 + 253;
    v35 = asc_4CDAC;
    v36 = 5LL;
    if ( a3 > a2 )
    {
LABEL_12:
      if ( a3 > a2 )
        a4 = a3;
      v37[0] = a4;
      v25 = (unsigned __int64 *)v37;
      v26 = core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
      v27 = (unsigned __int64 *)&v18;
      v28 = <&T as core::fmt::Display>::fmt;
      v29 = &v35;
      v30 = <&T as core::fmt::Display>::fmt;
      v20 = &off_5A600;
      v21 = 3LL;
      v24 = 0LL;
      v22 = &v25;
      v23 = 3LL;
      core::panicking::panic_fmt((__int64)&v20, a5);
    }
  }
  if ( a4 > a2 )
    goto LABEL_12;
  if ( a3 > a4 )
  {
    v25 = &v38;
    v26 = core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
    v27 = &v39;
    v28 = core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
    v29 = (const char **)&v18;
    v30 = <&T as core::fmt::Display>::fmt;
    v31 = &v35;
    v32 = <&T as core::fmt::Display>::fmt;
    v20 = &off_5A570;
    v21 = 4LL;
    v24 = 0LL;
    v22 = &v25;
    v23 = 4LL;
    core::panicking::panic_fmt((__int64)&v20, a5);
  }
  if ( !a3 || a3 >= a2 || (char)a1[a3] >= -64 )
    a3 = a4;
  v40 = a3;
  v6 = a2;
  if ( a3 < a2 )
  {
    v7 = 0LL;
    if ( a3 >= 3 )
      v7 = a3 - 3;
    v8 = a3 + 1;
    if ( v7 > a3 + 1 )
      core::slice::index::slice_index_order_fail(v7, v8, (__int64)&off_5A630);
    if ( v7 != a3 + 1 )
    {
      v9 = &a1[v7];
      v8 -= v7;
      if ( (char)a1[a3] <= -65 )
      {
        if ( v7 != a3 )
        {
          v10 = &a1[a3];
          if ( (char)*(v10 - 1) <= -65 )
          {
            if ( v9 != v10 - 1 )
            {
              if ( (char)*(v10 - 2) <= -65 )
              {
                if ( v9 != v10 - 2 )
                {
                  if ( (char)*(v10 - 3) <= -65 )
                  {
                    if ( v9 != v10 - 3 )
                      v8 -= 5LL;
                  }
                  else
                  {
                    v8 -= 4LL;
                  }
                }
              }
              else
              {
                v8 -= 3LL;
              }
            }
          }
          else
          {
            v8 -= 2LL;
          }
        }
      }
      else
      {
        --v8;
      }
    }
    v6 = v7 + v8;
  }
  if ( !v6 )
  {
LABEL_41:
    if ( v6 == a2 )
      goto LABEL_42;
    v11 = a1[v6];
    if ( v11 < 0 )
    {
      v13 = v11 & 0x1F;
      v14 = a1[v6 + 1] & 0x3F;
      if ( (unsigned __int8)v11 <= 0xDFu )
      {
        v16 = v14 | (v13 << 6);
      }
      else
      {
        v15 = (v14 << 6) | a1[v6 + 2] & 0x3F;
        if ( (unsigned __int8)v11 < 0xF0u )
        {
          v16 = (v13 << 12) | v15;
        }
        else
        {
          v16 = ((v11 & 7) << 18) | (v15 << 6) | a1[v6 + 3] & 0x3F;
          if ( v16 == 1114112 )
LABEL_42:
            core::option::unwrap_failed(a5);
        }
      }
      v17 = v16;
      v12 = 1LL;
      if ( v16 >= 0x80 )
      {
        v12 = 2LL;
        if ( v16 >= 0x800 )
          v12 = 4LL - (v16 < 0x10000);
      }
    }
    else
    {
      v17 = (unsigned __int8)a1[v6];
      v12 = 1LL;
    }
    v37[0] = v6;
    v37[1] = v6 + v12;
    v25 = &v40;
    v26 = core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt;
    v27 = (unsigned __int64 *)&v17;
    v28 = <char as core::fmt::Debug>::fmt;
    v29 = (const char **)v37;
    v30 = <core::ops::range::Range<Idx> as core::fmt::Debug>::fmt;
    v31 = (const char **)&v18;
    v32 = <&T as core::fmt::Display>::fmt;
    v33 = &v35;
    v34 = <&T as core::fmt::Display>::fmt;
    v20 = &off_5A5B0;
    v21 = 5LL;
    v24 = 0LL;
    v22 = &v25;
    v23 = 5LL;
    core::panicking::panic_fmt((__int64)&v20, a5);
  }
  if ( v6 >= a2 )
  {
    if ( v6 == a2 )
      goto LABEL_41;
  }
  else if ( (char)a1[v6] > -65 )
  {
    goto LABEL_41;
  }
  core::str::slice_error_fail(a1, a2, v6, a2, a5);
}
// 5A570: using guessed type char *off_5A570;
// 5A5B0: using guessed type char *off_5A5B0;
// 5A600: using guessed type char *off_5A600;
// 5A630: using guessed type char *off_5A630;

//----- (0000000000045D30) ----------------------------------------------------
char __fastcall core::unicode::printable::check(
        unsigned __int16 a1,
        _BYTE *a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        unsigned __int8 *a6,
        __int64 a7)
{
  _BYTE *v7; // rdx
  unsigned __int64 v8; // rax
  _BYTE *v9; // r14
  __int64 v10; // rbx
  unsigned __int64 v11; // r10
  __int64 v12; // rax
  __int64 v13; // r14
  unsigned __int8 *v15; // rcx
  int v16; // edx
  int v17; // esi
  int v18; // edi
  char v19; // al

  if ( a3 )
  {
    v7 = &a2[2 * a3];
    v8 = 0LL;
    do
    {
      v9 = a2;
      v10 = (unsigned __int8)a2[1];
      a2 += 2;
      v11 = v8 + v10;
      if ( *v9 == HIBYTE(a1) )
      {
        if ( v8 > v11 )
          core::slice::index::slice_index_order_fail(v8, v8 + v10, (__int64)&off_5A660);
        if ( v11 > a5 )
          core::slice::index::slice_end_index_len_fail(v8 + v10, a5, (__int64)&off_5A660);
        v12 = a4 + v8;
        v13 = 0LL;
        while ( v10 != v13 )
        {
          if ( *(_BYTE *)(v12 + v13++) == (unsigned __int8)a1 )
          {
            v19 = 0;
            return v19 & 1;
          }
        }
      }
      else if ( *v9 > HIBYTE(a1) )
      {
        break;
      }
      v8 = v11;
    }
    while ( a2 != v7 );
  }
  if ( a7 )
  {
    v15 = &a6[a7];
    v16 = a1;
    v19 = 1;
    while ( 1 )
    {
      v17 = *a6;
      if ( (v17 & 0x80u) != 0 )
      {
        if ( a6 + 1 == v15 )
          core::option::unwrap_failed((__int64)&off_5A648);
        v18 = a6[1];
        a6 += 2;
        v16 -= v18 | ((v17 & 0x7F) << 8);
        if ( v16 < 0 )
          return v19 & 1;
      }
      else
      {
        ++a6;
        v16 -= v17;
        if ( v16 < 0 )
          return v19 & 1;
      }
      v19 ^= 1u;
      if ( a6 == v15 )
        return v19 & 1;
    }
  }
  v19 = 1;
  return v19 & 1;
}
// 5A648: using guessed type char *off_5A648;
// 5A660: using guessed type char *off_5A660;

//----- (0000000000045E50) ----------------------------------------------------
char __fastcall core::unicode::printable::is_printable(unsigned int a1)
{
  char result; // al

  if ( a1 < 0x20 )
    return 0;
  result = 1;
  if ( a1 >= 0x7F )
  {
    if ( a1 >= 0x10000 )
    {
      if ( a1 >= 0x20000 )
      {
        result = 0;
        if ( _mm_movemask_ps((__m128)_mm_cmpgt_epi32(
                                       _mm_xor_si128(
                                         _mm_add_epi32(
                                           _mm_shuffle_epi32(_mm_cvtsi32_si128(a1), 0),
                                           (__m128i)xmmword_4C6B0),
                                         (__m128i)xmmword_4C6C0),
                                       (__m128i)xmmword_4C6D0)) == 15
          && a1 - 201547 >= 5
          && a1 - 205744 >= 0xADD50
          && (a1 & 0xFFFFFFE0) != 173792
          && (a1 & 0xFFFFFFFE) != 178206 )
        {
          return a1 - 1114112 < 0xFFFD01F0;
        }
      }
      else
      {
        return core::unicode::printable::check(a1, byte_4CE4D, 44LL, (__int64)aNo, 0xC4uLL, byte_4CF69, 450LL);
      }
    }
    else
    {
      return core::unicode::printable::check(a1, byte_4D12B, 40LL, (__int64)asc_4D17B, 0x11FuLL, byte_4D29A, 303LL);
    }
  }
  return result;
}
// 4C6B0: using guessed type __int128 xmmword_4C6B0;
// 4C6C0: using guessed type __int128 xmmword_4C6C0;
// 4C6D0: using guessed type __int128 xmmword_4C6D0;
// 4CE4D: using guessed type _BYTE[88];
// 4CF69: using guessed type unsigned __int8 byte_4CF69[450];
// 4D12B: using guessed type _BYTE byte_4D12B[80];
// 4D29A: using guessed type unsigned __int8 byte_4D29A[303];

//----- (0000000000045F70) ----------------------------------------------------
__int64 __fastcall core::num::<impl usize>::from_str_radix(
        __int64 a1,
        unsigned __int8 *a2,
        unsigned __int64 a3,
        unsigned int a4)
{
  core::num::from_str_radix(a1, a2, a3, a4);
  return a1;
}

//----- (0000000000045F80) ----------------------------------------------------
__int64 __fastcall core::num::<impl core::str::traits::FromStr for usize>::from_str(
        __int64 a1,
        unsigned __int8 *a2,
        unsigned __int64 a3)
{
  unsigned __int64 v3; // rcx
  int v4; // eax
  __int64 v5; // r8
  __int64 v6; // rax
  unsigned __int128 v7; // rax
  unsigned int v8; // r10d
  bool v9; // cf
  __int64 v11; // rdx
  unsigned int v12; // r8d

  if ( !a3 )
  {
    *(_BYTE *)(a1 + 1) = 0;
    *(_BYTE *)a1 = 1;
    return a1;
  }
  v3 = a3;
  v4 = *a2;
  if ( v4 == 43 )
  {
    v3 = a3 - 1;
    if ( a3 != 1 )
    {
      ++a2;
      if ( v3 > 0x10 )
        goto LABEL_6;
      goto LABEL_15;
    }
LABEL_19:
    *(_BYTE *)(a1 + 1) = 1;
    *(_BYTE *)a1 = 1;
    return a1;
  }
  if ( v4 == 45 && a3 == 1 )
    goto LABEL_19;
  if ( a3 <= 0x10 )
  {
LABEL_15:
    v11 = 0LL;
    v6 = 0LL;
    while ( 1 )
    {
      v12 = a2[v11] - 48;
      if ( v12 >= 0xA )
        goto LABEL_19;
      v6 = v12 + 10 * v6;
      if ( v3 == ++v11 )
        goto LABEL_18;
    }
  }
LABEL_6:
  v5 = 0LL;
  v6 = 0LL;
  while ( v3 != v5 )
  {
    v7 = 0xA * (unsigned __int128)(unsigned __int64)v6;
    BYTE8(v7) = *((_QWORD *)&v7 + 1) != 0LL;
    v8 = a2[v5] - 48;
    if ( v8 >= 0xA )
      goto LABEL_19;
    if ( !BYTE8(v7) )
    {
      ++v5;
      v9 = __CFADD__(v8, (_QWORD)v7);
      v6 = v8 + (_QWORD)v7;
      if ( !v9 )
        continue;
    }
    *(_BYTE *)(a1 + 1) = 2;
    *(_BYTE *)a1 = 1;
    return a1;
  }
LABEL_18:
  *(_QWORD *)(a1 + 8) = v6;
  *(_BYTE *)a1 = 0;
  return a1;
}

//----- (0000000000046050) ----------------------------------------------------
__int64 __fastcall core::fmt::num::<impl core::fmt::LowerHex for u8>::fmt(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int8 v2; // al
  void **v3; // r8
  __int64 v4; // r9
  unsigned __int8 v5; // cl
  char v6; // di
  bool v7; // cf
  void *retaddr; // [rsp+88h] [rbp+0h] BYREF

  v2 = *a1;
  v3 = &retaddr;
  v4 = 0LL;
  v5 = *a1;
  do
  {
    v5 >>= 4;
    v6 = (v2 & 0xF) + 87;
    if ( (v2 & 0xFu) < 0xA )
      v6 = (v2 & 0xF) + 48;
    *((_BYTE *)v3 - 1) = v6;
    v3 = (void **)((char *)v3 - 1);
    ++v4;
    v7 = v2 < 0x10u;
    v2 = v5;
  }
  while ( !v7 );
  if ( (unsigned __int64)(128 - v4) >= 0x81 )
    core::slice::index::slice_start_index_len_fail(128 - v4, 128LL, (__int64)&off_5A3C8);
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)a0x_0, 2uLL, (__int64)v3, v4);
}
// 5A3C8: using guessed type char *off_5A3C8;

//----- (00000000000460F0) ----------------------------------------------------
__int64 __fastcall core::fmt::num::<impl core::fmt::UpperHex for u8>::fmt(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int8 v2; // al
  void **v3; // r8
  __int64 v4; // r9
  unsigned __int8 v5; // cl
  char v6; // di
  bool v7; // cf
  void *retaddr; // [rsp+88h] [rbp+0h] BYREF

  v2 = *a1;
  v3 = &retaddr;
  v4 = 0LL;
  v5 = *a1;
  do
  {
    v5 >>= 4;
    v6 = (v2 & 0xF) + 55;
    if ( (v2 & 0xFu) < 0xA )
      v6 = (v2 & 0xF) + 48;
    *((_BYTE *)v3 - 1) = v6;
    v3 = (void **)((char *)v3 - 1);
    ++v4;
    v7 = v2 < 0x10u;
    v2 = v5;
  }
  while ( !v7 );
  if ( (unsigned __int64)(128 - v4) >= 0x81 )
    core::slice::index::slice_start_index_len_fail(128 - v4, 128LL, (__int64)&off_5A3C8);
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)a0x_0, 2uLL, (__int64)v3, v4);
}
// 5A3C8: using guessed type char *off_5A3C8;

//----- (0000000000046190) ----------------------------------------------------
__int64 __fastcall core::fmt::num::<impl core::fmt::LowerHex for u32>::fmt(unsigned int *a1, __int64 a2)
{
  unsigned int v2; // eax
  void **v3; // r8
  __int64 v4; // r9
  unsigned int v5; // ecx
  char v6; // di
  bool v7; // cf
  void *retaddr; // [rsp+88h] [rbp+0h] BYREF

  v2 = *a1;
  v3 = &retaddr;
  v4 = 0LL;
  v5 = *a1;
  do
  {
    v5 >>= 4;
    v6 = (v2 & 0xF) + 87;
    if ( (v2 & 0xF) < 0xA )
      v6 = (v2 & 0xF) + 48;
    *((_BYTE *)v3 - 1) = v6;
    v3 = (void **)((char *)v3 - 1);
    ++v4;
    v7 = v2 < 0x10;
    v2 = v5;
  }
  while ( !v7 );
  if ( (unsigned __int64)(128 - v4) >= 0x81 )
    core::slice::index::slice_start_index_len_fail(128 - v4, 128LL, (__int64)&off_5A3C8);
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)a0x_0, 2uLL, (__int64)v3, v4);
}
// 5A3C8: using guessed type char *off_5A3C8;

//----- (0000000000046230) ----------------------------------------------------
__int64 __fastcall core::fmt::num::<impl core::fmt::UpperHex for u32>::fmt(unsigned int *a1, __int64 a2)
{
  unsigned int v2; // eax
  void **v3; // r8
  __int64 v4; // r9
  unsigned int v5; // ecx
  char v6; // di
  bool v7; // cf
  void *retaddr; // [rsp+88h] [rbp+0h] BYREF

  v2 = *a1;
  v3 = &retaddr;
  v4 = 0LL;
  v5 = *a1;
  do
  {
    v5 >>= 4;
    v6 = (v2 & 0xF) + 55;
    if ( (v2 & 0xF) < 0xA )
      v6 = (v2 & 0xF) + 48;
    *((_BYTE *)v3 - 1) = v6;
    v3 = (void **)((char *)v3 - 1);
    ++v4;
    v7 = v2 < 0x10;
    v2 = v5;
  }
  while ( !v7 );
  if ( (unsigned __int64)(128 - v4) >= 0x81 )
    core::slice::index::slice_start_index_len_fail(128 - v4, 128LL, (__int64)&off_5A3C8);
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)a0x_0, 2uLL, (__int64)v3, v4);
}
// 5A3C8: using guessed type char *off_5A3C8;

//----- (00000000000462D0) ----------------------------------------------------
__int64 __fastcall core::fmt::num::<impl core::fmt::LowerHex for usize>::fmt(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  void **v3; // r8
  __int64 v4; // r9
  unsigned __int64 v5; // rcx
  char v6; // di
  bool v7; // cf
  void *retaddr; // [rsp+88h] [rbp+0h] BYREF

  v2 = *a1;
  v3 = &retaddr;
  v4 = 0LL;
  v5 = *a1;
  do
  {
    v5 >>= 4;
    v6 = (v2 & 0xF) + 87;
    if ( (v2 & 0xF) < 0xA )
      v6 = (v2 & 0xF) + 48;
    *((_BYTE *)v3 - 1) = v6;
    v3 = (void **)((char *)v3 - 1);
    ++v4;
    v7 = v2 < 0x10;
    v2 = v5;
  }
  while ( !v7 );
  if ( (unsigned __int64)(128 - v4) >= 0x81 )
    core::slice::index::slice_start_index_len_fail(128 - v4, 128LL, (__int64)&off_5A3C8);
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)a0x_0, 2uLL, (__int64)v3, v4);
}
// 5A3C8: using guessed type char *off_5A3C8;

//----- (0000000000046370) ----------------------------------------------------
__int64 __fastcall core::fmt::num::<impl core::fmt::UpperHex for usize>::fmt(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  void **v3; // r8
  __int64 v4; // r9
  unsigned __int64 v5; // rcx
  char v6; // di
  bool v7; // cf
  void *retaddr; // [rsp+88h] [rbp+0h] BYREF

  v2 = *a1;
  v3 = &retaddr;
  v4 = 0LL;
  v5 = *a1;
  do
  {
    v5 >>= 4;
    v6 = (v2 & 0xF) + 55;
    if ( (v2 & 0xF) < 0xA )
      v6 = (v2 & 0xF) + 48;
    *((_BYTE *)v3 - 1) = v6;
    v3 = (void **)((char *)v3 - 1);
    ++v4;
    v7 = v2 < 0x10;
    v2 = v5;
  }
  while ( !v7 );
  if ( (unsigned __int64)(128 - v4) >= 0x81 )
    core::slice::index::slice_start_index_len_fail(128 - v4, 128LL, (__int64)&off_5A3C8);
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)a0x_0, 2uLL, (__int64)v3, v4);
}
// 5A3C8: using guessed type char *off_5A3C8;

//----- (0000000000046410) ----------------------------------------------------
__int64 __fastcall core::fmt::num::<impl core::fmt::Debug for usize>::fmt(unsigned __int64 *a1, __int64 a2)
{
  int v2; // eax
  unsigned __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // r9
  unsigned __int64 v6; // rdx
  int v7; // r10d
  bool v8; // cc
  __int64 v9; // rax
  unsigned __int64 v10; // rax
  void **v11; // r8
  __int64 v12; // r9
  unsigned __int64 v13; // rcx
  char v14; // di
  bool v15; // cf
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rcx
  char v18; // di
  __int16 v20[66]; // [rsp+4h] [rbp-84h] BYREF
  void *retaddr; // [rsp+88h] [rbp+0h] BYREF

  v2 = *(_DWORD *)(a2 + 52);
  if ( (v2 & 0x10) != 0 )
  {
    v10 = *a1;
    v11 = &retaddr;
    v12 = 0LL;
    v13 = *a1;
    do
    {
      v13 >>= 4;
      v14 = (v10 & 0xF) + 87;
      if ( (v10 & 0xF) < 0xA )
        v14 = (v10 & 0xF) + 48;
      *((_BYTE *)v11 - 1) = v14;
      v11 = (void **)((char *)v11 - 1);
      ++v12;
      v15 = v10 < 0x10;
      v10 = v13;
    }
    while ( !v15 );
  }
  else
  {
    if ( (v2 & 0x20) == 0 )
    {
      v3 = *a1;
      v4 = 39LL;
      if ( *a1 < 0x2710 )
      {
        v6 = *a1;
        if ( v3 <= 0x63 )
          goto LABEL_8;
      }
      else
      {
        v5 = 39LL;
        do
        {
          v6 = v3 / 0x2710;
          v7 = v3 % 0x2710;
          v4 = v5 - 4;
          *(__int16 *)((char *)v20 + v5) = word_4CAD7[(unsigned int)(5243 * v7) >> 19];
          *(__int16 *)((char *)&v20[1] + v5) = word_4CAD7[(unsigned __int16)(v7
                                                                           - 100
                                                                           * ((unsigned __int16)((unsigned int)(5243 * v7) >> 16) >> 3))];
          v5 -= 4LL;
          v8 = v3 <= 0x5F5E0FF;
          v3 /= 0x2710uLL;
        }
        while ( !v8 );
        if ( v6 <= 0x63 )
        {
LABEL_8:
          if ( v6 >= 0xA )
          {
            *(__int16 *)((char *)&v20[1] + v4) = word_4CAD7[v6];
            v9 = v4 - 2;
          }
          else
          {
            *((_BYTE *)&v20[1] + v4 + 1) = v6 | 0x30;
            v9 = v4 - 1;
          }
          return core::fmt::Formatter::pad_integral(a2, 1, (__int64)&unk_4C8A8, 0LL, (__int64)&v20[2] + v9, 39 - v9);
        }
      }
      *(__int16 *)((char *)&v20[1] + v4) = word_4CAD7[(unsigned __int16)v6 % 0x64u];
      v4 -= 2LL;
      v6 = (unsigned int)(5243 * ((unsigned __int16)v6 >> 2)) >> 17;
      goto LABEL_8;
    }
    v16 = *a1;
    v11 = &retaddr;
    v12 = 0LL;
    v17 = *a1;
    do
    {
      v17 >>= 4;
      v18 = (v16 & 0xF) + 55;
      if ( (v16 & 0xF) < 0xA )
        v18 = (v16 & 0xF) + 48;
      *((_BYTE *)v11 - 1) = v18;
      v11 = (void **)((char *)v11 - 1);
      ++v12;
      v15 = v16 < 0x10;
      v16 = v17;
    }
    while ( !v15 );
  }
  if ( (unsigned __int64)(128 - v12) >= 0x81 )
    core::slice::index::slice_start_index_len_fail(128 - v12, 128LL, (__int64)&off_5A3C8);
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)a0x_0, 2uLL, (__int64)v11, v12);
}
// 4CAD7: using guessed type _WORD word_4CAD7[100];
// 5A3C8: using guessed type char *off_5A3C8;

//----- (0000000000046630) ----------------------------------------------------
__int64 __fastcall core::fmt::num::imp::<impl core::fmt::Display for u8>::fmt(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rcx
  char v5[37]; // [rsp+1h] [rbp-27h] BYREF
  __int16 v6; // [rsp+26h] [rbp-2h]

  v2 = *a1;
  if ( v2 < 0x64 )
  {
    v3 = 38LL;
    if ( (unsigned __int8)v2 >= 0xAu )
    {
      v6 = word_4CAD7[v2];
      v3 = 37LL;
      return core::fmt::Formatter::pad_integral(a2, 1, (__int64)&unk_4C8A8, 0LL, (__int64)&v5[v3], 39 - v3);
    }
  }
  else
  {
    v6 = word_4CAD7[(unsigned __int8)v2 % 0x64u];
    v3 = 36LL;
    LOBYTE(v2) = (unsigned __int8)v2 / 0x64u;
  }
  v5[v3] = v2 | 0x30;
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)&unk_4C8A8, 0LL, (__int64)&v5[v3], 39 - v3);
}
// 4CAD7: using guessed type _WORD word_4CAD7[100];
// 46630: using guessed type char var_27[37];

//----- (00000000000466C0) ----------------------------------------------------
__int64 __fastcall core::fmt::num::imp::<impl core::fmt::Display for i32>::fmt(int *a1, __int64 a2)
{
  int v2; // ecx
  unsigned __int64 v3; // r8
  __int64 v4; // rax
  __int64 v5; // r10
  unsigned __int64 v6; // rdx
  int v7; // r11d
  bool v8; // cc
  __int64 v9; // rax
  __int16 v11[25]; // [rsp+5h] [rbp-33h] BYREF

  v2 = *a1;
  v3 = (unsigned int)-*a1;
  if ( *a1 > 0 )
    v3 = (unsigned int)v2;
  v4 = 39LL;
  if ( (unsigned int)v3 >= 0x2710 )
  {
    v5 = 39LL;
    do
    {
      v6 = v3 / 0x2710;
      v7 = v3 % 0x2710;
      v4 = v5 - 4;
      *(__int16 *)((char *)v11 + v5) = word_4CAD7[(unsigned int)(5243 * v7) >> 19];
      *(__int16 *)((char *)&v11[1] + v5) = word_4CAD7[(unsigned __int16)(v7
                                                                       - 100
                                                                       * ((unsigned __int16)((unsigned int)(5243 * v7) >> 16) >> 3))];
      v5 -= 4LL;
      v8 = v3 <= 0x5F5E0FF;
      v3 /= 0x2710uLL;
    }
    while ( !v8 );
    if ( v6 <= 0x63 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v6 = v3;
  if ( v3 > 0x63 )
  {
LABEL_7:
    *(__int16 *)((char *)&v11[1] + v4) = word_4CAD7[(unsigned __int16)v6 % 0x64u];
    v4 -= 2LL;
    v6 = (unsigned int)(5243 * ((unsigned __int16)v6 >> 2)) >> 17;
  }
LABEL_8:
  if ( v6 >= 0xA )
  {
    *(__int16 *)((char *)&v11[1] + v4) = word_4CAD7[v6];
    v9 = v4 - 2;
  }
  else
  {
    *((_BYTE *)&v11[1] + v4 + 1) = v6 | 0x30;
    v9 = v4 - 1;
  }
  return core::fmt::Formatter::pad_integral(a2, v2 >= 0, (__int64)&unk_4C8A8, 0LL, (__int64)&v11[2] + v9, 39 - v9);
}
// 4CAD7: using guessed type _WORD word_4CAD7[100];

//----- (00000000000467E0) ----------------------------------------------------
__int64 __fastcall core::fmt::num::imp::<impl core::fmt::Display for u32>::fmt(unsigned int *a1, __int64 a2)
{
  unsigned __int64 v2; // rcx
  __int64 v3; // rax
  __int64 v4; // r9
  unsigned __int64 v5; // rdx
  int v6; // r10d
  bool v7; // cc
  __int64 v8; // rax
  __int16 v10[21]; // [rsp+1h] [rbp-2Bh] BYREF

  v2 = *a1;
  v3 = 39LL;
  if ( v2 >= 0x2710 )
  {
    v4 = 39LL;
    do
    {
      v5 = v2 / 0x2710;
      v6 = v2 % 0x2710;
      v3 = v4 - 4;
      *(__int16 *)((char *)v10 + v4) = word_4CAD7[(unsigned int)(5243 * v6) >> 19];
      *(__int16 *)((char *)&v10[1] + v4) = word_4CAD7[(unsigned __int16)(v6
                                                                       - 100
                                                                       * ((unsigned __int16)((unsigned int)(5243 * v6) >> 16) >> 3))];
      v4 -= 4LL;
      v7 = v2 <= 0x5F5E0FF;
      v2 /= 0x2710uLL;
    }
    while ( !v7 );
    if ( v5 <= 0x63 )
      goto LABEL_6;
    goto LABEL_5;
  }
  v5 = *a1;
  if ( v2 > 0x63 )
  {
LABEL_5:
    *(__int16 *)((char *)&v10[1] + v3) = word_4CAD7[(unsigned __int16)v5 % 0x64u];
    v3 -= 2LL;
    v5 = (unsigned int)(5243 * ((unsigned __int16)v5 >> 2)) >> 17;
  }
LABEL_6:
  if ( v5 >= 0xA )
  {
    *(__int16 *)((char *)&v10[1] + v3) = word_4CAD7[v5];
    v8 = v3 - 2;
  }
  else
  {
    *((_BYTE *)&v10[1] + v3 + 1) = v5 | 0x30;
    v8 = v3 - 1;
  }
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)&unk_4C8A8, 0LL, (__int64)&v10[2] + v8, 39 - v8);
}
// 4CAD7: using guessed type _WORD word_4CAD7[100];

//----- (00000000000468F0) ----------------------------------------------------
__int64 __fastcall core::fmt::num::imp::<impl core::fmt::Display for usize>::fmt(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rcx
  __int64 v3; // rax
  __int64 v4; // r9
  unsigned __int64 v5; // rdx
  int v6; // r10d
  bool v7; // cc
  __int64 v8; // rax
  __int16 v10[21]; // [rsp+1h] [rbp-2Bh] BYREF

  v2 = *a1;
  v3 = 39LL;
  if ( *a1 >= 0x2710 )
  {
    v4 = 39LL;
    do
    {
      v5 = v2 / 0x2710;
      v6 = v2 % 0x2710;
      v3 = v4 - 4;
      *(__int16 *)((char *)v10 + v4) = word_4CAD7[(unsigned int)(5243 * v6) >> 19];
      *(__int16 *)((char *)&v10[1] + v4) = word_4CAD7[(unsigned __int16)(v6
                                                                       - 100
                                                                       * ((unsigned __int16)((unsigned int)(5243 * v6) >> 16) >> 3))];
      v4 -= 4LL;
      v7 = v2 <= 0x5F5E0FF;
      v2 /= 0x2710uLL;
    }
    while ( !v7 );
    if ( v5 <= 0x63 )
      goto LABEL_6;
    goto LABEL_5;
  }
  v5 = *a1;
  if ( v2 > 0x63 )
  {
LABEL_5:
    *(__int16 *)((char *)&v10[1] + v3) = word_4CAD7[(unsigned __int16)v5 % 0x64u];
    v3 -= 2LL;
    v5 = (unsigned int)(5243 * ((unsigned __int16)v5 >> 2)) >> 17;
  }
LABEL_6:
  if ( v5 >= 0xA )
  {
    *(__int16 *)((char *)&v10[1] + v3) = word_4CAD7[v5];
    v8 = v3 - 2;
  }
  else
  {
    *((_BYTE *)&v10[1] + v3 + 1) = v5 | 0x30;
    v8 = v3 - 1;
  }
  return core::fmt::Formatter::pad_integral(a2, 1, (__int64)&unk_4C8A8, 0LL, (__int64)&v10[2] + v8, 39 - v8);
}
// 4CAD7: using guessed type _WORD word_4CAD7[100];

//----- (0000000000046A00) ----------------------------------------------------
__int64 __fastcall <&T as core::fmt::Debug>::fmt(_QWORD *a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(a1[1] + 24LL))(*a1);
}

//----- (0000000000046A10) ----------------------------------------------------
char __fastcall <&T as core::fmt::Display>::fmt(__int64 a1, __int64 a2)
{
  return core::fmt::Formatter::pad(a2, *(_QWORD *)a1, *(_QWORD *)(a1 + 8));
}

//----- (0000000000046A30) ----------------------------------------------------
bool __fastcall core::unicode::unicode_data::cc::lookup(unsigned int a1)
{
  if ( a1 << 11 >= 0x88050000 )
    core::panicking::panic_bounds_check(1LL, 1LL, (__int64)&off_5A678);
  return a1 < 0x20 || a1 - 127 < 0x21;
}
// 5A678: using guessed type char *off_5A678;

//----- (0000000000046A70) ----------------------------------------------------
bool __fastcall core::unicode::unicode_data::grapheme_extend::lookup(int a1)
{
  unsigned int v1; // eax
  unsigned __int64 v2; // rsi
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // r8
  unsigned __int64 v5; // rsi
  unsigned int v6; // r9d
  unsigned __int64 v7; // rax
  __int64 v8; // rsi
  int v9; // r8d
  unsigned int v11; // edi
  __int64 v12; // rsi
  unsigned int v13; // ecx
  unsigned __int64 v14; // rdx
  __int64 v15; // rdi

  v1 = a1 << 11;
  v2 = 33LL;
  v3 = 0LL;
  v4 = 33LL;
  while ( 1 )
  {
    v5 = v3 + (v2 >> 1);
    v6 = core::unicode::unicode_data::grapheme_extend::SHORT_OFFSET_RUNS[v5] << 11;
    if ( v6 == v1 )
      break;
    if ( v6 > v1 )
      v4 = v5;
    if ( v6 < v1 )
      v3 = v5 + 1;
    v2 = v4 - v3;
    if ( v4 <= v3 )
      goto LABEL_10;
  }
  v3 = v5 + 1;
LABEL_10:
  if ( v3 > 0x20 )
    core::panicking::panic_bounds_check(v3, 33LL, (__int64)&off_5A678);
  v7 = core::unicode::unicode_data::grapheme_extend::SHORT_OFFSET_RUNS[v3] >> 21;
  v8 = 727LL;
  if ( v3 != 32 && &core::unicode::unicode_data::grapheme_extend::SHORT_OFFSET_RUNS[v3] != (_DWORD *)-4LL )
    v8 = core::unicode::unicode_data::grapheme_extend::SHORT_OFFSET_RUNS[v3 + 1] >> 21;
  if ( v3 )
  {
    v9 = core::unicode::unicode_data::grapheme_extend::SHORT_OFFSET_RUNS[v3 - 1] & 0x1FFFFF;
    if ( !(v8 + ~v7) )
      return (core::unicode::unicode_data::grapheme_extend::SHORT_OFFSET_RUNS[v3] & 0x200000) != 0;
  }
  else
  {
    v9 = 0;
    if ( !(v8 + ~v7) )
      return (core::unicode::unicode_data::grapheme_extend::SHORT_OFFSET_RUNS[v3] & 0x200000) != 0;
  }
  v11 = a1 - v9;
  v12 = v8 - 1;
  v13 = 0;
  v14 = v7;
  while ( 1 )
  {
    if ( v14 > 0x2D6 )
    {
      v15 = 727LL;
      if ( v7 >= 0x2D8 )
        v15 = v7;
      core::panicking::panic_bounds_check(v15, 727LL, (__int64)&off_5A690);
    }
    v13 += core::unicode::unicode_data::grapheme_extend::OFFSETS[v14];
    if ( v13 > v11 )
      break;
    if ( v12 == ++v14 )
      return v12 & 1;
  }
  return v14 & 1;
}
// 4D40C: using guessed type _DWORD core::unicode::unicode_data::grapheme_extend::SHORT_OFFSET_RUNS[33];
// 4D490: using guessed type unsigned __int8 core::unicode::unicode_data::grapheme_extend::OFFSETS[727];
// 5A678: using guessed type char *off_5A678;
// 5A690: using guessed type char *off_5A690;

//----- (0000000000046BA0) ----------------------------------------------------
unsigned __int64 __fastcall _udivti3(unsigned __int128 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // r9
  char v5; // cl
  unsigned __int64 v6; // r10
  unsigned __int64 v7; // r10
  bool v8; // cf
  unsigned __int64 v9; // r10
  unsigned __int128 v11; // rtt
  unsigned __int128 v12; // rtt

  if ( a3 )
  {
    _BitScanReverse64((unsigned __int64 *)&v3, a3);
    v5 = 64 - (v3 ^ 0x3F);
    v6 = a3 >> v5;
    if ( (v5 & 0x40) == 0 )
      v6 = (a2 >> (64 - ((unsigned __int8)v3 ^ 0x3Fu))) | (a3 << ((unsigned __int8)v3 ^ 0x3Fu));
    v7 = (unsigned __int64)((a1 >> 1) / v6) >> v3;
    v8 = v7 == 0;
    v9 = v7 - 1;
    if ( v8 )
      v9 = 0LL;
    return v9 - ((a1 - __PAIR128__(a3, a2) * v9 < __PAIR128__(a3, a2)) - 1LL);
  }
  else if ( *((_QWORD *)&a1 + 1) >= a2 )
  {
    if ( (a2 | *((_QWORD *)&a1 + 1)) >> 32 )
    {
      *(_QWORD *)&v11 = a1;
      *((_QWORD *)&v11 + 1) = *((_QWORD *)&a1 + 1) % a2;
      return v11 / a2;
    }
    else
    {
      *(_QWORD *)&v12 = a1;
      *((_QWORD *)&v12 + 1) = DWORD2(a1) % (unsigned int)a2;
      return v12 / a2;
    }
  }
  else
  {
    return a1 / a2;
  }
}

//----- (0000000000046C68) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=602 queued=513 decompiled=513 lumina nreq=0 worse=0 better=0
// ALL OK, 513 function(s) have been successfully decompiled

