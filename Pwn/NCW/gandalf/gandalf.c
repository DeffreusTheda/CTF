/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

__int64 (**init_proc())(void);
void sub_2020();
void sub_2030();
void sub_2040();
void sub_2050();
void sub_2060();
void sub_2070();
void sub_2080();
void sub_2090();
void sub_20A0();
void sub_20B0();
void sub_20C0();
void sub_20D0();
void sub_20E0();
void sub_20F0();
void sub_2100();
void sub_2110();
void sub_2120();
void sub_2130();
void sub_2140();
void sub_2150();
void sub_2160();
void sub_2170();
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
FILE **sub_2310();
__int64 sub_2340();
FILE **sub_2380();
__int64 sub_23C0();
int sub_23C9();
int sub_2463();
int sub_24DB();
int sub_2553();
__int64 sub_25CB();
__int64 sub_2694();
__int64 sub_270D();
__int64 sub_2811();
__int64 sub_2A0E();
void __fastcall discardSpell(unsigned __int64 a1);
int __fastcall craftSpell(unsigned __int64 a1, size_t a2);
int __fastcall castSpell(unsigned __int64 a1);
int sub_2CEE();
unsigned __int64 __fastcall sub_2D6C(char *a1);
unsigned __int64 sub_2FD5();
int sub_3085();
int sub_309F();
unsigned __int64 screamToTheBox();
int destroyBox();
void term_proc();
_UNKNOWN main;
const char s = '\0'; // idb
void *off_7008 = &off_7008; // idb
int dword_70A0 = 4234; // weak
char *off_70C0[7] = {
  "\x1B[38;2;255;0;0m",
  "\x1B[38;2;255;50;0m",
  "\x1B[38;2;255;100;0m",
  "\x1B[38;2;255;150;0m",
  "\x1B[38;2;255;200;0m",
  "\x1B[38;2;255;220;0m",
  "\x1B[38;2;255;240;0m"
}; // weak
char *off_7100[49] = {
  "     .... NO! ...                  ... MNO! ...",
  "   ..... MNO!! ...................... MNNOO! ...",
  " ..... MMNO! ......................... MNNOO!! .",
  ".... MNOONNOO!   MMMMMMMMMMPPPOII!   MNNO!!!! .",
  " ... !O! NNO! MMMMMMMMMMMMMPPPOOOII!! NO! ....",
  "    ...... ! MMMMMMMMMMMMMPPPPOOOOIII! ! ...",
  "   ........ MMMMMMMMMMMMPPPPPOOOOOOII!! .....",
  "   ........ MMMMMOOOOOOPPPPPPPPOOOOMII! ...",
  "    ....... MMMMM..    OPPMMP    .,OMI! ....",
  "     ...... MMMM::   o.,OPMP,.o   ::I!! ...",
  "         .... NNM:::.,,OOPM!P,.::::!! ....",
  "          .. MMNNNNNOOOOPMO!!IIPPO!!O! .....",
  "         ... MMMMMNNNNOO:!!:!!IPPPPOO! ....",
  "           .. MMMMMNNOOMMNNIIIPPPOO!! ......",
  "          ...... MMMONNMMNNNIIIOO!..........",
  "       ....... MN MOMMMNNNIIIIIO! OO ..........",
  "    ......... MNO! IiiiiiiiiiiiI OOOO ...........",
  "  ...... NNN.MNO! . O!!!!!!!!!O . OONO NO! ........",
  "   .... MNNNNNO! ...OOOOOOOOOOO .  MMNNON!........",
  "   ...... MNNNNO! .. PPPPPPPPP .. MMNON!........",
  "      ...... OO! ................. ON! .......",
  "         ................................",
  "\x1B[1;38;2;0;255;0m",
  "\x1B[0m",
  "                  .",
  "                   .",
  "         /^\\     .",
  "    /\\   \"V\"",
  "   /__\\   I      O  o",
  "  //..\\\\  I     .",
  "  \\].`[/  I",
  "  /l\\/j\\  (]    .  O",
  " /. ~~ ,\\/I          .",
  " \\\\L__j^\\/I       o",
  "  \\/--v}  I     o   .",
  "  |    |  I   _________",
  "  |    |  I c(`       ')o",
  "  |    l  I   \\.     ,/",
  "_/j  L l\\_!  _//^---^\\\\_    ",
  "\x1B[1;38;2;173;216;230m",
  "                                   .''.       ",
  "       .''.      .        *''*    :_\\/_:     . ",
  "      :_\\/_:   _\\(/_  .:.*_\\/_*   : /\\ :  .'.:.'.",
  "  .''.: /\\ :   ./)\\   ':'* /\\ * :  '..'.  -=:o:=-",
  " :_\\/_:'.:::.    ' *''*    * '.\\'/.' _\\(/_'.':'.'",
  " : /\\ : :::::     *_\\/_*     -= o =-  /)\\    '  *",
  "  '..'  ':::'     * /\\ *     .'/.'.   '",
  "      *            *..*         :",
  "\x1B[1;38;2;255;105;180m"
}; // weak
char *off_71B0[27] = {
  "\x1B[1;38;2;0;255;0m",
  "\x1B[0m",
  "                  .",
  "                   .",
  "         /^\\     .",
  "    /\\   \"V\"",
  "   /__\\   I      O  o",
  "  //..\\\\  I     .",
  "  \\].`[/  I",
  "  /l\\/j\\  (]    .  O",
  " /. ~~ ,\\/I          .",
  " \\\\L__j^\\/I       o",
  "  \\/--v}  I     o   .",
  "  |    |  I   _________",
  "  |    |  I c(`       ')o",
  "  |    l  I   \\.     ,/",
  "_/j  L l\\_!  _//^---^\\\\_    ",
  "\x1B[1;38;2;173;216;230m",
  "                                   .''.       ",
  "       .''.      .        *''*    :_\\/_:     . ",
  "      :_\\/_:   _\\(/_  .:.*_\\/_*   : /\\ :  .'.:.'.",
  "  .''.: /\\ :   ./)\\   ':'* /\\ * :  '..'.  -=:o:=-",
  " :_\\/_:'.:::.    ' *''*    * '.\\'/.' _\\(/_'.':'.'",
  " : /\\ : :::::     *_\\/_*     -= o =-  /)\\    '  *",
  "  '..'  ':::'     * /\\ *     .'/.'.   '",
  "      *            *..*         :",
  "\x1B[1;38;2;255;105;180m"
}; // weak
char *off_71B8[26] = {
  "\x1B[0m",
  "                  .",
  "                   .",
  "         /^\\     .",
  "    /\\   \"V\"",
  "   /__\\   I      O  o",
  "  //..\\\\  I     .",
  "  \\].`[/  I",
  "  /l\\/j\\  (]    .  O",
  " /. ~~ ,\\/I          .",
  " \\\\L__j^\\/I       o",
  "  \\/--v}  I     o   .",
  "  |    |  I   _________",
  "  |    |  I c(`       ')o",
  "  |    l  I   \\.     ,/",
  "_/j  L l\\_!  _//^---^\\\\_    ",
  "\x1B[1;38;2;173;216;230m",
  "                                   .''.       ",
  "       .''.      .        *''*    :_\\/_:     . ",
  "      :_\\/_:   _\\(/_  .:.*_\\/_*   : /\\ :  .'.:.'.",
  "  .''.: /\\ :   ./)\\   ':'* /\\ * :  '..'.  -=:o:=-",
  " :_\\/_:'.:::.    ' *''*    * '.\\'/.' _\\(/_'.':'.'",
  " : /\\ : :::::     *_\\/_*     -= o =-  /)\\    '  *",
  "  '..'  ':::'     * /\\ *     .'/.'.   '",
  "      *            *..*         :",
  "\x1B[1;38;2;255;105;180m"
}; // weak
char *off_71C0[25] = {
  "                  .",
  "                   .",
  "         /^\\     .",
  "    /\\   \"V\"",
  "   /__\\   I      O  o",
  "  //..\\\\  I     .",
  "  \\].`[/  I",
  "  /l\\/j\\  (]    .  O",
  " /. ~~ ,\\/I          .",
  " \\\\L__j^\\/I       o",
  "  \\/--v}  I     o   .",
  "  |    |  I   _________",
  "  |    |  I c(`       ')o",
  "  |    l  I   \\.     ,/",
  "_/j  L l\\_!  _//^---^\\\\_    ",
  "\x1B[1;38;2;173;216;230m",
  "                                   .''.       ",
  "       .''.      .        *''*    :_\\/_:     . ",
  "      :_\\/_:   _\\(/_  .:.*_\\/_*   : /\\ :  .'.:.'.",
  "  .''.: /\\ :   ./)\\   ':'* /\\ * :  '..'.  -=:o:=-",
  " :_\\/_:'.:::.    ' *''*    * '.\\'/.' _\\(/_'.':'.'",
  " : /\\ : :::::     *_\\/_*     -= o =-  /)\\    '  *",
  "  '..'  ':::'     * /\\ *     .'/.'.   '",
  "      *            *..*         :",
  "\x1B[1;38;2;255;105;180m"
}; // weak
char *off_7238[10] = {
  "\x1B[1;38;2;173;216;230m",
  "                                   .''.       ",
  "       .''.      .        *''*    :_\\/_:     . ",
  "      :_\\/_:   _\\(/_  .:.*_\\/_*   : /\\ :  .'.:.'.",
  "  .''.: /\\ :   ./)\\   ':'* /\\ * :  '..'.  -=:o:=-",
  " :_\\/_:'.:::.    ' *''*    * '.\\'/.' _\\(/_'.':'.'",
  " : /\\ : :::::     *_\\/_*     -= o =-  /)\\    '  *",
  "  '..'  ':::'     * /\\ *     .'/.'.   '",
  "      *            *..*         :",
  "\x1B[1;38;2;255;105;180m"
}; // weak
char *off_7240[9] = {
  "                                   .''.       ",
  "       .''.      .        *''*    :_\\/_:     . ",
  "      :_\\/_:   _\\(/_  .:.*_\\/_*   : /\\ :  .'.:.'.",
  "  .''.: /\\ :   ./)\\   ':'* /\\ * :  '..'.  -=:o:=-",
  " :_\\/_:'.:::.    ' *''*    * '.\\'/.' _\\(/_'.':'.'",
  " : /\\ : :::::     *_\\/_*     -= o =-  /)\\    '  *",
  "  '..'  ':::'     * /\\ *     .'/.'.   '",
  "      *            *..*         :",
  "\x1B[1;38;2;255;105;180m"
}; // weak
char *off_7280 = "\x1B[1;38;2;255;105;180m"; // weak
char *off_72A0 = "                             /\\"; // weak
FILE *stdout; // idb
FILE *stdin; // idb
FILE *stderr; // idb
char byte_7368; // weak
_UNKNOWN unk_7380; // weak
__int64 (**init_proc())(void) {
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}

void sub_2020() {
  JUMPOUT(0LL);
}

void sub_2030() {
  sub_2020();
}

void sub_2040() {
  sub_2020();
}

void sub_2050() {
  sub_2020();
}

void sub_2060() {
  sub_2020();
}

void sub_2070() {
  sub_2020();
}

void sub_2080() {
  sub_2020();
}

void sub_2090() {
  sub_2020();
}

void sub_20A0() {
  sub_2020();
}

void sub_20B0() {
  sub_2020();
}

void sub_20C0() {
  sub_2020();
}

void sub_20D0() {
  sub_2020();
}

void sub_20E0() {
  sub_2020();
}

void sub_20F0() {
  sub_2020();
}

void sub_2100() {
  sub_2020();
}

void sub_2110() {
  sub_2020();
}

void sub_2120() {
  sub_2020();
}

void sub_2130() {
  sub_2020();
}

void sub_2140() {
  sub_2020();
}

void sub_2150() {
  sub_2020();
}

void sub_2160() {
  sub_2020();
}

void sub_2170() {
  sub_2020();
}

void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void)) {
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, 0LL, 0LL, a3, &v5);
  __halt();
}

FILE **sub_2310() {
  return &stdout;
}

__int64 sub_2340() {
  return 0LL;
}

FILE **sub_2380() {
  FILE **result; // rax

  if ( !byte_7368 ) {
    if ( &__cxa_finalize )
      _cxa_finalize(off_7008);
    result = sub_2310();
    byte_7368 = 1;
  }
  return result;
}

__int64 sub_23C0() {
  return sub_2340();
}

int sub_23C9() {
  int v1; // [rsp+4h] [rbp-Ch]
  unsigned int i; // [rsp+8h] [rbp-8h]

  v1 = 0;
  for ( i = 0; i <= 0x15; ++i ) {
    printf("%s%s\n", off_70C0[v1], off_7100[i]);
    v1 = (v1 + 1) % 7;
  }
  return printf("\x1B[0m");
}

int sub_2463() {
  unsigned int i; // [rsp+Ch] [rbp-4h]

  for ( i = 0; i <= 0xE; ++i )
    printf("%s%s\n", off_71B0[0], off_71C0[i]);
  return printf("%s", off_71B8[0]);
}

int sub_24DB() {
  unsigned int i; // [rsp+Ch] [rbp-4h]

  for ( i = 0; i <= 7; ++i )
    printf("%s%s\n", off_7238[0], off_7240[i]);
  return printf("%s", off_71B8[0]);
}

int sub_2553() {
  unsigned int i; // [rsp+Ch] [rbp-4h]

  for ( i = 0; i <= 0x13; ++i )
    printf("%s%s\n", off_7280, (&off_72A0)[i]);
  return printf("%s", off_71B8[0]);
}

__int64 sub_25CB() {
  __int64 v1; // [rsp+8h] [rbp-8h]

  v1 = seccomp_init(0LL);
  seccomp_rule_add(v1, 2147418112LL, 2LL, 0LL);
  seccomp_rule_add(v1, 2147418112LL, 0LL, 0LL);
  seccomp_rule_add(v1, 2147418112LL, 1LL, 0LL);
  seccomp_rule_add(v1, 2147418112LL, 5LL, 0LL);
  seccomp_rule_add(v1, 2147418112LL, 60LL, 0LL);
  return seccomp_load(v1);
}

__int64 sub_2694() {
  alarm(0x168u);
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  return sub_25CB();
}

__int64 sub_270D() {
  unsigned int v0; // eax
  int v1; // ebx
  int v2; // eax

  v0 = time(0LL);
  srand(v0);
  v1 = ((7 * ((rand() % 685) ^ dword_70A0) + dword_70A0) % 10000) ^ (3 * dword_70A0);
  v2 = v1 + rand() % 100;
  if ( v2 <= 0 )
    v2 = -v2;
  return (unsigned int)(v2 % 10000);
}

__int64 sub_2811() {
  unsigned int v1; // [rsp+4h] [rbp-3Ch]
  int v2; // [rsp+8h] [rbp-38h]
  int v3; // [rsp+Ch] [rbp-34h]
  char s[40]; // [rsp+10h] [rbp-30h] BYREF
  unsigned __int64 v5; // [rsp+38h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v2 = sub_270D();
  v1 = 0;
  puts(&::s);
  printf("\x1B[1;32m");
  puts("[+] Inside this box, there is dark spirit chained.");
  puts("[+] The box is locked with a random key.");
  puts("[+] Beware, sending an invalid key will somehow release the dark spirit.");
  printf("\x1B[1;33m");
  printf("[$] ");
  fgets(s, 40, stdin);
  v3 = atoi(s);
  printf("\x1B[0m");
  puts(&::s);
  if ( !v3 ) {
    printf("\x1B[1;31m");
    puts("[+] You have entered the wrong passkey!");
    puts("[+] Suddenly, the dark spirit breaks out of the box and takes Gandalf soul!");
    printf("\x1B[0m");
    exit(0);
  }
  if ( v3 == v2 ) {
    printf("\x1B[1;32m");
    puts("[+] The dark spirit still chained inside!");
    puts("[+] You successfully passing the correct key!");
    printf("\x1B[1;33m");
    return 1;
  }
  else {
    printf("\x1B[1;31m");
    puts("[+] You have entered the wrong passkey!");
    puts("[+] Suddenly, the dark spirit breaks out of the box and takes Gandalf soul!");
    printf("\x1B[0m");
  }
  return v1;
}

__int64 sub_2A0E() {
  if ( (unsigned int)sub_2811() != 1 )
    exit(0);
  return 1LL;
}

void __fastcall discardSpell(unsigned __int64 a1) {
  unsigned __int64 v1; // [rsp+8h] [rbp-8h] BYREF

  v1 = a1;
  sub_24DB();
  puts(&s);
  puts(&s);
  printf("Choose backpack slot: ");
  __isoc99_scanf("%lu", &v1);
  getchar();
  if ( v1 <= 0xD )
    free(*((void **)&unk_7380 + v1));
  else
    puts("[+] Invalid Slot.");
}

int __fastcall craftSpell(unsigned __int64 a1, size_t a2) {
  unsigned __int64 v3; // rbx
  size_t size; // [rsp+0h] [rbp-20h] BYREF
  unsigned __int64 v5; // [rsp+8h] [rbp-18h] BYREF

  v5 = a1;
  size = a2;
  sub_2463();
  puts(&s);
  puts("Gandalf slots are limited to 13.");
  printf("[+] Choose backpack slot: ");
  __isoc99_scanf("%lu", &v5);
  getchar();
  if ( v5 > 0xD )
    return puts("[+] Invalid Slot.");
  puts("[#] Gandalf has limit for manna usage.");
  puts("[#] For manna usage is limited from (21 - 1056).");
  printf("[+] Manna usage: ");
  __isoc99_scanf("%lu", &size);
  getchar();
  v3 = v5;
  *((_QWORD *)&unk_7380 + v3) = malloc(size);
  puts("[#] Enter magic phrase");
  printf(">> ");
  return (unsigned int)fgets(*((char **)&unk_7380 + v5), size, stdin);
}

int __fastcall castSpell(unsigned __int64 a1) {
  unsigned __int64 v2; // [rsp+8h] [rbp-8h] BYREF

  v2 = a1;
  puts(&s);
  puts("Gandalf opened his backpack to use the crafted spell...");
  printf("Backpack slot: ");
  __isoc99_scanf("%lu", &v2);
  getchar();
  if ( v2 <= 0xD )
    return puts(*((const char **)&unk_7380 + v2));
  else
    return puts("[+] Invalid Slot.");
}

int sub_2CEE() {
  puts(&s);
  printf("\x1B[1;95m");
  puts("=== WARNING: The Dybbuk Box ===");
  puts("[+] Inside this box, a malevolent spirit is chained with ancient and powerful magic.");
  puts("[+] Exorcising the spirit requires an immense amount of energy and swift, precise techniques.");
  puts("[+] Beware, disturbing the box without proper preparation could unleash chaos.");
  return printf("\x1B[0m");
}

unsigned __int64 __fastcall sub_2D6C(char *a1) {
  int v2; // [rsp+18h] [rbp-F8h]
  int i; // [rsp+1Ch] [rbp-F4h]
  char *needle[29]; // [rsp+20h] [rbp-F0h]
  unsigned __int64 v5; // [rsp+108h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  needle[0] = "%p";
  needle[1] = "%s";
  needle[2] = "%x";
  needle[3] = "%d";
  needle[4] = "%u";
  needle[5] = "%i";
  needle[6] = "%o";
  needle[7] = "%a";
  needle[8] = "%e";
  needle[9] = "%f";
  needle[10] = "%g";
  needle[11] = "%c";
  needle[12] = "%n";
  needle[13] = "%h";
  needle[14] = "%l";
  needle[15] = "%ll";
  needle[16] = "%z";
  needle[17] = "%t";
  needle[18] = "%L";
  needle[19] = "%j";
  needle[20] = "%#x";
  needle[21] = "%#o";
  needle[22] = "%lc";
  needle[23] = "%ls";
  needle[24] = "%.*s";
  needle[25] = "%1$s";
  needle[26] = "%2$d";
  needle[27] = 0LL;
  v2 = 0;
  for ( i = 0; needle[i]; ++i ) {
    if ( strstr(a1, needle[i]) ) {
      v2 = 1;
      break;
    }
  }
  if ( v2 ) {
    puts(&s);
    printf("\x1B[1;35m");
    puts("[+] Filtered!");
    printf("\x1B[0m");
    strncpy(a1, "[+] Input Contained!\n", 0x45uLL);
  }
  return v5 - __readfsqword(0x28u);
}

unsigned __int64 sub_2FD5() {
  char s[104]; // [rsp+0h] [rbp-70h] BYREF
  unsigned __int64 v2; // [rsp+68h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  puts(&::s);
  puts(
    "\x1B[1;32mWe would love to enhance our game day by day! Please provide us with feedback, and we will continue updati"
    "ng it to make it even better.\x1B[0m");
  printf("[!] ");
  fgets(s, 100, stdin);
  printf("[+] Your feedback: ");
  printf(s);
  puts(">> Thankyouu!");
  return v2 - __readfsqword(0x28u);
}

int sub_3085() {
  return puts("aa");
}

int sub_309F() {
  int result; // eax
  int v1; // [rsp+0h] [rbp-10h] BYREF
  int v2; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+8h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  puts(&s);
  puts(&s);
  puts("[+] Status: \x1B[1;31mLOCKED\x1B[0m");
  puts(&s);
  puts("\x1B[1;34m[1]. Read Warning.\x1B[0m");
  puts("\x1B[1;34m[2]. Lockpicking.\x1B[0m");
  puts("\x1B[1;34m[3]. Feedback.\x1B[0m");
  puts("\x1B[1;34m[4]. Exit.\x1B[0m");
  printf("[!] ");
  __isoc99_scanf("%1d", &v1);
  getchar();
  if ( v1 == 4 ) {
    puts(&s);
    printf("\x1B[1;33m");
    puts("[#] The game quits in 3 seconds.");
    puts("[#] ..1");
    sleep(1u);
    puts("[#] ..2");
    sleep(1u);
    puts("[#] ..3");
    sleep(1u);
    printf("\x1B[0m");
    exit(0);
  }
  if ( v1 > 4 ) {
LABEL_12:
    puts(&s);
    printf("\x1B[1;33m");
    puts("[#] The game quits in 3 seconds.");
    puts("[#] ..1");
    sleep(1u);
    puts("[#] ..2");
    sleep(1u);
    puts("[#] ..3");
    sleep(1u);
    printf("\x1B[0m");
    exit(0);
  }
  if ( v1 == 3 )
    return sub_2FD5();
  if ( v1 == 1 )
    return sub_2CEE();
  if ( v1 != 2 )
    goto LABEL_12;
  result = sub_2A0E();
  v2 = result;
  if ( result )
    return v2;
  return result;
}

unsigned __int64 screamToTheBox() {
  char v1[88]; // [rsp+0h] [rbp-60h] BYREF
  unsigned __int64 v2; // [rsp+58h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  puts(&s);
  printf("\x1B[1;33m[+] You seem stressed and chose to scream to the box\n\x1B[0m");
  puts("--");
  printf("Scream: ");
  __isoc99_scanf("%79s", v1);
  getchar();
  printf("You screamed --> ");
  printf("%s", v1);
  puts(" to the box");
  puts(&s);
  puts("--");
  printf("\x1B[1;33m... Nothing happened to the box and nothing came out of it\n\x1B[0m");
  puts(&s);
  return v2 - __readfsqword(0x28u);
}

int destroyBox() {
  puts(&s);
  printf("\x1B[1;33m[+] You can't destroy the box!\n\x1B[0m");
  return puts(&s);
}

__int64 __fastcall main(__int64 a1, char **a2, char **a3) {
  int v4; // [rsp+0h] [rbp-20h] BYREF
  int v5; // [rsp+4h] [rbp-1Ch]
  unsigned __int64 v6; // [rsp+8h] [rbp-18h]
  size_t v7; // [rsp+10h] [rbp-10h]
  unsigned __int64 v8; // [rsp+18h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  sub_2694();
  sub_23C9();
  v5 = sub_309F();
  if ( v5 != 1 )
    exit(0);
  while ( 2 ) {
    puts(&s);
    puts("[+] Status: \x1B[1;32mUNLOCKED\x1B[0m");
    puts(&s);
    puts("\x1B[1;32m=-=-=-=-=-=-=-=-=-=\x1B[0m");
    puts("\x1B[1;33m|                 |\x1B[0m");
    puts("\x1B[1;32m|     \x1B[1;33mDYBBUK\x1B[1;32m      |\x1B[0m");
    puts("\x1B[1;32m|         \x1B[1;33mBOX\x1B[1;32m     |\x1B[0m");
    puts("\x1B[1;33m|                 |\x1B[0m");
    puts("\x1B[1;32m=-=-=-=-=-=-=-=-=-=\x1B[0m");
    puts(&s);
    puts("\x1B[1;34m[1]. Cast Spell.\x1B[0m");
    puts("\x1B[1;34m[2]. Craft Spell.\x1B[0m");
    puts("\x1B[1;34m[3]. Discard Spell.\x1B[0m");
    puts("\x1B[1;34m[4]. Destroy Box.\x1B[0m");
    puts("\x1B[1;34m[5]. Scream to the Box.\x1B[0m");
    puts("\x1B[1;34m[6]. Exit.\x1B[0m");
    printf("$ ");
    __isoc99_scanf("%d", &v4);
    getchar();
    switch ( v4 ) {
      case 1:
        castSpell(v6);
        goto LABEL_11;
      case 2:
        craftSpell(v6, v7);
        goto LABEL_11;
      case 3:
        discardSpell(v6);
        goto LABEL_11;
      case 4:
        destroyBox();
        goto LABEL_11;
      case 5:
        screamToTheBox();
        goto LABEL_11;
      case 6:
        puts(&s);
        printf("\x1B[1;33m");
        puts("[#] The game quits in 3 seconds.");
        puts("[#] ..1");
        sleep(1u);
        puts("[#] ..2");
        sleep(1u);
        puts("[#] ..3");
        sleep(1u);
        printf("\x1B[0m");
        return 0LL;
      default:
        puts("Invalid choice!");
LABEL_11:
        if ( v4 != 6 )
          continue;
        return 0LL;
    }
  }
}
