from z3 import *

# Constants
TARGET = 0x1337
BIT_WIDTH = 16
NUM_INPUTS = 4
NUM_GATES = 8  # Increase if needed

# Inputs: symbolic constants (we assume all are 0xFFFF here)
inputs = [BitVecVal(0xFFFF, BIT_WIDTH) for _ in range(NUM_INPUTS)]

# Gate outputs
gate_outputs = [BitVec(f'gate_{i}_out', BIT_WIDTH) for i in range(NUM_GATES)]

# Gate input indices
gate_inputs_a = [Int(f'gate_{i}_a' ) for i in range(NUM_GATES)]
gate_inputs_b = [Int(f'gate_{i}_b' ) for i in range(NUM_GATES)]

s = Solver()

all_sources = list(range(NUM_INPUTS + NUM_GATES))

# Enforce NAND logic and valid indices
for i in range(NUM_GATES):
    a_idx = gate_inputs_a[i]
    b_idx = gate_inputs_b[i]

    s.add(And(a_idx >= 0, a_idx < len(all_sources)))
    s.add(And(b_idx >= 0, b_idx < len(all_sources)))

    # Lookup logic: input can be from earlier gate or initial input
    def get_val(idx):
        return If(idx < NUM_INPUTS, inputs[idx], gate_outputs[idx - NUM_INPUTS])

    a_val = get_val(a_idx)
    b_val = get_val(b_idx)
    s.add(gate_outputs[i] == ~(a_val & b_val))

# Constraint: final gate should equal 0x1337
s.add(gate_outputs[-1] == BitVecVal(TARGET, BIT_WIDTH))

# Solve!
if s.check() == sat:
    m = s.model()
    print("SOLUTION FOUND:")
    for i in range(NUM_GATES):
        a = m[gate_inputs_a[i]].as_long()
        b = m[gate_inputs_b[i]].as_long()
        out = m[gate_outputs[i]].as_long()
        print(f"Gate {i}: NAND(src[{a}], src[{b}]) -> 0x{out:04x}")
else:
    print("No solution found.")

